/**
 * skylark-slax-runtime - The skylark shells widget
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-slax/skylark-slax-runtime/
 * @license MIT
 */
(function(factory,globals) {
  var define = globals.define,
      require = globals.require,
      isAmd = (typeof define === 'function' && define.amd),
      isCmd = (!isAmd && typeof exports !== 'undefined');

  if (!isAmd && !define) {
    var map = {};
    function absolute(relative, base) {
        if (relative[0]!==".") {
          return relative;
        }
        var stack = base.split("/"),
            parts = relative.split("/");
        stack.pop(); 
        for (var i=0; i<parts.length; i++) {
            if (parts[i] == ".")
                continue;
            if (parts[i] == "..")
                stack.pop();
            else
                stack.push(parts[i]);
        }
        return stack.join("/");
    }
    define = globals.define = function(id, deps, factory) {
        if (typeof factory == 'function') {
            map[id] = {
                factory: factory,
                deps: deps.map(function(dep){
                  return absolute(dep,id);
                }),
                resolved: false,
                exports: null
            };
            require(id);
        } else {
            map[id] = {
                factory : null,
                resolved : true,
                exports : factory
            };
        }
    };
    require = globals.require = function(id) {
        if (!map.hasOwnProperty(id)) {
            throw new Error('Module ' + id + ' has not been defined');
        }
        var module = map[id];
        if (!module.resolved) {
            var args = [];

            module.deps.forEach(function(dep){
                args.push(require(dep));
            })

            module.exports = module.factory.apply(globals, args) || null;
            module.resolved = true;
        }
        return module.exports;
    };
  }
  
  if (!define) {
     throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
  }

  factory(define,require);

  if (!isAmd) {
    var skylarkjs = require("skylark-langx-ns");

    if (isCmd) {
      module.exports = skylarkjs;
    } else {
      globals.skylarkjs  = skylarkjs;
    }
  }

})(function(define,require) {

define('skylark-langx-ns/_attach',[],function(){
    return  function attach(obj1,path,obj2) {
        if (typeof path == "string") {
            path = path.split(".");//[path]
        };
        var length = path.length,
            ns=obj1,
            i=0,
            name = path[i++];

        while (i < length) {
            ns = ns[name] = ns[name] || {};
            name = path[i++];
        }

        if (ns[name]) {
            if (obj2) {
                throw new Error("This namespace already exists:" + path);
            }

        } else {
            ns[name] = obj2 || {};
        }
        return ns[name];
    }
});
define('skylark-langx-ns/ns',[
    "./_attach"
], function(_attach) {
    var root = {
    	attach : function(path,obj) {
    		return _attach(root,path,obj);
    	}
    };
    return root;
});

define('skylark-langx-ns/main',[
	"./ns"
],function(skylark){
	return skylark;
});
define('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });

define('skylark-langx-types/types',[
    "skylark-langx-ns"
],function(skylark){
    var nativeIsArray = Array.isArray, 
        toString = {}.toString;
    
    var type = (function() {
        var class2type = {};

        // Populate the class2type map
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" ").forEach(function(name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        return function type(obj) {
            return obj == null ? String(obj) :
                class2type[toString.call(obj)] || "object";
        };
    })();

 
    var  isArray = nativeIsArray || function(obj) {
        return object && object.constructor === Array;
    };


    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function/string/element and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * isArrayLike([1, 2, 3])
     * // => true
     *
     * isArrayLike(document.body.children)
     * // => false
     *
     * isArrayLike('abc')
     * // => true
     *
     * isArrayLike(Function)
     * // => false
     */    
    function isArrayLike(obj) {
        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * isBoolean(false)
     * // => true
     *
     * isBoolean(null)
     * // => false
     */
    function isBoolean(obj) {
       return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
       //return typeof(obj) === "boolean";
    }

    function isDefined(obj) {
        return typeof obj !== 'undefined';
    }

    function isDocument(obj) {
        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
    }

   // Is a given value a DOM element?
    function isElement(obj) {
        return !!(obj && obj.nodeType === 1);
    }   

    function isEmptyObject(obj) {
        var name;
        for (name in obj) {
            if (obj[name] !== null) {
                return false;
            }
        }
        return true;
    }


    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * isFunction(parseInt)
     * // => true
     *
     * isFunction(/abc/)
     * // => false
     */
    function isFunction(value) {
        return type(value) == "function";
    }



    function isHtmlNode(obj) {
        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME
    }

    function isInstanceOf( /*Object*/ value, /*Type*/ type) {
        //Tests whether the value is an instance of a type.
        if (value === undefined) {
            return false;
        } else if (value === null || type == Object) {
            return true;
        } else if (typeof value === "number") {
            return type === Number;
        } else if (typeof value === "string") {
            return type === String;
        } else if (typeof value === "boolean") {
            return type === Boolean;
        } else if (typeof value === "string") {
            return type === String;
        } else {
            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);
        }
    }

    function isNull(obj) {
        return obj === null;
    }

    function isNumber(obj) {
        return typeof obj == 'number';
    }

    function isObject(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;        
        //return type(obj) == "object";
    }

    function isPlainObject(obj) {
        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
    }

    function isString(obj) {
        return typeof obj === 'string';
    }

    function isWindow(obj) {
        return obj && obj == obj.window;
    }

    function isSameOrigin(href) {
        if (href) {
            var origin = location.protocol + '//' + location.hostname;
            if (location.port) {
                origin += ':' + location.port;
            }
            return href.startsWith(origin);
        }
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    // Is a given variable undefined?
    function isUndefined(obj) {
        return obj === void 0;
    }


    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }   

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }





    return skylark.attach("langx.types",{

        isArray: isArray,

        isArrayLike: isArrayLike,

        isBoolean: isBoolean,

        isDefined: isDefined,

        isDocument: isDocument,

        isElement,

        isEmpty : isEmptyObject,

        isEmptyObject: isEmptyObject,

        isFunction: isFunction,

        isHtmlNode: isHtmlNode,

        isNaN : function (obj) {
            return isNaN(obj);
        },

        isNull: isNull,


        isNumber: isNumber,

        isNumeric: isNumber,

        isObject: isObject,

        isPlainObject: isPlainObject,

        isString: isString,

        isSameOrigin: isSameOrigin,

        isSymbol : isSymbol,

        isUndefined: isUndefined,

        isWindow: isWindow,

        type: type,

        toFinite : toFinite,
        toNumber : toNumber,
        toInteger : toInteger
        
    });

});
define('skylark-langx-types/main',[
	"./types"
],function(types){
	return types;
});
define('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });

define('skylark-langx-objects/objects',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        slice = Array.prototype.slice,
        isBoolean = types.isBoolean,
        isFunction = types.isFunction,
        isObject = types.isObject,
        isPlainObject = types.isPlainObject,
        isArray = types.isArray,
        isArrayLike = types.isArrayLike,
        isString = types.isString,
        toInteger = types.toInteger;

     // An internal function for creating assigner functions.
    function createAssigner(keysFunc, defaults) {
        return function(obj) {
          var length = arguments.length;
          if (defaults) obj = Object(obj);  
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
       };
    }


    // Retrieve all the property names of an object.
    function allKeys(obj) {
        if (!isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys(obj) {
        if (isObject(obj)) return [];
        var keys = [];
        for (var key in obj) if (has(obj, key)) keys.push(key);
        return keys;
    }

    function has(obj, path) {
        if (!isArray(path)) {
            return obj != null && hasOwnProperty.call(obj, path);
        }
        var length = path.length;
        for (var i = 0; i < length; i++) {
            var key = path[i];
            if (obj == null || !hasOwnProperty.call(obj, key)) {
                return false;
            }
            obj = obj[key];
        }
        return !!length;
    }


    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
        var keys = keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    }    


    function removeItem(items, item) {
        if (isArray(items)) {
            var idx = items.indexOf(item);
            if (idx != -1) {
                items.splice(idx, 1);
            }
        } else if (isPlainObject(items)) {
            for (var key in items) {
                if (items[key] == item) {
                    delete items[key];
                    break;
                }
            }
        }

        return this;
    }



    // Retrieve the values of an object's properties.
    function values(obj) {
        var keys = allKeys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }


    return skylark.attach("langx.objects",{
        allKeys: allKeys,

        attach : skylark.attach,

        defaults : createAssigner(allKeys, true),

        has: has,

        isMatch: isMatch,

        keys: keys,

        removeItem: removeItem,

        values: values
    });


});
define('skylark-langx-objects/clone',[
    "skylark-langx-types",
    "./objects"
],function(types,objects) {
    var isPlainObject = types.isPlainObject,
        isArray = types.isArray;

    function clone( /*anything*/ src,checkCloneMethod) {
        var copy;
        if (src === undefined || src === null) {
            copy = src;
        } else if (checkCloneMethod && src.clone) {
            copy = src.clone();
        } else if (isArray(src)) {
            copy = [];
            for (var i = 0; i < src.length; i++) {
                copy.push(clone(src[i]));
            }
        } else if (isPlainObject(src)) {
            copy = {};
            for (var key in src) {
                copy[key] = clone(src[key]);
            }
        } else {
            copy = src;
        }

        return copy;

    }

    return objects.clone = clone;
});
define('skylark-langx-objects/each',[
    "./objects"
],function(objects) {

    function each(obj, callback,isForEach) {
        var length, key, i, undef, value;

        if (obj) {
            length = obj.length;

            if (length === undef) {
                // Loop object items
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        value = obj[key];
                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {
                            break;
                        }
                    }
                }
            } else {
                // Loop array items
                for (i = 0; i < length; i++) {
                    value = obj[i];
                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {
                        break;
                    }
                }
            }
        }

        return this;
    }

    return objects.each = each;
});
define('skylark-langx-objects/_mixin',[
    "skylark-langx-types",
    "./objects"
],function(types,objects) {

    var isPlainObject = types.isPlainObject;

    function _mixin(target, source, deep, safe) {
        for (var key in source) {
            //if (!source.hasOwnProperty(key)) {
            //    continue;
            //}
            if (safe && target[key] !== undefined) {
                continue;
            }
            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
            if (deep && isPlainObject(source[key])) {
                if (!isPlainObject(target[key])) {
                    target[key] = {};
                }
                //if (isArray(source[key]) && !isArray(target[key])) {
                //    target[key] = [];
                //}
                _mixin(target[key], source[key], deep, safe);
            } else if (source[key] !== undefined) {
                target[key] = source[key]
            }
        }
        return target;
    }

    return _mixin;
});
define('skylark-langx-objects/_parse_mixin_args',[
    "skylark-langx-types",
    "./objects"
],function(types,objects) {

    var slice = Array.prototype.slice,
        isBoolean = types.isBoolean;

    function _parseMixinArgs(args) {
        var params = slice.call(arguments, 0),
            target = params.shift(),
            deep = false;
        if (isBoolean(params[params.length - 1])) {
            deep = params.pop();
        }

        return {
            target: target,
            sources: params,
            deep: deep
        };
    }
    
    return _parseMixinArgs;
});
define('skylark-langx-objects/mixin',[
	"skylark-langx-types",
	"./objects",
  "./_mixin",
  "./_parse_mixin_args"
],function(types,objects,_mixin,_parseMixinArgs) {


    function mixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, false);
        });
        return args.target;
    }


    return objects.mixin = mixin;
	
});
define('skylark-langx-objects/extend',[
    "./objects",
    "./mixin"
],function(objects,mixin) {
    var slice = Array.prototype.slice;

    function extend(target) {
        var deep, args = slice.call(arguments, 1);
        if (typeof target == 'boolean') {
            deep = target
            target = args.shift()
        }
        if (args.length == 0) {
            args = [target];
            target = this;
        }
        args.forEach(function(arg) {
            mixin(target, arg, deep);
        });
        return target;
    }

    return objects.extend = extend;
});
define('skylark-langx-objects/includes',[
    "./objects"
],function(objects) {

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }



    return objects.includes = includes;
});
define('skylark-langx-objects/is-equal',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {
    var isFunction = types.isFunction;


    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // `null` or `undefined` only equal to itself (strict comparison).
        if (a == null || b == null) return false;
        // `NaN`s are equivalent, but non-reflexive.
        if (a !== a) return b !== b;
        // Exhaust primitive checks
        var type = typeof a;
        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
        return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
        // Unwrap any wrapped objects.
        //if (a instanceof _) a = a._wrapped;
        //if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b;
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN.
                if (+a !== +a) return +b !== +b;
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b;
            case '[object Symbol]':
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }

        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object') return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
                               isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
        }

        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);

        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length) return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            // Deep compare objects.
            var keys = Object.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (Object.keys(b).length !== length) return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    };


   // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
        return eq(a, b);
    }

    return objects.isEqual = isEqual;
	
});
define('skylark-langx-objects/omit',[
    "./objects"
],function(objects) {

   // Return a copy of the object without the blacklisted properties.
    function omit(obj, prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = mixin({},obj);
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                delete result[pn];
            }
        }
        return result;

    }
    
    return objects.omit = omit;
});
define('skylark-langx-objects/pick',[
    "./objects"
],function(objects) {

   // Return a copy of the object only containing the whitelisted properties.
    function pick(obj,prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = {};
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                result[pn] = obj[pn];
            }
        }
        return result;
    }
    
    return objects.pick = pick;
});
define('skylark-langx-objects/result',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {
	var isArray = types.isArray,
		isFunction = types.isFunction;

    function result(obj, path, fallback) {
        if (!isArray(path)) {
            path = path.split(".");//[path]
        };
        var length = path.length;
        if (!length) {
          return isFunction(fallback) ? fallback.call(obj) : fallback;
        }
        for (var i = 0; i < length; i++) {
          var prop = obj == null ? void 0 : obj[path[i]];
          if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
          }
          obj = isFunction(prop) ? prop.call(obj) : prop;
        }

        return obj;
    }

    return objects.result = result;
	
});
define('skylark-langx-objects/safe-mixin',[
	"./objects",
  "./_mixin",
  "./_parse_mixin_args"
],function(objects,_mixin,_parseMixinArgs) {

    function safeMixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, true);
        });
        return args.target;
    }

    return objects.safeMixin = safeMixin;
});
define('skylark-langx-objects/scall',[
    "./objects"
],function(objects) {

    function scall(obj,method,arg1,arg2) {
        if (obj && obj[method]) {
            var args = slice.call(arguments, 2);

            return obj[method].apply(obj,args);
        }
    }

    return objects.scall = scall;
});
 define('skylark-langx-objects/shadow',[
	"./objects"
],function(objects) {

    function shadow(obj, prop, value) {
        Object.defineProperty(obj, prop, {
            value,
            enumerable: true,
            configurable: true,
            writable: false
        });
        return value;
    }

    return objects.shadow = shadow;
});
define('skylark-langx-objects/main',[
	"./objects",
	"./clone",
	"./each",
	"./extend",
	"./includes",
	"./is-equal",
	"./mixin",
	"./omit",
	"./pick",
	"./result",
	"./safe-mixin",
	"./scall",
	"./shadow"
],function(objects){
	return objects;
});
define('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });

define('skylark-langx-hoster/hoster',[
    "skylark-langx-ns"
],function(skylark){
	// The javascript host environment, brower and nodejs are supported.
	var hoster = {
		"isBrowser" : true, // default
		"isNode" : null,
		"global" : this,
		"browser" : null,
		"node" : null
	};

	if (typeof process == "object" && process.versions && process.versions.node && process.versions.v8) {
		hoster.isNode = true;
		hoster.isBrowser = false;
	}

	hoster.global = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	var _document = null;

	Object.defineProperty(hoster,"document",function(){
		if (!_document) {
			var w = typeof window === 'undefined' ? require('html-element') : window;
			_document = w.document;
		}

		return _document;
	});

	if (hoster.global.CustomEvent === undefined) {
		hoster.global.CustomEvent = function(type,props) {
			this.type = type;
			this.props = props;
		};
	}

	if (hoster.isBrowser) {
	    function uaMatch( ua ) {
		    ua = ua.toLowerCase();

			//IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
			//Edge = !!navigator.userAgent.match(/Edge/i),
			//FireFox = !!navigator.userAgent.match(/firefox/i),
			//Safari = !!(navigator.userAgent.match(/safari/i) && !navigator.userAgent.match(/chrome/i) && !navigator.userAgent.match(/android/i)),
			//IOS = !!(navigator.userAgent.match(/iP(ad|od|hone)/i)),

		    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		      /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		      /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		      /(msie) ([\w.]+)/.exec( ua ) ||
		      ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		      [];

		    return {
		      browser: match[ 1 ] || '',
		      version: match[ 2 ] || '0'
		    };
	  	};

	    var matched = uaMatch( navigator.userAgent );

	    var browser = hoster.browser = {};

	    if ( matched.browser ) {
	      browser[ matched.browser ] = true;
	      browser.version = matched.version;
	    }

	    // Chrome is Webkit, but Webkit is also Safari.
	    if ( browser.chrome ) {
	      browser.webkit = true;
	    } else if ( browser.webkit ) {
	      browser.safari = true;
	    }
	}

	hoster.detects = {};

	return  skylark.attach("langx.hoster",hoster);
});
define('skylark-langx-hoster/detects/mobile',[
    "../hoster"
],function(hoster){
    //refer : https://github.com/kaimallea/isMobile

    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function (navigator) {
        return (typeof navigator !== 'undefined' &&
            navigator.platform === 'MacIntel' &&
            typeof navigator.maxTouchPoints === 'number' &&
            navigator.maxTouchPoints > 1 &&
            typeof MSStream === 'undefined');
    };
    function createMatch(userAgent) {
        return function (regex) { return regex.test(userAgent); };
    }
    
    function detectMobile(param) {
        var nav = {
            userAgent: '',
            platform: '',
            maxTouchPoints: 0
        };
        if (!param && typeof navigator !== 'undefined') {
            nav = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                maxTouchPoints: navigator.maxTouchPoints || 0
            };
        }
        else if (typeof param === 'string') {
            nav.userAgent = param;
        }
        else if (param && param.userAgent) {
            nav = {
                userAgent: param.userAgent,
                platform: param.platform,
                maxTouchPoints: param.maxTouchPoints || 0
            };
        }
        var userAgent = nav.userAgent;
        var tmp = userAgent.split('[FBAN');
        if (typeof tmp[1] !== 'undefined') {
            userAgent = tmp[0];
        }
        tmp = userAgent.split('Twitter');
        if (typeof tmp[1] !== 'undefined') {
            userAgent = tmp[0];
        }
        var match = createMatch(userAgent);
        var result = {
            apple: {
                phone: match(appleIphone) && !match(windowsPhone),
                ipod: match(appleIpod),
                tablet: !match(appleIphone) &&
                    (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                    !match(windowsPhone),
                universal: match(appleUniversal),
                device: (match(appleIphone) ||
                    match(appleIpod) ||
                    match(appleTablet) ||
                    match(appleUniversal) ||
                    isAppleTabletOnIos13(nav)) &&
                    !match(windowsPhone)
            },
            amazon: {
                phone: match(amazonPhone),
                tablet: !match(amazonPhone) && match(amazonTablet),
                device: match(amazonPhone) || match(amazonTablet)
            },
            android: {
                phone: (!match(windowsPhone) && match(amazonPhone)) ||
                    (!match(windowsPhone) && match(androidPhone)),
                tablet: !match(windowsPhone) &&
                    !match(amazonPhone) &&
                    !match(androidPhone) &&
                    (match(amazonTablet) || match(androidTablet)),
                device: (!match(windowsPhone) &&
                    (match(amazonPhone) ||
                        match(amazonTablet) ||
                        match(androidPhone) ||
                        match(androidTablet))) ||
                    match(/\bokhttp\b/i)
            },
            windows: {
                phone: match(windowsPhone),
                tablet: match(windowsTablet),
                device: match(windowsPhone) || match(windowsTablet)
            },
            other: {
                blackberry: match(otherBlackBerry),
                blackberry10: match(otherBlackBerry10),
                opera: match(otherOpera),
                firefox: match(otherFirefox),
                chrome: match(otherChrome),
                device: match(otherBlackBerry) ||
                    match(otherBlackBerry10) ||
                    match(otherOpera) ||
                    match(otherFirefox) ||
                    match(otherChrome)
            },
            any: false,
            phone: false,
            tablet: false
        };
        result.any =
            result.apple.device ||
                result.android.device ||
                result.windows.device ||
                result.other.device;
        result.phone =
            result.apple.phone || result.android.phone || result.windows.phone;
        result.tablet =
            result.apple.tablet || result.android.tablet || result.windows.tablet;
        return result;
    }

    return hoster.detects.mobile = detectMobile;
});

define('skylark-langx-hoster/is-mobile',[
    "./hoster",
    "./detects/mobile"
],function(hoster,detectMobile){
    if (hoster.isMobile == undefined) {
        hoster.isMobile = detectMobile();
    }

    return hoster.isMobile;
});

define('skylark-langx-hoster/main',[
	"./hoster",
	"./is-mobile"
],function(hoster){
	return hoster;
});
define('skylark-langx-hoster', ['skylark-langx-hoster/main'], function (main) { return main; });

define('skylark-langx-arrays/arrays',[
  "skylark-langx-ns",
  "skylark-langx-types",
  "skylark-langx-objects"
],function(skylark,types,objects){
    var filter = Array.prototype.filter,
        find = Array.prototype.find,
        isArrayLike = types.isArrayLike;

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }


    function compact(array) {
        return filter.call(array, function(item) {
            return item != null;
        });
    }

    function filter2(array,func) {
      return filter.call(array,func);
    }

    function flatten(array) {
        if (isArrayLike(array)) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                if (isArrayLike(item)) {
                    for (var j = 0; j < item.length; j++) {
                        result.push(item[j]);
                    }
                } else {
                    result.push(item);
                }
            }
            return result;
        } else {
            return array;
        }
        //return array.length > 0 ? concat.apply([], array) : array;
    }

    function grep(array, callback) {
        var out = [];

        objects.each(array, function(i, item) {
            if (callback(item, i)) {
                out.push(item);
            }
        });

        return out;
    }

    function inArray(item, array) {
        if (!array) {
            return -1;
        }
        var i;

        if (array.indexOf) {
            return array.indexOf(item);
        }

        i = array.length;
        while (i--) {
            if (array[i] === item) {
                return i;
            }
        }

        return -1;
    }

    function indexOf(array,item) {
      return array.indexOf(item);
    }

    function makeArray(obj, offset, startWith) {
       if (isArrayLike(obj) ) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }

      // array of single index
      return [ obj ];             
    }


    function forEach (arr, fn) {
      if (arr.forEach) return arr.forEach(fn)
      for (var i = 0; i < arr.length; i++) fn(arr[i], i);
    }

    function last(arr) {
        return arr[arr.length - 1];     
    }

    function map(elements, callback) {
        var value, values = [],
            i, key
        if (isArrayLike(elements))
            for (i = 0; i < elements.length; i++) {
                value = callback.call(elements[i], elements[i], i);
                if (value != null) values.push(value)
            }
        else
            for (key in elements) {
                value = callback.call(elements[key], elements[key], key);
                if (value != null) values.push(value)
            }
        return flatten(values)
    }


    function merge( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }

    function reduce(array,callback,initialValue) {
        return Array.prototype.reduce.call(array,callback,initialValue);
    }

    function uniq(array) {
        return filter.call(array, function(item, idx) {
            return array.indexOf(item) == idx;
        })
    }

    function find2(array,func) {
      return find.call(array,func);
    }

    return skylark.attach("langx.arrays",{
        baseFindIndex: baseFindIndex,

        baseIndexOf : baseIndexOf,
        
        compact: compact,

        first : function(items,n) {
            if (n) {
                return items.slice(0,n);
            } else {
                return items[0];
            }
        },

        filter : filter2,

        find : find2,
        
        flatten: flatten,

        grep: grep,

        inArray: inArray,

        indexOf : indexOf,

        makeArray: makeArray, // 

        toArray : makeArray,

        last : last,

        merge : merge,

        forEach : forEach,

        map : map,
        
        reduce : reduce,

        uniq : uniq

    });
});
define('skylark-langx-arrays/main',[
	"./arrays"
],function(arrays){
	return arrays;
});
define('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });

define('skylark-langx-funcs/funcs',[
  "skylark-langx-ns",
],function(skylark,types,objects){
        



    function noop() {
    }




    return skylark.attach("langx.funcs",{
        noop : noop,

        returnTrue: function() {
            return true;
        },

        returnFalse: function() {
            return false;
        }

    });
});
define('skylark-langx-funcs/defer',[
    "skylark-langx-types",
    "./funcs"
],function(types,funcs){

    function defer(fn,trigger,args,context) {
        var ret = {
            cancel : null
        },
        fn1 = fn;

        if (!types.isNumber(trigger) && !types.isFunction(trigger)) {
            context = args;
            args = trigger;
            trigger = 0;
        }

        if (args) {
            fn1 = function() {
                fn.apply(context,args);
            };
        }

        if (types.isFunction(trigger)) {
            var canceled = false;
            trigger(function(){
                if (!canceled) {
                    fn1();
                }
            });

            ret.cancel = function() {
                canceled = true;
            }

        } else {
            var  id;
            if (trigger == 0 && requestAnimationFrame) {
                id = requestAnimationFrame(fn1);
                ret.cancel = function() {
                    return cancelAnimationFrame(id);
                };
            } else {
                id = setTimeout(fn1,trigger);
                ret.cancel = function() {
                    return clearTimeout(id);
                };
            }            
        }

        return ret;
    }

    return funcs.defer = defer;
});
define('skylark-langx-funcs/debounce',[
	"./funcs",
    "./defer"
],function(funcs,defer){
   
    function debounce(fn, wait,useAnimationFrame) {
        var timeout,
            defered,
            debounced = function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (useAnimationFrame) {
                        defered = defer(fn,args,context);
                    } else {
                        fn.apply(context, args);
                    }
                };

                cancel();
                timeout = setTimeout(later, wait);

                return {
                    cancel 
                };
            },
            cancel = debounced.cancel = function () {
                if (timeout) {
                    clearTimeout(timeout);
                }
                if (defered) {
                    defered.cancel();
                }
                timeout = void 0;
                defered = void 0;
            };

        return debounced;
    }

    return funcs.debounce = debounce;

});
define('skylark-langx-funcs/delegate',[
  "skylark-langx-objects",
  "./funcs"
],function(objects,funcs){
	var mixin = objects.mixin;

    var delegate = (function() {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {}
        return function(obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();

    return funcs.delegate = delegate;

});
define('skylark-langx-funcs/loop',[
	"./funcs"
],function(funcs){

	/**
	 * Animation timer is a special type of timer that uses the requestAnimationFrame method.
	 *
	 * This timer calls the method with the same rate as the screen refesh rate.
	 * 
	 * Loop time can be changed dinamically.
	 *
	 * @class AnimationTimer
	 * @param {Function} callback Timer callback function.
	 */
	function AnimationTimer(callback)
	{
		this.callback = callback;

		this.running = false;
		this.id = -1;
	}

	/**
	 * Start timer, is the timer is already running dosen't do anything.
	 * 
	 * @method start
	 */
	AnimationTimer.prototype.start = function()
	{
		if(this.running)
		{
			return;
		}

		this.running = true;

		var self = this;
		function run()
		{
			self.callback();

			if(self.running)
			{
				self.id = requestAnimationFrame(run);
			}
		}

		run();
	};

	/**
	 * Stop animation timer.
	 * 
	 * @method stop
	 */
	AnimationTimer.prototype.stop = function()
	{
		this.running = false;
		cancelAnimationFrame(this.id);
	};

	function loop(fn) {
		return new AnimationTimer(fn);
    }

    return funcs.loop = loop;
});
define('skylark-langx-funcs/negate',[
	"./funcs"
],function(funcs){
   
    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0
     * }
     *
     * filter([1, 2, 3, 4, 5, 6], negate(isEven))
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate !== 'function') {
        throw new TypeError('Expected a function')
      }
      return function(...args) {
        return !predicate.apply(this, args)
      }
    }


    return funcs.negate = negate;

});
define('skylark-langx-funcs/proxy',[
  "skylark-langx-types",
	"./funcs"
],function(types,funcs){
    var slice = Array.prototype.slice,
        isFunction = types.isFunction,
        isString = types.isString;

    function proxy(fn, context) {
        var args = (2 in arguments) && slice.call(arguments, 2)
        if (isFunction(fn)) {
            var proxyFn = function() {
                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
            }
            return proxyFn;
        } else if (isString(context)) {
            if (args) {
                args.unshift(fn[context], fn)
                return proxy.apply(null, args)
            } else {
                return proxy(fn[context], fn);
            }
        } else {
            throw new TypeError("expected function");
        }
    }

    return funcs.bind = funcs.proxy = proxy;

});
define('skylark-langx-funcs/template',[
  "skylark-langx-objects",
  "./funcs",
  "./proxy"
],function(objects,funcs,proxy){
    //ref : underscore
    var slice = Array.prototype.slice;
   
    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    var templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;


    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;


    function template(text, data, settings) {
        var render;
        settings = objects.defaults({}, settings,templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset)
              .replace(escaper, function(match) { return '\\' + escapes[match]; });

          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';

        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }

        if (data) {
          return render(data,this)
        }
        var template = proxy(function(data) {
          return render.call(this, data,this);
        },this);

        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';

        return template;
    }

    template.templateSettings = funcs.templateSettings = templateSettings;

    return funcs.template = template;

});
define('skylark-langx-funcs/throttle',[
  "./funcs"
],function(funcs){

    const throttle = function (fn, wait) {
        let last = window.performance.now();
        const throttled = function (...args) {
            const now = window.performance.now();
            if (now - last >= wait) {
                fn(...args);
                last = now;
            }
        };
        return throttled;
    };

    /*
    function throttle(func, delay) {
        var timer = null;

        return function() {
            var context = this,
                args = arguments;

            if ( timer === null ) {
                timer = setTimeout(function() {
                    func.apply(context, args);
                    timer = null;
                }, delay);
            }
        };
    }
    */


    return funcs.throttle = throttle;
});
define('skylark-langx-funcs/main',[
	"./funcs",
	"./debounce",
	"./defer",
	"./delegate",
	"./loop",
	"./negate",
	"./proxy",
	"./template",
	"./throttle"
],function(funcs){
	return funcs;
});
define('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });

define('skylark-langx-async/deferred',[
    "skylark-langx-arrays",
	"skylark-langx-funcs",
    "skylark-langx-objects"
],function(arrays,funcs,objects){
    "use strict";

    var slice = Array.prototype.slice,
        proxy = funcs.proxy,
        makeArray = arrays.makeArray,
        result = objects.result,
        mixin = objects.mixin;

    mixin(Promise.prototype,{
        always: function(handler) {
            //this.done(handler);
            //this.fail(handler);
            this.then(handler,handler);
            return this;
        },
        done : function() {
            for (var i = 0;i<arguments.length;i++) {
                this.then(arguments[i]);
            }
            return this;
        },
        fail : function(handler) { 
            //return mixin(Promise.prototype.catch.call(this,handler),added);
            //return this.then(null,handler);
            this.catch(handler);
            return this;
         }
    });


    var Deferred = function() {
        var self = this,
            p = this.promise = makePromise2(new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            }));

        //wrapPromise(p,self);

        //this[PGLISTENERS] = [];
        //this[PGNOTIFIES] = [];

        //this.resolve = Deferred.prototype.resolve.bind(this);
        //this.reject = Deferred.prototype.reject.bind(this);
        //this.progress = Deferred.prototype.progress.bind(this);

    };

   
    function makePromise2(promise) {
        // Don't modify any promise that has been already modified.
        if (promise.isResolved) return promise;

        // Set initial state
        var isPending = true;
        var isRejected = false;
        var isResolved = false;

        // Observe the promise, saving the fulfillment in a closure scope.
        var result = promise.then(
            function(v) {
                isResolved = true;
                isPending = false;
                return v; 
            }, 
            function(e) {
                isRejected = true;
                isPending = false;
                throw e; 
            }
        );

        result.isResolved = function() { return isResolved; };
        result.isPending = function() { return isPending; };
        result.isRejected = function() { return isRejected; };

        result.state = function() {
            if (isResolved) {
                return 'resolved';
            }
            if (isRejected) {
                return 'rejected';
            }
            return 'pending';
        };

        var notified = [],
            listeners = [];

          
        result.then = function(onResolved,onRejected,onProgress) {
            if (onProgress) {
                this.progress(onProgress);
            }
            return makePromise2(Promise.prototype.then.call(this,
                onResolved && function(args) {
                    if (args && args.__ctx__ !== undefined) {
                        return onResolved.apply(args.__ctx__,args);
                    } else {
                        return onResolved(args);
                    }
                },
                onRejected && function(args){
                    if (args && args.__ctx__ !== undefined) {
                        return onRejected.apply(args.__ctx__,args);
                    } else {
                        return onRejected(args);
                    }
                }
            ));
        };

        result.progress = function(handler) {
            notified.forEach(function (value) {
                handler(value);
            });
            listeners.push(handler);
            return this;
        };

        result.pipe = result.then;

        result.notify = function(value) {
            try {
                notified.push(value);

                return listeners.forEach(function (listener) {
                    return listener(value);
                });
            } catch (error) {
            this.reject(error);
            }
            return this;
        };

        return result;
    }

 
    Deferred.prototype.resolve = function(value) {
        var args = slice.call(arguments);
        return this.resolveWith(null,args);
    };

    Deferred.prototype.resolveWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._resolve(args);
        this._resolved = true;
        return this;
    };

    Deferred.prototype.notify = function(value) {
        var p = result(this,"promise");
        p.notify(value);
        return this;
    };

    Deferred.prototype.reject = function(reason) {
        var args = slice.call(arguments);
        return this.rejectWith(null,args);
    };

    Deferred.prototype.rejectWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._reject(args);
        this._rejected = true;
        return this;
    };

    Deferred.prototype.isResolved = function() {
        var p = result(this,"promise");
        return p.isResolved();
    };

    Deferred.prototype.isRejected = function() {
        var p = result(this,"promise");
        return p.isRejected();
    };

    Deferred.prototype.state = function() {
        var p = result(this,"promise");
        return p.state();
    };

    Deferred.prototype.then = function(callback, errback, progback) {
        var p = result(this,"promise");
        return p.then(callback, errback, progback);
    };

    Deferred.prototype.progress = function(progback){
        var p = result(this,"promise");
        return p.progress(progback);
    };
   
    Deferred.prototype.catch = function(errback) {
        var p = result(this,"promise");
        return p.catch(errback);
    };


    Deferred.prototype.always  = function() {
        var p = result(this,"promise");
        p.always.apply(p,arguments);
        return this;
    };

    Deferred.prototype.done  = function() {
        var p = result(this,"promise");
        p.done.apply(p,arguments);
        return this;
    };

    Deferred.prototype.fail = function(errback) {
        var p = result(this,"promise");
        p.fail(errback);
        return this;
    };


    Deferred.all = function(array) {
        //return wrapPromise(Promise.all(array));
        var d = new Deferred();
        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));
        return result(d,"promise");
    };

    Deferred.first = function(array) {
        return makePromise2(Promise.race(array));
    };


    Deferred.when = function(valueOrPromise, callback, errback, progback) {
        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

        if (!receivedPromise) {
            if (arguments.length > 1) {
                return callback ? callback(valueOrPromise) : valueOrPromise;
            } else {
                return new Deferred().resolve(valueOrPromise);
            }
        } else if (!nativePromise) {
            var deferred = new Deferred(valueOrPromise.cancel);
            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);
            valueOrPromise = deferred.promise;
        }

        if (callback || errback || progback) {
            return valueOrPromise.then(callback, errback, progback);
        }
        return valueOrPromise;
    };

    Deferred.reject = function(err) {
        var d = new Deferred();
        d.reject(err);
        return d.promise;
    };

    Deferred.resolve = function(data) {
        var d = new Deferred();
        d.resolve.apply(d,arguments);
        return d.promise;
    };

    Deferred.immediate = Deferred.resolve;


    Deferred.promise = function(callback) {
        var d = new Deferred();

        callback(d.resolve.bind(d),d.reject.bind(d),d.progress.bind(d));

        return d.promise;
    };

    return Deferred;
});
define('skylark-langx-async/async',[
    "skylark-langx-ns",
    "skylark-langx-objects",
    "./deferred"
],function(skylark,objects,Deferred){
    var each = objects.each;
    
    var async = {
        Deferred : Deferred,

        parallel : function(arr,args,ctx) {
            var rets = [];
            ctx = ctx || null;
            args = args || [];

            each(arr,function(i,func){
                rets.push(func.apply(ctx,args));
            });

            return Deferred.all(rets);
        },

        series : function(arr,args,ctx) {
            var rets = [],
                d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolve();
            each(arr,function(i,func){
                p = p.then(function(){
                    return func.apply(ctx,args);
                });
                rets.push(p);
            });

            return Deferred.all(rets);
        },

        waterful : function(arr,args,ctx) {
            var d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolveWith(ctx,args);

            each(arr,function(i,func){
                p = p.then(func);
            });
            return p;
        }
    };

	return skylark.attach("langx.async",async);	
});
define('skylark-langx-async/main',[
	"./async"
],function(async){
	return async;
});
define('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });

define('skylark-langx-events/events',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("langx.events",{});
});
define('skylark-langx-constructs/constructs',[
  "skylark-langx-ns"
],function(skylark){

    return skylark.attach("langx.constructs",{});
});
define('skylark-langx-constructs/inherit',[
	"./constructs"
],function(constructs){

    function inherit(ctor,base) {
        ///var f = function() {};
        ///f.prototype = base.prototype;
        ///
        ///ctor.prototype = new f();

	    if ((typeof base !== "function") && base) {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    ctor.prototype = Object.create(base && base.prototype, {
	      constructor: {
	        value: ctor,
	        writable: true,
	        configurable: true
	      }
	    });

	    if (base) {
	    	//tor.__proto__ = base;
	    	Object.setPrototypeOf(ctor, base);
	    } 
    }

    return constructs.inherit = inherit
});
define('skylark-langx-constructs/klass',[
  "skylark-langx-ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "./constructs",
  "./inherit"
],function(skylark,types,objects,arrays,constructs,inherit){
    var uniq = arrays.uniq,
        has = objects.has,
        mixin = objects.mixin,
        isArray = types.isArray,
        isDefined = types.isDefined;

/* for reference 
 function klass(props,parent) {
    var ctor = function(){
        this._construct();
    };
    ctor.prototype = props;
    if (parent) {
        ctor._proto_ = parent;
        props.__proto__ = parent.prototype;
    }
    return ctor;
}

// Type some JavaScript code here.
let animal = klass({
  _construct(){
      this.name = this.name + ",hi";
  },
    
  name: "Animal",
  eat() {         // [[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
    
    
});


let rabbit = klass({
  name: "Rabbit",
  _construct(){
      super._construct();
  },
  eat() {         // [[HomeObject]] == rabbit
    super.eat();
  }
},animal);

let longEar = klass({
  name: "Long Ear",
  eat() {         // [[HomeObject]] == longEar
    super.eat();
  }
},rabbit);
*/
    


    var f1 = function() {
        function extendClass(ctor, props, options) {
            // Copy the properties to the prototype of the class.
            var proto = ctor.prototype,
                _super = ctor.superclass.prototype,
                noOverrided = options && options.noOverrided,
                overrides = options && options.overrides || {};

            for (var name in props) {
                if (name === "constructor") {
                    continue;
                }

                // Check if we're overwriting an existing function
                var prop = props[name];
                if (typeof props[name] == "function") {
                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == "function" ?
                          (function(name, fn, superFn) {
                            return function() {
                                var tmp = this.overrided;

                                // Add a new ._super() method that is the same method
                                // but on the super-class
                                this.overrided = superFn;

                                // The method only need to be bound temporarily, so we
                                // remove it when we're done executing
                                var ret = fn.apply(this, arguments);

                                this.overrided = tmp;

                                return ret;
                            };
                        })(name, prop, _super[name]) :
                        prop;
                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {
                    Object.defineProperty(proto,name,prop);
                } else {
                    proto[name] = prop;
                }
            }
            return ctor;
        }

        function serialMixins(ctor,mixins) {
            var result = [];

            mixins.forEach(function(mixin){
                if (has(mixin,"__mixins__")) {
                     throw new Error("nested mixins");
                }
                var clss = [];
                while (mixin) {
                    clss.unshift(mixin);
                    mixin = mixin.superclass;
                }
                result = result.concat(clss);
            });

            result = uniq(result);

            result = result.filter(function(mixin){
                var cls = ctor;
                while (cls) {
                    if (mixin === cls) {
                        return false;
                    }
                    if (has(cls,"__mixins__")) {
                        var clsMixines = cls["__mixins__"];
                        for (var i=0; i<clsMixines.length;i++) {
                            if (clsMixines[i]===mixin) {
                                return false;
                            }
                        }
                    }
                    cls = cls.superclass;
                }
                return true;
            });

            if (result.length>0) {
                return result;
            } else {
                return false;
            }
        }

        function mergeMixins(ctor,mixins) {
            var newCtor =ctor;
            for (var i=0;i<mixins.length;i++) {
                var xtor = new Function();

                inherit(xtor,newCtor)
                //xtor.prototype = Object.create(newCtor.prototype);
                //xtor.__proto__ = newCtor;
                xtor.superclass = null;
                mixin(xtor.prototype,mixins[i].prototype);
                xtor.prototype.__mixin__ = mixins[i];
                newCtor = xtor;
            }

            return newCtor;
        }

        function _constructor ()  {
            if (this._construct) {
                return this._construct.apply(this, arguments);
            } else  if (this.init) {
                return this.init.apply(this, arguments);
            }
        }

        return function createClass(props, parent, mixins,options) {
            if (isArray(parent)) {
                options = mixins;
                mixins = parent;
                parent = null;
            }
            parent = parent || Object;

            if (isDefined(mixins) && !isArray(mixins)) {
                options = mixins;
                mixins = false;
            }

            var innerParent = parent;

            if (mixins) {
                mixins = serialMixins(innerParent,mixins);
            }

            if (mixins) {
                innerParent = mergeMixins(innerParent,mixins);
            }

            var klassName = props.klassName || "",
                ctor = new Function(
                    "return function " + klassName + "() {" +
                    "var inst = this," +
                    " ctor = arguments.callee;" +
                    "if (!(inst instanceof ctor)) {" +
                    "inst = Object.create(ctor.prototype);" +
                    "}" +
                    "return ctor._constructor.apply(inst, arguments) || inst;" + 
                    "}"
                )();


            // Populate our constructed prototype object
            ///ctor.prototype = Object.create(innerParent.prototype);

            // Enforce the constructor to be what we expect
            ///ctor.prototype.constructor = ctor;
  
            // And make this class extendable
            ///ctor.__proto__ = innerParent;

            inherit(ctor,innerParent);

            ctor.superclass = parent;

            if (!ctor._constructor) {
                ctor._constructor = _constructor;
            } 

            if (mixins) {
                ctor.__mixins__ = mixins;
            }

            if (!ctor.partial) {
                ctor.partial = function(props, options) {
                    return extendClass(this, props, options);
                };
            }
            if (!ctor.inherit) {
                ctor.inherit = function(props, mixins,options) {
                    return createClass(props, this, mixins,options);
                };
            }

            ctor.partial(props, options);

            return ctor;
        };
    }

    var createClass = f1();

    return constructs.klass = createClass;
});
define('skylark-langx-klass/klass',[
  "skylark-langx-ns",
  "skylark-langx-constructs/klass"
],function(skylark,klass){


    return skylark.attach("langx.klass",klass);
});
define('skylark-langx-klass/main',[
	"./klass"
],function(klass){
	return klass;
});
define('skylark-langx-klass', ['skylark-langx-klass/main'], function (main) { return main; });

define('skylark-langx-events/event',[
  "skylark-langx-objects",
  "skylark-langx-funcs",
  "skylark-langx-klass",
  "skylark-langx-hoster",
    "./events"
],function(objects,funcs,klass,events){
    var eventMethods = {
        preventDefault: "isDefaultPrevented",
        stopImmediatePropagation: "isImmediatePropagationStopped",
        stopPropagation: "isPropagationStopped"
     };
        

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            objects.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = funcs.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = funcs.returnFalse;
            });
        }
        return event;
    }


    /*
    var Event = klass({
        _construct : function(type,props) {
            CustomEvent.call(this,type.props);
            objects.safeMixin(this, props);
            compatible(this);
        }
    },CustomEvent);
    */

    class Event extends CustomEvent {
        constructor(type,props) {
            super(type,props);
            objects.safeMixin(this, props);
            compatible(this);
        } 
    }


    Event.compatible = compatible;

    return events.Event = Event;
    
});
define('skylark-langx-events/listener',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./event"
],function(types,objects,arrays,klass,events,Event){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isUndefined = types.isUndefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isBoolean = types.isBoolean,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;


    var Listener = klass({

        listenTo: function(obj, event, selector,callback, /*used internally*/ one) {
            if (!obj) {
                return this;
            }

            if (types.isPlainObject(event)){
                //listenTo(obj,callbacks,one)
                if (types.isBoolean(selector)) {
                    one = selector;
                    selector = null;
                } else if (types.isBoolean(callback)) {
                    one = callback;
                }
                var callbacks = event;
                for (var name in callbacks) {

                    var match = name.match( /^([\w:-]*)\s*(.*)$/ );
                    var name1 = match[ 1 ];
                    var selector1 = match[ 2 ] || selector;

                    if (selector1) {
                        this.listenTo(obj,name1,selector1,callbacks[name],one);
                    } else {
                        this.listenTo(obj,name1,callbacks[name],one);
                    }

                }
                return this;
            }

            if (isBoolean(callback)) {
                one = callback;
                callback = selector;
                selector = null;
            } else if (isBoolean(selector)) {
                one = selector;
                callback = selector = null;
            } else if (isUndefined(callback)){
                one = false;
                callback = selector;
                selector = null;
            }



            if (!callback) {
                callback = "handleEvent";
            }
            
            // Bind callbacks on obj,
            if (isString(callback)) {
                callback = this[callback];
            }

            if (one) {
                if (selector) {
                    obj.one(event, selector,callback, this);
                } else {
                    obj.one(event, callback, this);
                }
            } else {
                 if (selector) {
                    obj.on(event, selector, callback, this);
                } else {
                    obj.on(event, callback, this);
                }
            }

            //keep track of them on listening.
            var listeningTo = this._listeningTo || (this._listeningTo = []),
                listening;

            for (var i = 0; i < listeningTo.length; i++) {
                if (listeningTo[i].obj == obj) {
                    listening = listeningTo[i];
                    break;
                }
            }
            if (!listening) {
                listeningTo.push(
                    listening = {
                        obj: obj,
                        events: {}
                    }
                );
            }
            var listeningEvents = listening.events,
                listeningEvent = listeningEvents[event] = listeningEvents[event] || [];
            if (listeningEvent.indexOf(callback) == -1) {
                listeningEvent.push(callback);
            }

            return this;
        },

        listenToOnce: function(obj, event,selector, callback) {
            return this.listenTo(obj, event,selector, callback, 1);
        },

        unlistenTo: function(obj, event, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo) {
                return this;
            }

            if (isString(callback)) {
                callback = this[callback];
            }

            for (var i = 0; i < listeningTo.length; i++) {
                var listening = listeningTo[i];

                if (obj && obj != listening.obj) {
                    continue;
                }

                var listeningEvents = listening.events;

                for (var eventName in listeningEvents) {
                    if (event && event != eventName) {
                        continue;
                    }

                    var listeningEvent = listeningEvents[eventName];

                    if (!listeningEvent) { 
                        continue;
                    }

                    for (var j = 0; j < listeningEvent.length; j++) {
                        if (!callback || callback == listeningEvent[i]) {
                            listening.obj.off(eventName, listeningEvent[i], this);
                            listeningEvent[i] = null;
                        }
                    }

                    listeningEvent = listeningEvents[eventName] = compact(listeningEvent);

                    if (isEmptyObject(listeningEvent)) {
                        listeningEvents[eventName] = null;
                    }

                }

                if (isEmptyObject(listeningEvents)) {
                    listeningTo[i] = null;
                }
            }

            listeningTo = this._listeningTo = compact(listeningTo);
            if (isEmptyObject(listeningTo)) {
                this._listeningTo = null;
            }

            return this;
        }
    });

    return events.Listener = Listener;

});
define('skylark-langx-events/emitter',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./event",
  "./listener"
],function(types,objects,arrays,klass,events,Event,Listener){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    
    var queues  = new Map();


    var Emitter = Listener.inherit({
        _prepareArgs : function(e,args) {
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            return args;
        },

        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (!callback ) {
                throw new Error("No callback function");
            } else if (!isFunction(callback)) {
                throw new Error("The callback  is not afunction");
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new Event(e); //new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);

            args = this._prepareArgs(e,args);

            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                        return this;
                    }
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }

                    if (listener.data) {
                        e.data = mixin({}, listener.data, e.data);
                    }
                    if (args.length == 2 && isPlainObject(args[1])) {
                        e.data = e.data || {};
                        mixin(e.data,args[1]);
                    }

                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        queueEmit : function (event) {
            const type = event.type || event;
            let map = queues.get(this);
            if (!map) {
                map = new Map();
                queues.set(this, map);
            }
            const oldTimeout = map.get(type);
            map.delete(type);
            window.clearTimeout(oldTimeout);
            const timeout = window.setTimeout(() => {
                if (map.size === 0) {
                    map = null;
                    queues.delete(this);
                }
                this.trigger(event);
            }, 0);
            map.set(type, timeout);
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        off: function(events, callback) {
            if (!events) {
              this._hub = null;
              return;
            }
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },

        trigger  : function() {
            return this.emit.apply(this,arguments);
        },

        queueTrigger : function (event) {
            return this.queueEmit.apply(this,arguments);
        }

    });


    return events.Emitter = Emitter;

});
define('skylark-langx-events/create-event',[
	"./events",
	"./event"
],function(events,Event){
    function createEvent(type,props) {
        //var e = new CustomEvent(type,props);
        //return safeMixin(e, props);
        return new Event(type,props);
    };

    return events.createEvent = createEvent;	
});
define('skylark-langx-events/main',[
	"./events",
	"./event",
	"./listener",
	"./emitter",
	"./create-event"
],function(events){
	return events;
});
define('skylark-langx-events', ['skylark-langx-events/main'], function (main) { return main; });

define('skylark-langx-emitter/emitter',[
    "skylark-langx-events"
],function(events){
    return events.Emitter;
});
define('skylark-langx-emitter/evented',[
	"./emitter"
],function(Emitter){
	return Emitter;
});
define('skylark-langx-urls/urls',[
  "skylark-langx-ns"
],function(skylark){


    return skylark.attach("langx.urls",{

    });
});



define('skylark-langx-urls/parse-url',[
    './urls'
], function (urls) {
    'use strict';
    const parseUrl = function (url) {
        const props = [
            'protocol',
            'hostname',
            'port',
            'pathname',
            'search',
            'hash',
            'host'
        ];
        let a = document.createElement('a');
        a.href = url;
        const addToBody = a.host === '' && a.protocol !== 'file:';
        let div;
        if (addToBody) {
            div = document.createElement('div');
            div.innerHTML = `<a href="${ url }"></a>`;
            a = div.firstChild;
            div.setAttribute('style', 'display:none; position:absolute;');
            document.body.appendChild(div);
        }
        const details = {};
        for (let i = 0; i < props.length; i++) {
            details[props[i]] = a[props[i]];
        }
        if (details.protocol === 'http:') {
            details.host = details.host.replace(/:80$/, '');
        }
        if (details.protocol === 'https:') {
            details.host = details.host.replace(/:443$/, '');
        }
        if (!details.protocol) {
            details.protocol = window.location.protocol;
        }
        if (addToBody) {
            document.body.removeChild(div);
        }
        return details;
    };

    return urls.parseUrl = parseUrl;
});
define('skylark-langx-urls/is-cross-origin',[
    './urls',
    "./parse-url"
], function (urls,parseUrl) {
    'use strict';

    const isCrossOrigin = function (url, winLoc = window.location) {
        const urlInfo = parseUrl(url);
        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;
        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
        return crossOrigin;
    };

    return urls.isCrossOrigin = isCrossOrigin;

});
define('skylark-net-http/http',[
  "skylark-langx-ns/ns",
],function(skylark){
	return skylark.attach("net.http",{});
});
define('skylark-net-http/Xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/deferred",
  "skylark-langx-emitter/evented",
  "skylark-langx-urls/is-cross-origin",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,isCrossOrigin,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            traditional : false,
            
            xhrFields : {
                ///withCredentials : false
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                if (type(options.data) != "string") {
                    options.data = param(options.data, options.traditional);
                }
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }
        
        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                if (dataType == "blob" || dataType == "arraybuffer") {
                    xhr.responseType = dataType;
                }

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        //result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(xhr.responseText);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(xhr.responseText) ? null : JSON.parse(xhr.responseText);
                            } else if (dataType == "blob") {
                                result = xhr.response; // new Blob([xhr.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.response;
                            } else {
                                //if (dataType == "text" || dataType=="html")
                                result = xhr.responseText;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };
                
                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    if (!isCrossOrigin(url)) {// for s02
                      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); 
                    }
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

    return http.Xhr = Xhr;  
});
define('skylark-langx/skylark',[
    "skylark-langx-ns"
], function(ns) {
	return ns;
});

define('skylark-langx/arrays',[
	"skylark-langx-arrays"
],function(arrays){
  return arrays;
});
define('skylark-langx/klass',[
    "skylark-langx-klass"
],function(klass){
    return klass;
});
define('skylark-langx/array-store',[
    "./klass"
],function(klass){
    var SimpleQueryEngine = function(query, options){
        // summary:
        //      Simple query engine that matches using filter functions, named filter
        //      functions or objects by name-value on a query object hash
        //
        // description:
        //      The SimpleQueryEngine provides a way of getting a QueryResults through
        //      the use of a simple object hash as a filter.  The hash will be used to
        //      match properties on data objects with the corresponding value given. In
        //      other words, only exact matches will be returned.
        //
        //      This function can be used as a template for more complex query engines;
        //      for example, an engine can be created that accepts an object hash that
        //      contains filtering functions, or a string that gets evaluated, etc.
        //
        //      When creating a new dojo.store, simply set the store's queryEngine
        //      field as a reference to this function.
        //
        // query: Object
        //      An object hash with fields that may match fields of items in the store.
        //      Values in the hash will be compared by normal == operator, but regular expressions
        //      or any object that provides a test() method are also supported and can be
        //      used to match strings by more complex expressions
        //      (and then the regex's or object's test() method will be used to match values).
        //
        // options: dojo/store/api/Store.QueryOptions?
        //      An object that contains optional information such as sort, start, and count.
        //
        // returns: Function
        //      A function that caches the passed query under the field "matches".  See any
        //      of the "query" methods on dojo.stores.
        //
        // example:
        //      Define a store with a reference to this engine, and set up a query method.
        //
        //  |   var myStore = function(options){
        //  |       //  ...more properties here
        //  |       this.queryEngine = SimpleQueryEngine;
        //  |       //  define our query method
        //  |       this.query = function(query, options){
        //  |           return QueryResults(this.queryEngine(query, options)(this.data));
        //  |       };
        //  |   };

        // create our matching query function
        switch(typeof query){
            default:
                throw new Error("Can not query with a " + typeof query);
            case "object": case "undefined":
                var queryObject = query;
                query = function(object){
                    for(var key in queryObject){
                        var required = queryObject[key];
                        if(required && required.test){
                            // an object can provide a test method, which makes it work with regex
                            if(!required.test(object[key], object)){
                                return false;
                            }
                        }else if(required != object[key]){
                            return false;
                        }
                    }
                    return true;
                };
                break;
            case "string":
                // named query
                if(!this[query]){
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];
                // fall through
            case "function":
                // fall through
        }
        
        function filter(arr, callback, thisObject){
            // summary:
            //      Returns a new Array with those items from arr that match the
            //      condition implemented by callback.
            // arr: Array
            //      the array to iterate over.
            // callback: Function|String
            //      a function that is invoked with three arguments (item,
            //      index, array). The return of this function is expected to
            //      be a boolean which determines whether the passed-in item
            //      will be included in the returned array.
            // thisObject: Object?
            //      may be used to scope the call to callback
            // returns: Array
            // description:
            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
            //      run over sparse arrays, this implementation passes the "holes" in the sparse array to
            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
            //      For more details, see:
            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
            // example:
            //  | // returns [2, 3, 4]
            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });

            // TODO: do we need "Ctr" here like in map()?
            var i = 0, l = arr && arr.length || 0, out = [], value;
            if(l && typeof arr == "string") arr = arr.split("");
            if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
            if(thisObject){
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback.call(thisObject, value, i, arr)){
                        out.push(value);
                    }
                }
            }else{
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback(value, i, arr)){
                        out.push(value);
                    }
                }
            }
            return out; // Array
        }

        function execute(array){
            // execute the whole query, first we filter
            var results = filter(array, query);
            // next we sort
            var sortSet = options && options.sort;
            if(sortSet){
                results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
                    for(var sort, i=0; sort = sortSet[i]; i++){
                        var aValue = a[sort.attribute];
                        var bValue = b[sort.attribute];
                        // valueOf enables proper comparison of dates
                        aValue = aValue != null ? aValue.valueOf() : aValue;
                        bValue = bValue != null ? bValue.valueOf() : bValue;
                        if (aValue != bValue){
                            // modified by lwf 2016/07/09
                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                        }
                    }
                    return 0;
                });
            }
            // now we paginate
            if(options && (options.start || options.count)){
                var total = results.length;
                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                results.total = total;
            }
            return results;
        }
        execute.matches = query;
        return execute;
    };

    var QueryResults = function(results){
        // summary:
        //      A function that wraps the results of a store query with additional
        //      methods.
        // description:
        //      QueryResults is a basic wrapper that allows for array-like iteration
        //      over any kind of returned data from a query.  While the simplest store
        //      will return a plain array of data, other stores may return deferreds or
        //      promises; this wrapper makes sure that *all* results can be treated
        //      the same.
        //
        //      Additional methods include `forEach`, `filter` and `map`.
        // results: Array|dojo/promise/Promise
        //      The result set as an array, or a promise for an array.
        // returns:
        //      An array-like object that can be used for iterating over.
        // example:
        //      Query a store and iterate over the results.
        //
        //  |   store.query({ prime: true }).forEach(function(item){
        //  |       //  do something
        //  |   });

        if(!results){
            return results;
        }

        var isPromise = !!results.then;
        // if it is a promise it may be frozen
        if(isPromise){
            results = Object.delegate(results);
        }
        function addIterativeMethod(method){
            // Always add the iterative methods so a QueryResults is
            // returned whether the environment is ES3 or ES5
            results[method] = function(){
                var args = arguments;
                var result = Deferred.when(results, function(results){
                    //Array.prototype.unshift.call(args, results);
                    return QueryResults(Array.prototype[method].apply(results, args));
                });
                // forEach should only return the result of when()
                // when we're wrapping a promise
                if(method !== "forEach" || isPromise){
                    return result;
                }
            };
        }

        addIterativeMethod("forEach");
        addIterativeMethod("filter");
        addIterativeMethod("map");
        if(results.total == null){
            results.total = Deferred.when(results, function(results){
                return results.length;
            });
        }
        return results; // Object
    };

    var ArrayStore = klass({
        "klassName": "ArrayStore",

        "queryEngine": SimpleQueryEngine,
        
        "idProperty": "id",


        get: function(id){
            // summary:
            //      Retrieves an object by its identity
            // id: Number
            //      The identity to use to lookup the object
            // returns: Object
            //      The object in the store that matches the given id.
            return this.data[this.index[id]];
        },

        getIdentity: function(object){
            return object[this.idProperty];
        },

        put: function(object, options){
            var data = this.data,
                index = this.index,
                idProperty = this.idProperty;
            var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
            if(id in index){
                // object exists
                if(options && options.overwrite === false){
                    throw new Error("Object already exists");
                }
                // replace the entry in data
                data[index[id]] = object;
            }else{
                // add the new object
                index[id] = data.push(object) - 1;
            }
            return id;
        },

        add: function(object, options){
            (options = options || {}).overwrite = false;
            // call put with overwrite being false
            return this.put(object, options);
        },

        remove: function(id){
            // summary:
            //      Deletes an object by its identity
            // id: Number
            //      The identity to use to delete the object
            // returns: Boolean
            //      Returns true if an object was removed, falsy (undefined) if no object matched the id
            var index = this.index;
            var data = this.data;
            if(id in index){
                data.splice(index[id], 1);
                // now we have to reindex
                this.setData(data);
                return true;
            }
        },
        query: function(query, options){
            // summary:
            //      Queries the store for objects.
            // query: Object
            //      The query to use for retrieving objects from the store.
            // options: dojo/store/api/Store.QueryOptions?
            //      The optional arguments to apply to the resultset.
            // returns: dojo/store/api/Store.QueryResults
            //      The results of the query, extended with iterative methods.
            //
            // example:
            //      Given the following store:
            //
            //  |   var store = new Memory({
            //  |       data: [
            //  |           {id: 1, name: "one", prime: false },
            //  |           {id: 2, name: "two", even: true, prime: true},
            //  |           {id: 3, name: "three", prime: true},
            //  |           {id: 4, name: "four", even: true, prime: false},
            //  |           {id: 5, name: "five", prime: true}
            //  |       ]
            //  |   });
            //
            //  ...find all items where "prime" is true:
            //
            //  |   var results = store.query({ prime: true });
            //
            //  ...or find all items where "even" is true:
            //
            //  |   var results = store.query({ even: true });
            return QueryResults(this.queryEngine(query, options)(this.data));
        },

        setData: function(data){
            // summary:
            //      Sets the given data as the source for this store, and indexes it
            // data: Object[]
            //      An array of objects to use as the source of data.
            if(data.items){
                // just for convenience with the data format IFRS expects
                this.idProperty = data.identifier || this.idProperty;
                data = this.data = data.items;
            }else{
                this.data = data;
            }
            this.index = {};
            for(var i = 0, l = data.length; i < l; i++){
                this.index[data[i][this.idProperty]] = i;
            }
        },

        init: function(options) {
            for(var i in options){
                this[i] = options[i];
            }
            this.setData(this.data || []);
        }

    });

	return ArrayStore;
});
define('skylark-langx-aspect/aspect',[
    "skylark-langx-ns"
],function(skylark){

  var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments){
        var previous = dispatcher[type];
        var around = type == "around";
        var signal;
        if(around){
            var advised = advice(function(){
                return previous.advice(this, arguments);
            });
            signal = {
                remove: function(){
                    if(advised){
                        advised = dispatcher = advice = null;
                    }
                },
                advice: function(target, args){
                    return advised ?
                        advised.apply(target, args) :  // called the advised function
                        previous.advice(target, args); // cancelled, skip to next one
                }
            };
        }else{
            // create the remove handler
            signal = {
                remove: function(){
                    if(signal.advice){
                        var previous = signal.previous;
                        var next = signal.next;
                        if(!next && !previous){
                            delete dispatcher[type];
                        }else{
                            if(previous){
                                previous.next = next;
                            }else{
                                dispatcher[type] = next;
                            }
                            if(next){
                                next.previous = previous;
                            }
                        }

                        // remove the advice to signal that this signal has been removed
                        dispatcher = advice = signal.advice = null;
                    }
                },
                id: nextId++,
                advice: advice,
                receiveArguments: receiveArguments
            };
        }
        if(previous && !around){
            if(type == "after"){
                // add the listener to the end of the list
                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
                while(previous.next && (previous = previous.next)){}
                previous.next = signal;
                signal.previous = previous;
            }else if(type == "before"){
                // add to beginning
                dispatcher[type] = signal;
                signal.next = previous;
                previous.previous = signal;
            }
        }else{
            // around or first one just replaces
            dispatcher[type] = signal;
        }
        return signal;
    }
    function aspect(type){
        return function(target, methodName, advice, receiveArguments){
            var existing = target[methodName], dispatcher;
            if(!existing || existing.target != target){
                // no dispatcher in place
                target[methodName] = dispatcher = function(){
                    var executionId = nextId;
                    // before advice
                    var args = arguments;
                    var before = dispatcher.before;
                    while(before){
                        args = before.advice.apply(this, args) || args;
                        before = before.next;
                    }
                    // around advice
                    if(dispatcher.around){
                        var results = dispatcher.around.advice(this, args);
                    }
                    // after advice
                    var after = dispatcher.after;
                    while(after && after.id < executionId){
                        if(after.receiveArguments){
                            var newResults = after.advice.apply(this, args);
                            // change the return value only if a new value was returned
                            results = newResults === undefined ? results : newResults;
                        }else{
                            results = after.advice.call(this, results, args);
                        }
                        after = after.next;
                    }
                    return results;
                };
                if(existing){
                    dispatcher.around = {advice: function(target, args){
                        return existing.apply(target, args);
                    }};
                }
                dispatcher.target = target;
            }
            var results = advise((dispatcher || existing), type, advice, receiveArguments);
            advice = null;
            return results;
        };
    }

    return skylark.attach("langx.aspect",{
        after: aspect("after"),
 
        around: aspect("around"),
        
        before: aspect("before")
    });
});
define('skylark-langx-aspect/main',[
	"./aspect"
],function(aspect){
	return aspect;
});
define('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });

define('skylark-langx/aspect',[
    "skylark-langx-aspect"
],function(aspect){
  return aspect;
});
define('skylark-langx/async',[
    "skylark-langx-async"
],function(async){
    return async;
});
define('skylark-langx-binary/binary',[
  "skylark-langx-ns",
],function(skylark){
	"use strict";


	/**
	 * Create arraybuffer from binary string
	 *
	 * @method fromBinaryString
	 * @param {String} str
	 * @return {Arraybuffer} data
	 */
	function fromBinaryString(str) {
		var length = str.length;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		for(var i = 0; i < length; i++)
		{
			view[i] = str.charCodeAt(i);
		}

		return arraybuffer;
	}

	/**
	 * Create arraybuffer from base64 string
	 *
	 * @method fromBase64
	 * @param {String} base64
	 * @return {Arraybuffer} data
	 */
	function fromBase64(str){
		var encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var length = str.length / 4 * 3;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		var a, b, c, d;

		for(var i = 0, j = 0; i < length; i += 3)
		{
			a = encoding.indexOf(str.charAt(j++));
			b = encoding.indexOf(str.charAt(j++));
			c = encoding.indexOf(str.charAt(j++));
			d = encoding.indexOf(str.charAt(j++));

			view[i] = (a << 2) | (b >> 4);
			if(c !== 64)
			{
				view[i+1] = ((b & 15) << 4) | (c >> 2);
			}
			if(d !== 64)
			{
				view[i+2] = ((c & 3) << 6) | d;
			}
		}

		return arraybuffer;
	}

	/**
	 * Create arraybuffer from Nodejs buffer
	 *
	 * @method fromBuffer
	 * @param {Buffer} buffer
	 * @return {Arraybuffer} data
	 */
	function fromBuffer(buffer)	{
		var array = new ArrayBuffer(buffer.length);
		var view = new Uint8Array(array);

		for(var i = 0; i < buffer.length; i++)
		{
			view[i] = buffer[i];
		}

		return array;

		//Faster but the results is failing the "instanceof ArrayBuffer" test
		//return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
	}

    function readInt8(data, offset) {
        return data[offset] << 24 >> 24;
    }
    function readUint16(data, offset) {
        return data[offset] << 8 | data[offset + 1];
    }
    function readUint32(data, offset) {
        return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
    }


	return skylark.attach("langx.binary",{
		fromBase64,
		fromBinaryString,
		fromBuffer,
		readInt8,
		readUint16,
		readUint32
	});
});
define('skylark-langx-binary/main',[
	"./binary"
],function(binary){
	return binary;
});
define('skylark-langx-binary', ['skylark-langx-binary/main'], function (main) { return main; });

define('skylark-langx/binary',[
	"skylark-langx-binary"
],function(binary){
  return binary;
});
define('skylark-langx-constructs/main',[
	"./constructs",
	"./inherit",
	"./klass"
],function(constructs){
	return constructs;
});
define('skylark-langx-constructs', ['skylark-langx-constructs/main'], function (main) { return main; });

define('skylark-langx/constructs',[
	"skylark-langx-constructs"
],function(constructs){
  return constructs;
});
define('skylark-langx-datetimes/datetimes',[
    "skylark-langx-ns"
],function(skylark){
     function parseMilliSeconds(str) {

        var strs = str.split(' ');
        var number = parseInt(strs[0]);

        if (isNaN(number)){
            return 0;
        }

        var min = 60000 * 60;

        switch (strs[1].trim().replace(/\./g, '')) {
            case 'minutes':
            case 'minute':
            case 'min':
            case 'mm':
            case 'm':
                return 60000 * number;
            case 'hours':
            case 'hour':
            case 'HH':
            case 'hh':
            case 'h':
            case 'H':
                return min * number;
            case 'seconds':
            case 'second':
            case 'sec':
            case 'ss':
            case 's':
                return 1000 * number;
            case 'days':
            case 'day':
            case 'DD':
            case 'dd':
            case 'd':
                return (min * 24) * number;
            case 'months':
            case 'month':
            case 'MM':
            case 'M':
                return (min * 24 * 28) * number;
            case 'weeks':
            case 'week':
            case 'W':
            case 'w':
                return (min * 24 * 7) * number;
            case 'years':
            case 'year':
            case 'yyyy':
            case 'yy':
            case 'y':
                return (min * 24 * 365) * number;
            default:
                return 0;
        }
    };
	
	return skylark.attach("langx.datetimes",{
		parseMilliSeconds
	});
});
define('skylark-langx-datetimes/to_date',[
	"skylark-langx-types",
    "./datetimes"
],function(types,datetimes){

//original :pdf.js-2.7.750/src/display/display_utils.js

  /**
class PDFDateString {
   * Convert a PDF date string to a JavaScript `Date` object.
   *
   * The PDF date string format is described in section 7.9.4 of the official
   * PDF 32000-1:2008 specification. However, in the PDF 1.7 reference (sixth
   * edition) Adobe describes the same format including a trailing apostrophe.
   * This syntax in incorrect, but Adobe Acrobat creates PDF files that contain
   * them. We ignore all apostrophes as they are not necessary for date parsing.
   *
   * Moreover, Adobe Acrobat doesn't handle changing the date to universal time
   * and doesn't use the user's time zone (effectively ignoring the HH' and mm'
   * parts of the date string).
   *
   * @param {string} input
   * @returns {Date|null}
   *
  static toDateObject(input) {
   **/


	let pdfDateStringRegex;

	function toDate(input) {
    if (!input || !types.isString(input)) {
      return null;
    }

    // Lazily initialize the regular expression.
    if (!pdfDateStringRegex) {
      pdfDateStringRegex = new RegExp(
        "^D:" + // Prefix (required)
          "(\\d{4})" + // Year (required)
          "(\\d{2})?" + // Month (optional)
          "(\\d{2})?" + // Day (optional)
          "(\\d{2})?" + // Hour (optional)
          "(\\d{2})?" + // Minute (optional)
          "(\\d{2})?" + // Second (optional)
          "([Z|+|-])?" + // Universal time relation (optional)
          "(\\d{2})?" + // Offset hour (optional)
          "'?" + // Splitting apostrophe (optional)
          "(\\d{2})?" + // Offset minute (optional)
          "'?" // Trailing apostrophe (optional)
      );
    }

    // Optional fields that don't satisfy the requirements from the regular
    // expression (such as incorrect digit counts or numbers that are out of
    // range) will fall back the defaults from the specification.
    const matches = pdfDateStringRegex.exec(input);
    if (!matches) {
      return null;
    }

    // JavaScript's `Date` object expects the month to be between 0 and 11
    // instead of 1 and 12, so we have to correct for that.
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

    // Universal time relation 'Z' means that the local time is equal to the
    // universal time, whereas the relations '+'/'-' indicate that the local
    // time is later respectively earlier than the universal time. Every date
    // is normalized to universal time.
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }

    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }

  return datetimes.toDate = toDate;

});
define('skylark-langx-datetimes/main',[
	"./datetimes",
	"./to_date"
],function(datetimes){
	return datetimes;
});
define('skylark-langx-datetimes', ['skylark-langx-datetimes/main'], function (main) { return main; });

define('skylark-langx/datetimes',[
    "skylark-langx-datetimes"
],function(datetimes){
    return datetimes;
});
define('skylark-langx/deferred',[
    "skylark-langx-async"
],function(async){
    return async.Deferred;
});
define('skylark-langx/emitter',[
    "skylark-langx-events"
],function(events){
    return events.Emitter;
});
define('skylark-langx/evented',[
    "./emitter"
],function(Emitter){
    return Emitter;
});
define('skylark-langx/events',[
	"skylark-langx-events"
],function(events){
	return events;
});
define('skylark-langx/funcs',[
    "skylark-langx-funcs"
],function(funcs){
    return funcs;
});
define('skylark-langx-globals/globals',[
	"skylark-langx-ns"
],function(ns) {
	var globals = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	return ns.attach("langx.globals",globals);

});
define('skylark-langx-globals/console',[
	"./globals"
], function(globals) {
	return globals.console = console;
});
define('skylark-langx-globals/document',[
	"./globals"
], function(globals) {
	var topLevel = typeof global !== 'undefined' ? global :
	    typeof window !== 'undefined' ? window : {};

	var doccy;

	if (typeof document !== 'undefined') {
	    doccy = document;
	} else {
        doccy  = require('min-document');
	}


	return globals.document = doccy;
});




define('skylark-langx-globals/window',[
	"./globals"
], function(globals) {

	var win = (function() {
		if (typeof window !== "undefined") {
		    return window;
		} else {
		    return {};
		}
	})();

	return globals.window = win;
});

define('skylark-langx-globals/main',[
	"./globals",
	"./console",
	"./document",
	"./window"
],function(globals){

	return globals;
});
define('skylark-langx-globals', ['skylark-langx-globals/main'], function (main) { return main; });

define('skylark-langx/globals',[
    "skylark-langx-globals"
],function(globals){
    return globals;
});
define('skylark-langx/hoster',[
	"skylark-langx-hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx-maths/maths',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){


	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var maths = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,



		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * maths.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * maths.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};



	return  skylark.attach("langx.maths",maths);
});
define('skylark-langx-maths/main',[
	"./maths"
],function(maths){
	return maths;
});
define('skylark-langx-maths', ['skylark-langx-maths/main'], function (main) { return main; });

define('skylark-langx/maths',[
    "skylark-langx-maths"
],function(maths){
    return maths;
});
define('skylark-langx-numerics/numerics',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){

	return  skylark.attach("langx.numerics",{
		toFinite : types.toFinite,
		toNumber : types.toNumber,
		toInteger : types.toInteger
	});
});
define('skylark-langx-numerics/maths',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "./numerics"
],function(skylark,types,numerics){


	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var maths = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,



		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * maths.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * maths.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};


	return  numerics.maths = maths;
});
define('skylark-langx-numerics/quaternion',[
	"skylark-langx-klass",
	"./numerics",
	"./maths"
] ,function(klass,numerics,maths) {

	var Quaternion = klass({
		"klassName" : "Quaternion",

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this._onChangeCallback();

			}

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'mathsQuaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		},

		setFromUnitVectors: function ( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			var EPS = 0.000001;

			var r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		},

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( maths.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'mathsQuaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {},


		"_construct" : function ( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}


	})


	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.assign( Quaternion.prototype, {


	} );


	return numerics.Quaternion = Quaternion;


});
define('skylark-langx-numerics/vector3',[
	"skylark-langx-klass",
	"./numerics",
	"./maths",
	"./quaternion"
] ,function(
	klass,
	numerics,
	maths,
	Quaternion
) {

	var _quaternion = new Quaternion();

	var Vector3 = klass({
		"klassName" : "Vector3",

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'mathsVector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

		},

		applyAxisAngle: function ( axis, angle ) {

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyNormalMatrix: function ( m ) {

			return this.applyMatrix3( m ).normalize();

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function ( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		},

		unproject: function ( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		},

		transformDirection: function ( m ) {

			// input: mathsMatrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( v ) {

			var denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			var scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		},

		projectOnPlane: function ( planeNormal ) {

			_vector.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector );

		},

		reflect: function ( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		},

		angleTo: function ( v ) {

			var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			var theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		},

		setFromSphericalCoords: function ( radius, phi, theta ) {

			var sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		},

		setFromCylindricalCoords: function ( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		setFromMatrix3Column: function ( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'mathsVector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		},


		"_construct" : function ( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

	});

	var _vector = new Vector3();


	return numerics.Vector3 = Vector3;
});
define('skylark-langx-numerics/matrix4',[
	"skylark-langx-klass",
	"./numerics",
	"./vector3"
] ,function(
	klass,
	numerics,
	Vector3
) {

	var _v1 = new Vector3();
	var _zero = new Vector3( 0, 0, 0 );
	var _one = new Vector3( 1, 1, 1 );
	var _x = new Vector3();
	var _y = new Vector3();
	var _z = new Vector3();

	var Matrix4 = klass({
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function ( m ) {

			// this method does not support reflection matrices

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'mathsMatrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function ( q ) {

			return this.compose( _zero, q, _one );

		},

		lookAt: function ( eye, target, up ) {

			var te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		},

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'mathsMatrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( x, y, z ) {

			var te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			if ( throwOnDegenerate !== undefined ) {

				console.warn( "mathsMatrix4: .getInverse() can no longer be configured to throw on degenerate." );

			}

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		},

		decompose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1.copy( this );

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			_m1.elements[ 0 ] *= invSX;
			_m1.elements[ 1 ] *= invSX;
			_m1.elements[ 2 ] *= invSX;

			_m1.elements[ 4 ] *= invSY;
			_m1.elements[ 5 ] *= invSY;
			_m1.elements[ 6 ] *= invSY;

			_m1.elements[ 8 ] *= invSZ;
			_m1.elements[ 9 ] *= invSZ;
			_m1.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		},

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'mathsMatrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		"_construct" : function() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'mathsMatrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

	});

	var _m1 = new Matrix4();

	return numerics.Matrix4 =  Matrix4 ;

});
define('skylark-langx-numerics/euler',[
	"skylark-langx-klass",
	"./numerics",
	"./maths",
	"./quaternion",
	"./vector3",
	"./matrix4"
] ,function(
	klass,
	numerics,
	maths,
	Quaternion,
	Vector3,
	Matrix4
) {

	var _matrix = new Matrix4();
	var _quaternion = new Quaternion();

	var Euler = klass({
		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this._onChangeCallback();

			}

		},

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = maths.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'skylark-nunustudio/editor/gui/element/RendererCanvasEuler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromQuaternion: function ( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		},

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function ( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion.setFromEuler( this );

			return this.setFromQuaternion( _quaternion, newOrder );

		},

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {},


		"_construct" : function ( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}


	});


	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';


	return numerics.Euler = Euler ;
});

define('skylark-langx-numerics/matrix3',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Matrix3 = klass({
		"klassName" : "Matrix3",

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( throwOnDegenerate !== undefined ) {

				console.warn( "mathsMatrix3: .getInverse() can no longer be configured to throw on degenerate." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		},


		"_construct" : function () {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

	});


	return numerics.Matrix3 = Matrix3;
});
define('skylark-langx-numerics/transform',[
	"skylark-langx-klass",	
    "./numerics",
], function(klass,numerics) {

    var Transform =  klass({
        "klassName": "Transform",
		"value": {
			get : function(){
				return this._.value;
			}
		}
	});

	return numerics.Transform =Transform;
});

define('skylark-langx-numerics/matrix-transform',[
    "./numerics",
	"./transform"
],function(numerics,Transform) {

    var MatrixTransform =  Transform.inherit({
        "klassName": "MatrixTransform",

		"value"	:	{
			get : function(){
				return this.matrix.clone();
			}
		},
		
		"matrix" : {
			get : function(){
				return this._.matrix;
			}
		},

		clone : /*ScaleTransform*/function() {
		},
		
		transform : /*Point*/function(/*Point*/point) {
		},
		
		//wE{bNXAi[sE{bNXB
		transformBounds : /*Rect*/function(/*Rect*/rect) {
		},		
		"_construct" : function(/*Martix*/matrix) {
            var _ = this._ = {};
			
			_.matrix = matrix;
		}
				
	});

	return numerics.MatrixTransform = MatrixTransform;
	
});	

define('skylark-langx-numerics/plane',[
	"skylark-langx-klass",
	"./numerics",
	"./matrix3",
	"./vector3"
] ,function(
	klass,
	numerics,
	Matrix3,
	Vector3
) {


	var _vector1 = new Vector3();
	var _vector2 = new Vector3();
	var _normalMatrix = new Matrix3();

	var Plane = klass({
		"klassName" : "Plane",

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function ( a, b, c ) {

			var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function ( line, target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			var direction = line.delta( _vector1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		},

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function ( matrix, optionalNormalMatrix ) {

			var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		},

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		},


		"_construct" : function( normal, constant ) {

			// normal is assumed to be normalized

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

	});


	return numerics.Plane = Plane;
});
define('skylark-langx-numerics/rotate-transform',[
    "./numerics",
	"./transform",
	"./matrix-transform"
],function(numerics,Transform,Matrix) {


    var RotateTransform = numerics.RotateTransform = Transform.inherit({
        "klassName": "RotateTransform",

        "value": {
            get: function() {
                return Matrix.rotateAt(this.angle, this.centerX, this.centerY);
            }
        },

        "angle": {
            get : function() {
                return this._.angle;
            }
        },
        // cy: Number
        //		The Y coordinate of the center of the circle, default value 0.
        "centerX": {
            get : function() {
                return this._.centerX;
            }
        },
        // r: Number
        //		The radius, default value 100.
        "centerY": {
            get : function() {
                return this._.centerY;
            }
        },

		clone : /*ScaleTransform*/function() {
		},
		
		transform : /*Point*/function(/*Point*/point) {
		},
		
		transformBounds : /*Rect*/function(/*Rect*/rect) {
		},
		
		"init" : function(/*Number*/angle,/*Number*/centerX,/*Number*/centerY) {
			var _ = this._ = {};
			_.angle = angle ? angle :0;
			_.centerX = centerX ? centerX :0;
			_.centerY = centerY ? centerY :0;
		}
	});

	return RotateTransform;
	
});	

define('skylark-langx-numerics/scale-transform',[
    "./numerics",
    "./transform",
    "./matrix-transform"
], function(numerics, Transform, Matrix) {

   var ScaleTransform =  Transform.inherit({
        "klassName": "ScaleTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.scaleX, this.scaleY, this.centerX, this.centerY);
            }
        },

        "scaleX": {
            get : function() {
                return this._.scaleX;
            }
        },

        "scaleY": {
            get : function() {
                return this._.scaleY;
            }
        },

        // cy: Number
        //      The Y coordinate of the center of the circle, default value 0.
        "centerX": {
            get : function() {
                return this._.centerX;
            }
        },
        // r: Number
        //      The radius, default value 100.
        "centerY": {
            get : function() {
                return this._.centerY;
            }
        },

        clone: /*ScaleTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "_construct": function( /*Number*/ scaleX, /*Number*/ scaleY, /*Number*/ centerX, /*Number*/ centerY) {
            var _ = this._ = {};

            _.scaleX = scaleX ? scaleX : 1;
            _.scaleY = scaleY ? scaleY : 1;
            _.centerX = centerX ? centerX : 0;
            _.centerY = centerY ? centerY : 0;
        }
    });

    return numerics.ScaleTransform = ScaleTransform;

});

define('skylark-langx-numerics/skew-transform',[
    "./numerics",
    "./transform",
    "./matrix-transform"
], function(numerics, Transform, Matrix) {

   var SkewTransform = Transform.inherit({
        "klassName": "SkewTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.skewX, this.skewY);
            }
        },

        "skewX": {
            get : function() {
                return this._.skewX;
            }
        },

        "skewY": {
            get : function() {
                return this._.skewY;
            }
        },

        clone: /*SkewTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "_construct": function( /*Number*/ skewX, /*Number*/ skewY) {
            var _ = this._ = {};

            _.skewX = skewX ? skewX : 0;
            _.skewY = skewY ? skewY : 0;
        }
    });

    return numerics.SkewTransform = SkewTransform;

});

define('skylark-langx-numerics/vector2',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Vector2 = klass({
		"klassName" : "Vector2",

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;
		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},


		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},


		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;
		},

		"_construct" : function ( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}


	});


	/*
	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );
	*/




	return numerics.Vector2 = Vector2 ;
});

define( 'skylark-langx-numerics/transform-matrix',[
    "skylark-langx-klass",
    "./numerics",
    "./vector2"
], function(klass,numerics,Vector2){
	// reference easeljs/numerics/Matrix2D  and dojox/gfx/matrix
	
	var DEG_TO_RAD = Math.PI/180;
	var _degToRadCache = {};
	var degToRad = function(degree){
		return _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));
	};
	var radToDeg = function(radian){ return radian / Math.PI * 180; };
	

	//Represents a 3 x 3 affine transformation matrix used for transformation in 2-D space.
	//|----------|
	//|m11|m21|dx| 
	//|----------|
	//|m12|m22|dy|
	//|----------|
	//|  0|  0| 1|
	//|----------|
	
    var TransformMatrix =  klass({
        "klassName": "TransformMatrix",

		"_multiplyPoint"	: 	function(p){
			// summary:
			//		applies the matrix to a point
			// p: Point
			//		a point
			// returns: Point
			var _ = this._,
				x = p.x * _.m11 + p.y * _.m21  + _.dx,
			    y = p.x * _.m12 +  p.y * _.m22 + _.dy;

			return new Vector2(x,y); // Point
		},

       "m11": {
       		//Position (0, 0) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m11;
            }
        },

       "m12": {
       		//Position (0, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m12;
            }
        },

       "m21": {
       		//Position (1, 0) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m21;
            }
        },

       "m22": {
       		//Position (1, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m22;
            }
        },

       "dx": {
       		// Position (2, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.dx;
            }
        },

       "dy": {
       		// Position (2, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.dy;
            }
        },

       "alpha": {
       		// Property representing the alpha that will be applied to a display object. This is not part of matrix
       		// operations, but is used for operations like getConcatenatedMatrix to provide concatenated alpha values.
            get : function() {
                return this._.alpha;
            }
        },

       "shadow": {
       		// Property representing the shadow that will be applied to a display object. This is not part of matrix
       		// operations, but is used for operations like getConcatenatedMatrix to provide concatenated shadow values..
            get : function() {
                return this._.shadow;
            }
        },

       "compositeOperation": {
			/**
			 * Property representing the compositeOperation that will be applied to a display object. This is not part of
			 * matrix operations, but is used for operations like getConcatenatedMatrix to provide concatenated
			 * compositeOperation values. You can find a list of valid composite operations at:
			 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
			 * @property compositeOperation
			 * @type String
			 **/
            get : function() {
                return this._.compositeOperation;
            }
        },

        //Converts the specified point with TransformMatrix and returns the result.
		multiplyPoint: /*Vector2*/function(/*Vector2 */ p){
			// summary:
			//		applies the matrix to a point
			return this._multiplyPoint(p); // Vector2
		},
				/**
				 *  TransformMatrix 
				 */
		multiplyRectangle: /*Rect*/function(/*Rect*/ rect){
			// summary:
			//		Applies the matrix to a rectangle.
			// returns: Rect
			if(this.isIdentity())
				return rect.clone(); // Rect
			var p0 = this.multiplyPoint(rect.leftTop),
				p1 = this.multiplyPoint(rect.leftBottom),
				p2 = this.multiplyPoint(rect.right),
				p3 = this.multiplyPoint(rect.rightBottom),
				minx = Math.min(p0.x, p1.x, p2.x, p3.x),
				miny = Math.min(p0.y, p1.y, p2.y, p3.y),
				maxx = Math.max(p0.x, p1.x, p2.x, p3.x),
				maxy = Math.max(p0.y, p1.y, p2.y, p3.y);
			return new Rect(minx,miny,maxx-minx,maxy-miny);  // Rect
		},
		/**
		 * Concatenates the specified matrix properties with this matrix. All parameters are required.
		 * @method prepend
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		prepend : function(m11, m12, m21, m22, dx, dy) {
			var tx1 = this.dx;
			if (m11 != 1 || m12 != 0 || m21 != 0 || m22 != 1) {
				var a1 = this.m11;
				var c1 = this.m21;
				this.m11  = a1*m11+this.m12*m21;
				this.m12  = a1*m12+this.m12*m22;
				this.m21  = c1*m11+this.m22*m21;
				this.m22  = c1*m12+this.m22*m22;
			}
			this.dx = tx1*m11+this.dy*m21+dx;
			this.dy = tx1*m12+this.dy*m22+dy;
			return this;
		},

		/**
		 * Appends the specified matrix properties with this matrix. All parameters are required.
		 *  Matrix Matrix
		 * @method append
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		append : function(m11, m12, m21, m22, dx, dy) {
			var a1 = this.m11;
			var b1 = this.m12;
			var c1 = this.m21;
			var d1 = this.m22;

			this.m11  = m11*a1+m12*c1;
			this.m12  = m11*b1+m12*d1;
			this.m21  = m21*a1+m22*c1;
			this.m22  = m21*b1+m22*d1;
			this.dx = dx*a1+dy*c1+this.dx;
			this.dy = dx*b1+dy*d1+this.dy;
			return this;
		},

		/**
		 * Prepends the specified matrix with this matrix.
		 * @method prependMatrix
		 * @param {TransformMatrix} matrix
		 **/
		prependMatrix : function(matrix) {
			this.prepend(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);
			this.prependProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
			return this;
		},

		/**
		 * Appends the specified matrix with this matrix.
		 *  Matrix Matrix
		 * @method appendMatrix
		 * @param {TransformMatrix} matrix
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		appendMatrix : function(matrix) {
			this.append(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);
			this.appendProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
			return this;
		},

		/**
		 * Generates matrix properties from the specified display object transform properties, and prepends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();
		 * mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method prependTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		prependTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (regX || regY) {
				// append the registration offset:
				this.dx -= regX; this.dy -= regY;
			}
			if (skewX || skewY) {
				// TODO: can this be combined into a single prepend operation?
				skewX *= DEG_TO_RAD;
				skewY *= DEG_TO_RAD;
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
				this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			} else {
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			return this;
		},

		/**
		 * Generates matrix properties from the specified display object transform properties, and appends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();
		 * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method appendTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		appendTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (skewX || skewY) {
				// TODO: can this be combined into a single append?
				skewX *= DEG_TO_RAD;
				skewY *= DEG_TO_RAD;
				this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			} else {
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}

			if (regX || regY) {
				// prepend the registration offset:
				this.dx -= regX*this.m11+regY*this.m21; 
				this.dy -= regX*this.m12+regY*this.m22;
			}
			return this;
		},

		/**
		 * Applies a rotation transformation to the matrix.
		 * @method rotate
		 * @param {Number} angle The angle in degrees.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		rotate : function(angle) {
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);

			var a1 = this.m11;
			var c1 = this.m21;
			var tx1 = this.dx;

			this.m11 = a1*cos-this.m12*sin;
			this.m12 = a1*sin+this.m12*cos;
			this.m21 = c1*cos-this.m22*sin;
			this.m22 = c1*sin+this.m22*cos;
			this.dx = tx1*cos-this.dy*sin;
			this.dy = tx1*sin+this.dy*cos;
			return this;
		},

		/**
		 * Applies a skew transformation to the matrix.
		 * @method skew
		 * @param {Number} skewX The amount to skew horizontally in degrees.
		 * @param {Number} skewY The amount to skew vertically in degrees.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		skew : function(skewX, skewY) {
			skewX = skewX*DEG_TO_RAD;
			skewY = skewY*DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
			return this;
		},

		/**
		 * Applies a scale transformation to the matrix.
		 * @method scale
		 * @param {Number} x
		 * @param {Number} y
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		scale : function(x, y) {
			this.m11 *= x;
			this.m22 *= y;
			this.dx *= x;
			this.dy *= y;
			return this;
		},

		/**
		 * Translates the matrix on the x and y axes.
		 * @method translate
		 * @param {Number} x
		 * @param {Number} y
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		translate : function(x, y) {
			this.dx += x;
			this.dy += y;
			return this;
		},

		/**
		 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
		 * @method identity
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		identity : function() {
			this.alpha = this.m11 = this.m22 = 1;
			this.m12 = this.m21 = this.dx = this.dy = 0;
			this.shadow = this.compositeOperation = null;
			return this;
		},

		/**
		 * Inverts the matrix, causing it to perform the opposite transformation.
		 * @method invert
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		invert : function() {
			var a1 = this.m11;
			var b1 = this.m12;
			var c1 = this.m21;
			var d1 = this.m22;
			var tx1 = this.dx;
			var n = a1*d1-b1*c1;

			this.m11 = d1/n;
			this.m12 = -b1/n;
			this.m21 = -c1/n;
			this.m22 = a1/n;
			this.dx = (c1*this.dy-d1*tx1)/n;
			this.dy = -(a1*this.dy-b1*tx1)/n;
			return this;
		},

		/**
		 * Returns true if the matrix is an identity matrix.
		 * @method isIdentity
		 * @return {Boolean}
		 **/
		isIdentity : function() {
			return this.dx == 0 && this.dy == 0 && this.m11 == 1 && this.m12 == 0 && this.m21 == 0 && this.m22 == 1;
		},

		/**
		 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that this these values
		 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
		 * results.
		 * @method decompose
		 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		decompose : function(target) {
			// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation
			// even when scale is negative
			if (target == null) { target = {}; }
			target.x = this.dx;
			target.y = this.dy;
			target.scaleX = Math.sqrt(this.m11 * this.m11 + this.m12 * this.m12);
			target.scaleY = Math.sqrt(this.m21 * this.m21 + this.m22 * this.m22);

			var skewX = Math.atan2(-this.m21, this.m22);
			var skewY = Math.atan2(this.m12, this.m11);

			if (skewX == skewY) {
				target.rotation = skewY/DEG_TO_RAD;
				if (this.m11 < 0 && this.m22 >= 0) {
					target.rotation += (target.rotation <= 0) ? 180 : -180;
				}
				target.skewX = target.skewY = 0;
			} else {
				target.skewX = skewX/DEG_TO_RAD;
				target.skewY = skewY/DEG_TO_RAD;
			}
			return target;
		},

		/**
		 * Reinitializes all matrix properties to those specified.
		 * @method appendProperties
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		reinitialize : function(m11,m12,m21,m22,dx,dy,alpha,shadow,compositeOperation) {
			this._initialize(m11,m12,m21,m22,dx,dy);
			this.alpha = alpha || 1;
			this.shadow = shadow;
			this.compositeOperation = compositeOperation;
			return this;
		},

		/**
		 * Appends the specified visual properties to the current matrix.
		 * @method appendProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		appendProperties : function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = shadow || this.shadow;
			this.compositeOperation = compositeOperation || this.compositeOperation;
			return this;
		},

		/**
		 * Prepends the specified visual properties to the current matrix.
		 * @method prependProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		prependProperties : function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = this.shadow || shadow;
			this.compositeOperation = this.compositeOperation || compositeOperation;
			return this;
		},

		/**
		 *Multiply TransformMatrix by another TransformMatrix.
		 */
		multiply: function(matrix){
			// summary:
			//		combines matrices by multiplying them sequentially in the given order
			// matrix: TransformMatrix
			//		a 2D matrix-like object,
			//		all subsequent arguments are matrix-like objects too

			// combine matrices
			var m11 = this.m11,m12 = this.m12,m21 = this.m21,m22=this.m22,dx=this.dx,dy=this.dy;
			var r = matrix;
			this.m11 = m11 * r.m11 + m21 * r.m12;
			this.m12 = m12 * r.m11 + m22 * r.m12;
			this.m21 = m11 * r.m21 + m21 * r.m22;
			this.m22 = m12 * r.m21 + m22 * r.m22;
			this.dx =  m11 * r.dx + m21 * r.dy + dx;
			this.dy =  m12 * r.dx + m22 * r.dy + dy;
			return this // TransformMatrix
		},

		/**
		 * Returns a clone of the TransformMatrix instance.
		 * @method clone
		 * @return {TransformMatrix} a clone of the TransformMatrix instance.
		 **/
		clone : function() {

			var _ = this._,
				mtx = new TransformMatrix(_.m11, _.m12, _.m21, _.m22, _.dx, _.dy);
			mtx.shadow = this.shadow;
			mtx.alpha = this.alpha;
			mtx.compositeOperation = this.compositeOperation;
			return mtx;
		},

		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		toString : function() {
			var _ = this._;
			return "[TransformMatrix (m11="+_.m11+" m12="+_.m12+" m21="+_.m21+" m22="+_.m22+" dx="+_.dx+" dy="+_.dy+")]";
		},
		
		"_construct" : function(m11, m12, m21, m22, dx, dy) {
			var _ = this._ = {};
			_.m11 = m11 || 1;
			_.m12 = m12 || 0;
			_.m21 = m21 || 0;
			_.m22 = m22 || 1;
			_.dx = dx || 0;
			_.dy = dy || 0;
		}

	});
	
	Object.assign(TransformMatrix,{
		translate: function(a, b){
			// summary:
			//		forms a translation matrix
			// description:
			//		The resulting matrix is used to translate (move) points by specified offsets.
			// a: Number
			//		an x coordinate value
			// b: Number
			//		a y coordinate value
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1|   0| a|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   1| b|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|

			return new TransformMatrix(1,0,0,1,a,b); // TransformMatrix
		},
		scale: function(a, b){
			// summary:
			//		forms a scaling matrix
			// description:
			//		The resulting matrix is used to scale (magnify) points by specified offsets.
			// a: Number
			//		a scaling factor used for the x coordinate
			// b: Number?
			//		a scaling factor used for the y coordinate
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  a|   0| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   b| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			return new TransformMatrix(a,0,0,b?b:a,0,0); // TransformMatrix
		},
		rotate: function(angle){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |cos|-sin| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |sin| cos| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
			return new TransformMatrix(cos,sin,-sin,cos,0,0); // TransformMatrix
		},
		rotateg: function(degree){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified degree.
			//		Seerotate() for comparison.
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// returns: TransformMatrix
			return this.rotate(degToRad(degree)); // TransformMatrix
		},
		skewX: function(angle) {
			//TODO : will be modified
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1| tan| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   1| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var tan = Math.tan(angle);
			return new TransformMatrix(1,0,tan,1); // TransformMatrix
		},
		skewXg: function(degree){
			//TODO : will be modified
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox/gfx/matrix.skewX() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: TransformMatrix
			return this.skewX(degToRad(degree)); // dojox/gfx/matrix.TransformMatrix
		},
		skewY: function(angle){
			//TODO : will be modified
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1|   0| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |tan|   1| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var tan = Math.tan(angle);

			return new TransformMatrix(1,tan,0,1); // TransformMatrix
		},
		skewYg: function(degree){
			//TODO : will be modified
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See skewY() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: TransformMatrix
			return this.skewY(degToRad(degree)); // TransformMatrix
		},
		reflect: function(a, b){
			// summary:
			//		forms a reflection matrix
			// description:
			//		The resulting matrix is used to reflect points around a vector,
			//		which goes through the origin.
			// a: dojox/gfx.Point|Number
			//		a point-like object, which specifies a vector of reflection, or an X value
			// b: Number?
			//		a Y value
			// returns: TransformMatrix
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, 
				xx=2 * a2 / n2 - 1, 
				xy = 2 * a * b / n2,
				yx = xy,
				yy = 2 * b2 / n2 - 1;
			return new TransformMatrix(xx,yx,xy, yy); // TransformMatrix
		},
		project: function(a, b){
			// summary:
			//		forms an orthogonal projection matrix
			// description:
			//		The resulting matrix is used to project points orthogonally on a vector,
			//		which goes through the origin.
			// a:   Number
			//		an x coordinate value
			// b: Number?
			//		a y coordinate value
			// returns: TransformMatrix

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, 
				xx = a2 / n2,
				xy = a * b / n2
				yx = xy,
				yy = b2 / n2;
			return new TransformMatrix(xx,yx,xy,yy); // TransformMatrix
		},

		// common operations

		// high level operations

		_sandwich: function(matrix, x, y){
			// summary:
			//		applies a matrix at a central point
			// matrix: TransformMatrix
			//		a 2D matrix-like object, which is applied at a central point
			// x: Number
			//		an x component of the central point
			// y: Number
			//		a y component of the central point
			return this.translate(x, y).multiply(matrix)
			                           .multiply(this.translate(-x, -y)); // TransformMatrix
		},
		scaleAt: function(a, b, c, d){
			// summary:
			//		scales a picture using a specified point as a center of scaling
			// description:
			//		Compare with scale().
			// a: Number
			//		a scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates
			// b: Number?
			//		a scaling factor used for the y coordinate
			// c: Number|Point
			//		an x component of a central point, or a central point
			// d: Number
			//		a y component of a central point
			// returns: TransformMatrix
			switch(arguments.length){
				case 4:
					// a and b are scale factor components, c and d are components of a point
					return this._sandwich(this.scale(a, b), c, d); // TransformMatrix
				case 3:
					if(typeof c == "number"){
						return this._sandwich(this.scale(a), b, c); // TransformMatrix
					}
					return this._sandwich(this.scale(a, b), c.x, c.y); // TransformMatrix
			}
			return this._sandwich(this.scale(a), b.x, b.y); // TransformMatrix
		},
		rotateAt: function(angle, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with rotate().
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.rotate(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.rotate(angle), a.x, a.y); // TransformMatrix
		},
		rotategAt: function(degree, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with rotateg().
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.rotateg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.rotateg(degree), a.x, a.y); // TransformMatrix
		},
		skewXAt: function(angle, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with skewX().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewX(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewX(angle), a.x, a.y); // TransformMatrix
		},
		skewXgAt: function(degree, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with skewXg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewXg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewXg(degree), a.x, a.y); // TransformMatrix
		},
		skewYAt: function(angle, a, b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with skewY().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewY(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewY(angle), a.x, a.y); // TransformMatrix
		},
		skewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with skewYg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewYg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewYg(degree), a.x, a.y); // TransformMatrix
		}
	
	
	});

	return numerics.TransformMatrix = TransformMatrix;
});

define('skylark-langx-numerics/translate-transform',[
    "./numerics",
    "./transform",
    "./matrix-transform"
],function(numerics,Transform,Matrix,Point,Rect) {

    //|1   0   dx|
    //|0   1   dy|
    //|0   0    1|

   var TranslateTransform =  Transform.inherit({
        "klassName": "TranslateTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.x, this.y);
            }
        },

        "x": {
            get : function() {
                return this._.x;
            }
        },

        "y": {
            get : function() {
                return this._.y;
            }
        },

        clone: /*SkewTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "init": function( /*Number*/ x, /*Number*/ y) {
            var _ = this._;

            _.x = x ? x : 0;
            _.y = y ? y : 0;
        }
    });

    return numerics.TranslateTransform =TranslateTransform;
});	

define('skylark-langx-numerics/vector4',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Vector4 = klass({
		"klassName" : "Vector4",

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;
		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;
		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		},


		"_construct" :function ( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

	});

/*
	Object.defineProperties( Vector4.prototype, {

		"width": {

			get: function () {

				return this.z;

			},

			set: function ( value ) {

				this.z = value;

			}

		},

		"height": {

			get: function () {

				return this.w;

			},

			set: function ( value ) {

				this.w = value;

			}

		}

	} );
*/

	return numerics.Vector4 = Vector4 ;

});
define('skylark-langx-numerics/main',[
	"./numerics",
	"./euler",
	"./maths",
	"./matrix3",
	"./matrix4",
	"./matrix-transform",
	"./plane",
	"./quaternion",
	"./rotate-transform",
	"./scale-transform",
	"./skew-transform",
	"./transform",
	"./transform-matrix",
	"./translate-transform",
	"./vector2",
	"./vector3",
	"./vector4"
],function(numerics){
	return numerics;
});
define('skylark-langx-numerics', ['skylark-langx-numerics/main'], function (main) { return main; });

define('skylark-langx/numerics',[
	"skylark-langx-numerics"
],function(numerics){
	return numerics;
});
define('skylark-langx/objects',[
    "skylark-langx-objects"
],function(objects){
    return objects;
});
define('skylark-langx/Evented',[
    "./emitter"
],function(Emitter){
    return Emitter;
});
define('skylark-langx-strings/strings',[
    "skylark-langx-ns"
],function(skylark){
    // add default escape function for escaping HTML entities
    var escapeCharMap = Object.freeze({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;',
    });
    function replaceChar(c) {
        return escapeCharMap[c];
    }
    var escapeChars = /[&<>"'`=]/g;


     /*
     * Converts camel case into dashes.
     * @param {String} str
     * @return {String}
     * @exapmle marginTop -> margin-top
     */
    function dasherize(str) {
        return str.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/_/g, '-')
            .toLowerCase();
    }

    function deserializeValue(value) {
        try {
            return value ?
                value == "true" ||
                (value == "false" ? false :
                    value == "null" ? null :
                    +value + "" == value ? +value :
                    /^[\[\{]/.test(value) ? JSON.parse(value) :
                    value) : value;
        } catch (e) {
            return value;
        }
    }

    function escapeHTML(str) {
        if (str == null) {
            return '';
        }
        if (!str) {
            return String(str);
        }

        return str.toString().replace(escapeChars, replaceChar);
    }

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : ((r & 0x3) | 0x8);
            return v.toString(16);
        });
    }

    function trim(str) {
        return str == null ? "" : String.prototype.trim.call(str);
    }

    const NullCharactersRegExp = /\x00/g;

    /**
     * @param {string} str
     */
    function trimNull(str) {
      if (typeof str !== "string") {
        warn("The argument for removeNullCharacters must be a string.");
        return str;
      }
      return str.replace(NullCharactersRegExp, "");
    }

    function substitute( /*String*/ template,
        /*Object|Array*/
        map,
        /*Function?*/
        transform,
        /*Object?*/
        thisObject) {
        // summary:
        //    Performs parameterized substitutions on a string. Throws an
        //    exception if any parameter is unmatched.
        // template:
        //    a string with expressions in the form `${key}` to be replaced or
        //    `${key:format}` which specifies a format function. keys are case-sensitive.
        // map:
        //    hash to search for substitutions
        // transform:
        //    a function to process all parameters before substitution takes


        thisObject = thisObject || window;
        transform = transform ?
            proxy(thisObject, transform) : function(v) {
                return v;
            };

        function getObject(key, map) {
            if (key.match(/\./)) {
                var retVal,
                    getValue = function(keys, obj) {
                        var _k = keys.pop();
                        if (_k) {
                            if (!obj[_k]) return null;
                            return getValue(keys, retVal = obj[_k]);
                        } else {
                            return retVal;
                        }
                    };
                return getValue(key.split(".").reverse(), map);
            } else {
                return map[key];
            }
        }

        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
            function(match, key, format) {
                var value = getObject(key, map);
                if (format) {
                    value = getObject(format, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            }); // String
    }

    var idCounter = 0;
    function uniqueId (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    }


    /**
     * https://github.com/cho45/micro-template.js
     * (c) cho45 http://cho45.github.com/mit-license
     */
    function template (id, data) {

        function include(name, args) {
            var stash = {};
            for (var key in template.context.stash) if (template.context.stash.hasOwnProperty(key)) {
                stash[key] = template.context.stash[key];
            }
            if (args) for (var key in args) if (args.hasOwnProperty(key)) {
                stash[key] = args[key];
            }
            var context = template.context;
            context.ret += template(name, stash);
            template.context = context;
        }

        function wrapper(name, fun) {
            var current = template.context.ret;
            template.context.ret = '';
            fun.apply(template.context);
            var content = template.context.ret;
            var orig_content = template.context.stash.content;
            template.context.stash.content = content;
            template.context.ret = current + template(name, template.context.stash);
            template.context.stash.content = orig_content;
        }

        var me = arguments.callee;
        if (!me.cache[id]) me.cache[id] = (function () {
            var name = id, string = /^[\w\-]+$/.test(id) ? me.get(id): (name = 'template(string)', id); // no warnings
            var line = 1, body = (
                "try { " +
                    (me.variable ?  "var " + me.variable + " = this.stash;" : "with (this.stash) { ") +
                        "this.ret += '"  +
                        string.
                            replace(/<%/g, '\x11').replace(/%>/g, '\x13'). // if you want other tag, just edit this line
                            replace(/'(?![^\x11\x13]+?\x13)/g, '\\x27').
                            replace(/^\s*|\s*$/g, '').
                            replace(/\n|\r\n/g, function () { return "';\nthis.line = " + (++line) + "; this.ret += '\\n" }).
                            replace(/\x11=raw(.+?)\x13/g, "' + ($1) + '").
                            replace(/\x11=(.+?)\x13/g, "' + this.escapeHTML($1) + '").
                            replace(/\x11(.+?)\x13/g, "'; $1; this.ret += '") +
                    "'; " + (me.variable ? "" : "}") + "return this.ret;" +
                "} catch (e) { throw 'TemplateError: ' + e + ' (on " + name + "' + ' line ' + this.line + ')'; } " +
                "//@ sourceURL=" + name + "\n" // source map
            ).replace(/this\.ret \+= '';/g, '');
            var func = new Function(body);
            var map  = { '&' : '&amp;', '<' : '&lt;', '>' : '&gt;', '\x22' : '&#x22;', '\x27' : '&#x27;' };
            var escapeHTML = function (string) { return (''+string).replace(/[&<>\'\"]/g, function (_) { return map[_] }) };
            return function (stash) { return func.call(me.context = { escapeHTML: escapeHTML, line: 1, ret : '', stash: stash }) };
        })();
        return data ? me.cache[id](data) : me.cache[id];
    }

    template.cache = {};
    

    template.get = function (id) {
        return document.getElementById(id).innerHTML;
    };


    function ltrim(str) {
        return str.replace(/^\s+/, '');
    }
    
    function rtrim(str) {
        return str.replace(/\s+$/, '');
    }

    // Slugify a string
    function slugify(str) {
        str = str.replace(/^\s+|\s+$/g, '');

        // Make the string lowercase
        str = str.toLowerCase();

        // Remove accents, swap  for n, etc
        var from = "a/_,:;";
        var to   = "AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------";
        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }

        // Remove invalid chars
        //str = str.replace(/[^a-z0-9 -]/g, '') 
        // Collapse whitespace and replace by -
        str = str.replace(/\s+/g, '-') 
        // Collapse dashes
        .replace(/-+/g, '-'); 

        return str;
    }    

    // return boolean if string 'true' or string 'false', or if a parsable string which is a number
    // also supports JSON object and/or arrays parsing
    function toType(str) {
        var type = typeof str;
        if (type !== 'string') {
            return str;
        }
        var nb = parseFloat(str);
        if (!isNaN(nb) && isFinite(str)) {
            return nb;
        }
        if (str === 'false') {
            return false;
        }
        if (str === 'true') {
            return true;
        }

        try {
            str = JSON.parse(str);
        } catch (e) {}

        return str;
    }

	return skylark.attach("langx.strings",{
        camelCase: function(str) {
            return str.replace(/-([\da-z])/g, function(a) {
                return a.toUpperCase().replace('-', '');
            });
        },

        dasherize: dasherize,

        deserializeValue: deserializeValue,

        escapeHTML : escapeHTML,

        generateUUID : generateUUID,

        ltrim : ltrim,

        lowerFirst: function(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        },

        rtrim : rtrim,

        serializeValue: function(value) {
            return JSON.stringify(value)
        },


        substitute: substitute,

        slugify : slugify,

        //template : template,

        trim: trim,

        trimNull,

        uniqueId: uniqueId,

        upperFirst: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
	}) ; 

});
define('skylark-langx-strings/base64',[
	"./strings"
],function(strings) {

	// private property
	const _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

	// private method for UTF-8 encoding
	function _utf8_encode(string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	}

	// private method for UTF-8 decoding
	function _utf8_decode(utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;

		while ( i < utftext.length ) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			}
			else if((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			}
			else {
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	}

	// public method for encoding
	function encode(input, binary) {
		binary = (binary != null) ? binary : false;
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		if (!binary)
		{
			input = _utf8_encode(input);
		}

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	}

	// public method for decoding
	function decode(input, binary) {
		binary = (binary != null) ? binary : false;
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		if (!binary) {
			output = _utf8_decode(output);
		}

		return output;

	}


	return strings.base64 = {
		decode,
		encode
	};
	
});
define('skylark-langx-strings/main',[
	"./strings",
	"./base64"
],function(strings){
	return strings;
});
define('skylark-langx-strings', ['skylark-langx-strings/main'], function (main) { return main; });

define('skylark-langx/strings',[
    "skylark-langx-strings"
],function(strings){
    return strings;
});
define('skylark-langx/stateful',[
	"./Evented",
  "./strings",
  "./objects"
],function(Evented,strings,objects){
    var isEqual = objects.isEqual,
        mixin = objects.mixin,
        result = objects.result,
        isEmptyObject = objects.isEmptyObject,
        clone = objects.clone,
        uniqueId = strings.uniqueId;

    var Stateful = Evented.inherit({
        _construct : function(attributes, options) {
            var attrs = attributes || {};
            options || (options = {});
            this.cid = uniqueId(this.cidPrefix);
            this.attributes = {};
            if (options.collection) this.collection = options.collection;
            if (options.parse) attrs = this.parse(attrs, options) || {};
            var defaults = result(this, 'defaults');
            attrs = mixin({}, defaults, attrs);
            this.set(attrs, options);
            this.changed = {};
        },

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',


        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return clone(this.attributes);
        },


        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null) return this;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options || (options = {});

          // Run validation.
          if (!this._validate(attrs, options)) return false;

          // Extract attributes and options.
          var unset      = options.unset;
          var silent     = options.silent;
          var changes    = [];
          var changing   = this._changing;
          this._changing = true;

          if (!changing) {
            this._previousAttributes = clone(this.attributes);
            this.changed = {};
          }

          var current = this.attributes;
          var changed = this.changed;
          var prev    = this._previousAttributes;

          // For each `set` attribute, update or delete the current value.
          for (var attr in attrs) {
            val = attrs[attr];
            if (!isEqual(current[attr], val)) changes.push(attr);
            if (!isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }

          // Update the `id`.
          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }

          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, mixin({}, options, {unset: true}));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, mixin({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !isEmptyObject(this.changed);
          return this.changed[attr] !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (isEqual(old[attr], val)) continue;
            changed[attr] = val;
          }
          return !isEmptyObject(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return clone(this._previousAttributes);
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, mixin({}, options, {validate: true}));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = mixin({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, mixin(options, {validationError: error}));
          return false;
        }
    });

	return Stateful;
});
define('skylark-langx-topic/topic',[
	"skylark-langx-ns",
	"skylark-langx-events"
],function(skylark,events){
	var hub = new events.Emitter();

	return skylark.attach("langx.topic",{
	    publish: function(name, arg1,argn) {
	        var data = [].slice.call(arguments, 1);

	        return hub.trigger({
	            type : name,
	            data : data
	        });
	    },

        subscribe: function(name, listener,ctx) {
        	var handler = function(e){
                listener.apply(ctx,e.data);
            };
            hub.on(name, handler);
            return {
            	remove : function(){
            		hub.off(name,handler);
            	}
            }

        }

	});
});
define('skylark-langx-topic/main',[
	"./topic"
],function(topic){
	return topic;
});
define('skylark-langx-topic', ['skylark-langx-topic/main'], function (main) { return main; });

define('skylark-langx/topic',[
	"skylark-langx-topic"
],function(topic){
	return topic;
});
define('skylark-langx/types',[
    "skylark-langx-types"
],function(types){
    return types;
});
define('skylark-langx-urls/get-absolute-url',[
    './urls'
], function (urls) {
    'use strict';

    const getAbsoluteUrl = function (url) {
        if (!url.match(/^https?:\/\//)) {
            const div = document.createElement('div');
            div.innerHTML = `<a href="${ url }">x</a>`;
            url = div.firstChild.href;
        }
        return url;
    };

    return urls.getAbsoluteUrl = getAbsoluteUrl;

});
define('skylark-langx-urls/get-file-extension',[
    './urls'
], function (urls) {
    'use strict';

    const getFileExtension = function (path) {
        if (typeof path === 'string') {
            const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
            const pathParts = splitPathRe.exec(path);
            if (pathParts) {
                return pathParts.pop().toLowerCase();
            }
        }
        return '';
    };

    return urls.getFileExtension = getFileExtension;

});
   define('skylark-langx-urls/get-file-name',[
    './urls'
], function (urls) {
    'use strict';

    function getFileName (url) {
        ///var fileName = url.split('/').pop() || "";
        ///return fileName;
        const anchor = url.indexOf('#');
        const query = url.indexOf('?');
        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
        return url.substring(url.lastIndexOf('/', end) + 1, end);         
    }




    return urls.getFileName = getFileName;

});
define('skylark-langx-urls/get-query',[
    './urls'
], function (urls) {
    'use strict';
	function getQuery(querystring) {
		var query = {};

		var pairs = querystring.split('&'),
		    length = pairs.length,
		    keyval = [],
		    i = 0;

		for (; i < length; i++) {
		  keyval = pairs[i].split('=', 2);
		  try {
		    keyval[0] = decodeURIComponent(keyval[0]); // key
		    keyval[1] = decodeURIComponent(keyval[1]); // value
		  } catch (e) {}

		  if (query[keyval[0]] === undefined) {
		    query[keyval[0]] = keyval[1];
		  } else {
		    query[keyval[0]] += ',' + keyval[1];
		  }
		}

		return query;
	}

	return urls.getQuery = getQuery;

});
define('skylark-langx-urls/path',[
    "skylark-langx-types",
    "skylark-langx-constructs/klass",
    "./urls"
], function(types,klass,urls) {

    /**
     * @class Path
     * @constructor
     */
    var Path =   klass({
        _construct : function() {
            var _ = this._ = {
                segments : null,
                hasLeading : false,
                hasTrailing : false
            };
            if (arguments.length == 1 && types.isString(arguments[0])) {
                  this._parse(arguments[0]);
            } else  if (types.isArray(arguments[0])){
                _.segments = arguments[0];
                _.hasLeading = arguments[1] || false;
                _.hasTrailing = arguments[2] || false;
                this._canonicalize();                
            }
        },

        _canonicalize: function() {
            var doIt;
            var segments = this._.segments;
            for (var i = 0; i < segments.length; i++) {
                if (segments[i] == "." || segments[i] == "..") {
                    doIt = true;
                    break;
                }
            }
            if (doIt) {
                var stack = [];
                for (var i = 0; i < segments.length; i++) {
                    if (segments[i] == "..") {
                        if (stack.length == 0) {
                            // if the stack is empty we are going out of our scope
                            // so we need to accumulate segments.  But only if the original
                            // path is relative.  If it is absolute then we can't go any higher than
                            // root so simply toss the .. references.
                            if (!this.hasLeading) {
                                stack.push(segments[i]); //stack push
                            }
                        } else {
                            // if the top is '..' then we are accumulating segments so don't pop
                            if (".." == stack[stack.length - 1]) {
                                stack.push("..");
                            } else {
                                stack.pop();
                            }
                        }
                        //collapse current references
                    } else if (segments[i] != "." || segments.length == 1) {
                        stack.push(segments[i]); //stack push
                    }
                }
                //if the number of segments hasn't changed, then no modification needed
                if (stack.length == segments.length) {
                    return;
                }
                this._.segments = stack;
            }
        },

        _length: function(anotherPath) {
            return this._.segments.length;
        },


        _parse : function( /*String*/ path) {
            if (!path) {
                path = ".";
            }
            var _ = this._,
                segments = path.split("/");

            if (path.charAt(0) == "/") {
                _.hasLeading = true;
                segments.shift();
            }
            if (path.charAt(path.length - 1) == "/") {
                _.hasTrailing = true;
                // If the path ends in '/', split() will create an array whose last element
                // is an empty string. Remove that here.
                segments.pop();
            }
            _.segments = segments;
            _.path = path;

            this._canonicalize()
        },

        /*
         *
         *@method append
         *@parameter {Path|String}tail
         *@return {Path}
         */
        append: /*Path*/ function( /*Path*/ tail) {
            if (types.isString(tail)) {
                return this.appendPathStr(tail);
            } else {
                return this.appendPath(tail);
            }
        },

        /*
         *
         *@method appendPath
         *@parameter {Path}tail
         *@return {Path}
         */
        appendPath: /*Path*/ function( /*Path*/ tail) {
            if (tail.isAbsolute()) {
                return tail;
            }
            var mySegments = this.segments,
                tailSegments = tail.segments,
                newSegments = mySegments.concat(tailSegments),
                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);
            return result;
        },

        /*
         *
         *@method appendPathStr
         *@parameter {String}tail
         *@return {Path}
         */
        appendPathStr: function( /*String*/ tail) {
            tail = new Path(tail || "");
            return this.appendPath(tail);
        },

        /*
         *
         *@method clone
         *@return {Path}
         */
        "clone": function() {
            return new Path(this.segments, this.hasLeading, this.hasTrailing);
        },

        /*
         *Tests if this path ends with the given path.
         *@method endsWidth
         *@parameter {String}tail
         *@return {Boolean}
         */
        "endsWith": /*Boolean*/ function( /*String*/ tail) {
            var segments = this.segments;
            var tailSegments = (new Path(tail)).segments;
            while (tailSegments.length > 0 && segments.length > 0) {
                if (tailSegments.pop() != segments.pop()) {
                    return false;
                }
            }
            return true;
        },

        /*
         *Tests this path for equality with the given object.
         *@method equals
         *@parameter {Path}another
         *@return {Boolean}
         */
        "equals": /*Boolean*/ function( /*Path*/ another) {
            var segments = this._.segments,
                anotherSegments = another._.segments;
            if (segments.length != anotherSegments.length) {
                return false;
            }
            for (var i = 0; i < segments.length; i++) {
                if (anotherSegments[i] != segments[i]) {
                    return false;
                };
            }
            return true;
        },

        /*
         *
         *@method firstSegment
         *@parameter {Number}length
         *@return {String}
         */
        firstSegment: /*String*/ function( /*Number*/ length) {
            var segments = this._.segments;
            return segments[length || 0];
        },

        /*
         *
         *@method getExtension
         *@return {String}
         */
        getExtension: function() {
            var extension = this._.extension,
                path = this._.path;
            if (!textension) {
                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);
            }
            return extension;
        },

        /*
         *
         *@method getSegments
         *@return {Array}
         */
        getSegments: /*Array*/ function() {
            return this.segments;
        },

        /*
         *Returns the parent path, or null if this path does not have a parent.
         *@method getParentPath
         *@return {Path}
         */
        getParentPath: /*Path*/ function() {
            var parentPath = this._.parentPath;
            if (!parentPath) {
                var parentSegments = this.segments;
                parentSegments.pop();
                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);
            }
            return parentPath;
        },


        /*
         *Returns the root component of this path as a Path object, or null if this path does not have a root component.
         *@method getRoot
         *@return {Path}
         */
        "getRoot": /*Path*/ function() {
            //TODO: will be implemented
        },

        /*
         *Tells whether or not this path is absolute.
         *@method isAbsolute
         *@return {Boolean}
         */
        isAbsolute: /*Boolean*/ function() {
            return this.hasLeading;
        },


        /*
         *
         *@method lastSegment
         *@ return {String}
         */
        lastSegment: /*String*/ function() {
            var segments = this._.segments;
            return segments[segments.length - 1];
        },

        /*
         *
         *@method matchingFirstSegments
         *@parameter {Path}another
         *@return {Number}
         */
        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {
            var mySegments = this.segments;
            var pathSegments = another.segments;
            var max = Math.min(mySegments.length, pathSegments.length);
            var count = 0;
            for (var i = 0; i < max; i++) {
                if (mySegments[i] != pathSegments[i]) {
                    return count;
                }
                count++;
            }
            return count;
        },

        /*
         *Returns a path that is this path with redundant name elements eliminated.
         *@method normalize
         *@return {Path}
         */
        "normalize": /*Path*/ function() {
            //TODO: will be implemented
        },


        /*
         *
         *@method removeFirstSegments
         *@parameter {Number}count
         *@return {Path}
         */
        removeFirstSegments: /*Path*/ function( /*Number*/ count) {
            var segments = this._.segments,
                hasLeading = this._.hasLeading;
            hasTrailing = this._.hasTrailing;

            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);
        },

        /*
         *
         *@method removeLastSegments
         *@parameter {Number}count
         *@return {Path}
         */
        removeLastSegments: /*Path*/ function( /*Number?*/ count) {
            var segments = this._.segments,
                hasLeading = this._.hasLeading;
            hasTrailing = this._.hasTrailing;

            if (!count) {
                count = 1;
            }

            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);
        },

        /*
         *
         *@method removeMatchingFirstSegments
         *@parameter {Path}another
         *@return {Path}
         */
        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {
            var match = this.matchingFirstSegments(another);
            return this.removeFirstSegments(match);
        },

        /*
         *
         *@method removeMatchingLastSegments
         *@parameter {Path}another
         *@return {Path}
         */
        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {
            var match = this.matchingFirstSegments(anotherPath);
            return this.removeLastSegments(match);
        },

        /*
         *
         *@method removeRelative
         *@return {Path}
         */
        removeRelative: function() {
            var segs = this.segments;
            if (segs.length > 0 && segs[1] == ".")
                return this.removeFirstSegments(1);
            return this;
        },

        /*
         *Constructs a relative path between this path and a given path.
         *@method relativeTo
         *@parameter {Path}base
         *@return {Path}
         */
        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {
            if (typeof base == 'string') {
                base = new Path(base);
            }
            var mySegments = this.segments;
            if (this.isAbsolute()) {
                return this;
            }
            var baseSegments = base.segments;
            var commonLength = this.matchingFirstSegments(base);
            var baseSegmentLength = baseSegments.length;
            if (ignoreFilename) {
                baseSegmentLength = baseSegmentLength - 1;
            }
            var differenceLength = baseSegmentLength - commonLength;
            var newSegmentLength = differenceLength + mySegments.length - commonLength;
            if (newSegmentLength == 0) {
                return Path.EMPTY;
            }
            var newSegments = [];
            for (var i = 0; i < differenceLength; i++) {
                newSegments.push('..');
            }
            for (var i = commonLength; i < mySegments.length; i++) {
                newSegments.push(mySegments[i]);
            }
            return new Path(newSegments, false, this.hasTrailing);
        },

        /*
         *
         *@method segment
         *@parameter {Number}index
         *@return {String}
         */
        segment: /*String*/ function( /*Number*/ index) {
            var segments = this._.segments;
            if (segments.length < index) return null;
            return segments[index];
        },

        /*
         *
         *@method startsWith
         *@parameter {Path}index
         *@return {Boolean}
         */
        startsWith: /*Boolean*/ function( /*Path*/ another) {
            var count = this.matchingFirstSegments(another);
            return another._length() == count;
        },

        /*
         *
         *@method toString
         *@return {String}
         */
        toString: function() {
            var result = [],
                segments = this._.segments;
            if (this.hasLeading) {
                result.push("/");
            }
            for (var i = 0; i < segments.length; i++) {
                if (i > 0) {
                    result.push("/");
                }
                result.push(segments[i]);
            }
            if (this.hasTrailing) {
                result.push("/");
            }
            return result.join("");
        },

        hasLeading : {
            get : function() {
                return this._.hasLeading
            }
        },

        hasTrailing : {
            get : function() {
                return this._.hasTrailing
            }
        }

    });


    Path.EMPTY = new Path("");

    return urls.Path = Path;
});

define('skylark-langx-urls/main',[
	"./urls",
	"./get-absolute-url",
	"./get-file-extension",
	"./get-file-name",
	"./get-query",
	"./is-cross-origin",
	"./parse-url",
	"./path"
],function(urls){
	return urls;
});
define('skylark-langx-urls', ['skylark-langx-urls/main'], function (main) { return main; });

define('skylark-langx/urls',[
	"skylark-langx-urls"
],function(urls){
	return urls;
});
define('skylark-langx/langx',[
    "./skylark",
    "./arrays",
    "./array-store",
    "./aspect",
    "./async",
    "./binary",
    "./constructs",
    "./datetimes",
    "./deferred",
    "./emitter",
    "./evented",
    "./events",
    "./funcs",
    "./globals",
    "./hoster",
    "./klass",
    "./maths",
    "./numerics",
    "./objects",
    "./stateful",
    "./strings",
    "./topic",
    "./types",
    "./urls"
], function(
    skylark,
    arrays,
    ArrayStore,
    aspect,
    async,
    binary,
    constructs,
    datetimes,
    Deferred,
    Emitter,
    Evented,
    events,
    funcs,
    globals,
    hoster,
    klass,
    maths,
    numerics,
    objects,
    Stateful,
    strings,
    topic,
    types,
    urls
) {
    "use strict";
    var toString = {}.toString,
        concat = Array.prototype.concat,
        indexOf = Array.prototype.indexOf,
        slice = Array.prototype.slice,
        filter = Array.prototype.filter,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin,
        isFunction = types.isFunction;


    function funcArg(context, arg, idx, payload) {
        return isFunction(arg) ? arg.call(context, idx, payload) : arg;
    }

    function getQueryParams(url) {
        var url = url || window.location.href,
            segs = url.split("?"),
            params = {};

        if (segs.length > 1) {
            segs[1].split("&").forEach(function(queryParam) {
                var nv = queryParam.split('=');
                params[nv[0]] = nv[1];
            });
        }
        return params;
    }


    function toPixel(value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
    }


    var _uid = 1;

    function uid(obj) {
        return obj._uid || (obj._uid = _uid++);
    }

    function langx() {
        return langx;
    }

    mixin(langx, {
        createEvent : Emitter.createEvent,

        funcArg: funcArg,

        getQueryParams: getQueryParams,

        toPixel: toPixel,

        uid: uid,

        URL: typeof window !== "undefined" ? window.URL || window.webkitURL : null

    });


    mixin(langx, arrays,aspect,datetimes,funcs,numerics,objects,strings,types,{
        ArrayStore : ArrayStore,

        async : async,
        
        Deferred: Deferred,

        Emitter: Emitter,

        Evented: Evented,

        hoster : hoster,

        klass : klass,
       
        Stateful: Stateful,

        topic : topic
    });

    return skylark.langx = langx;
});
define('skylark-domx-browser/browser',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {
    "use strict";

    var browser = langx.hoster.browser;


    langx.mixin(browser, {

        isIE : !!/msie/i.exec( window.navigator.userAgent ),

        location: function() {
            return window.location;
        },

        support : {

        }

    });



    return skylark.attach("domx.browser",browser);
});

define('skylark-domx-browser/support/css3',[
    "skylark-langx/langx",
    "../browser"
], function(langx,browser) {
    "use strict";

    var checkedCssProperties = {
            "transitionproperty": "TransitionProperty",
        },
        transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        },
        transEndEventName = null;


    var css3PropPrefix = "",
        css3StylePrefix = "",
        css3EventPrefix = "",

        cssStyles = {},
        cssProps = {},

        vendorPrefix,
        vendorPrefixRE,
        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,

        document = window.document,
        testEl = document.createElement("div"),

        matchesSelector = testEl.webkitMatchesSelector ||
                          testEl.mozMatchesSelector ||
                          testEl.oMatchesSelector ||
                          testEl.matchesSelector,

        testStyle = testEl.style;

    for (var name in testStyle) {
        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);
        if (matched) {
            if (!vendorPrefixRE) {
                vendorPrefix = matched[1];
                vendorPrefixRE = new RegExp("^(" + vendorPrefix + ")(.*)$");

                css3StylePrefix = vendorPrefix;
                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';
                css3EventPrefix = vendorPrefix.toLowerCase();
            }

            cssStyles[langx.lowerFirst(matched[2])] = name;
            var cssPropName = langx.dasherize(matched[2]);
            cssProps[cssPropName] = css3PropPrefix + cssPropName;

            if (transEndEventNames[name]) {
              transEndEventName = transEndEventNames[name];
            }
        }
    }

    if (!transEndEventName) {
        if (testStyle["transition"] !== undefined) {
            transEndEventName = transEndEventNames["transition"];
        }
    }

    function normalizeCssEvent(name) {
        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();
    }

    function normalizeCssProperty(name) {
        return cssProps[name] || name;
    }

    function normalizeStyleProperty(name) {
        return cssStyles[name] || name;
    }


    var css3 = {

        normalizeStyleProperty: normalizeStyleProperty,

        normalizeCssProperty: normalizeCssProperty,

        normalizeCssEvent: normalizeCssEvent,

        matchesSelector: matchesSelector        
    };

    langx.mixin(browser,css3);

    browser.css3PropPrefix = css3.propPrefix =  css3PropPrefix;

    if  (transEndEventName) {
        browser.support.transition = css3.transition = {
            end : transEndEventName
        };
    }

    browser.support.cssPointerEvents = css3.pointerEvents =  (function() {
        testEl.style.cssText = 'pointer-events:auto';
        return testEl.style.pointerEvents === 'auto';
    })(),




    testEl = null;

    return browser.support.css3 = css3;
});

define('skylark-domx-browser/support/fullscreen',[
    "../browser"
],function(browser){

    const FullscreenApi = { 
        prefixed: true 
    };

    const apiMap = [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror',
            'fullscreen'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror',
            '-webkit-full-screen'
        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror',
            '-moz-full-screen'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError',
            '-ms-fullscreen'
        ]
    ];
    const specApi = apiMap[0];
    let browserApi;
    for (let i = 0; i < apiMap.length; i++) {
        if (apiMap[i][1] in document) {
            browserApi = apiMap[i];
            break;
        }
    }
    if (browserApi) {
        for (let i = 0; i < browserApi.length; i++) {
            FullscreenApi[specApi[i]] = browserApi[i];
        }
        FullscreenApi.prefixed = browserApi[0] !== specApi[0];

        browser.requestFullscreen = function() {
            return document.body[FullscreenApi["requestFullscreen"]].apply(this,arguments);
        };
        browser.exitFullscreen = function() {
            return document[FullscreenApi["exitFullscreen"]].apply(this,arguments);
        };

        browser.support.fullscreen = FullscreenApi;
    } else {
        browser.support.fullscreen = null;
    }

    return browser.support.fullscreen;
});
define('skylark-domx-browser/support/touch',[
	"../browser"
],function(browser){

    function supportTouch() {
        return !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
    }

    return browser.support.tocuh = supportTouch();
});
define('skylark-domx-browser/main',[
	"./browser",
	"./support/css3",
	"./support/fullscreen",
	"./support/touch"
],function(browser){
	return browser;
});
define('skylark-domx-browser', ['skylark-domx-browser/main'], function (main) { return main; });

define('skylark-langx/main',[
    "./langx"
], function(langx) {
    return langx;
});

define('skylark-langx', ['skylark-langx/main'], function (main) { return main; });

define('skylark-langx-scripter/scripter',[
    "skylark-langx/skylark",
    "skylark-langx"
], function(skylark, langx) {

    var head = document.getElementsByTagName('head')[0],
        scriptsByUrl = {},
        scriptElementsById = {},
        count = 0;

    function scripter() {
        return scripter;
    }


    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function evaluate(code,node, doc ) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if ( node ) {
            for ( i in preservedScriptAttributes ) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[ i ] || node.getAttribute && node.getAttribute( i );
                if ( val ) {
                    script.setAttribute( i, val );
                }
            }
        }
        doc.head.appendChild( script ).parentNode.removeChild( script );

        return this;
    }

    langx.mixin(scripter, {
        /*
         * Load a script from a url into the document.
         * @param {} url
         * @param {} loadedCallback
         * @param {} errorCallback
         */
        loadJavaScript: function(url, loadedCallback, errorCallback) {
            var script = scriptsByUrl[url];
            if (!script) {
                script = scriptsByUrl[url] = {
                    state: 0, //0:unload,1:loaded,-1:loaderror
                    loadedCallbacks: [],
                    errorCallbacks: []
                }
            }

            script.loadedCallbacks.push(loadedCallback);
            script.errorCallbacks.push(errorCallback);

            if (script.state === 1) {
                script.node.onload();
            } else if (script.state === -1) {
                script.node.onerror();
            } else {
                var node = script.node = document.createElement("script"),
                    id = script.id = (count++);

                node.type = "text/javascript";
                node.async = false;
                node.defer = false;
                startTime = new Date().getTime();
                head.appendChild(node);

                node.onload = function() {
                        script.state = 1;

                        var callbacks = script.loadedCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    },
                    node.onerror = function() {
                        script.state = -1;
                        var callbacks = script.errorCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    };
                node.src = url;

                scriptElementsById[id] = node;
            }
            return script.id;
        },
        /*
         * Remove the specified script from the document.
         * @param {Number} id
         */
        deleteJavaScript: function(id) {
            var node = scriptElementsById[id];
            if (node) {
                var url = node.src;
                if (node.parentNode) {
                    node.parentNode.remove(node);
                }
                delete scriptElementsById[id];
                delete scriptsByUrl[url];
            }
        },

        evaluate : evaluate,

        loadScript : function(url) {
            var d = new langx.Deferred();

            d.promise.scriptId = this.loadJavaScript(url,function(){
                d.resolve();
            },function(e){
                d.reject(e);
            });

            return d.promise;
        }


    });

    return skylark.attach("langx.scripter", scripter);
});
define('skylark-langx-scripter/main',[
	"./scripter"
],function(scripter){
	
	return scripter;
});
define('skylark-langx-scripter', ['skylark-langx-scripter/main'], function (main) { return main; });

define('skylark-domx-noder/noder',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "skylark-langx-arrays",
    "skylark-langx-strings",
    "skylark-langx-scripter",
    "skylark-domx-browser"
], function(skylark, types, arrays, strings,scripter,browser) {
    var isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g),
        fragmentRE = /^\s*<(\w+|!)[^>]*>/,
        singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        div = document.createElement("div"),
        table = document.createElement('table'),
        tableBody = document.createElement('tbody'),
        tableRow = document.createElement('tr'),
        containers = {
            'tr': tableBody,
            'tbody': table,
            'thead': table,
            'tfoot': table,
            'td': tableRow,
            'th': tableRow,
            '*': div
        },
        rootNodeRE = /^(?:body|html)$/i,
        rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i ),
        map = Array.prototype.map,
        slice = Array.prototype.slice;



    function normalizeContent(content) {
        if (typeof content === 'function') {
            content = content();
        }
        return map.call(types.isArrayLike(content) ? content : [content],value => {
            if (typeof value === 'function') {
                value = value();
            }
            if (isElement(value) || isTextNode(value)) {
                return value;
            }
            if (typeof value === 'string' && /\S/.test(value)) {
                return document.createTextNode(value);
            }
        }).filter(value => value);
    }

    function ensureNodes(content, copyByClone) {
        var nodes = normalizeContent(content);


        //if (!types.isArrayLike(nodes)) {
        //    nodes = [nodes];
        //}
        if (copyByClone) {
            nodes = map.call(nodes, function(node) {
                return node.cloneNode(true);
            });
        }
        return arrays.flatten(nodes);
    }

    function nodeName(elm, chkName) {
        var name = elm.nodeName && elm.nodeName.toLowerCase();
        if (chkName !== undefined) {
            return name === chkName.toLowerCase();
        }
        return name;
    };


    function activeElement(doc) {
        doc = doc || document;
        var el;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            el = doc.activeElement;
        } catch ( error ) {
            el = doc.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if ( !el ) {
            el = doc.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if ( !el.nodeName ) {
            el = doc.body;
        }

        return el;
    };

    function enhancePlaceContent(placing,node) {
        if (types.isFunction(placing)) {
            return placing.apply(node,[]);
        }
        if (types.isArrayLike(placing)) {
            var neddsFlattern;
            for (var i=0;i<placing.length;i++) {
                if (types.isFunction(placing[i])) {
                    placing[i] = placing[i].apply(node,[]);
                    if (types.isArrayLike(placing[i])) {
                        neddsFlattern = true;
                    }
                }
            }
            if (neddsFlattern) {
                placing = arrays.flatten(placing);
            }
        }
        return placing;
    }
    function after(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone),
                refNode = refNode.nextSibling;

            for (var i = 0; i < nodes.length; i++) {
                if (refNode) {
                    parent.insertBefore(nodes[i], refNode);
                } else {
                    parent.appendChild(nodes[i]);
                }
            }
        }
        return this;
    }

    function append(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var parentNode = node,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            parentNode.appendChild(nodes[i]);
        }
        return this;
    }

    function before(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                parent.insertBefore(nodes[i], refNode);
            }
        }
        return this;
    }
    /*   
     * Get the children of the specified node, including text and comment nodes.
     * @param {HTMLElement} elm
     */
    function contents(elm) {
        if (nodeName(elm, "iframe")) {
            return elm.contentDocument;
        }
        return elm.childNodes;
    }

    /*   
     * Create a element and set attributes on it.
     * @param {HTMLElement} tag
     * @param {attrs} attrs
     * @param } parent
     */
    function createElement(tag, props,attrs, parent) {
        var node;

        if (/svg/i.test(tag)) {
            node = document.createElementNS("http://www.w3.org/2000/svg", tag)
        } else {
            node = document.createElement(tag);
        }

        if (types.isHtmlNode(props)) {
            parent = props;
            props = null;
            attrs = null;
        } else if (types.isHtmlNode(attrs)){
            parent = attrs;
            attrs = null;
        }

        if (props) {
            for (var name in props) {
                node[name] = props[name];
            }
        }

        if (attrs) {
            for (var name in attrs) {
                node.setAttribute(name, attrs[name]);
            }
        }
        if (parent) {
            append(parent, node);
        }
        return node;
    }

function removeSelfClosingTags(xml) {
    var split = xml.split("/>");
    var newXml = "";
    for (var i = 0; i < split.length - 1;i++) {
        var edsplit = split[i].split("<");
        newXml += split[i] + "></" + edsplit[edsplit.length - 1].split(" ")[0] + ">";
    }
    return newXml + split[split.length-1];
}

    /*   
     * Create a DocumentFragment from the HTML fragment.
     * @param {String} html
     */
    function createFragment(html) {
        // A special case optimization for a single tag
        html = strings.trim(html);
        if (singleTagRE.test(html)) {
            return [createElement(RegExp.$1)];
        }

        var name = fragmentRE.test(html) && RegExp.$1
        if (!(name in containers)) {
            name = "*"
        }
        var container = containers[name];
        container.innerHTML = removeSelfClosingTags("" + html);
        dom = slice.call(container.childNodes);

        dom.forEach(function(node) {
            container.removeChild(node);
        })

        return dom;
    }

    /*   
     * Create a deep copy of the set of matched elements.
     * @param {HTMLElement} node
     * @param {Boolean} deep
     */
    function clone(node, deep) {
        var self = this,
            clone;

        // TODO: Add feature detection here in the future
        if (!isIE || node.nodeType !== 1 || deep) {
            return node.cloneNode(deep);
        }

        // Make a HTML5 safe shallow copy
        if (!deep) {
            clone = document.createElement(node.nodeName);

            // Copy attribs
            each(self.getAttribs(node), function(attr) {
                self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
            });

            return clone;
        }
    }

    /*   
     * Check to see if a dom node is a descendant of another dom node .
     * @param {String} node
     * @param {Node} child
     */
    function contains(node, child) {
        return isChildOf(child, node);
    }

    /*   
     * Create a new Text node.
     * @param {String} text
     * @param {Node} child
     */
    function createTextNode(text) {
        return document.createTextNode(text);
    }

    /*   
     * Get the current document object.
     */
    function doc() {
        return document;
    }

    /*   
     * Remove all child nodes of the set of matched elements from the DOM.
     * @param {Object} node
     */
    function empty(node) {
        while (node.hasChildNodes()) {
            var child = node.firstChild;
            node.removeChild(child);
        }
        return this;
    }

    var fulledEl = null;

    function fullscreen(el) {
        if (el === false) {
            return browser.exitFullscreen.apply(document);
        } else if (el) {
            return el[browser.support.fullscreen.requestFullscreen]();
            fulledEl = el;
        } else {
            return (
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
            )
        }
    }

    function isFullscreen(el) {
        return fullscreen() === el;
    }


    // Selectors
    function focusable( element, hasTabindex ) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" );
            return img.length > 0 && img.is( ":visible" );
        }

        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
            focusableIfVisible = !element.disabled;

            if ( focusableIfVisible ) {

                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $( element ).closest( "fieldset" )[ 0 ];
                if ( fieldset ) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ( "a" === nodeName ) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
    };

    function fromPoint(x,y) {
        return document.elementFromPoint(x,y);
    }

    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */
    function generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent,
            i = str.length,
            sum = 0;

        while (i--) {
            sum += str.charCodeAt(i);
        }

        return sum.toString(36);
    }


   var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
 
    /*   
     * Get the HTML contents of the first element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} html
     */
    function _html(node, html) {
        if (html === undefined) {
            return node.innerHTML;
        } else {
            empty(node);
            html = html || "";
            if (types.isString(html)) {
                html = html.replace( rxhtmlTag, "<$1></$2>" );
            }
            if (types.isString(html) || types.isNumber(html)) {               
                node.innerHTML = html;
            } else if (types.isArrayLike(html)) {
                for (var i = 0; i < html.length; i++) {
                    node.appendChild(html[i]);
                }
            } else {
                node.appendChild(html);
            }

            return this;
        }
    }


    function html(node,value) {
        var result = _html(node,value);

        if (value !== undefined) {
            var scripts = node.querySelectorAll('script');

            for (var i =0; i<scripts.length; i++) {
                var node1 = scripts[i];
                if (rscriptType.test( node1.type || "" ) ) {
                  scripter.evaluate(node1.textContent,node1);
                }
            }       
            return this;         
        } else {
            return result;
        }
    }

    /*   
     * Check to see if a dom node is a descendant of another dom node.
     * @param {Node} node
     * @param {Node} parent
     * @param {Node} directly
     */
    function isChildOf(node, parent, directly) {
        if (directly) {
            return node.parentNode === parent;
        }
        if (document.documentElement.contains) {
            return parent.contains(node);
        }
        while (node) {
            if (parent === node) {
                return true;
            }

            node = node.parentNode;
        }

        return false;
    }

    /*   
     * Check to see if a dom node is a document.
     * @param {Node} node
     */
    function isDocument(node) {
        return node != null && node.nodeType == node.DOCUMENT_NODE
    }

    /*   
     * Check to see if a dom node is in the document
     * @param {Node} node
     */
    function isInDocument(node) {
      return (node === document.body) ? true : document.body.contains(node);
    }        

    var blockNodes = ["div", "p", "ul", "ol", "li", "blockquote", "hr", "pre", "h1", "h2", "h3", "h4", "h5", "table"];

    function isBlockNode(node) {
        if (!node || node.nodeType === 3) {
          return false;
        }
        return new RegExp("^(" + (blockNodes.join('|')) + ")$").test(node.nodeName.toLowerCase());
    }

    function isActive (elem) {
            return elem === document.activeElement && (elem.type || elem.href);
    }


    function isTextNode(node) {
        return node && node.nodeType === 3;
    }


    function isElement(node) {
        return node && node.nodeType === 1;
    }

    function isInFrame() {
        try {
            return window.parent !== window.self;
        } catch (x) {
            return true;
        }
    }

    /*   
     * Get the owner document object for the specified element.
     * @param {Node} elm
     */
    function ownerDoc(elm) {
        if (!elm) {
            return document;
        }

        if (elm.nodeType == 9) {
            return elm;
        }

        return elm.ownerDocument;
    }

    /*   
     *
     * @param {Node} elm
     */
    function ownerWindow(elm) {
        var doc = ownerDoc(elm);
        return doc.defaultView || doc.parentWindow;
    }

    /*   
     * insert one or more nodes as the first children of the specified node.
     * @param {Node} node
     * @param {Node or ArrayLike} placing
     * @param {Boolean Optional} copyByClone
     */
    function prepend(node, placing, copyByClone) {
        var parentNode = node,
            refNode = parentNode.firstChild,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            if (refNode) {
                parentNode.insertBefore(nodes[i], refNode);
            } else {
                parentNode.appendChild(nodes[i]);
            }
        }
        return this;
    }

    /*   
     *
     * @param {Node} elm
     */
    function offsetParent(elm) {
        var parent = elm.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && document.defaultView.getComputedStyle(parent).position == "static") {
            parent = parent.offsetParent;
        }
        return parent;
    }

    /*   
     * Remove the set of matched elements from the DOM.
     * @param {Node} node
     */
    function remove(node) {
        if (node && node.parentNode) {
            try {
                node.parentNode.removeChild(node);
            } catch (e) {
                console.warn("The node is already removed", e);
            }
        }
        return this;
    }

    function removeChild(node,children) {
        if (!types.isArrayLike(children)) {
            children = [children];
        }
        for (var i=0;i<children.length;i++) {
            node.removeChild(children[i]);
        }

        return this;
    }

    function scrollParent( elm, includeHidden ) {
        var position = document.defaultView.getComputedStyle(elm).position,
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter( function() {
                var parent = $( this );
                if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                    return false;
                }
                return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                    parent.css( "overflow-x" ) );
            } ).eq( 0 );

        return position === "fixed" || !scrollParent.length ?
            $( this[ 0 ].ownerDocument || document ) :
            scrollParent;
    };


    function reflow(elm) {
        if (!elm) {
          elm = document;
        }
        elm.offsetHeight;

        return this;      
    }

    /*   
     * Replace an old node with the specified node.
     * @param {Node} node
     * @param {Node} oldNode
     */
    function replace(node, oldNode) {
        oldNode.parentNode.replaceChild(node, oldNode);
        return this;
    }


    function selectable(elem, selectable) {
        if (elem === undefined || elem.style === undefined)
            return;
        elem.onselectstart = selectable ? function () {
            return false;
        } : function () {
        };
        elem.style.MozUserSelect = selectable ? 'auto' : 'none';
        elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
        elem.unselectable = selectable ? 'on' : 'off';
    }

    /*   
     * traverse the specified node and its descendants, perform the callback function on each
     * @param {Node} node
     * @param {Function} fn
     */
    function traverse(node, fn) {
        fn(node)
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            traverse(node.childNodes[i], fn);
        }
        return this;
    }

    /*   
     *
     * @param {Node} node
     */
    function reverse(node) {
        var firstChild = node.firstChild;
        for (var i = node.children.length - 1; i > 0; i--) {
            if (i > 0) {
                var child = node.children[i];
                node.insertBefore(child, firstChild);
            }
        }
    }

    /*   
     * Wrap an HTML structure around each element in the set of matched elements.
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapper(node, wrapperNode) {
        if (types.isString(wrapperNode)) {
            wrapperNode = this.createFragment(wrapperNode).firstChild;
        }
        node.parentNode.insertBefore(wrapperNode, node);
        wrapperNode.appendChild(node);
    }

    /*   
     * Wrap an HTML structure around the content of each element in the set of matched
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapperInner(node, wrapperNode) {
        var childNodes = slice.call(node.childNodes);
        node.appendChild(wrapperNode);
        for (var i = 0; i < childNodes.length; i++) {
            wrapperNode.appendChild(childNodes[i]);
        }
        return this;
    }

    /*   
     * Remove the parents of the set of matched elements from the DOM, leaving the matched
     * @param {Node} node
     */
    function unwrap(node) {
        var child, parent = node.parentNode;
        if (parent) {
            if (this.isDoc(parent.parentNode)) return;
            parent.parentNode.insertBefore(node, parent);
        }
    }



    function isInput (el) { 
        return el.tagName === 'INPUT' || 
               el.tagName === 'TEXTAREA' || 
               el.tagName === 'SELECT' || 
               isEditable(el); 
    }
    
    function isEditable (el) {
      if (!el) { return false; } // no parents were editable
      if (el.contentEditable === 'false') { return false; } // stop the lookup
      if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
      return isEditable(el.parentNode); // contentEditable is set to 'inherit'
    }

    function noder() {
        return noder;
    }

    Object.assign(noder, {
        active  : activeElement,

        after: after,

        append: append,

        before: before,

        blur : function(el) {
            el.blur();
        },

        body: function() {
            return document.body;
        },

        clone: clone,

        contains: contains,

        contents: contents,

        createElement: createElement,

        createFragment: createFragment,

        createTextNode: createTextNode,

        doc: doc,

        empty: empty,

        generateId,

        fullscreen: fullscreen,

        focusable: focusable,

        fromPoint,

        html: html,

        isActive,

        isChildOf,

        isDocument,

        isEditable,
        
        isElement,

        isFullscreen,

        isInDocument,

        isInFrame,

        isInput,

        isTextNode,

        isWindow: types.isWindow,

        nodeName : nodeName,

        offsetParent: offsetParent,

        ownerDoc: ownerDoc,

        ownerWindow: ownerWindow,

        prepend: prepend,

        reflow: reflow,

        remove: remove,

        removeChild : removeChild,

        replace: replace,

        selectable,

        traverse: traverse,

        reverse: reverse,

        wrapper: wrapper,

        wrapperInner: wrapperInner,

        unwrap: unwrap
    });

    return skylark.attach("domx.noder" , noder);
});
define('skylark-domx-styler/styler',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark, langx) {
    var every = Array.prototype.every,
        forEach = Array.prototype.forEach,
        camelCase = langx.camelCase,
        dasherize = langx.dasherize;

    function maybeAddPx(name, value) {
        return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
    }

    var cssNumber = {
            'column-count': 1,
            'columns': 1,
            'font-weight': 1,
            'line-height': 1,
            'opacity': 1,
            'z-index': 1,
            'zoom': 1
        },
        classReCache = {

        };

    function classRE(name) {
        return name in classReCache ?
            classReCache[name] : (classReCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'));
    }

    // access className property while respecting SVGAnimatedString
    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} value
     */
    function className(node, value) {
        var klass = node.className || '',
            svg = klass && klass.baseVal !== undefined

        if (value === undefined) return svg ? klass.baseVal : klass
        svg ? (klass.baseVal = value) : (node.className = value)
    }

    function disabled(elm, value ) {
        if (arguments.length < 2) {
            return !!this.dom.disabled;
        }

        elm.disabled = value;

        return this;
    }

    var elementDisplay = {};

    function defaultDisplay(nodeName) {
        var element, display
        if (!elementDisplay[nodeName]) {
            element = document.createElement(nodeName)
            document.body.appendChild(element)
            display = getStyles(element).getPropertyValue("display")
            element.parentNode.removeChild(element)
            display == "none" && (display = "block")
            elementDisplay[nodeName] = display
        }
        return elementDisplay[nodeName]
    }
    /*
     * Display the matched elements.
     * @param {HTMLElement} elm
     */
    function show(elm) {
        styler.css(elm, "display", "");
        if (styler.css(elm, "display") == "none") {
            styler.css(elm, "display", defaultDisplay(elm.nodeName));
        }
        return this;
    }

    function isInvisible(elm) {
        return styler.css(elm, "display") == "none" || styler.css(elm, "opacity") == 0 || styler.css(elm,"visibility") == "hidden";
    }

    /*
     * Hide the matched elements.
     * @param {HTMLElement} elm
     */
    function hide(elm) {
        styler.css(elm, "display", "none");
        return this;
    }

    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function addClass(elm, name) {
        if (!name) return this
        var cls = className(elm),
            names;
        if (langx.isString(name)) {
            names = name.split(/\s+/g);
        } else {
            names = name;
        }
        names.forEach(function(klass) {
            var re = classRE(klass);
            if (!cls.match(re)) {
                cls += (cls ? " " : "") + klass;
            }
        });

        className(elm, cls);

        return this;
    }

    function getStyles( elem ) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem);
    }


    /*
     * Get the value of a computed style property for the first element in the set of matched elements or set one or more CSS properties for every matched element.
     * @param {HTMLElement} elm
     * @param {String} property
     * @param {Any} value
     */
    function css(elm, property, value) {
        //if (arguments.length < 3) {
        if (value == void 0) {
            var computedStyle,
                computedStyle = getStyles(elm)
            if (property == void 0) {
                return computedStyle;
            } else if (langx.isString(property)) {
                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(dasherize(property))
            } else if (langx.isArrayLike(property)) {
                var props = {}
                forEach.call(property, function(prop) {
                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(dasherize(prop)))
                })
                return props
            }
        }

        var css = '';
        if (typeof(property) == 'string') {
            if (!value && value !== 0) {
                elm.style.removeProperty(dasherize(property));
            } else {
                css = dasherize(property) + ":" + maybeAddPx(property, value)
            }
        } else {
            for (key in property) {
                if (property[key] === undefined) {
                    continue;
                }
                if (!property[key] && property[key] !== 0) {
                    elm.style.removeProperty(dasherize(key));
                } else {
                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
                }
            }
        }

        elm.style.cssText += ';' + css;
        return this;
    }

    /*
     * Determine whether any of the matched elements are assigned the given class.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function hasClass(elm, name) {
        var re = classRE(name);
        return elm.className && elm.className.match(re);
    }

    /*
     * Remove a single class, multiple classes, or all classes from each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function removeClass(elm, name) {
        if (name) {
            var cls = className(elm),
                names;

            if (langx.isString(name)) {
                names = name.split(/\s+/g);
            } else {
                names = name;
            }

            names.forEach(function(klass) {
                var re = classRE(klass);
                if (cls.match(re)) {
                    cls = cls.replace(re, " ");
                }
            });

            className(elm, cls.trim());
        } else {
            className(elm, "");
        }

        return this;
    }

    /*
     * Add or remove one or more classes from the specified element.
     * @param {HTMLElement} elm
     * @param {String} name
     * @param {} when
     */
    function toggleClass(elm, name, when) {
        var self = this;
        name.split(/\s+/g).forEach(function(klass) {
            if (when === undefined) {
                when = !hasClass(elm, klass);
            }
            if (when) {
                addClass(elm, klass);
            } else {
                removeClass(elm, klass)
            }
        });

        return self;
    }

    var styler = function() {
        return styler;
    };

    langx.mixin(styler, {
        autocssfix: false,
        cssHooks: {

        },

        addClass: addClass,
        className: className,
        css: css,
        disabled : disabled,        
        hasClass: hasClass,
        hide: hide,
        isInvisible: isInvisible,
        removeClass: removeClass,
        show: show,
        toggleClass: toggleClass
    });

    return skylark.attach("domx.styler", styler);
});
define('skylark-domx-styler/main',[
	"./styler"
],function(styler,velm,$){
	
	return styler;
});
define('skylark-domx-styler', ['skylark-domx-styler/main'], function (main) { return main; });

define('skylark-domx-noder/overlay',[
	"skylark-domx-styler",
	"./noder"
],function(styler,noder){
    /*   
     *
     * @param {Node} elm
     * @param {Node} params
     */
    function overlay(elm, params) {
        var overlayDiv = noder.createElement("div", params);
        styler.css(overlayDiv, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 0x7FFFFFFF,
            opacity: 0.7
        });
        elm.appendChild(overlayDiv);
        return overlayDiv;

    }

    return noder.overlay = overlay;
 });
define('skylark-domx-noder/throb',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./noder"
],function(langx,styler,noder) {

    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};

        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "className": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };

        if (params.style) {
            styler.css(throbber,params.style);
        }

        //throb = noder.createElement("div", {
        //   "class": params.throb && params.throb.className || "throb"
        //}),
        //textNode = noder.createTextNode(text || ""),
 
        var content = params.content ||  '<span class="throb"></span>';

        //throb.appendChild(textNode);
        //throbber.appendChild(throb);

        noder.html(throbber,content);
        
        elm.appendChild(throbber);

        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            throbber : throbber,
            remove: remove,
            update: update
        };
    }

    return noder.throb = throb;
});
define('skylark-domx-noder/main',[
	"./noder",
	"./overlay",
	"./throb"
],function(noder){
	return noder;
});
define('skylark-domx-noder', ['skylark-domx-noder/main'], function (main) { return main; });

define('skylark-domx-finder/finder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, browser, noder,styler) {
    var local = {},
        filter = Array.prototype.filter,
        slice = Array.prototype.slice,
        nativeMatchesSelector = browser.matchesSelector;

    /*
    ---
    name: Slick.Parser
    description: Standalone CSS3 Selector parser
    provides: Slick.Parser
    ...
    */
    ;
    (function() {

        var parsed,
            separatorIndex,
            combinatorIndex,
            reversed,
            cache = {},
            reverseCache = {},
            reUnescape = /\\/g;

        var parse = function(expression, isReversed) {
            if (expression == null) return null;
            if (expression.Slick === true) return expression;
            expression = ('' + expression).replace(/^\s+|\s+$/g, '');
            reversed = !!isReversed;
            var currentCache = (reversed) ? reverseCache : cache;
            if (currentCache[expression]) return currentCache[expression];
            parsed = {
                Slick: true,
                expressions: [],
                raw: expression,
                reverse: function() {
                    return parse(this.raw, true);
                }
            };
            separatorIndex = -1;
            while (expression != (expression = expression.replace(regexp, parser)));
            parsed.length = parsed.expressions.length;
            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
        };

        var reverseCombinator = function(combinator) {
            if (combinator === '!') return ' ';
            else if (combinator === ' ') return '!';
            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
            else return '!' + combinator;
        };

        var reverse = function(expression) {
            var expressions = expression.expressions;
            for (var i = 0; i < expressions.length; i++) {
                var exp = expressions[i];
                var last = {
                    parts: [],
                    tag: '*',
                    combinator: reverseCombinator(exp[0].combinator)
                };

                for (var j = 0; j < exp.length; j++) {
                    var cexp = exp[j];
                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
                    cexp.combinator = cexp.reverseCombinator;
                    delete cexp.reverseCombinator;
                }

                exp.reverse().push(last);
            }
            return expression;
        };

        var escapeRegExp = (function() {
            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
            var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g,
                to = '\\';
            return function(string) {
                return string.replace(from, to)
            }
        }())

        var regexp = new RegExp(
            "^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
            .replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
            .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
            .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
        );

        function parser(
            rawMatch,

            separator,
            combinator,
            combinatorChildren,

            tagName,
            id,
            className,

            attributeKey,
            attributeOperator,
            attributeQuote,
            attributeValue,

            pseudoMarker,
            pseudoClass,
            pseudoQuote,
            pseudoClassQuotedValue,
            pseudoClassValue
        ) {
            if (separator || separatorIndex === -1) {
                parsed.expressions[++separatorIndex] = [];
                combinatorIndex = -1;
                if (separator) return '';
            }

            if (combinator || combinatorChildren || combinatorIndex === -1) {
                combinator = combinator || ' ';
                var currentSeparator = parsed.expressions[separatorIndex];
                if (reversed && currentSeparator[combinatorIndex])
                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
                currentSeparator[++combinatorIndex] = {
                    combinator: combinator,
                    tag: '*'
                };
            }

            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

            if (tagName) {
                currentParsed.tag = tagName.replace(reUnescape, '');

            } else if (id) {
                currentParsed.id = id.replace(reUnescape, '');

            } else if (className) {
                className = className.replace(reUnescape, '');

                if (!currentParsed.classList) currentParsed.classList = [];
                if (!currentParsed.classes) currentParsed.classes = [];
                currentParsed.classList.push(className);
                currentParsed.classes.push({
                    value: className,
                    regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
                });

            } else if (pseudoClass) {
                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

                if (!currentParsed.pseudos) currentParsed.pseudos = [];
                currentParsed.pseudos.push({
                    key: pseudoClass.replace(reUnescape, ''),
                    value: pseudoClassValue,
                    type: pseudoMarker.length == 1 ? 'class' : 'element'
                });

            } else if (attributeKey) {
                attributeKey = attributeKey.replace(reUnescape, '');
                attributeValue = (attributeValue || '').replace(reUnescape, '');

                var test, regexp;

                switch (attributeOperator) {
                    case '^=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue));
                        break;
                    case '$=':
                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');
                        break;
                    case '~=':
                        regexp = new RegExp('(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)');
                        break;
                    case '|=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');
                        break;
                    case '=':
                        test = function(value) {
                            return attributeValue == value;
                        };
                        break;
                    case '*=':
                        test = function(value) {
                            return value && value.indexOf(attributeValue) > -1;
                        };
                        break;
                    case '!=':
                        test = function(value) {
                            return attributeValue != value;
                        };
                        break;
                    default:
                        test = function(value) {
                            return !!value;
                        };
                }

                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {
                    return false;
                };

                if (!test) test = function(value) {
                    return value && regexp.test(value);
                };

                if (!currentParsed.attributes) currentParsed.attributes = [];
                currentParsed.attributes.push({
                    key: attributeKey,
                    operator: attributeOperator,
                    value: attributeValue,
                    test: test
                });

            }

            return '';
        };

        // Slick NS

        var Slick = (this.Slick || {});

        Slick.parse = function(expression) {
            return parse(expression);
        };

        Slick.escapeRegExp = escapeRegExp;

        if (!this.Slick) this.Slick = Slick;

    }).apply(local);


    var simpleClassSelectorRE = /^\.([\w-]*)$/,
        simpleIdSelectorRE = /^#([\w-]*)$/,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        slice = Array.prototype.slice;


    local.parseSelector = local.Slick.parse;


    var pseudos = local.pseudos = {
        // custom pseudos
        "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        'checked': function(elm) {
            return !!elm.checked;
        },

        'contains': function(elm, idx, nodes, text) {
            if ($(this).text().indexOf(text) > -1) return this
        },

        'disabled': function(elm) {
            return !!elm.disabled;
        },

        'enabled': function(elm) {
            return !elm.disabled;
        },

        'eq': function(elm, idx, nodes, value) {
            return (idx == value);
        },

        'even': function(elm, idx, nodes, value) {
            return (idx % 2) === 0;
        },

        'focus': function(elm) {
            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);
        },

        'focusable': function( elm ) {
            return noder.focusable(elm, elm.tabindex != null );
        },

        'first': function(elm, idx) {
            return (idx === 0);
        },

        'gt': function(elm, idx, nodes, value) {
            return (idx > value);
        },

        'has': function(elm, idx, nodes, sel) {
            return find(elm, sel);
        },

        // Element/input types
        "header": function(elem) {
            return rheader.test(elem.nodeName);
        },

        'hidden': function(elm) {
            return !local.pseudos["visible"](elm);
        },

        "input": function(elem) {
            return rinputs.test(elem.nodeName);
        },

        'last': function(elm, idx, nodes) {
            return (idx === nodes.length - 1);
        },

        'lt': function(elm, idx, nodes, value) {
            return (idx < value);
        },

        'not': function(elm, idx, nodes, sel) {
            return !matches(elm, sel);
        },

        'odd': function(elm, idx, nodes, value) {
            return (idx % 2) === 1;
        },

        /*   
         * Get the parent of each element in the current set of matched elements.
         * @param {Object} elm
         */
        'parent': function(elm) {
            return !!elm.parentElement;
        },

        'selected': function(elm) {
            return !!elm.selected;
        },

        'tabbable': function(elm) {
            var tabIndex = elm.tabindex,
                hasTabindex = tabIndex != null;
            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );
        },

        'text': function(elm) {
            return elm.type === "text";
        },

        'visible': function(elm) {
            return elm.offsetWidth && elm.offsetWidth
        },
        'empty': function(elm) {
            return !elm.hasChildNodes();
        }
    };

    ["first", "eq", "last"].forEach(function(item) {
        pseudos[item].isArrayFilter = true;
    });



    pseudos["nth"] = pseudos["eq"];

    function createInputPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    function createButtonPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }

    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
    }) {
        pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
    }) {
        pseudos[i] = createButtonPseudo(i);
    }


    local.divide = function(cond) {
        var nativeSelector = "",
            customPseudos = [],
            tag,
            id,
            classes,
            attributes,
            pseudos;


        if (id = cond.id) {
            nativeSelector += ("#" + id);
        }
        if (classes = cond.classes) {
            for (var i = classes.length; i--;) {
                nativeSelector += ("." + classes[i].value);
            }
        }
        if (attributes = cond.attributes) {
            for (var i = 0; i < attributes.length; i++) {
                if (attributes[i].operator) {
                    nativeSelector += ("[" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + "]");
                } else {
                    nativeSelector += ("[" + attributes[i].key + "]");
                }
            }
        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (this.pseudos[part.key]) {
                    customPseudos.push(part);
                } else {
                    if (part.value !== undefined) {
                        nativeSelector += (":" + part.key + "(" + JSON.stringify(part))
                    }
                }
            }
        }

        if (tag = cond.tag) {
            if (tag !== "*") {
                nativeSelector = tag.toUpperCase() + nativeSelector;
            }
        }

        if (!nativeSelector) {
            nativeSelector = "*";
        }

        return {
            nativeSelector: nativeSelector,
            customPseudos: customPseudos
        }

    };

    local.check = function(node, cond, idx, nodes, arrayFilte) {
        var tag,
            id,
            classes,
            attributes,
            pseudos,

            i, part, cls, pseudo;

        if (!arrayFilte) {
            if (tag = cond.tag) {
                var nodeName = node.nodeName.toUpperCase();
                if (tag == '*') {
                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
                } else {
                    if (nodeName != (tag || "").toUpperCase()) return false;
                }
            }

            if (id = cond.id) {
                if (node.getAttribute('id') != id) {
                    return false;
                }
            }


            if (classes = cond.classes) {
                for (i = classes.length; i--;) {
                    cls = node.getAttribute('class');
                    if (!(cls && classes[i].regexp.test(cls))) return false;
                }
            }

            if (attributes = cond.attributes) {
                for (i = attributes.length; i--;) {
                    part = attributes[i];
                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;
                }
            }

        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (pseudo = this.pseudos[part.key]) {
                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {
                        if (!pseudo(node, idx, nodes, part.value)) {
                            return false;
                        }
                    }
                } else {
                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    local.match = function(node, selector) {

        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            parsed = selector;
        }

        if (!parsed) {
            return true;
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            simpleExpCounter = 0,
            i,
            currentExpression;
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];
                if (this.check(node, exp)) {
                    return true;
                }
                simpleExpCounter++;
            }
        }

        if (simpleExpCounter == parsed.length) {
            return false;
        }

        var nodes = this.query(document, parsed),
            item;
        for (i = 0; item = nodes[i++];) {
            if (item === node) {
                return true;
            }
        }
        return false;
    };


    local.filterSingle = function(nodes, exp) {
        var matchs = filter.call(nodes, function(node, idx) {
            return local.check(node, exp, idx, nodes, false);
        });

        matchs = filter.call(matchs, function(node, idx) {
            return local.check(node, exp, idx, matchs, true);
        });
        return matchs;
    };

    local.filter = function(nodes, selector) {
        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            return local.filterSingle(nodes, selector);
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            i,
            currentExpression,
            ret = [];
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];

                var matchs = local.filterSingle(nodes, exp);

                ret = langx.uniq(ret.concat(matchs));
            } else {
                throw new Error("not supported selector:" + selector);
            }
        }

        return ret;

    };

    local.combine = function(elm, bit) {
        var op = bit.combinator,
            cond = bit,
            node1,
            nodes = [];

        switch (op) {
            case '>': // direct children
                nodes = children(elm, cond);
                break;
            case '+': // next sibling
                node1 = nextSibling(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '^': // first child
                node1 = firstChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '~': // next siblings
                nodes = nextSiblings(elm, cond);
                break;
            case '++': // next sibling and previous sibling
                var prev = previousSibling(elm, cond, true),
                    next = nextSibling(elm, cond, true);
                if (prev) {
                    nodes.push(prev);
                }
                if (next) {
                    nodes.push(next);
                }
                break;
            case '~~': // next siblings and previous siblings
                nodes = siblings(elm, cond);
                break;
            case '!': // all parent nodes up to document
                nodes = ancestors(elm, cond);
                break;
            case '!>': // direct parent (one level)
                node1 = parent(elm, cond);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!+': // previous sibling
                nodes = previousSibling(elm, cond, true);
                break;
            case '!^': // last child
                node1 = lastChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!~': // previous siblings
                nodes = previousSiblings(elm, cond);
                break;
            default:
                var divided = this.divide(bit);
                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));
                if (divided.customPseudos) {
                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, false)
                        });

                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, true)
                        });
                    }
                }
                break;

        }
        return nodes;
    }

    local.query = function(node, selector, single) {


        var parsed = this.Slick.parse(selector);

        var
            founds = [],
            currentExpression, currentBit,
            expressions = parsed.expressions;

        for (var i = 0;
            (currentExpression = expressions[i]); i++) {
            var currentItems = [node],
                found;
            for (var j = 0;
                (currentBit = currentExpression[j]); j++) {
                found = langx.map(currentItems, function(item, i) {
                    return local.combine(item, currentBit)
                });
                if (found) {
                    currentItems = found;
                }
            }
            if (found) {
                founds = founds.concat(found);
            }
        }

        return founds;
    }

    /*
     * Get the nearest ancestor of the specified element,optional matched by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestor(node, selector, root) {
        var rootIsSelector = root && langx.isString(root);
        while (node = node.parentElement) {
            if (matches(node, selector)) {
                return node;
            }
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
        }
        return null;
    }

    /*
     * Get the ancestors of the specitied element , optionally filtered by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestors(node, selector, root) {
        var ret = [],
            rootIsSelector = root && langx.isString(root);
        while ((node = node.parentElement) && (node.nodeType !== 9)) {
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (langx.isArrayLike(root)) {
                    if (langx.inArray(node,root)>-1) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
            if (!selector || matches(node, selector)) {
              ret.push(node); 
            }
        }

        //if (selector) {
        //    ret = local.filter(ret, selector);
        //}
        return ret;
    }


    /*
     * Returns a element by its ID.
     * @param {string} id
     */
    function byId(id, doc) {
        doc = doc || noder.doc();
        return doc.getElementById(id);
    }

    /*
     * Get the children of the specified element , optionally filtered by a selector.
     * @param {string} node
     * @param {String optionlly} selector
     */
    function children(node, selector) {
        var childNodes = node.childNodes,
            ret = [];
        for (var i = 0; i < childNodes.length; i++) {
            var node = childNodes[i];
            if (node.nodeType == 1) {
                ret.push(node);
            }
        }
        if (selector) {
            ret = local.filter(ret, selector);
        }
        return ret;
    }



    /**
     * Gets nth child of elm, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
     * and non-draggable elements
     * @param  {HTMLElement} elm       The parent element
     * @param  {Number} idx      The index of the child
     * @param  {Object} options       Parent's options
     * @return {HTMLElement}          The child at index idx, or null if not found
     */
    function childAt(elm, idx, options) {
        var currentChild = 0,
            children = elm.children;

        options = langx.mixin({
            ignoreHidden : true,
            excluding : null,
            closesting : null
        },options);

        for(var i=0;i < children.length;i++) {
            var child = children[i];
            if (options.ignoreHidden && styler.css(child) === "none") {
                continue;
            }
            if (options.excluding && options.excluding.includes(child)) {
                continue;
            }

            if (options.closesting &&  !closest(child, options.closesting, elm, false)) {
                continue;
            }

            if (currentChild === idx) {
                return child;
            }
            currentChild++;
        }
        return null;
    }



    //function closest(node, selector) {
    //    while (node && !(matches(node, selector))) {
    //        node = node.parentElement;
    //    }
    //   return node;
    //}


    function closest(/**HTMLElement*/elm, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
        if (elm) {
            ctx = ctx || document;

            do {
                if (
                    selector != null &&
                    (
                        selector[0] === '>' ?
                        elm.parentElement === ctx && matches(elm, selector) :
                        matches(elm, selector)
                    ) ||
                    includeCTX && elm === ctx
                ) {
                    return elm;
                }

                if (elm === ctx) break;
                /* jshint boss:true */
            } while (elm = parent(elm));
        }

        return null;
    }
    /*
     * Get the decendant of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendants(elm, selector) {
        // Selector
        try {
            return slice.call(elm.querySelectorAll(selector));
        } catch (matchError) {
            //console.log(matchError);
        }
        return local.query(elm, selector);
    }

    /*
     * Get the nearest decendent of the specified element,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendant(elm, selector) {
        // Selector
        try {
            return elm.querySelector(selector);
        } catch (matchError) {
            //console.log(matchError);
        }
        var nodes = local.query(elm, selector);
        if (nodes.length > 0) {
            return nodes[0];
        } else {
            return null;
        }
    }

    /*
     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function find(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        if (matches(elm, selector)) {
            return elm;
        } else {
            return descendant(elm, selector);
        }
    }

    /*
     * Get the findAll of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function findAll(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        return descendants(elm, selector);
    }

    /*
     * Get the first child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String} first
     */
    function firstChild(elm, selector, first) {
        var childNodes = elm.childNodes,
            node = childNodes[0];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (first) {
                    break;
                }
            }
            node = node.nextSibling;
        }

        return null;
    }


    /**
     * Returns the index of an element within its parent for a selected set of
     * elements
     * @param  {HTMLElement} el
     * @param  {selector} selector
     * @return {number}
     */
    function index(el, selector) {
        var index = 0;

        if (!el || !el.parentNode) {
            return -1;
        }

        while (el && (el = el.previousElementSibling)) {
            if (langx.isString(selector)) {
                if (matches(el, selector)) {
                    index++;
                }
            } else if (langx.isFunction(selector)) {
                if (selector(el)) {
                    index++;
                }
            }
            index++;
        }

        return index;
    }    

    /*
     * Get the last child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String } last
     */
    function lastChild(elm, selector, last) {
        var childNodes = elm.childNodes,
            node = childNodes[childNodes.length - 1];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (last) {
                    break;
                }
            }
            node = node.previousSibling;
        }

        return null;
    }

    /*
     * Check the specified element against a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function matches(elm, selector) {
        if (!selector || !elm || elm.nodeType !== 1) {
            return false
        }

        if (langx.isString(selector)) {
            try {
                return nativeMatchesSelector.call(elm, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
            } catch (matchError) {
                //console.log(matchError);
            }
            return local.match(elm, selector);
        } else if (langx.isArrayLike(selector)) {
            return langx.inArray(elm, selector) > -1;
        } else if (langx.isPlainObject(selector)) {
            return local.check(elm, selector);
        } else {
            return elm === selector;
        }

    }

    /*
     * Get the nearest next sibing of the specitied element , optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional} adjacent
     */
    function nextSibling(elm, selector, adjacent) {
        var node = elm.nextSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.nextSibling;
        }
        return null;
    }

    /*
     * Get the next siblings of the specified element , optional filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function nextSiblings(elm, selector) {
        var node = elm.nextSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    /*
     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function parent(elm, selector) {
        var node = (elm.host && elm !== document && elm.host.nodeType) ? elm.host : elm.parentElement;

        if (node && (!selector || matches(node, selector))) {
            return node;
        }

        return null;
    }

    /*
     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional } adjacent
     */
    function previousSibling(elm, selector, adjacent) {
        var node = elm.previousSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.previousSibling;
        }
        return null;
    }

    /*
     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function previousSiblings(elm, selector) {
        var node = elm.previousSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.previousSibling;
        }
        return ret;
    }

    /*
     * Selects all sibling elements that follow after the prev element, have the same parent, and match the filtering siblings selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function siblings(elm, selector) {
        var node = elm.parentElement.firstChild,
            ret = [];
        while (node) {
            if (node.nodeType == 1 && node !== elm) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    var finder = function() {
        return finder;
    };

    langx.mixin(finder, {

        ancestor: ancestor,

        ancestors: ancestors,

        byId: byId,

        childAt: childAt,

        children: children,

        closest: closest,

        descendant: descendant,

        descendants: descendants,

        find: find,

        findAll: findAll,

        firstChild: firstChild,

        index,

        lastChild: lastChild,

        matches: matches,

        nextSibling: nextSibling,

        nextSiblings: nextSiblings,

        parent: parent,

        previousSibling,

        previousSiblings,

        pseudos: local.pseudos,

        siblings: siblings
    });

    return skylark.attach("domx.finder", finder);
});
define('skylark-domx-finder/main',[
	"./finder"
],function(finder){

	return finder;
});
define('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });

define('skylark-domx-data/data',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-finder",
    "skylark-domx-noder"
], function(skylark, langx, finder,noder) {
    var map = Array.prototype.map,
        filter = Array.prototype.filter,
        camelCase = langx.camelCase,
        deserializeValue = langx.deserializeValue,

        capitalRE = /([A-Z])/g,
        propMap = {
            'tabindex': 'tabIndex',
            'readonly': 'readOnly',
            'for': 'htmlFor',
            'class': 'className',
            'maxlength': 'maxLength',
            'cellspacing': 'cellSpacing',
            'cellpadding': 'cellPadding',
            'rowspan': 'rowSpan',
            'colspan': 'colSpan',
            'usemap': 'useMap',
            'frameborder': 'frameBorder',
            'contenteditable': 'contentEditable'
        };

    // Strip and collapse whitespace according to HTML spec
    function stripAndCollapse( value ) {
      var tokens = value.match( /[^\x20\t\r\n\f]+/g ) || [];
      return tokens.join( " " );
    }


    var valHooks = {
      option: {
        get: function( elem ) {
          var val = elem.getAttribute( "value" );
          return val != null ?  val :  stripAndCollapse(text( elem ) );
        }
      },
      select: {
        get: function( elem ) {
          var value, option, i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;

          if ( index < 0 ) {
            i = max;

          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for ( ; i < max; i++ ) {
            option = options[ i ];

            if ( option.selected &&

                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                ( !option.parentNode.disabled ||
                  !noder.nodeName( option.parentNode, "optgroup" ) ) ) {

              // Get the specific value for the option
              value = val(option);

              // We don't need an array for one selects
              if ( one ) {
                return value;
              }

              // Multi-Selects return an array
              values.push( value );
            }
          }

          return values;
        },

        set: function( elem, value ) {
          var optionSet, option,
            options = elem.options,
            values = langx.makeArray( value ),
            i = options.length;

          while ( i-- ) {
            option = options[ i ];

            /* eslint-disable no-cond-assign */

            if ( option.selected =
              langx.inArray( valHooks.option.get( option ), values ) > -1
            ) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if ( !optionSet ) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    };


    // Radios and checkboxes getter/setter
    langx.each( [ "radio", "checkbox" ], function() {
      valHooks[ this ] = {
        set: function( elem, value ) {
          if ( langx.isArray( value ) ) {
            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );
          }
        }
      };
    });



    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function setAttribute(elm, name, value) {
        if (value == null) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    function aria(elm, name, value) {
        return this.attr(elm, "aria-" + name, value);
    }

    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function attr(elm, name, value) {
        if (value === undefined) {
            if (typeof name === "object") {
                for (var attrName in name) {
                    attr(elm, attrName, name[attrName]);
                }
                return this;
            } else {
                return elm.getAttribute ? elm.getAttribute(name) : elm[name];
            }
        } else {
            elm.setAttribute ? elm.setAttribute(name, value) : elm[name] = value;
            return this;
        }
    }


    /*
     *  Read all "data-*" attributes from a node
     * @param {Object} elm  
     */

    function _attributeData(elm) {
        var store = {}
        langx.each(elm.attributes || [], function(i, attr) {
            if (attr.name.indexOf('data-') == 0) {
                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);
            }
        })
        return store;
    }

    function _store(elm, confirm) {
        var store = elm["_$_store"];
        if (!store && confirm) {
            store = elm["_$_store"] = _attributeData(elm);
        }
        return store;
    }

    function _getData(elm, name) {
        if (name === undefined) {
            return _store(elm, true);
        } else {
            var store = _store(elm);
            if (store) {
                if (name in store) {
                    return store[name];
                }
                var camelName = camelCase(name);
                if (camelName in store) {
                    return store[camelName];
                }
            }
            var attrName = 'data-' + name.replace(capitalRE, "-$1").toLowerCase()
            var value = attr(elm, attrName);
            if (!langx.isString(value)) {
              value = undefined;
            }
            return value;
        }

    }

    function _setData(elm, name, value) {
        var store = _store(elm, true);
        store[camelCase(name)] = value;
    }


    /*
     * xxx
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function data(elm, name, value) {

        if (value === undefined) {
            if (typeof name === "object") {
                for (var dataAttrName in name) {
                    _setData(elm, dataAttrName, name[dataAttrName]);
                }
                return this;
            } else {
                return _getData(elm, name);
            }
        } else {
            _setData(elm, name, value);
            return this;
        }
    } 
    /*
     * Remove from the element all items that have not yet been run. 
     * @param {Object} elm  
     */

    function cleanData(elm) {
        if (elm["_$_store"]) {
            delete elm["_$_store"];
        }
    }

    /*
     * Remove a previously-stored piece of data. 
     * @param {Object} elm  
     * @param {Array} names
     */
    function removeData(elm, names) {
        if (names) {
            if (langx.isString(names)) {
                names = names.split(/\s+/);
            }
            var store = _store(elm, true);
            names.forEach(function(name) {
                delete store[name];
            });            
        } else {
            cleanData(elm);
        }
        return this;
    }

    /*
     * xxx 
     * @param {Object} elm  
     * @param {Array} names
     */
    function pluck(nodes, property) {
        return map.call(nodes, function(elm) {
            return elm[property];
        });
    }

    /*
     * Get or set the value of an property for the specified element.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function prop(elm, name, value) {
      if (value === undefined) {
          if (typeof name === "object") {
              for (var propName in name) {
                  prop(elm, propName, name[propName]);
              }
              return this;
          } 
      } 


      name = propMap[name] || name;
      if (value === undefined) {
          return elm[name];
      } else {
          elm[name] = value;
          return this;
      }
    }

    /*
     * remove Attributes  
     * @param {Object} elm  
     * @param {String} name
     */
    function removeAttr(elm, name) {
        name.split(' ').forEach(function(attr) {
            setAttribute(elm, attr);
        });
        return this;
    }


    /*
     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.
     * @param {Object} elm  
     * @param {String} name
     */
    function removeProp(elm, name) {
        name.split(' ').forEach(function(prop) {
            delete elm[prop];
        });
        return this;
    }

    /*   
     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  
     * @param {Object} elm  
     * @param {String} txt
     */
    function text(elm, txt) {
        if (txt === undefined) {
            return elm.textContent !==undefined  ? elm.textContent : elm.innerText;
        } else {
            txt = txt == null ? '' : '' + txt ;
            if (elm.textContent !==undefined ) {
              elm.textContent = txt ;
            } else {
              elm.innerText = txt ;
            }
            return this;
        }
    }

    /*   
     * Get the current value of the first element in the set of matched elements or set the value of every matched element.
     * @param {Object} elm  
     * @param {String} value
     */
    function val(elm, value) {
        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];
        if (value === undefined) {
/*
            if (elm.multiple) {
                // select multiple values
                var selectedOptions = filter.call(finder.find(elm, "option"), (function(option) {
                    return option.selected;
                }));
                return pluck(selectedOptions, "value");
            } else {
                if (/input|textarea/i.test(elm.tagName)) {
                  return elm.value;
                }
                return text(elm);
            }
*/

          if ( hooks &&  "get" in hooks &&  ( ret = hooks.get( elm, "value" ) ) !== undefined ) {
            return ret;
          }

          ret = elm.value;

          // Handle most common string cases
          if ( typeof ret === "string" ) {
            return ret.replace( /\r/g, "" );
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;

        } else {
/*          
            if (/input|textarea/i.test(elm.tagName)) {
              elm.value = value;
            } else {
              text(elm,value);
            }
            return this;
*/
          // Treat null/undefined as ""; convert numbers to string
          if ( value == null ) {
            value = "";

          } else if ( typeof value === "number" ) {
            value += "";

          } else if ( langx.isArray( value ) ) {
            value = langx.map( value, function( value1 ) {
              return value1 == null ? "" : value1 + "";
            } );
          }

          // If set returns undefined, fall back to normal setting
          if ( !hooks || !( "set" in hooks ) || hooks.set( elm, value, "value" ) === undefined ) {
            elm.value = value;
          }
        }      
    }


    finder.pseudos.data = function( elem, i, match,dataName ) {
        return !!data( elem, dataName || match[3]);
    };
   

    function datax() {
        return datax;
    }

    langx.mixin(datax, {
        aria: aria,

        attr: attr,

        cleanData: cleanData,

        data: data,

        pluck: pluck,

        prop: prop,

        removeAttr: removeAttr,

        removeData: removeData,

        removeProp: removeProp,

        text: text,

        val: val,

        valHooks : valHooks
    });

    return skylark.attach("domx.data", datax);
});
define('skylark-domx-query/query',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {
    var some = Array.prototype.some,
        push = Array.prototype.push,
        every = Array.prototype.every,
        concat = Array.prototype.concat,
        slice = Array.prototype.slice,
        map = Array.prototype.map,
        filter = Array.prototype.filter,
        forEach = Array.prototype.forEach,
        indexOf = Array.prototype.indexOf,
        sort = Array.prototype.sort,
        isQ;

    var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;

    var funcArg = langx.funcArg,
        isArrayLike = langx.isArrayLike,
        isString = langx.isString,
        uniq = langx.uniq,
        isFunction = langx.isFunction;

    var type = langx.type,
        isArray = langx.isArray,

        isWindow = langx.isWindow,

        isDocument = langx.isDocument,

        isObject = langx.isObject,

        isPlainObject = langx.isPlainObject,

        compact = langx.compact,

        flatten = langx.flatten,

        camelCase = langx.camelCase,

        dasherize = langx.dasherize,
        children = finder.children;

    function wrapper_node_operation(func, context, oldValueFunc) {
        return function(html) {
            var argType, nodes = langx.map(arguments, function(arg) {
                argType = type(arg)
                return argType == "function" || argType == "object" || argType == "array" || arg == null ?
                    arg : noder.createFragment(arg)
            });
            if (nodes.length < 1) {
                return this
            }
            this.each(function(idx) {
                func.apply(context, [this, nodes, idx > 0]);
            });
            return this;
        }
    }

    function wrapper_map(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            var result = langx.map(self, function(elem, idx) {
                return func.apply(context, [elem].concat(params));
            });
            return query(uniq(result));
        }
    }

    function wrapper_selector(func, context, last) {
        return function(selector) {
            var self = this,
                params = slice.call(arguments);
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) {
                if (elem.querySelector) {
                    return func.apply(context, last ? [elem] : [elem, selector]);
                } else {
                    return [];
                }
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }

    function wrapper_selector_until(func, context, last) {
        return function(util, selector) {
            var self = this,
                params = slice.call(arguments);
            //if (selector === undefined) { //TODO : needs confirm?
            //    selector = util;
            //    util = undefined;
            //}
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) { // TODO
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem, util] : [elem, selector, util]);
                //} else {
                //    return [];
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }


    function wrapper_every_act(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            this.each(function(idx,node) {
                func.apply(context, [this].concat(params));
            });
            return self;
        }
    }

    function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {
        return function(arg1) {
            var self = this,
                params = slice.call(arguments);
            forEach.call(self, function(elem, idx) {
                var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));
                func.apply(context, [elem, newArg1].concat(params.slice(1)));
            });
            return self;
        }
    }

    function wrapper_some_chk(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            return some.call(self, function(elem) {
                return func.apply(context, [elem].concat(params));
            });
        }
    }

    function wrapper_name_value(func, context, oldValueFunc) {
        return function(name, value) {
            var self = this;

            if (langx.isPlainObject(name) || langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem,name,newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0], name]);
                }
            }

        }
    }

    function wrapper_value(func, context, oldValueFunc) {
        return function(value) {
            var self = this;

            if (langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem, newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0]]);
                }
            }

        }
    }


    var NodeList = langx.klass({
        klassName: "SkNodeList",
        init: function(selector, context) {
            var self = this,
                match, nodes, node, props;

            if (selector) {
                self.context = context = context || noder.doc();

                if (isString(selector)) {
                    // a html string or a css selector is expected
                    self.selector = selector;

                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        match = [null, selector, null];
                    } else {
                        match = rquickExpr.exec(selector);
                    }

                    if (match) {
                        if (match[1]) {
                            // if selector is html
                            nodes = noder.createFragment(selector);

                            if (langx.isPlainObject(context)) {
                                props = context;
                            }

                        } else {
                            node = finder.byId(match[2], noder.ownerDoc(context));

                            if (node) {
                                // if selector is id
                                nodes = [node];
                            }

                        }
                    } else {
                        // if selector is css selector
                        if (langx.isString(context)) {
                            context = finder.find(context);
                        }

                        nodes = finder.descendants(context, selector);
                    }
                } else {
                    if (!noder.isWindow(selector) && isArrayLike(selector)) {
                        // a dom node array is expected
                        nodes = selector;
                    } else {
                        // a dom node is expected
                        nodes = [selector];
                    }
                    //self.add(selector, false);
                }
            }


            if (nodes) {

                push.apply(self, nodes);

                if (props) {
                    for ( var name  in props ) {
                        // Properties of context are called as methods if possible
                        if ( langx.isFunction( this[ name ] ) ) {
                            this[ name ]( props[ name ] );
                        } else {
                            this.attr( name, props[ name ] );
                        }
                    }
                }
            }

            return self;
        }
    });

    var query = (function() {
        isQ = function(object) {
            return object instanceof NodeList;
        }
        init = function(selector, context) {
            return new NodeList(selector, context);
        }

        var $ = function(selector, context) {
            if (isFunction(selector)) {
                $.ready(function() {
                    selector($);
                });
                return rootQuery;
            } else if (isQ(selector)) {
                return selector;
            } else {
                if (context && isQ(context) && isString(selector)) {
                    return context.find(selector);
                }
                return init(selector, context);
            }
        },rootQuery = $(document);

        $.fn = NodeList.prototype;
        langx.mixin($.fn, {
            // `map` and `slice` in the jQuery API work differently
            // from their array counterparts
            length : 0,

            map: function(fn) {
                return $(uniq(langx.map(this, function(el, i) {
                    return fn.call(el, i, el)
                })));
            },

            slice: function() {
                return $(slice.apply(this, arguments))
            },

            forEach: function() {
                return forEach.apply(this,arguments);
            },

            get: function(idx) {
                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
            },

            indexOf: function() {
                return indexOf.apply(this,arguments);
            },

            sort : function() {
                return sort.apply(this,arguments);
            },

            toArray: function() {
                return slice.call(this);
            },

            size: function() {
                return this.length
            },

            //remove: wrapper_every_act(noder.remove, noder),
            remove : function(selector) {
                if (selector) {
                    return this.find(selector).remove();
                }
                this.each(function(i,node){
                    noder.remove(node);
                });
                return this;
            },

            each: function(callback) {
                langx.each(this, callback);
                return this;
            },

            filter: function(selector) {
                if (isFunction(selector)) return this.not(this.not(selector))
                return $(filter.call(this, function(element) {
                    return finder.matches(element, selector)
                }))
            },

            add: function(selector, context) {
                return $(uniq(this.toArray().concat($(selector, context).toArray())));
            },

            is: function(selector) {
                if (this.length > 0) {
                    var self = this;
                    if (langx.isString(selector)) {
                        return some.call(self,function(elem) {
                            return finder.matches(elem, selector);
                        });
                    } else if (langx.isArrayLike(selector)) {
                       return some.call(self,function(elem) {
                            return langx.inArray(elem, selector) > -1;
                        });
                    } else if (langx.isHtmlNode(selector)) {
                       return some.call(self,function(elem) {
                            return elem ==  selector;
                        });
                    }
                }
                return false;
            },
            
            not: function(selector) {
                var nodes = []
                if (isFunction(selector) && selector.call !== undefined)
                    this.each(function(idx,node) {
                        if (!selector.call(this, idx,node)) nodes.push(this)
                    })
                else {
                    var excludes = typeof selector == 'string' ? this.filter(selector) :
                        (isArrayLike(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
                    this.forEach(function(el) {
                        if (excludes.indexOf(el) < 0) nodes.push(el)
                    })
                }
                return $(nodes)
            },

            has: function(selector) {
                return this.filter(function() {
                    return isObject(selector) ?
                        noder.contains(this, selector) :
                        $(this).find(selector).size()
                })
            },

            eq: function(idx) {
                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
            },

            first: function() {
                return this.eq(0);
            },

            last: function() {
                return this.eq(-1);
            },

            find: wrapper_selector(finder.descendants, finder),

            closest: wrapper_selector(finder.closest, finder),
            /*
                        closest: function(selector, context) {
                            var node = this[0],
                                collection = false
                            if (typeof selector == 'object') collection = $(selector)
                            while (node && !(collection ? collection.indexOf(node) >= 0 : finder.matches(node, selector)))
                                node = node !== context && !isDocument(node) && node.parentNode
                            return $(node)
                        },
            */


            parents: wrapper_selector(finder.ancestors, finder),

            parentsUntil: wrapper_selector_until(finder.ancestors, finder),


            parent: wrapper_selector(finder.parent, finder),

            children: wrapper_selector(finder.children, finder),

            contents: wrapper_map(noder.contents, noder),

            empty: wrapper_every_act(noder.empty, noder),

            html: wrapper_value(noder.html, noder),

            // `pluck` is borrowed from Prototype.js
            pluck: function(property) {
                return langx.map(this, function(el) {
                    return el[property]
                })
            },

            pushStack : function(elms) {
                var ret = $(elms);
                ret.prevObject = this;
                return ret;
            },
            
            replaceWith: function(newContent) {
                return this.before(newContent).remove();
            },

            wrap: function(html) {
                /*
                var func = isFunction(structure)
                if (this[0] && !func)
                    var dom = $(structure).get(0),
                        clone = dom.parentNode || this.length > 1

                return this.each(function(index,node) {
                    $(this).wrapAll(
                        func ? structure.call(this, index,node) :
                        clone ? dom.cloneNode(true) : dom
                    )
                })
                */
                var htmlIsFunction = typeof html === "function";

                return this.each( function( i ) {
                    $( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
                } );                
            },

            wrapAll: function(html) {
                /*
                if (this[0]) {
                    $(this[0]).before(wrappingElement = $(wrappingElement));
                    var children;
                    // drill down to the inmost element
                    while ((children = wrappingElement.children()).length) {
                        wrappingElement = children.first();
                    }
                    $(wrappingElement).append(this);
                }
                return this
                */
                var wrap;

                if ( this[ 0 ] ) {
                    if ( typeof html === "function" ) {
                        html = html.call( this[ 0 ] );
                    }

                    // The elements to wrap the target around
                    wrap = $( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                    if ( this[ 0 ].parentNode ) {
                        wrap.insertBefore( this[ 0 ] );
                    }

                    wrap.map( function() {
                        var elem = this;

                        while ( elem.firstElementChild ) {
                            elem = elem.firstElementChild;
                        }

                        return elem;
                    } ).append( this );
                }

                return this;

            },

            wrapInner: function(html) {
                /*
                var func = isFunction(wrappingElement)
                return this.each(function(index,node) {
                    var self = $(this),
                        contents = self.contents(),
                        dom = func ? wrappingElement.call(this, index,node) : wrappingElement
                    contents.length ? contents.wrapAll(dom) : self.append(dom)
                })
                */
                if ( typeof html === "function" ) {
                    return this.each( function( i ) {
                        $( this ).wrapInner( html.call( this, i ) );
                    } );
                }

                return this.each( function() {
                    var self = $( this ),
                        contents = self.contents();

                    if ( contents.length ) {
                        contents.wrapAll( html );

                    } else {
                        self.append( html );
                    }
                } );

            },

            unwrap: function(selector) {
                /*
                if (this.parent().children().length === 0) {
                    // remove dom without text
                    this.parent(selector).not("body").each(function() {
                        $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));
                    });
                } else {
                    this.parent().each(function() {
                        $(this).replaceWith($(this).children())
                    });
                }
                return this
                */
                this.parent(selector).not("body").each( function() {
                    $(this).replaceWith(this.childNodes);
                });
                return this;

            },

            clone: function() {
                return this.map(function() {
                    return this.cloneNode(true)
                })
            },


            toggle: function(setting) {
                return this.each(function() {
                    var el = $(this);
                    (setting === undefined ? el.css("display") == "none" : setting) ? el.show(): el.hide()
                })
            },

            prev: function(selector) {
                return $(this.pluck('previousElementSibling')).filter(selector || '*')
            },

            prevAll: wrapper_selector(finder.previousSiblings, finder),

            next: function(selector) {
                return $(this.pluck('nextElementSibling')).filter(selector || '*')
            },

            nextAll: wrapper_selector(finder.nextSiblings, finder),

            siblings: wrapper_selector(finder.siblings, finder),

            index: function(elem) {
                if (elem) {
                    return this.indexOf($(elem)[0]);
                } else {
                    return this.parent().children().indexOf(this[0]);
                }
            }
        });

        // for now
        $.fn.detach = $.fn.remove;

        $.fn.hover = function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        };


        var traverseNode = noder.traverse;


        $.fn.after = wrapper_node_operation(noder.after, noder);

        $.fn.prepend = wrapper_node_operation(noder.prepend, noder);

        $.fn.before = wrapper_node_operation(noder.before, noder);

        $.fn.append = wrapper_node_operation(noder.append, noder);


        langx.each( {
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function( name, original ) {
            $.fn[ name ] = function( selector ) {
                var elems,
                    ret = [],
                    insert = $( selector ),
                    last = insert.length - 1,
                    i = 0;

                for ( ; i <= last; i++ ) {
                    elems = i === last ? this : this.clone( true );
                    $( insert[ i ] )[ original ]( elems );

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // .get() because push.apply(_, arraylike) throws on ancient WebKit
                    push.apply( ret, elems.get() );
                }

                return this.pushStack( ret );
            };
        } );

/*
        $.fn.insertAfter = function(html) {
            $(html).after(this);
            return this;
        };

        $.fn.insertBefore = function(html) {
            $(html).before(this);
            return this;
        };

        $.fn.appendTo = function(html) {
            $(html).append(this);
            return this;
        };

        $.fn.prependTo = function(html) {
            $(html).prepend(this);
            return this;
        };

        $.fn.replaceAll = function(selector) {
            $(selector).replaceWith(this);
            return this;
        };
*/
        return $;
    })();

    (function($) {
        $.fn.scrollParent = function( includeHidden ) {
            var position = this.css( "position" ),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter( function() {
                    var parent = $( this );
                    if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                        return false;
                    }
                    return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                        parent.css( "overflow-x" ) );
                } ).eq( 0 );

            return position === "fixed" || !scrollParent.length ?
                $( this[ 0 ].ownerDocument || document ) :
                scrollParent;
        };

    })(query);


    (function($) {
        $.fn.end = function() {
            return this.prevObject || $()
        }

        $.fn.andSelf = function() {
            return this.add(this.prevObject || $())
        }

        $.fn.addBack = function(selector) {
            if (this.prevObject) {
                if (selector) {
                    return this.add(this.prevObject.filter(selector));
                } else {
                    return this.add(this.prevObject);
                }
            } else {
                return this;
            }
        }

        'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings,prev,prevAll,next,nextAll'.split(',').forEach(function(property) {
            var fn = $.fn[property]
            $.fn[property] = function() {
                var ret = fn.apply(this, arguments)
                ret.prevObject = this
                return ret
            }
        })
    })(query);


    (function($) {
        $.fn.query = $.fn.find;

        $.fn.place = function(refNode, position) {
            // summary:
            //      places elements of this node list relative to the first element matched
            //      by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
            // queryOrNode:
            //      may be a string representing any valid CSS3 selector or a DOM node.
            //      In the selector case, only the first matching element will be used
            //      for relative positioning.
            // position:
            //      can be one of:
            //
            //      -   "last" (default)
            //      -   "first"
            //      -   "before"
            //      -   "after"
            //      -   "only"
            //      -   "replace"
            //
            //      or an offset in the childNodes
            if (langx.isString(refNode)) {
                refNode = finder.descendant(refNode);
            } else if (isQ(refNode)) {
                refNode = refNode[0];
            }
            return this.each(function(i, node) {
                switch (position) {
                    case "before":
                        noder.before(refNode, node);
                        break;
                    case "after":
                        noder.after(refNode, node);
                        break;
                    case "replace":
                        noder.replace(refNode, node);
                        break;
                    case "only":
                        noder.empty(refNode);
                        noder.append(refNode, node);
                        break;
                    case "first":
                        noder.prepend(refNode, node);
                        break;
                        // else fallthrough...
                    default: // aka: last
                        noder.append(refNode, node);
                }
            });
        };

        $.fn.addContent = function(content, position) {
            if (content.template) {
                content = langx.substitute(content.template, content);
            }
            return this.append(content);
        };



        $.fn.disableSelection = ( function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.on( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                } );
            };
        } )();

        $.fn.enableSelection = function() {
            return this.off( ".ui-disableSelection" );
        };

        $.fn.reflow = function() {
            return noder.reflow(this[0]);
        };

        $.fn.isBlockNode = function() {
            return noder.isBlockNode(this[0]);
        };
       

    })(query);

    query.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = plugins.instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };


    query.wraps = {
        wrapper_node_operation,
        wrapper_map,
        wrapper_value,
        wrapper_selector,
        wrapper_some_chk,
        wrapper_selector_until,
        wrapper_every_act_firstArgFunc,
        wrapper_every_act,
        wrapper_name_value

    };

    return skylark.attach("domx.query", query);

});
define('skylark-domx-query/main',[
	"./query",
	"skylark-domx-styler"
],function($,styler){

    $.fn.style = $.wraps.wrapper_name_value(styler.css, styler);

    $.fn.css = $.wraps.wrapper_name_value(styler.css, styler);

    //hasClass(name)
    $.fn.hasClass = $.wraps.wrapper_some_chk(styler.hasClass, styler);

    //addClass(name)
    $.fn.addClass = $.wraps.wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className);

    //removeClass(name)
    $.fn.removeClass = $.wraps.wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className);

    //toogleClass(name,when)
    $.fn.toggleClass = $.wraps.wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className);

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };
        

	return $;
});
define('skylark-domx-query', ['skylark-domx-query/main'], function (main) { return main; });

define('skylark-domx-velm/velm',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query"
], function(skylark, langx, noder, finder, $) {
    var map = Array.prototype.map,
        slice = Array.prototype.slice;
    /*
     * VisualElement is a skylark class type wrapping a visule dom node,
     * provides a number of prototype methods and supports chain calls.
     */
    var VisualElement = langx.klass({
        klassName: "VisualElement",

        "_construct": function(node) {
            if (langx.isString(node)) {
                node = langx.trim(node);
                if (node.charAt(0) === "<") {
                    //html
                    node = noder.createFragment(node)[0];
                } else {
                    // id
                    node = document.getElementById(node);
                }
            }
            this._elm = node;
        }
    });

    VisualElement.prototype.$ = VisualElement.prototype.query = function(selector) {
        return $(selector,this._elm);
    };

    VisualElement.prototype.elm = function() {
        return this._elm;
    };

    /*
     * the VisualElement object wrapping document.body
     */
    var root = new VisualElement(document.body),
        velm = function(node) {
            if (node) {
                return new VisualElement(node);
            } else {
                return root;
            }
        };
    /*
     * Extend VisualElement prototype with wrapping the specified methods.
     * @param {ArrayLike} fn
     * @param {Object} context
     */
    function _delegator(fn, context) {
        return function() {
            var self = this,
                elem = self._elm,
                ret = fn.apply(context, [elem].concat(slice.call(arguments)));

            if (ret) {
                if (ret === context) {
                    return self;
                } else {
                    if (ret instanceof HTMLElement) {
                        ret = new VisualElement(ret);
                    } else if (langx.isArrayLike(ret)) {
                        ret = map.call(ret, function(el) {
                            if (el instanceof HTMLElement) {
                                return new VisualElement(el);
                            } else {
                                return el;
                            }
                        })
                    }
                }
            }
            return ret;
        };
    }

    langx.mixin(velm, {
        batch: function(nodes, action, args) {
            nodes.forEach(function(node) {
                var elm = (node instanceof VisualElement) ? node : velm(node);
                elm[action].apply(elm, args);
            });

            return this;
        },

        root: new VisualElement(document.body),

        VisualElement: VisualElement,

        partial: function(name, fn) {
            var props = {};

            props[name] = fn;

            VisualElement.partial(props);
        },

        delegate: function(names, context,matching) {
            var props = {};

            names.forEach(function(name) {
                var matchedName = name;
                if (matching && matching[name]) {
                    matchedName = matching[name];
                } 
                props[name] = _delegator(context[matchedName], context);
            });

            VisualElement.partial(props);
        }
    });

    // from ./finder
    velm.delegate([
        "ancestor",
        "ancestors",
        "children",
        "descendant",
        "find",
        "findAll",
        "firstChild",
        "lastChild",
        "matches",
        "nextSibling",
        "nextSiblings",
        "parent",
        "previousSibling",
        "previousSiblings",
        "siblings"
    ], finder);

    /*
     * find a dom element matched by the specified selector.
     * @param {String} selector
     */
    velm.find = function(selector) {
        if (selector === "body") {
            return this.root;
        } else {
            return this.root.descendant(selector);
        }
    };


    // from ./noder
    velm.delegate([
        "after",
        "append",
        "before",
        "clone",
        "contains",
        "contents",
        "empty",
        "html",
        "isChildOf",
        "isDocument",
        "isInDocument",
        "isWindow",
        "ownerDoc",
        "prepend",
        "remove",
        "removeChild",
        "replace",
        "reverse",
        "throb",
        "traverse",
        "wrapper",
        "wrapperInner",
        "unwrap"
    ], noder);


    return skylark.attach("domx.velm", velm);
});
define('skylark-domx-velm/main',[
	"./velm",
	"skylark-domx-styler"
],function(velm,styler){
    // from ./styler
    velm.delegate([
        "addClass",
        "className",
        "css",
        "hasClass",
        "hide",
        "isInvisible",
        "removeClass",
        "show",
        "toggleClass"
    ], styler);

    // properties

    var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',
    'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',
    'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];

    properties.forEach( function ( property ) {

        var method = property;

        velm.VisualElement.prototype[method ] = function (value) {

            this.css( property, value );

            return this;

        };

    });

	return velm;
});
define('skylark-domx-velm', ['skylark-domx-velm/main'], function (main) { return main; });

define('skylark-domx-data/main',[
    "./data",
    "skylark-domx-velm",
    "skylark-domx-query"    
],function(data,velm,$){
    // from ./data
    velm.delegate([
        "attr",
        "data",
        "prop",
        "removeAttr",
        "removeData",
        "text",
        "val"
    ], data);

    $.fn.text = $.wraps.wrapper_value(data.text, data, data.text);

    $.fn.attr = $.wraps.wrapper_name_value(data.attr, data, data.attr);

    $.fn.removeAttr = $.wraps.wrapper_every_act(data.removeAttr, data);

    $.fn.prop = $.wraps.wrapper_name_value(data.prop, data, data.prop);

    $.fn.removeProp = $.wraps.wrapper_every_act(data.removeProp, data);

    $.fn.data = $.wraps.wrapper_name_value(data.data, data);

    $.fn.removeData = $.wraps.wrapper_every_act(data.removeData);

    $.fn.val = $.wraps.wrapper_value(data.val, data, data.val);


    return data;
});
define('skylark-domx-data', ['skylark-domx-data/main'], function (main) { return main; });

define('skylark-domx-eventer/eventer',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-finder",
    "skylark-domx-noder",
    "skylark-domx-data"
], function(skylark, langx, browser, finder, noder, datax) {
    var mixin = langx.mixin,
        each = langx.each,
        slice = Array.prototype.slice,
        uid = langx.uid,
        ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,
        eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        },
        readyRE = /complete|loaded|interactive/;

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            langx.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = langx.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = langx.returnFalse;
            });
        }
        return event;
    }

    function parse(event) {
        if (event) {
            var segs = ("" + event).split(".");
            return {
                type: segs[0],
                ns: segs.slice(1).sort().join(" ")
            };
        } else {
            return {
                type : null,
                ns : null
            }
        }
    }

    function isHandler(callback) {
        return callback && (langx.isFunction(callback) || langx.isFunction(callback.handleEvent));
    }

    var NativeEventCtors = [
            window["CustomEvent"], // 0 default
            window["CompositionEvent"], // 1
            window["DragEvent"], // 2
            window["Event"], // 3
            window["FocusEvent"], // 4
            window["KeyboardEvent"], // 5
            window["MessageEvent"], // 6
            window["MouseEvent"], // 7
            window["MouseScrollEvent"], // 8
            window["MouseWheelEvent"], // 9
            window["MutationEvent"], // 10
            window["ProgressEvent"], // 11
            window["TextEvent"], // 12
            window["TouchEvent"], // 13
            window["UIEvent"], // 14
            window["WheelEvent"], // 15
            window["ClipboardEvent"] // 16
        ],
        NativeEvents = {
            "compositionstart": 1, // CompositionEvent
            "compositionend": 1, // CompositionEvent
            "compositionupdate": 1, // CompositionEvent

            "beforecopy": 16, // ClipboardEvent
            "beforecut": 16, // ClipboardEvent
            "beforepaste": 16, // ClipboardEvent
            "copy": 16, // ClipboardEvent
            "cut": 16, // ClipboardEvent
            "paste": 16, // ClipboardEvent

            "drag": 2, // DragEvent
            "dragend": 2, // DragEvent
            "dragenter": 2, // DragEvent
            "dragexit": 2, // DragEvent
            "dragleave": 2, // DragEvent
            "dragover": 2, // DragEvent
            "dragstart": 2, // DragEvent
            "drop": 2, // DragEvent

            "abort": 3, // Event
            "change": 3, // Event
            "error": 3, // Event
            "selectionchange": 3, // Event
            "submit": 3, // Event
            "reset": 3, // Event
            'fullscreenchange':3,
            'fullscreenerror':3,

/*
            'disablepictureinpicturechanged':3,
            'ended':3,
            'enterpictureinpicture':3,
            'durationchange':3,
            'leavepictureinpicture':3,
            'loadstart' : 3,
            'loadedmetadata':3,
            'pause' : 3,
            'play':3,
            'posterchange':3,
            'ratechange':3,
            'seeking' : 3,
            'sourceset':3,
            'suspend':3,
            'textdata':3,
            'texttrackchange':3,
            'timeupdate':3,
            'volumechange':3,
            'waiting' : 3,
*/


            "focus": 4, // FocusEvent
            "blur": 4, // FocusEvent
            "focusin": 4, // FocusEvent
            "focusout": 4, // FocusEvent

            "keydown": 5, // KeyboardEvent
            "keypress": 5, // KeyboardEvent
            "keyup": 5, // KeyboardEvent

            "message": 6, // MessageEvent

            "click": 7, // MouseEvent
            "contextmenu": 7, // MouseEvent
            "dblclick": 7, // MouseEvent
            "mousedown": 7, // MouseEvent
            "mouseup": 7, // MouseEvent
            "mousemove": 7, // MouseEvent
            "mouseover": 7, // MouseEvent
            "mouseout": 7, // MouseEvent
            "mouseenter": 7, // MouseEvent
            "mouseleave": 7, // MouseEvent


            "progress" : 11, //ProgressEvent

            "textInput": 12, // TextEvent

            "tap": 13,
            "touchstart": 13, // TouchEvent
            "touchmove": 13, // TouchEvent
            "touchend": 13, // TouchEvent

            "load": 14, // UIEvent
            "resize": 14, // UIEvent
            "select": 14, // UIEvent
            "scroll": 14, // UIEvent
            "unload": 14, // UIEvent,

            "wheel": 15, // WheelEvent



        };

    //create a custom dom event
    var createEvent = (function() {

        function getEventCtor(type) {
            var idx = NativeEvents[type];
            if (!idx) {
                idx = 0;
            }
            return NativeEventCtors[idx];
        }

        return function(type, props) {
            //create a custom dom event

            if (langx.isString(type)) {
                props = props || {};
            } else {
                props = type || {};
                type = props.type || "";
            }
            var parsed = parse(type);
            type = parsed.type;

            props = langx.mixin({
                bubbles: true,
                cancelable: true
            }, props);

            if (parsed.ns) {
                props.namespace = parsed.ns;
            }

            var ctor = getEventCtor(type),
                e = new ctor(type, props);

            langx.safeMixin(e, props);

            return compatible(e);
        };
    })();

    function createProxy(src, props) {
        var key,
            proxy = {
                originalEvent: src
            };
        for (key in src) {
            if (key !== "keyIdentifier" && !ignoreProperties.test(key) && src[key] !== undefined) {
                proxy[key] = src[key];
            }
        }
        if (props) {
            langx.mixin(proxy, props);
        }
        return compatible(proxy, src);
    }

    var
        specialEvents = {},
        focusinSupported = "onfocusin" in window,
        focus = { focus: "focusin", blur: "focusout" },
        hover = { mouseenter: "mouseover", mouseleave: "mouseout" },
        realEvent = function(type) {
            return hover[type] || (focusinSupported && focus[type]) || type;
        },
        handlers = {},
        EventBindings = langx.klass({
            init: function(target, event) {
                this._target = target;
                this._event = event;
                this._bindings = [];
            },

            add: function(fn, options) {
                var bindings = this._bindings,
                    binding = {
                        fn: fn,
                        options: langx.mixin({}, options)
                    };

                bindings.push(binding);

                var self = this;
                if (!self._listener) {
                    self._listener = function(domEvt) {
                        var elm = this,
                            e = createProxy(domEvt),
                            args = domEvt._args,
                            bindings = self._bindings,
                            ns = e.namespace;

                        if (langx.isDefined(args)) {
                            args = [e].concat(args);
                        } else {
                            args = [e];
                        }

                        e.type = self._event; // convert realEvent to listened event

                        langx.each(bindings, function(idx, binding) {
                            var match = elm;
                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                                return false;
                            }
                            var fn = binding.fn,
                                options = binding.options || {},
                                selector = options.selector,
                                one = options.one,
                                data = options.data;

                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {
                                return;
                            }
                            if (selector) {
                                match = finder.closest(e.target, selector);
                                if (match && match !== elm) {
                                    langx.mixin(e, {
                                        currentTarget: match,
                                        liveFired: elm
                                    });
                                } else {
                                    return;
                                }
                            }

                            var originalEvent = self._event;
                            if (originalEvent in hover) {
                                var related = e.relatedTarget;
                                if (related && (related === match || noder.contains(match, related))) {
                                    return;
                                }
                            }

                            if (langx.isDefined(data)) {
                                e.data = data;
                            }

                            if (one) {
                                self.remove(fn, options);
                            }

                            var result ;
                            if (fn.handleEvent) {
                                result = fn.handleEvent.apply(fn,args);
                            } else {
                                if (options.ctx) {
                                    result = fn.apply(options.ctx, args);                                   
                                } else {
                                    result = fn.apply(match, args);                                   
                                }
                            }

                            if (result === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });;
                    };

                    var event = self._event;
                    /*
                                        if (event in hover) {
                                            var l = self._listener;
                                            self._listener = function(e) {
                                                var related = e.relatedTarget;
                                                if (!related || (related !== this && !noder.contains(this, related))) {
                                                    return l.apply(this, arguments);
                                                }
                                            }
                                        }
                    */

                    if (self._target.addEventListener) {
                        self._target.addEventListener(realEvent(event), self._listener, false);
                    } else {
                        console.warn("invalid eventer object", self._target);
                    }
                }

            },
            remove: function(fn, options) {
                options = langx.mixin({}, options);

                function matcherFor(ns) {
                    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
                }
                var matcher;
                if (options.ns) {
                    matcher = matcherFor(options.ns);
                }

                this._bindings = this._bindings.filter(function(binding) {
                    var removing = (!fn || fn === binding.fn) &&
                        (!matcher || matcher.test(binding.options.ns)) &&
                        (!options.selector || options.selector == binding.options.selector);

                    return !removing;
                });
                if (this._bindings.length == 0) {
                    if (this._target.removeEventListener) {
                        this._target.removeEventListener(realEvent(this._event), this._listener, false);
                    }
                    this._listener = null;
                }
            }
        }),
        EventsHandler = langx.klass({
            init: function(elm) {
                this._target = elm;
                this._handler = {};
            },

            // add a event listener
            // selector Optional
            register: function(event, callback, options) {
                // Seperate the event from the namespace
                var parsed = parse(event),
                    event = parsed.type,
                    specialEvent = specialEvents[event],
                    bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);

                var events = this._handler;

                // Check if there is already a handler for this event
                if (events[event] === undefined) {
                    events[event] = new EventBindings(this._target, bindingEvent || event);
                }

                // Register the new callback function
                events[event].add(callback, langx.mixin({
                    ns: parsed.ns
                }, options)); // options:{selector:xxx}
            },

            // remove a event listener
            unregister: function(event, fn, options) {
                // Check for parameter validtiy
                var events = this._handler,
                    parsed = parse(event);
                event = parsed.type;

                if (event) {
                    var listener = events[event];

                    if (listener) {
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                } else {
                    //remove all events
                    for (event in events) {
                        var listener = events[event];
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                }
            }
        }),

        findHandler = function(elm) {
            var id = uid(elm),
                handler = handlers[id];
            if (!handler) {
                handler = handlers[id] = new EventsHandler(elm);
            }
            return handler;
        };


    /*   
     * Remove all event handlers from the specified element.
     * @param {HTMLElement} elm  
     */
    function clear(elm) {
        var handler = findHandler(elm);

        handler.unregister();

        return this;
    }

    var focusedQueue = [],
        focuser = langx.loop(function(){
            for (var i = 0; i<focusedQueue.length; i++) {
                trigger(focusedQueue[i],"focused");
            }
            focusedQueue = [];
        });

    focuser.start();


    function focused(elm) {
        if (!focusedQueue.includes(elm)) {
            focusedQueue.push(elm)
        }
    }

    /*   
     * Remove an event handler for one or more events from the specified element.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {StringOptional } selector
     * @param {Function} callback
     */
    function off(elm, events, selector, callback) {
        var $this = this
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                off(elm, type, selector, fn);
            })
            return $this;
        }

        if (!langx.isString(selector) && !isHandler(callback) && callback !== false) {
            callback = selector;
            selector = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        if (events) events.forEach(function(event) {

            handler.unregister(event, callback, {
                selector: selector,
            });
        });
        return this;
    }

    /*   
     * Attach an event handler function for one or more events to the selected elements.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {StringOptional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     * @param {BooleanOptional} one
     */
    function on(elm, events, selector, data, callback, ctx,one) {

        var autoRemove, delegator;
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                on(elm, type, selector, data, fn, one);
            });
            return this;
        }

        if (!langx.isString(selector) && !isHandler(callback)) {
            one = ctx;
            ctx = callback;
            callback = data;
            data = selector;
            selector = undefined;
        }

        if (isHandler(data)) {
            one = ctx;
            ctx = callback;
            callback = data;
            data = undefined;
        }

        if (langx.isBoolean(ctx)) {
            one = ctx;
            ctx = undefined;
        }
        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        events.forEach(function(event) {
            if (event == "ready") {
                return ready(callback);
            }
            handler.register(event, callback, {
                data: data,
                selector: selector,
                ctx : ctx,
                one: !!one
            });
        });
        return this;
    }

    /*   
     * Attach a handler to an event for the elements. The handler is executed at most once per 
     * @param {HTMLElement} elm  
     * @param {String} event
     * @param {StringOptional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     */
    function one(...args) {
        on(...args, true);

        return this;
    }

    /*   
     * Prevents propagation and clobbers the default action of the passed event. The same as calling event.preventDefault() and event.stopPropagation(). 
     * @param {String} event
     */
    function stop(event) {
        if (window.document.all) {
            event.keyCode = 0;
        }
        if (event.preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
        return this;
    }
    /*   
     * Execute all handlers and behaviors attached to the matched elements for the given event  
     * @param {String} evented
     * @param {String} type
     * @param {Array or PlainObject } args
     */
    function trigger(evented, type, args) {
        var e;
        if (type instanceof Event) {
            e = type;
        } else {
            e = createEvent(type, args);
        }
        e._args = args;

        var fn = (evented.dispatchEvent || evented.trigger);
        if (fn) {
            fn.call(evented, e);
        } else {
            console.warn("The evented parameter is not a eventable object");
        }

        return this;
    }
    /*   
     * Specify a function to execute when the DOM is fully loaded.  
     * @param {Function} callback
     */
    function ready(callback) {
        // need to check if document.body exists for IE as that browser reports
        // document ready when it hasn't yet created the body elm
        if (readyRE.test(document.readyState) && document.body) {
            langx.defer(callback);
        } else {
            document.addEventListener('DOMContentLoaded', callback, false);
        }

        return this;
    }

    var resizedQueue = [],
        resizer = langx.loop(function(){
            for (var i = 0; i<resizedQueue.length; i++) {
                trigger(resizedQueue[i],"resized");
            }
            resizedQueue = [];
        });

    resizer.start();


    function resized(elm) {
        if (!resizedQueue.includes(elm)) {
            resizedQueue.push(elm)
        }
    }


    var keyCodeLookup = {
        "backspace": 8,
        "comma": 188,
        "delete": 46,
        "down": 40,
        "end": 35,
        "enter": 13,
        "escape": 27,
        "home": 36,
        "left": 37,
        "page_down": 34,
        "page_up": 33,
        "period": 190,
        "right": 39,
        "space": 32,
        "tab": 9,
        "up": 38
    };
    //example:
    //shortcuts(elm).add("CTRL+ALT+SHIFT+X",function(){console.log("test!")});
    function shortcuts(elm) {

        var registry = datax.data(elm, "shortcuts");
        if (!registry) {
            registry = {};
            datax.data(elm, "shortcuts", registry);
            var run = function(shortcut, event) {
                var n = event.metaKey || event.ctrlKey;
                if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {
                    if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {
                        event.preventDefault();
                        if ("keydown" == event.type) {
                            shortcut.fn(event);
                        }
                        return true;
                    }
                }
            };
            on(elm, "keyup keypress keydown", function(event) {
                if (!(/INPUT|TEXTAREA/.test(event.target.nodeName))) {
                    for (var key in registry) {
                        run(registry[key], event);
                    }
                }
            });

        }

        return {
            add: function(pattern, fn) {
                var shortcutKeys;
                if (pattern.indexOf(",") > -1) {
                    shortcutKeys = pattern.toLowerCase().split(",");
                } else {
                    shortcutKeys = pattern.toLowerCase().split(" ");
                }
                shortcutKeys.forEach(function(shortcutKey) {
                    var setting = {
                        fn: fn,
                        alt: false,
                        ctrl: false,
                        shift: false
                    };
                    shortcutKey.split("+").forEach(function(key) {
                        switch (key) {
                            case "alt":
                            case "ctrl":
                            case "shift":
                                setting[key] = true;
                                break;
                            default:
                                setting.charCode = key.charCodeAt(0);
                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);
                        }
                    });
                    var regKey = (setting.ctrl ? "ctrl" : "") + "," + (setting.alt ? "alt" : "") + "," + (setting.shift ? "shift" : "") + "," + setting.keyCode;
                    registry[regKey] = setting;
                })
            }

        };

    }

    if (browser.support.transition) {
        specialEvents.transitionEnd = {
//          handle: function (e) {
//            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
//          },
          bindType: browser.support.transition.end,
          delegateType: browser.support.transition.end
        }        
    }

    function isNativeEvent(events) {
        if (langx.isString(events)) {
            return !!NativeEvents[events];
        } else if (langx.isArray(events)) {
            for (var i=0; i<events.length; i++) {
                if (NativeEvents[events]) {
                    return false;
                }
            }
            return events.length > 0;
        }
    }


    function eventer() {
        return eventer;
    }

    langx.mixin(eventer, {
        NativeEvents : NativeEvents,
        
        clear,
        
        create: createEvent,

        focused,

        keys: keyCodeLookup,

        isNativeEvent,

        off: off,

        on: on,

        one: one,

        proxy: createProxy,

        ready: ready,

        resized,
        
        shortcuts: shortcuts,

        special: specialEvents,

        stop: stop,

        trigger: trigger

    });

    each(NativeEvents,function(name){
        eventer[name] = function(elm,selector,data,callback) {
            if (arguments.length>1) {
                return this.on(elm,name,selector,data,callback);
            } else {
                if (name == "focus") {
                    if (elm.focus) {
                        elm.focus();
                    }
                } else if (name == "blur") {
                    if (elm.blur) {
                        elm.blur();
                    }
                } else if (name == "click") {
                    if (elm.click) {
                        elm.click();
                    }
                } else {
                    this.trigger(elm,name);
                }

                return this;
            }
        };
    });

    return skylark.attach("domx.eventer",eventer);
});
define('skylark-domx-eventer/main',[
    "skylark-langx/langx",
    "./eventer",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,eventer,velm,$){

    var delegateMethodNames = [
        "off",
        "on",
        "one",
        "trigger"
    ];

    langx.each(eventer.NativeEvents,function(name){
        delegateMethodNames.push(name);
    });

    // from ./eventer
    velm.delegate(delegateMethodNames, eventer);

    langx.each(delegateMethodNames,function(i,name){
        $.fn[name] = $.wraps.wrapper_every_act(eventer[name],eventer);
    });


    /*
    $.fn.on = $.wraps.wrapper_every_act(eventer.on, eventer);

    $.fn.off = $.wraps.wrapper_every_act(eventer.off, eventer);

    $.fn.trigger = $.wraps.wrapper_every_act(eventer.trigger, eventer);

    ('focusin focusout focus blur load resize scroll unload click dblclick ' +
        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
        'change select keydown keypress keyup error transitionEnd').split(' ').forEach(function(event) {
        $.fn[event] = $.wraps.wrapper_every_act(eventer[event],eventer);
    });

    $.fn.one = function(event, selector, data, callback) {
        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = null;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = null;
        }

        return this.on(event, selector, data, callback, 1)
    }; 
    */

    $.ready = eventer.ready;

    return eventer;
});
define('skylark-domx-eventer', ['skylark-domx-eventer/main'], function (main) { return main; });

define('skylark-slax-runtime/slax',[
	"skylark-langx-ns",
	"skylark-langx-objects",
	"skylark-langx-hoster",
	"skylark-langx-async",
	"skylark-net-http/Xhr",
	"skylark-domx-eventer"
],function(skylark, objects, hoster, async, Xhr, eventer){

    var _config = {


    },
    _rootUrl = "",  //The root url of slax system
    _baseUrl = "";  //the base url of slax app



    var slax = {
        prepare : function(config) {
            var p,slaxRoot,slaxApp;
            if (!config) {
                config = hoster.global.slaxConfig;
            }
            if (!config) {
                var scripts = document.getElementsByTagName("script"),
                    i = 0,
                    script, slaxDir, src, match;
                while(i < scripts.length){
                    script = scripts[i++];
                    if((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)skylark-slax-runtime([0-9A-Za-z\-]*)\.js(\W|$)/i))){
                        // sniff slaxDir and baseUrl
                        slaxDir = match[3] || "";

                        // sniff configuration on attribute in script element
                        if(src = script.getAttribute("data-slax-config") ){
                            config = eval("({ " + src + " })");
                        } else {
                            slaxRoot = script.getAttribute("data-slax-root");
                            if (slaxRoot == undefined) {
                                slaxRoot = slaxDir;
                            }
                            slaxApp = script.getAttribute("data-slax-app");
                        }


                        break;
                    }
                }
            }

            if (config) {
                objects.mixin(_config,config);
                p = async.Deferred.resolve()
            } else {
                var d = new async.Deferred(),
                    p = d.promise;
                Xhr.get(slaxRoot + "/slax-config.json").then(function(config){
                    if (slaxApp) {
                        var slaxAppPath;
                        for (var i=0; i<config.apps.length;i++) {
                            if (config.apps[i].name == slaxApp) {
                                slaxAppPath = slaxRoot + config.apps[i].dir;
                            } 
                        }
                        Xhr.get(slaxAppPath+"/spa.json").then(function(config){
                            objects.mixin(_config,config);
                            d.resolve();
                        });
                    } else {
                        objects.mixin(_config,config);
                        d.resolve();

                    }
                });

            }

            return p;
        },

        start : function() {
            var cfg = _config;

            //if (cfg.contextPath) {
            //  _cfg.baseUrl = cfg.contextPath;
            //}

            if (cfg.runtime) {
                require.config(cfg.runtime);
            }

            if (cfg.boot) {
                let bootFunc = window[cfg.boot];
                bootFunc(cfg);
            } else {
                var initApp = function(spa, _cfg) {
                    _cfg = _cfg || cfg;
      
                    var app = spa(_cfg);

                    hoster.global.go =  function(path, force) {
                        app.go(path, force);
                    };

                    app.prepare().then(function(){
                        app.run();
                    });
                };
                if(cfg.spaModule) {
                    require([cfg.spaModule], function(spa) {
                        if(spa._start) {
                            spa._start().then(function(_cfg){
                                initApp(spa, _cfg);
                            });
                        } else {
                            initApp(spa);
                        }
                    });
                } else {
                    initApp(skylark.spa);
                }                
            }
        }
    };

    define("slax",[],function(){
        return slax;
    });

    return skylark.attach("slax",slax);

});
define('skylark-io-caches/caches',[
	"skylark-langx-ns"
],function(skylark){
	"use strict";
	let caches = skylark.attach("io.caches");
	caches.storages =  caches.storages || {};
	return caches;
});
define('skylark-io-caches/clipboard',[
	"./caches"
],function(caches){
	
});
define('skylark-io-caches/cookie',[
    "skylark-langx-types",
    "skylark-langx-objects/mixin",
    "skylark-langx-datetimes",
    "./caches"
], function(types,mixin,datetimes,caches) {
	"use strict";

    function cookie() {
        return cookie;
    }

    mixin(cookie, {
		get : function(name) {
		    if (!sKey || !this.has(name)) { return null; }
				return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(name).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"),"$1"));

		},

		has : function(name) {
			return (new RegExp("(?:^|;\\s*)" + escape(name).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
		},


		list : function() {
		    var values = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
		    for (var i = 0; i < values.length; i++) { 
		    	values[i] = unescape(values[i]); 
		    }
		    return values;
		},

		remove : function(name,path) {
		    if (!name || !this.has(name)) { 
		    	return; 
		   	}
		    document.cookie = escape(name) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (path ? "; path=" + path : "");
		},

		set: function (name, value, expires, path, domain, secure) {
		    if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) { return; }

			var type = types.type(expires);
			if (type === 'number') {
				var date = Date.now();
				date.setTime(date.getTime() + (expire * 24 * 60 * 60 * 1000));
				expires = date;
			} else if (type === 'string') {
				expires = new Date(Date.now() + datetimes.parseMilliSeconds(expires));
			}

		    document.cookie = escape(name) + "=" + escape(value) + (expires? "; domain=" + expires.toGMTString()  : "") + (domain ? "; domain=" + domain : "") + (path ? "; path=" + path : "") + (secure ? "; secure" : "");
		  }	
    });


    return caches.cookie = cookie;

});


define('skylark-langx-events/Emitter',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./event",
  "./listener"
],function(types,objects,arrays,klass,events,Event,Listener){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    
    var queues  = new Map();


    var Emitter = Listener.inherit({
        _prepareArgs : function(e,args) {
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            return args;
        },

        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (!callback ) {
                throw new Error("No callback function");
            } else if (!isFunction(callback)) {
                throw new Error("The callback  is not afunction");
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new Event(e); //new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);

            args = this._prepareArgs(e,args);

            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                        return this;
                    }
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }

                    if (listener.data) {
                        e.data = mixin({}, listener.data, e.data);
                    }
                    if (args.length == 2 && isPlainObject(args[1])) {
                        e.data = e.data || {};
                        mixin(e.data,args[1]);
                    }

                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        queueEmit : function (event) {
            const type = event.type || event;
            let map = queues.get(this);
            if (!map) {
                map = new Map();
                queues.set(this, map);
            }
            const oldTimeout = map.get(type);
            map.delete(type);
            window.clearTimeout(oldTimeout);
            const timeout = window.setTimeout(() => {
                if (map.size === 0) {
                    map = null;
                    queues.delete(this);
                }
                this.trigger(event);
            }, 0);
            map.set(type, timeout);
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        off: function(events, callback) {
            if (!events) {
              this._hub = null;
              return;
            }
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },

        trigger  : function() {
            return this.emit.apply(this,arguments);
        },

        queueTrigger : function (event) {
            return this.queueEmit.apply(this,arguments);
        }

    });


    return events.Emitter = Emitter;

});
define('skylark-langx-async/Deferred',[
    "skylark-langx-arrays",
	"skylark-langx-funcs",
    "skylark-langx-objects"
],function(arrays,funcs,objects){
    "use strict";

    var slice = Array.prototype.slice,
        proxy = funcs.proxy,
        makeArray = arrays.makeArray,
        result = objects.result,
        mixin = objects.mixin;

    mixin(Promise.prototype,{
        always: function(handler) {
            //this.done(handler);
            //this.fail(handler);
            this.then(handler,handler);
            return this;
        },
        done : function() {
            for (var i = 0;i<arguments.length;i++) {
                this.then(arguments[i]);
            }
            return this;
        },
        fail : function(handler) { 
            //return mixin(Promise.prototype.catch.call(this,handler),added);
            //return this.then(null,handler);
            this.catch(handler);
            return this;
         }
    });


    var Deferred = function() {
        var self = this,
            p = this.promise = makePromise2(new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            }));

        //wrapPromise(p,self);

        //this[PGLISTENERS] = [];
        //this[PGNOTIFIES] = [];

        //this.resolve = Deferred.prototype.resolve.bind(this);
        //this.reject = Deferred.prototype.reject.bind(this);
        //this.progress = Deferred.prototype.progress.bind(this);

    };

   
    function makePromise2(promise) {
        // Don't modify any promise that has been already modified.
        if (promise.isResolved) return promise;

        // Set initial state
        var isPending = true;
        var isRejected = false;
        var isResolved = false;

        // Observe the promise, saving the fulfillment in a closure scope.
        var result = promise.then(
            function(v) {
                isResolved = true;
                isPending = false;
                return v; 
            }, 
            function(e) {
                isRejected = true;
                isPending = false;
                throw e; 
            }
        );

        result.isResolved = function() { return isResolved; };
        result.isPending = function() { return isPending; };
        result.isRejected = function() { return isRejected; };

        result.state = function() {
            if (isResolved) {
                return 'resolved';
            }
            if (isRejected) {
                return 'rejected';
            }
            return 'pending';
        };

        var notified = [],
            listeners = [];

          
        result.then = function(onResolved,onRejected,onProgress) {
            if (onProgress) {
                this.progress(onProgress);
            }
            return makePromise2(Promise.prototype.then.call(this,
                onResolved && function(args) {
                    if (args && args.__ctx__ !== undefined) {
                        return onResolved.apply(args.__ctx__,args);
                    } else {
                        return onResolved(args);
                    }
                },
                onRejected && function(args){
                    if (args && args.__ctx__ !== undefined) {
                        return onRejected.apply(args.__ctx__,args);
                    } else {
                        return onRejected(args);
                    }
                }
            ));
        };

        result.progress = function(handler) {
            notified.forEach(function (value) {
                handler(value);
            });
            listeners.push(handler);
            return this;
        };

        result.pipe = result.then;

        result.notify = function(value) {
            try {
                notified.push(value);

                return listeners.forEach(function (listener) {
                    return listener(value);
                });
            } catch (error) {
            this.reject(error);
            }
            return this;
        };

        return result;
    }

 
    Deferred.prototype.resolve = function(value) {
        var args = slice.call(arguments);
        return this.resolveWith(null,args);
    };

    Deferred.prototype.resolveWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._resolve(args);
        this._resolved = true;
        return this;
    };

    Deferred.prototype.notify = function(value) {
        var p = result(this,"promise");
        p.notify(value);
        return this;
    };

    Deferred.prototype.reject = function(reason) {
        var args = slice.call(arguments);
        return this.rejectWith(null,args);
    };

    Deferred.prototype.rejectWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._reject(args);
        this._rejected = true;
        return this;
    };

    Deferred.prototype.isResolved = function() {
        var p = result(this,"promise");
        return p.isResolved();
    };

    Deferred.prototype.isRejected = function() {
        var p = result(this,"promise");
        return p.isRejected();
    };

    Deferred.prototype.state = function() {
        var p = result(this,"promise");
        return p.state();
    };

    Deferred.prototype.then = function(callback, errback, progback) {
        var p = result(this,"promise");
        return p.then(callback, errback, progback);
    };

    Deferred.prototype.progress = function(progback){
        var p = result(this,"promise");
        return p.progress(progback);
    };
   
    Deferred.prototype.catch = function(errback) {
        var p = result(this,"promise");
        return p.catch(errback);
    };


    Deferred.prototype.always  = function() {
        var p = result(this,"promise");
        p.always.apply(p,arguments);
        return this;
    };

    Deferred.prototype.done  = function() {
        var p = result(this,"promise");
        p.done.apply(p,arguments);
        return this;
    };

    Deferred.prototype.fail = function(errback) {
        var p = result(this,"promise");
        p.fail(errback);
        return this;
    };


    Deferred.all = function(array) {
        //return wrapPromise(Promise.all(array));
        var d = new Deferred();
        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));
        return result(d,"promise");
    };

    Deferred.first = function(array) {
        return makePromise2(Promise.race(array));
    };


    Deferred.when = function(valueOrPromise, callback, errback, progback) {
        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

        if (!receivedPromise) {
            if (arguments.length > 1) {
                return callback ? callback(valueOrPromise) : valueOrPromise;
            } else {
                return new Deferred().resolve(valueOrPromise);
            }
        } else if (!nativePromise) {
            var deferred = new Deferred(valueOrPromise.cancel);
            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);
            valueOrPromise = deferred.promise;
        }

        if (callback || errback || progback) {
            return valueOrPromise.then(callback, errback, progback);
        }
        return valueOrPromise;
    };

    Deferred.reject = function(err) {
        var d = new Deferred();
        d.reject(err);
        return d.promise;
    };

    Deferred.resolve = function(data) {
        var d = new Deferred();
        d.resolve.apply(d,arguments);
        return d.promise;
    };

    Deferred.immediate = Deferred.resolve;


    Deferred.promise = function(callback) {
        var d = new Deferred();

        callback(d.resolve.bind(d),d.reject.bind(d),d.progress.bind(d));

        return d.promise;
    };

    return Deferred;
});
define('skylark-io-caches/local-file-system',[
    "skylark-langx-objects/mixin",
    "skylark-langx-events/Emitter",
    "skylark-langx-async/Deferred",
    "./caches"
], function(mixin,Emitter,Deferred,caches) {
	"use strict";

	var requestFileSystem =  window.requestFileSystem || window.webkitRequestFileSystem,
		resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL,
     	BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.BlobBuilder;


	function errorHandler(e) {
	  var msg = '';

	  switch (e.code) {
	    case FileError.QUOTA_EXCEEDED_ERR:
	      msg = 'QUOTA_EXCEEDED_ERR';
	      break;
	    case FileError.NOT_FOUND_ERR:
	      msg = 'NOT_FOUND_ERR';
	      break;
	    case FileError.SECURITY_ERR:
	      msg = 'SECURITY_ERR';
	      break;
	    case FileError.INVALID_MODIFICATION_ERR:
	      msg = 'INVALID_MODIFICATION_ERR';
	      break;
	    case FileError.INVALID_STATE_ERR:
	      msg = 'INVALID_STATE_ERR';
	      break;
	    default:
	      msg = 'Unknown Error';
	      break;
	  };

	  return msg;
	}
	
	var LocalFileSystem = Emitter.inherit({
		_fs : null,
		_isPersisted : true,
		_cwd : null,

		init:	function (fs) {
			this._fs = fs;
			this._cwd = fs.root;
		},
			

		readfileAsArrayBuffer :  function (path,callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.file(function (file) {
		        var reader = new FileReader();
		        reader.onloadend = function () {
		          callback(null, this.result);
		        };
		        reader.readAsArrayBuffer(file);
		      }, errback);
		    }, errback);
		},

		readfileAsDataURL :  function (path,callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.file(function (file) {
		        var reader = new FileReader();
		        reader.onloadend = function () {
		          callback(null, this.result);
		        };
		        reader.readAsDataURL(file);
		      }, errback);
		    }, errback);
		},

		readfileAsText :  function (path,callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.file(function (file) {
		        var reader = new FileReader();
		        reader.onloadend = function () {
		          callback(null, this.result);
		        };
		        reader.readAsText(file);
		      }, errback);
		    }, errback);
		},

		writefile : function (path, contents, callback,errback) {
		    var self = this,
		    	folders = path.split('/');
		    folders = folders.slice(0, folders.length - 1);

		    this.mkdir(folders.join('/'),function(){
			    self._cwd.getFile(path, {create: true}, function (fileEntry) {
			      fileEntry.createWriter(function (fileWriter) {
			        var truncated = false;
			        fileWriter.onwriteend = function () {
			          if (!truncated) {
			            truncated = true;
			            this.truncate(this.position);
			            return;
			          }
			          callback && callback();
			        };
			        fileWriter.onerror = errback;
			        // TODO: find a way to write as binary too
			        var blob = contents;
			        if (!blob instanceof Blob) {
			        	blob = new Blob([contents], {type: 'text/plain'});
			        } 
			        fileWriter.write(blob);
			      }, errback);
			    }, errback);

		    });
		},

		rmfile : function (path, callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.remove(function () {
		        callback();
		      }, errback);
		    }, errback);
		},

		readdir : function (path, callback,errback) {
		    this._cwd.getDirectory(path, {}, function (dirEntry) {
		      var dirReader = dirEntry.createReader();
		      var entries = [];
		      readEntries();
		      function readEntries() {
		        dirReader.readEntries(function (results) {
		          if (!results.length) {
		            callback(null, entries);
		          }
		          else {
		            entries = entries.concat(
		            	Array.prototype.slice.call(results).map(
		            		function (entry) {
		              			return entry.name + (entry.isDirectory ? "/" : "");
		            		}
		            	)
		            );
		            readEntries();
		          }
		        }, errback);
		      }
		    }, errback);
		},

		mkdir : function (path, callback,errback) {
		    var folderParts = path.split('/');

		    var createDir = function(rootDir, folders) {
		      // Throw out './' or '/' and move on. Prevents: '/foo/.//bar'.
		      if (folders[0] == '.' || folders[0] == '') {
		        folders = folders.slice(1);
		      }

		      if (folders.length ==0) {
		      	callback(rootDir);
		      	return;
		      }
		      rootDir.getDirectory(folders[0], {create: true, exclusive: false},
		        function (dirEntry) {
		          if (dirEntry.isDirectory) { // TODO: check shouldn't be necessary.
		            // Recursively add the new subfolder if we have more to create and
		            // There was more than one folder to create.
		            if (folders.length && folderParts.length != 1) {
		              createDir(dirEntry, folders.slice(1));
		            } else {
		              // Return the last directory that was created.
		              if (callback) callback(dirEntry);
		            }
		          } else {
		            var e = new Error(path + ' is not a directory');
		            if (errback) {
		              errback(e);
		            } else {
		              throw e;
		            }
		          }
		        },
		        function(e) {
		            if (errback) {
		              errback(e);
		            } else {
		              throw e;
		            }
		        }
		      );
		    };

		    createDir(this._cwd, folderParts);

		},

		rmdir : function (path, callback,errback) {
		    this._cwd.getDirectory(path, {}, function (dirEntry) {
		      dirEntry.removeRecursively(function () {
		        callback();
		      }, errback);
		    }, errback);
		  },

		copy : function (src, dest, callback) {
		    // TODO: make sure works for cases where dest includes and excludes file name.
		    this._cwd.getFile(src, {}, function(fileEntry) {
		      cwd.getDirectory(dest, {}, function(dirEntry) {
		        fileEntry.copyTo(dirEntry, function () {
		          callback();
		        }, callback);
		      }, callback);
		    }, callback);
		},

		move : function(src, dest, callback) {
		    // TODO: handle more cases like file renames and moving/renaming directories
		    this._cwd.getFile(src, {}, function(fileEntry) {
		      cwd.getDirectory(dest, {}, function(dirEntry) {
		        fileEntry.moveTo(dirEntry, function () {
		          callback();
		        }, callback);
		      }, callback);
		    }, callback);
		},

		chdir : function (path, callback) {
		    this._cwd.getDirectory(path, {}, function (dirEntry) {
		      cwd = dirEntry;
		      if (fs.onchdir) {
		        fs.onchdir(cwd.fullPath);
		      }
		      callback();
		    }, callback);
		},

		importFromHost : function(files) {
		    // Duplicate each file the user selected to the app's fs.
		    var deferred = new Deferred();
		    for (var i = 0, file; file = files[i]; ++i) {
		        (function(f) {
			        cwd.getFile(file.name, {create: true, exclusive: true}, function(fileEntry) {
			          fileEntry.createWriter(function(fileWriter) {
			            fileWriter.write(f); // Note: write() can take a File or Blob object.
			          }, errorHandler);
			        }, errorHandler);
		     	})(file);
 	   	 	}
  		    return deferred.promise;
		  },

		  exportToHost : function() {

		  }
	
	});
	


    function localfs() {
        return localfs;
    }

    mixin(LocalFileSystem, {
        isSupported : function() {
            return !!requestFileSystem;
        },
        request : function(size,isPersisted){
        	size = size || 1024 * 1024 * 10;
        	var typ = isPersisted ? PERSISTENT : TEMPORARY,
        		d = new Deferred();
            requestFileSystem(typ, size, function(_fs) {
                var fs = new LocalFileSystem(_fs,!!isPersisted);
                d.resolve(fs);
            }, function(e) {
            	d.reject(e);
            });

            return d.promise;
        }
    });
    
    caches.requestLocalFileSystem = LocalFileSystem.request;

	return caches.LocalFileSystem = LocalFileSystem;
});
define('skylark-io-caches/storages/local',[
    "skylark-langx-objects/mixin",
    "skylark-langx-strings",
    "../caches"
], function(mixin,strings,caches) {
    "use strict";


    var storage  = null;

    try {
        storage = window["localStorage"];
    } catch (e){

    }

    function localStorage() {
        return localStorage;
    }

    mixin(localStorage, {
        isSupported : function() {
            return !!storage;
        },

        set : function(key, val) {
            if (val === undefined) { 
                return this.remove(key) 
            }
            storage.setItem(key, strings.serializeValue(val));
            return val
        },

        get : function(key, defaultVal) {
            var val = strings.deserializeValue(storage.getItem(key))
            return (val === undefined ? defaultVal : val)
        },

        remove : function(key) { 
            storage.removeItem(key) 
        },

        clear : function() { 
            storage.clear() 
        },

        list : function() {
            var vaules = {}
            for (var i=0; i<storage.length; i++) {
                vaules[key] = storage.key(i)
            }

            return values;
        }
    });

    return  caches.storages.local = localStorage;

});


define('skylark-io-caches/storages/session',[
    "skylark-langx-objects/mixin",
    "skylark-langx-strings",
    "../caches"
], function(mixin,strings,caches) {
    "use strict";

    var storage  = null;

    try {
        storage = window["sessiionStorage"];
    } catch (e){

    }

    function sessiionStorage() {
        return sessiionStorage;
    }

    mixin(sessiionStorage, {
        isSupported : function() {
            return !!storage;
        },

        set : function(key, val) {
            if (val === undefined) { 
                return this.remove(key) 
            }
            storage.setItem(key, strings.serializeValue(val));
            return val
        },

        get : function(key, defaultVal) {
            var val = strings.deserializeValue(storage.getItem(key))
            return (val === undefined ? defaultVal : val)
        },

        remove : function(key) { 
            storage.removeItem(key) 
        },

        clear : function() { 
            storage.clear() 
        },

        list : function() {
            var vaules = {}
            for (var i=0; i<storage.length; i++) {
                vaules[key] = storage.key(i)
            }

            return values;
        }
    });

    return  caches.storages.session = sessionStorage;

});


define('skylark-io-caches/main',[
	"./caches",
	"./clipboard",
	"./cookie",
	"./local-file-system",
	"./storages/local",
	"./storages/session"
],function(caches) {
	"use strict";
	
	return caches;
});
define('skylark-io-caches', ['skylark-io-caches/main'], function (main) { return main; });

define('skylark-slax-runtime/caches',[
	"./slax",
	"skylark-io-caches"
],function(slax,caches){
	//local
	//page
	//session
	return slax.caches = caches;
});
define('skylark-langx-logging/logging',[
  "skylark-langx-ns"
],function(skylark){


    return skylark.attach("langx.logging",{

    });
});
define('skylark-langx-logging/levels',[
	"./logging"
],function(logging){
    return logging.levels = {
	    all: 'debug|info|warn|error',
	    off: '',
	    debug: 'debug|info|warn|error',
	    info: 'info|warn|error',
	    warn: 'warn|error',
	    error: 'error',
	    DEFAULT: "info"
    };	
});
define('skylark-langx-logging/Logger',[
    "skylark-langx-objects",
    "skylark-langx-constructs/klass",
    "./logging",
    "./levels"
],function(objects,klass,logging,levels){
    'use strict';

    let history = [];
 
    const LogByTypeFactory = (name) => (type, level, args) => {
        const lvl = levels[level];
        const lvlRegExp = new RegExp(`^(${ lvl })$`);
        if (type !== 'debug') {
            args.unshift(type.toUpperCase() + ':');
        }
        args.unshift(name + ':');
        if (history) {
            history.push([].concat(args));
            const splice = history.length - 1000;
            history.splice(0, splice > 0 ? splice : 0);
        }
        if (!window.console) {
            return;
        }
        let fn = window.console[type];
        if (!fn && type === 'debug') {
            fn = window.console.info || window.console.log;
        }
        if (!fn || !lvl || !lvlRegExp.test(type)) {
            return;
        }
        fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);
    };

    var Logger = klass({
        _level : "info",

        _construct : function(name) {
            this.name = name;

            this._logByType = LogByTypeFactory(name);
        },

        level : function(lvl) {
            if (typeof lvl === 'string') {
                if (!levels.hasOwnProperty(lvl)) {
                    throw new Error(`"${ lvl }" in not a valid log level`);
                }
                this._level = lvl;
            }
            return this._level;
        },

        error : function(...args){ 
            this._logByType('error', this._level, args);
        },

        warn : function(...args){ 
            this._logByType('warn', this._level, args);
        },

        debug : function(...args){ 
            this._logByType('debug', this._level, args);
        },

        info : function(...args){ 
            this._logByType('info', this._level, args);
        },

        history : function() {
            return history ? [].concat(history) : [];
        },

        createLogger : function(subname) {
            return new Logger(this.name ? this.name  + ': ' + subname : subname);   
        }

    });


    objects.mixin(Logger.prototype.history,{
        enable : function() {
           if (history === null) {
                history = [];
            }            
        },
        
        filter : function(fname) {
            return (history || []).filter(historyItem => {
                return new RegExp(`.*${ fname }.*`).test(historyItem[0]);
            });
        },
        clear : function() {
            if (history) {
                history.length = 0;
            }
        },
        disable : function()  {
            if (history !== null) {
                history.length = 0;
                history = null;
            }
        }
    });

    Logger.root = new Logger("");

    return logging.Logger = Logger;

});
define('skylark-langx-logging/main',[
	"./logging",
	"./Logger"
],function(logging,Logger){
	let rootLogger = Logger.root;

	logging.debug = function(...args) {
		rootLogger.debug(...args);
	};

	logging.info = function(...args) {
		rootLogger.debug(...args);
	};

	logging.warn = function(...args) {
		rootLogger.debug(...args);
	};

	logging.error = function(...args) {
		rootLogger.debug(...args);
	};


	return logging;
});
define('skylark-langx-logging', ['skylark-langx-logging/main'], function (main) { return main; });

define('skylark-domx-animates/animates',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser"
], function(skylark,langx,browser) {

    function animates() {
        return animates;
    }

    langx.mixin(animates, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        },
        animationName : browser.normalizeCssProperty("animation-name"),
        animationDuration : browser.normalizeCssProperty("animation-duration"),
        animationDelay : browser.normalizeCssProperty("animation-delay"),
        animationTiming : browser.normalizeCssProperty("animation-timing-function"),
        animationEnd : browser.normalizeCssEvent('AnimationEnd'),

        animateBaseClass : "animated"
    });

    return skylark.attach("domx.animates", animates);
});
define('skylark-domx-geom/geom',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, noder, styler) {
  'use strict'

    var rootNodeRE = /^(?:body|html)$/i,
        px = langx.toPixel,
        offsetParent = noder.offsetParent,
        cachedScrollbarWidth;

    function scrollbarWidth() {
        if (cachedScrollbarWidth !== undefined) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = noder.createFragment("<div style=" +
                "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                "<div style='height:300px;width:auto;'></div></div>")[0],
            innerDiv = div.childNodes[0];

        noder.append(document.body, div);

        w1 = innerDiv.offsetWidth;
        styler.css(div, "overflow", "scroll");

        w2 = innerDiv.offsetWidth;

        if (w1 === w2) {
            w2 = div[0].clientWidth;
        }

        noder.remove(div);

        return (cachedScrollbarWidth = w1 - w2);
    }


    function hasScrollbar() {
        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);
    }

    /*
     * Get the widths of each border of the specified element.
     * @param {HTMLElement} elm
     */
    function borderExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }        var s = getComputedStyle(elm);
        return {
            left: px(s.borderLeftWidth, elm),
            top: px(s.borderTopWidth, elm),
            right: px(s.borderRightWidth, elm),
            bottom: px(s.borderBottomWidth, elm)
        }
    }

    //viewport coordinate
    /*
     * Get or set the viewport position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingPosition(elm, coords) {
        if (coords === undefined) {
            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top + (scrollTop(parent) || 0),
                left: coords.left - parentOffset.left - mex.left - pbex.left + (scrollLeft(parent) || 0)
            });
            return this;
        }
    }

    /*
     * Get or set the viewport rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingRect(elm, coords) {
        if (coords === undefined) {
            if (elm == window || elm == document.documentElement || elm == document.body){
                return {
                    top : 0,
                    left : 0,
                    bottom : window.innerHeight,
                    right : window.innerWidth,
                    height : window.innerHeight,
                    width : window.innerWidth
                };
            } else if (elm.getBoundingClientRect) {
                return elm.getBoundingClientRect();
            }
        } else {
            boundingPosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the height of the specified element client box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function clientHeight(elm, value) {
        if (value == undefined) {
            return clientSize(elm).height;
        } else {
            return clientSize(elm, {
                height: value
            });
        }
    }

    /*
     * Get or set the size of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientSize(elm, dimension) {
        if (dimension == undefined) {
            return {
                width: elm.clientWidth,
                height: elm.clientHeight
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width - pex.left - pex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height - pex.top - pex.bottom;
                }
            } else {
                var bex = borderExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width + bex.left + bex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height + bex.top + bex.bottom;
                }

            }
            styler.css(elm, props);
            return this;
        }
        return {
            width: elm.clientWidth,
            height: elm.clientHeight
        };
    }

    /*
     * Get or set the width of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientWidth(elm, value) {
        if (value == undefined) {
            return clientSize(elm).width;
        } else {
            clientSize(elm, {
                width: value
            });
            return this;
        }
    }

    /*
     * Get the rect of the specified element content box.
     * @param {HTMLElement} elm
     */
    function contentRect(elm) {
        var cs = clientSize(elm),
            pex = paddingExtents(elm);


        //// On Opera, offsetLeft includes the parent's border
        //if(has("opera")){
        //    pe.l += be.l;
        //    pe.t += be.t;
        //}
        return {
            left: pex.left,
            top: pex.top,
            width: cs.width - pex.left - pex.right,
            height: cs.height - pex.top - pex.bottom
        };
    }

    /*
     * Get the document size.
     * @param {HTMLDocument} doc
     */
    function getDocumentSize(doc) {
        var documentElement = doc.documentElement,
            body = doc.body,
            max = Math.max,
            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),
            clientWidth = max(documentElement.clientWidth, body.clientWidth),
            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),
            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),
            clientHeight = max(documentElement.clientHeight, body.clientHeight),
            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);

        return {
            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
        };
    }

    /*
     * Get the document size.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function height(elm, value) {
        if (value == undefined) {
            return size(elm).height;
        } else {
            size(elm, {
                height: value
            });
            return this;
        }
    }



    function inview(elm, cushion) {
        function calibrate(coords, cushion) {
            var o = {};
            cushion = +cushion || 0;
            o.width = (o.right = coords.right + cushion) - (o.left = coords.left - cushion);
            o.height = (o.bottom = coords.bottom + cushion) - (o.top = coords.top - cushion);
            return o;
        }

        var r = calibrate(boundingRect(elm), cushion),
            vsize = viewportSize();

        return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= vsize.height && r.left <= vsize.width;
    }


    /*
     * Get the widths of each margin of the specified element.
     * @param {HTMLElement} elm
     */
    function marginExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.marginLeft),
            top: px(s.marginTop),
            right: px(s.marginRight),
            bottom: px(s.marginBottom),
        }
    }


    function marginRect(elm) {
        var obj = relativeRect(elm),
            me = marginExtents(elm);

        return {
            left: obj.left,
            top: obj.top,
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }


    function marginSize(elm) {
        var obj = size(elm),
            me = marginExtents(elm);

        return {
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }

    /*
     * Get the widths of each padding of the specified element.
     * @param {HTMLElement} elm
     */
    function paddingExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.paddingLeft),
            top: px(s.paddingTop),
            right: px(s.paddingRight),
            bottom: px(s.paddingBottom),
        }
    }

    /*
     * Get or set the document position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    //coordinate to the document
    function pagePosition(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect(),
                w = elm.ownerDocument.defaultView;
            return {
                left: obj.left + w.pageXOffset,
                top: obj.top + w.pageYOffset
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = pagePosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the document rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function pageRect(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect(),
                w = elm.ownerDocument.defaultView;
            return {
                left: obj.left + w.pageXOffset,
                top: obj.top + w.pageYOffset,
                width: Math.round(obj.width),
                height: Math.round(obj.height)
            }
        } else {
            pagePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the position of the specified element border box , relative to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    // coordinate relative to it's parent
    function relativePosition(elm, coords) {
        if (coords == undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingPosition(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top - mex.top,
                left: offset.left - parentOffset.left - pbex.left - mex.left
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm);

            var props = {
                top: coords.top,
                left: coords.left
            };

            /*
            if (langx.isDefined(props.top)) {
                props.top = props.top + (scrollTop(parent) || 0);
            }

            if (langx.isDefined(props.left)) {
                props.left = props.left + (scrollLeft(parent) || 0);
            } 
            */ 

            if (styler.css(elm, "position") == "static") {
                props['position'] = "relative";
            }


            styler.css(elm, props);
            return this;
        }
    }

    /*
     * Get or set the rect of the specified element border box , relatived to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function relativeRect(elm, coords) {
        if (coords === undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingRect(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left,
                width: offset.width,
                height: offset.height
            }
        } else {
            relativePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }
    /*
     * Scroll the specified element into view.
     * @param {HTMLElement} elm
     * @param {} align
     */
    function scrollIntoView(elm, align) {
        function getOffset(elm, rootElm) {
            var x, y, parent = elm;

            x = y = 0;
            while (parent && parent != rootElm && parent.nodeType) {
                x += parent.offsetLeft || 0;
                y += parent.offsetTop || 0;
                parent = parent.offsetParent;
            }

            return { x: x, y: y };
        }

        var parentElm = elm.parentNode;
        var x, y, width, height, parentWidth, parentHeight;
        var pos = getOffset(elm, parentElm);

        x = pos.x;
        y = pos.y;
        width = elm.offsetWidth;
        height = elm.offsetHeight;
        parentWidth = parentElm.clientWidth;
        parentHeight = parentElm.clientHeight;

        if (align == "end") {
            x -= parentWidth - width;
            y -= parentHeight - height;
        } else if (align == "center") {
            x -= (parentWidth / 2) - (width / 2);
            y -= (parentHeight / 2) - (height / 2);
        }

        parentElm.scrollLeft = x;
        parentElm.scrollTop = y;

        return this;
    }
    /*
     * Get or set the current horizontal position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollLeft(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        } else if (elm == document.body) {
            elm = document.scrollingElement  || document.documentElement;
        }
        var hasScrollLeft = "scrollLeft" in elm;
        if (value === undefined) {
            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset
        } else {
            if (hasScrollLeft) {
                elm.scrollLeft = value;
            } else {
                elm.scrollTo(value, elm.scrollY);
            }
            return this;
        }
    }
    /*
     * Get or the current vertical position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollTop(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        } else if (elm == document.body) {
            elm = document.scrollingElement  || document.documentElement;
        }

        var hasScrollTop = "scrollTop" in elm;

        if (value === undefined) {
            return hasScrollTop ? elm.scrollTop : elm.pageYOffset
        } else {
            if (hasScrollTop) {
                elm.scrollTop = value;
            } else {
                elm.scrollTo(elm.scrollX, value);
            }
            return this;
        }
    }

    function scrollBy(elm, x, y) {
        elm.scrollLeft += x;
        elm.scrollTop += y;
    }


    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject}dimension
     */
    function size(elm, dimension) {
        if (dimension == undefined) {
            if (langx.isWindow(elm)) {
                return {
                    width: elm.innerWidth,
                    height: elm.innerHeight
                }

            } else if (langx.isDocument(elm)) {
                return getDocumentSize(document);
            } else {
                return {
                    width: elm.offsetWidth,
                    height: elm.offsetHeight
                }
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm),
                    bex = borderExtents(elm);

                if (props.width !== undefined && props.width !== "" && props.width !== null) {
                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;
                }

                if (props.height !== undefined && props.height !== "" && props.height !== null) {
                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;
                }
            }
            styler.css(elm, props);
            return this;
        }
    }


    function viewportSize(win) {
        win = win || window;

        return boundingRect(win);
    }

    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function width(elm, value) {
        if (value == undefined) {
            return size(elm).width;
        } else {
            size(elm, {
                width: value
            });
            return this;
        }
    }

    function testAxis(elm) {
       
        var top = elm.offsetTop;
        var left = elm.offsetLeft;
        var width = elm.offsetWidth;
        var height = elm.offsetHeight;

        while(elm.offsetParent) {
            elm = elm.offsetParent;
            top += elm.offsetTop;
            left += elm.offsetLeft;
        }

        var result = {x: 0, y: 0};

        //Over the top of the window
        if(top < window.pageYOffset) {
            result.y = top - window.pageYOffset;
        }
        //Bellow the window
        else if((top + height) > (window.pageYOffset + window.innerHeight))
        {
            result.y = (top + height) - (window.pageYOffset + window.innerHeight);
        }

        //Left to the window
        if(left < window.pageXOffset) {
            result.x = left - window.pageXOffset;
        }
        //Right to the window
        else if((left + width) > (window.pageXOffset + window.innerWidth))
        {
            result.x = (left + width) - (window.pageXOffset + window.innerWidth);
        }

        return result;
    };    

    function geom() {
        return geom;
    }

    langx.mixin(geom, {
        borderExtents: borderExtents,
        //viewport coordinate
        boundingPosition: boundingPosition,

        boundingRect: boundingRect,

        clientHeight: clientHeight,

        clientSize: clientSize,

        clientWidth: clientWidth,

        contentRect: contentRect,

        getDocumentSize: getDocumentSize,

        hasScrollbar,

        height: height,

        inview,

        marginExtents: marginExtents,

        marginRect: marginRect,

        marginSize: marginSize,

        offsetParent: offsetParent,

        paddingExtents: paddingExtents,

        //coordinate to the document
        pagePosition: pagePosition,

        pageRect: pageRect,

        // coordinate relative to it's parent
        relativePosition: relativePosition,

        relativeRect: relativeRect,

        scrollbarWidth: scrollbarWidth,

        scrollIntoView: scrollIntoView,

        scrollLeft: scrollLeft,

        scrollTop: scrollTop,

        scrollBy,
            
        size: size,

        testAxis,

        viewportSize,

        width: width
    });



    return skylark.attach("domx.geom", geom);
});
define('skylark-domx-geom/posit',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler",
    "./geom"
],function(langx,noder,styler,geom){
  'use strict'

    var max = Math.max,
        abs = Math.abs,
        rhorizontal = /left|center|right/,
        rvertical = /top|center|bottom/,
        roffset = /[\+\-]\d+(\.[\d]+)?%?/,
        rposition = /^\w+/,
        rpercent = /%$/;

    function getOffsets( offsets, width, height ) {
        return [
            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
        ];
    }

    function parseCss( element, property ) {
        return parseInt( styler.css( element, property ), 10 ) || 0;
    }

    function getDimensions( raw ) {
        if ( raw.nodeType === 9 ) {
            return {
                size: size(raw),
                offset: { top: 0, left: 0 }
            };
        }
        if ( noder.isWindow( raw ) ) {
            return {
                size: geom.size(raw),
                offset: { 
                    top: geom.scrollTop(raw), 
                    left: geom.scrollLeft(raw) 
                }
            };
        }
        if ( raw.preventDefault ) {
            return {
                size : {
                    width: 0,
                    height: 0
                },
                offset: { 
                    top: raw.pageY, 
                    left: raw.pageX 
                }
            };
        }
        return {
            size: geom.size(raw),
            offset: geom.pagePosition(raw)
        };
    }

    function getScrollInfo( within ) {
        var overflowX = within.isWindow || within.isDocument ? "" :
                styler.css(within.element,"overflow-x" ),
            overflowY = within.isWindow || within.isDocument ? "" :
                styler.css(within.element,"overflow-y" ),
            hasOverflowX = overflowX === "scroll" ||
                ( overflowX === "auto" && within.width < geom.scrollWidth(within.element) ),
            hasOverflowY = overflowY === "scroll" ||
                ( overflowY === "auto" && within.height < geom.scrollHeight(within.element));
        return {
            width: hasOverflowY ? geom.scrollbarWidth() : 0,
            height: hasOverflowX ? geom.scrollbarWidth() : 0
        };
    }

    function getWithinInfo( element ) {
        var withinElement = element || window,
            isWindow = noder.isWindow( withinElement),
            isDocument = !!withinElement && withinElement.nodeType === 9,
            hasOffset = !isWindow && !isDocument,
            msize = geom.marginSize(withinElement);
        return {
            element: withinElement,
            isWindow: isWindow,
            isDocument: isDocument,
            offset: hasOffset ? geom.pagePosition(element) : { left: 0, top: 0 },
            scrollLeft: geom.scrollLeft(withinElement),
            scrollTop: geom.scrollTop(withinElement),
            width: msize.width,
            height: msize.height
        };
    }

    function posit(elm,options ) {
        // Make a copy, we don't want to modify arguments
        options = langx.extend( {}, options );

        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
            target = options.of,
            within = getWithinInfo( options.within ),
            scrollInfo = getScrollInfo( within ),
            collision = ( options.collision || "flip" ).split( " " ),
            offsets = {};

        dimensions = getDimensions( target );
        if ( target.preventDefault ) {

            // Force left top to allow flipping
            options.at = "left top";
        }
        targetWidth = dimensions.size.width;
        targetHeight = dimensions.size.height;
        targetOffset = dimensions.offset;

        // Clone to reuse original targetOffset later
        basePosition = langx.extend( {}, targetOffset );

        // Force my and at to have valid horizontal and vertical positions
        // if a value is missing or invalid, it will be converted to center
        langx.each( [ "my", "at" ], function() {
            var pos = ( options[ this ] || "" ).split( " " ),
                horizontalOffset,
                verticalOffset;

            if ( pos.length === 1 ) {
                pos = rhorizontal.test( pos[ 0 ] ) ?
                    pos.concat( [ "center" ] ) :
                    rvertical.test( pos[ 0 ] ) ?
                        [ "center" ].concat( pos ) :
                        [ "center", "center" ];
            }
            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

            // Calculate offsets
            horizontalOffset = roffset.exec( pos[ 0 ] );
            verticalOffset = roffset.exec( pos[ 1 ] );
            offsets[ this ] = [
                horizontalOffset ? horizontalOffset[ 0 ] : 0,
                verticalOffset ? verticalOffset[ 0 ] : 0
            ];

            // Reduce to just the positions without the offsets
            options[ this ] = [
                rposition.exec( pos[ 0 ] )[ 0 ],
                rposition.exec( pos[ 1 ] )[ 0 ]
            ];
        } );

        // Normalize collision option
        if ( collision.length === 1 ) {
            collision[ 1 ] = collision[ 0 ];
        }

        if ( options.at[ 0 ] === "right" ) {
            basePosition.left += targetWidth;
        } else if ( options.at[ 0 ] === "center" ) {
            basePosition.left += targetWidth / 2;
        }

        if ( options.at[ 1 ] === "bottom" ) {
            basePosition.top += targetHeight;
        } else if ( options.at[ 1 ] === "center" ) {
            basePosition.top += targetHeight / 2;
        }

        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
        basePosition.left += atOffset[ 0 ];
        basePosition.top += atOffset[ 1 ];

        return ( function(elem) {
            var collisionPosition, using,
                msize = geom.marginSize(elem),
                elemWidth = msize.width,
                elemHeight = msize.height,
                marginLeft = parseCss( elem, "marginLeft" ),
                marginTop = parseCss( elem, "marginTop" ),
                collisionWidth = elemWidth + marginLeft + parseCss( elem, "marginRight" ) +
                    scrollInfo.width,
                collisionHeight = elemHeight + marginTop + parseCss( elem, "marginBottom" ) +
                    scrollInfo.height,
                position = langx.extend( {}, basePosition ),
                myOffset = getOffsets( offsets.my, msize.width, msize.height);

            if ( options.my[ 0 ] === "right" ) {
                position.left -= elemWidth;
            } else if ( options.my[ 0 ] === "center" ) {
                position.left -= elemWidth / 2;
            }

            if ( options.my[ 1 ] === "bottom" ) {
                position.top -= elemHeight;
            } else if ( options.my[ 1 ] === "center" ) {
                position.top -= elemHeight / 2;
            }

            position.left += myOffset[ 0 ];
            position.top += myOffset[ 1 ];

            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };

            langx.each( [ "left", "top" ], function( i, dir ) {
                if ( positions[ collision[ i ] ] ) {
                    positions[ collision[ i ] ][ dir ]( position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    } );
                }
            } );

            if ( options.using ) {

                // Adds feedback as second argument to using callback, if present
                using = function( props ) {
                    var left = targetOffset.left - position.left,
                        right = left + targetWidth - elemWidth,
                        top = targetOffset.top - position.top,
                        bottom = top + targetHeight - elemHeight,
                        feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                        feedback.horizontal = "center";
                    }
                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                        feedback.vertical = "middle";
                    }
                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call( this, props, feedback );
                };
            }

            geom.pagePosition(elem, langx.extend( position, { using: using } ));
        })(elm);
    }

    var positions = {
        fit: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                    outerWidth = within.width,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = withinOffset - collisionPosLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                    newOverRight;

                // Element is wider than within
                if ( data.collisionWidth > outerWidth ) {

                    // Element is initially over the left side of within
                    if ( overLeft > 0 && overRight <= 0 ) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                            withinOffset;
                        position.left += overLeft - newOverRight;

                    // Element is initially over right side of within
                    } else if ( overRight > 0 && overLeft <= 0 ) {
                        position.left = withinOffset;

                    // Element is initially over both left and right sides of within
                    } else {
                        if ( overLeft > overRight ) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }

                // Too far left -> align with left edge
                } else if ( overLeft > 0 ) {
                    position.left += overLeft;

                // Too far right -> align with right edge
                } else if ( overRight > 0 ) {
                    position.left -= overRight;

                // Adjust based on position and margin
                } else {
                    position.left = max( position.left - collisionPosLeft, position.left );
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                    outerHeight = data.within.height,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = withinOffset - collisionPosTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                    newOverBottom;

                // Element is taller than within
                if ( data.collisionHeight > outerHeight ) {

                    // Element is initially over the top of within
                    if ( overTop > 0 && overBottom <= 0 ) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                            withinOffset;
                        position.top += overTop - newOverBottom;

                    // Element is initially over bottom of within
                    } else if ( overBottom > 0 && overTop <= 0 ) {
                        position.top = withinOffset;

                    // Element is initially over both top and bottom of within
                    } else {
                        if ( overTop > overBottom ) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }

                // Too far up -> align with top
                } else if ( overTop > 0 ) {
                    position.top += overTop;

                // Too far down -> align with bottom edge
                } else if ( overBottom > 0 ) {
                    position.top -= overBottom;

                // Adjust based on position and margin
                } else {
                    position.top = max( position.top - collisionPosTop, position.top );
                }
            }
        },
        flip: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.left + within.scrollLeft,
                    outerWidth = within.width,
                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = collisionPosLeft - offsetLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                    myOffset = data.my[ 0 ] === "left" ?
                        -data.elemWidth :
                        data.my[ 0 ] === "right" ?
                            data.elemWidth :
                            0,
                    atOffset = data.at[ 0 ] === "left" ?
                        data.targetWidth :
                        data.at[ 0 ] === "right" ?
                            -data.targetWidth :
                            0,
                    offset = -2 * data.offset[ 0 ],
                    newOverRight,
                    newOverLeft;

                if ( overLeft < 0 ) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                        outerWidth - withinOffset;
                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                        position.left += myOffset + atOffset + offset;
                    }
                } else if ( overRight > 0 ) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                        atOffset + offset - offsetLeft;
                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.top + within.scrollTop,
                    outerHeight = within.height,
                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = collisionPosTop - offsetTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                    top = data.my[ 1 ] === "top",
                    myOffset = top ?
                        -data.elemHeight :
                        data.my[ 1 ] === "bottom" ?
                            data.elemHeight :
                            0,
                    atOffset = data.at[ 1 ] === "top" ?
                        data.targetHeight :
                        data.at[ 1 ] === "bottom" ?
                            -data.targetHeight :
                            0,
                    offset = -2 * data.offset[ 1 ],
                    newOverTop,
                    newOverBottom;
                if ( overTop < 0 ) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                        outerHeight - withinOffset;
                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                        position.top += myOffset + atOffset + offset;
                    }
                } else if ( overBottom > 0 ) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                        offset - offsetTop;
                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function() {
                positions.flip.left.apply( this, arguments );
                positions.fit.left.apply( this, arguments );
            },
            top: function() {
                positions.flip.top.apply( this, arguments );
                positions.fit.top.apply( this, arguments );
            }
        }
    };

    return geom.posit = posit;
});
define('skylark-domx-geom/scrollToTop',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./geom"
],function(langx,styler,geom) {
    /*   
     * Set the vertical position of the scroll bar for an element.
     * @param {Object} elm  
     * @param {Number or String} pos
     * @param {Number or String} speed
     * @param {Function} callback
     */
    function scrollToTop(elm, pos, speed, callback) {
        var scrollFrom = parseInt(elm.scrollTop),
            i = 0,
            runEvery = 5, // run every 5ms
            freq = speed * 1000 / runEvery,
            scrollTo = parseInt(pos);

        var interval = setInterval(function() {
            i++;

            if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;

            if (i >= freq + 1) {
                clearInterval(interval);
                if (callback) langx.debounce(callback, 1000)();
            }
        }, runEvery);

        return this;
    }

    return geom.scrollToTop = scrollToTop;
});
define('skylark-domx-geom/main',[
    "skylark-langx/langx",
    "./geom",
    "skylark-domx-velm",
    "skylark-domx-query",
    "./posit",
    "./scrollToTop"
],function(langx,geom,velm,$){
   // from ./geom
    velm.delegate([
        "borderExtents",
        "boundingPosition",
        "boundingRect",
        "clientHeight",
        "clientSize",
        "clientWidth",
        "contentRect",
        "height",
        "marginExtents",
        "marginRect",
        "marginSize",
        "offsetParent",
        "paddingExtents",
        "pagePosition",
        "pageRect",
        "relativePosition",
        "relativeRect",
        "scrollIntoView",
        "scrollLeft",
        "scrollTop",
        "pageSize",
        "width"
    ], geom,{
        "pageSize" : "size"
    });

    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);

    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);

    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);

    $.fn.position =  function(options) {
        if (!this.length) {
            return this;
        }

        if (options) {
            if (options.of && options.of.length) {
                options = langx.clone(options);
                options.of = options.of[0];
            }
            return this.each( function() {
                geom.posit(this,options);
            });
        } else {
            var elem = this[0];

            return geom.relativePosition(elem);

        }             
    };

    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);


    $.fn.pageSize = $.wraps.wrapper_value(geom.size, geom);

    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);

    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);

    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom.clientSize);
    
    ['width', 'height'].forEach(function(dimension) {
        var offset, Dimension = dimension.replace(/./, function(m) {
            return m[0].toUpperCase()
        });

        $.fn['outer' + Dimension] = function(margin, value) {
            if (arguments.length) {
                if (typeof margin !== 'boolean') {
                    value = margin;
                    margin = false;
                }
            } else {
                margin = false;
                value = undefined;
            }

            if (value === undefined) {
                var el = this[0];
                if (!el) {
                    return undefined;
                }
                var cb = geom.size(el);
                if (margin) {
                    var me = geom.marginExtents(el);
                    cb.width = cb.width + me.left + me.right;
                    cb.height = cb.height + me.top + me.bottom;
                }
                return dimension === "width" ? cb.width : cb.height;
            } else {
                return this.each(function(idx, el) {
                    var mb = {};
                    var me = geom.marginExtents(el);
                    if (dimension === "width") {
                        mb.width = value;
                        if (margin) {
                            mb.width = mb.width - me.left - me.right
                        }
                    } else {
                        mb.height = value;
                        if (margin) {
                            mb.height = mb.height - me.top - me.bottom;
                        }
                    }
                    geom.size(el, mb);
                })

            }
        };
    })

    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);

    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);

    return geom;
});
define('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });

define('skylark-domx-animates/animation',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./animates"
], function(langx, browser, noder, geom, styler, eventer,animates) {

    var animationName = animates.animationName,
        animationDuration = animates.animationDuration,
        animationTiming = animates.animationTiming,
        animationDelay = animates.animationDelay,

        animationEnd = animates.animationEnd,

        cssReset = {};


    cssReset[animationName] =
        cssReset[animationDuration] =
        cssReset[animationDelay] =
        cssReset[animationTiming] = "";

    /*   
     * Perform a custom animation.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animation(elm, name, duration, ease, callback, delay) {
        var cssValues = {};
        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = animates.speeds[duration];
        }
        if (duration === undefined) {
            duration = animates.speeds.normal;
        }
        duration = duration / 1000;

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }
        // keyframe animation
        cssValues[animationName] = name;
        cssValues[animationDuration] = duration + "s";
        cssValues[animationTiming] = ease;


        if (duration > 0) {
            eventer.on(elm, animationEnd, callback);
        }

        // trigger page reflow so new elements can animate
        elm.clientLeft;

        styler.css(elm, cssValues);

        return this;
    }

    return animates.animation = animation;

});
define('skylark-domx-animates/animate',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./animates"
], function(langx, styler, eventer,animates) {


    function animate(elm,className) {
        if (animates.animateBaseClass) {
          className = animates.animateBaseClass + " " + className;
        }
        styler.addClass(elm,className);
        eventer.one(elm,animates.animationEnd, function() {
            styler.removeClass(elm,className);
        });
        return this;
    }
    
    return animates.animate = animate;
});
define('skylark-domx-animates/main',[
	"./animates",
    "./animation",
    "./animate"
],function(animates){

	return animates;
});
define('skylark-domx-animates', ['skylark-domx-animates/main'], function (main) { return main; });

define('skylark-domx/animates',[
    "skylark-domx-animates"
], function( animates) {
    return animates;
});
define('skylark-domx/browser',[
    "skylark-domx-browser"
], function(browser) {
    "use strict";

    return browser;
});

define('skylark-domx-css/css',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder"
], function(skylark, langx, noder) {
    "use strict";

    var head = document.getElementsByTagName("head")[0],
        count = 0,
        sheetsByUrl = {},
        sheetsById = {},
        defaultSheetId = _createStyleSheet(),
        defaultSheet = sheetsById[defaultSheetId],
        rulesPropName = ("cssRules" in defaultSheet) ? "cssRules" : "rules",
        insertRuleFunc,
        deleteRuleFunc = defaultSheet.deleteRule || defaultSheet.removeRule;

    if (defaultSheet.insertRule) {
        var _insertRule = defaultSheet.insertRule;
        insertRuleFunc = function(selector, css, index) {
            _insertRule.call(this, selector + "{" + css + "}", index);
        };
    } else {
        insertRuleFunc = defaultSheet.addRule;
    }

    function normalizeSelector(selectorText) {
        var selector = [],
            last, len;
        last = defaultSheet[rulesPropName].length;
        insertRuleFunc.call(defaultSheet, selectorText, ';');
        len = defaultSheet[rulesPropName].length;
        for (var i = len - 1; i >= last; i--) {
            selector.push(_sheet[_rules][i].selectorText);
            deleteRuleFunc.call(defaultSheet, i);
        }
        return selector.reverse().join(', ');
    }

    /*
     * create a stylesheet element.
     * @param {Boolean} external
     * @param {Object} options
     * @param {String} [options.media = null]
     */
    function _createStyleSheet(external,options ) {
        var node,
            props = {
                type : "text/css"
            },
            id = (count++);

        options = options || {};
        if (options.media) {
            props.media = options.media;
        }

        if (external) {
            node = noder.create("link",langx.mixin(props,{
                rel  : "stylesheet",
                async : false
            }));
        } else {
            node = noder.createElement("style",props);
        }

        noder.append(head,node);
        sheetsById[id] = {
            id : id,
            node :node
        };

        return id;
    }

    function createStyleSheet(css,options) {
        if (!options) {
            options = {};
        }
        var sheetId = _createStyleSheet(false,options);
        if (css) {
            addSheetRules(sheetId,css);
        }

        return sheetId;
    }

    function loadStyleSheet(url, options,loadedCallback, errorCallback) {
        if (langx.isFunction(options)) {
            errorCallback = loadedCallback;
            loadedCallback = options;
            options = {};
        }
        var sheet = sheetsByUrl[url];
        if (!sheet) {
            var sheetId = _createStyleSheet(true,options);

            sheet = sheetsByUrl[url] = sheetsById[sheetId];
            langx.mixin(sheet,{
                state: 0, //0:unload,1:loaded,-1:loaderror
                url : url,
                deferred : new langx.Deferred()
            });

            var node = sheet.node;

            startTime = new Date().getTime();

            node.onload = function() {
                sheet.state = 1;
                sheet.deferred.resolve(sheet.id);
            },
            node.onerror = function(e) {
                sheet.state = -1;
                sheet.deferred.reject(e);
            };

            node.href = sheet.url;
        }
        if (loadedCallback || errorCallback) {
            sheet.deferred.promise.then(loadedCallback,errorCallback);
        }
        return sheet.id;
    }

    function deleteSheetRule(sheetId, rule) {
        var sheet = sheetsById[sheetId];
        if (langx.isNumber(rule)) {
            deleteRuleFunc.call(sheet, rule);
        } else {
            langx.each(sheet[rulesPropName], function(i, _rule) {
                if (rule === _rule) {
                    deleteRuleFunc.call(sheet, i);
                    return false;
                }
            });
        }
        return this;
    }

    function deleteRule(rule) {
        deleteSheetRule(defaultSheetId, rule);
        return this;
    }

    function removeStyleSheet(sheetId) {
        if (sheetId === defaultSheetId) {
            throw new Error("The default stylesheet can not be deleted");
        }
        var sheet = sheetsById[sheetId];
        delete sheetsById[sheetId];

        noder.remove(sheet.node);
        return this;
    }

    /*
     * insert a rule to the default stylesheet.
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertRule(selector, css, index) {
        return this.insertSheetRule(defaultSheetId, selector, css, index);
    }

    /*
     * Add rules to the default stylesheet.
     * @param {Object} rules
     */
    function addRules(rules) {
        return this.addRules(defaultSheetId,rules);
    }

    /*
     * insert a rule to the stylesheet specified by sheetId.
     * @param {Number} sheetId  
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertSheetRule(sheetId, selector, css, index) {
        if (!selector || !css) {
            return -1;
        }

        var sheet = sheetsById[sheetId];
        index = index || sheet[rulesPropName].length;

        return insertRuleFunc.call(sheet, selector, css, index);
    }

    /*
     * Add  rules to stylesheet.
     * @param {Number} sheetId  
     * @param {Object|String} rules
     * @return this
     * @example insertSheetRules(sheetId,{
     * 
     * });
     */
    function addSheetRules(sheetId,rules) {
        var sheet = sheetsById[sheetId],
            css;
        if (langx.isString(rules)) {
            css = rules;
        } else {
            css = toString(rules);
        }

        noder.append(sheet.node,noder.createTextNode(css));
        
        return this;
    }

    function isAtRule(str) {
        return str.startsWith("@");
    }

    function toString(json){
        var adjust = function(parentName,name,depth) {
            if (parentName) {
                if (isAtRule(parentName)) {
                    depth += 1;
                } else {
                    name =  parentName + " " + name;
                }                
            }
            return {
                name : name,
                depth : depth
            }
        };

        var strNode = function (name, values, depth) {
            var str = "",
                atFlg = isAtRule(name);


            if (isAtRule(name)) {
                // at rule
                if (langx.isString(values)) {
                    // an at rule without block
                    // ex: (1) @charset 'utf8';
                    str = css.SPACE.repeat(depth) + name.trim() + " \"" + values.trim() + " \";\n";
                } else {
                    // an at rule with block, ex :
                    //  @media 'screen' {
                    //  }
                    str += css.SPACE.repeat(depth) + name.trim() + " {\n";
                    str += strNode("",values,depth+1);
                    str += css.SPACE.repeat(depth) + " }\n";
                }
            } else {
                // a selector or a property
                if (langx.isString(values)) {
                    // a css property 
                    // ex : (1) font-color : red;
                    str = css.SPACE.repeat(depth) + name.trim() ;
                    if (atFlg) {
                        str = str +  " \"" + values.trim() + " \";\n";
                    } else {
                        str = str + ': ' + values.trim() + ";\n";
                    }

                } else {
                    // a selector rule 
                    // ex : (1) .class1 : {
                    //            font-color : red;
                    //          }
                    if (langx.isArray(values)) {
                        // array for ordering
                        for (var n =0; n<values.length; n ++) {
                           str +=  strNode(name,values[n],depth);
                        }
                    } else {
                        // plain object

                        if (name) {
                            str += css.SPACE.repeat(depth) + name.trim() + " {\n";

                            for (var n in values) {
                                var value =values[n];
                                if (langx.isString(value)) {
                                    // css property
                                    str += strNode(n,value,depth+1)
                                }
                            }

                            str += css.SPACE.repeat(depth) + "}\n";
                        }

                        for (var n in values) {
                            var value =values[n];
                            if (!langx.isString(value)) {
                                var adjusted = adjust(name,n,depth);
                                str +=  strNode(adjusted.name,value,adjusted.depth);
                            } 
                        }

                    }
                }
            }   

            return str;
        };


        return strNode("",json,0);
    }
 

    function css() {
        return css;
    }

    langx.mixin(css, {
        SPACE : "\t",

        addRules : addRules,

        addSheetRules : addSheetRules,

        createStyleSheet: createStyleSheet,

        deleteSheetRule : deleteSheetRule,

        deleteRule : deleteRule,

        insertRule : insertRule,

        insertSheetRule : insertSheetRule,

        loadStyleSheet : loadStyleSheet,

        removeStyleSheet : removeStyleSheet,

        toString : toString
    });

    return skylark.attach("domx.css", css);
});

define('skylark-domx-css/main',[
	"./css"
],function(css){
	return css;
});
define('skylark-domx-css', ['skylark-domx-css/main'], function (main) { return main; });

define('skylark-domx/css',[
    "skylark-domx-css"
], function( css) {
    "use strict";

     return css;
});

define('skylark-domx/data',[
    "skylark-domx-data"
], function( data) {
 
    return data;
});
define('skylark-domx/eventer',[
    "skylark-domx-eventer"
], function( eventer) {
 
    return eventer;
});
define('skylark-domx/finder',[
    "skylark-domx-finder"
], function( finder) {

    return finder;
});
define('skylark-domx-fx/fx',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {

    function fx() {
        return fx;
    }

    langx.mixin(fx, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        }
    });

    return skylark.attach("domx.fx", fx);
});
define('skylark-domx-transits/transits',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {

    function transits() {
        return transits;
    }

    langx.mixin(transits, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        }
    });

    return skylark.attach("domx.transits", transits);
});
define('skylark-domx-transits/transit',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./transits"
], function(langx, browser, noder, geom, styler, eventer,transits) {

    var transitionProperty,
        transitionDuration,
        transitionTiming,
        transitionDelay,

        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),

        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
        transform = browser.css3PropPrefix + "transform",
        cssReset = {};

    cssReset[transitionProperty = browser.normalizeCssProperty("transition-property")] =
        cssReset[transitionDuration = browser.normalizeCssProperty("transition-duration")] =
        cssReset[transitionDelay = browser.normalizeCssProperty("transition-delay")] =
        cssReset[transitionTiming = browser.normalizeCssProperty("transition-timing-function")] = "";

    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function transit(elm, properties, duration, ease, callback, delay) {
        var key,
            cssValues = {},
            cssProperties = [],
            transforms = "",
            that = this,
            endEvent,
            wrappedCallback,
            fired = false,
            hasScrollTop = false,
            resetClipAuto = false;

        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = transits.speeds[duration];
        }
        if (duration === undefined) {
            duration = transits.speeds.normal;
        }
        duration = duration / 1000;
        if (transits.off) {
            duration = 0;
        }

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }

        // CSS transitions
        for (key in properties) {
            var v = properties[key];
            if (supportedTransforms.test(key)) {
                transforms += key + "(" + v + ") ";
            } else {
                if (key === "scrollTop") {
                    hasScrollTop = true;
                }
                if (key == "clip" && langx.isPlainObject(v)) {
                    cssValues[key] = "rect(" + v.top+"px,"+ v.right +"px,"+ v.bottom +"px,"+ v.left+"px)";
                    if (styler.css(elm,"clip") == "auto") {
                        var size = geom.size(elm);
                        styler.css(elm,"clip","rect("+"0px,"+ size.width +"px,"+ size.height +"px,"+"0px)");  
                        resetClipAuto = true;
                    }

                } else {
                    cssValues[key] = v;
                }
                cssProperties.push(langx.dasherize(key));
            }
        }
        endEvent = transitionEnd;

        if (transforms) {
            cssValues[transform] = transforms;
            cssProperties.push(transform);
        }

        if (duration > 0) {
            cssValues[transitionProperty] = cssProperties.join(", ");
            cssValues[transitionDuration] = duration + "s";
            cssValues[transitionDelay] = delay + "s";
            cssValues[transitionTiming] = ease;
        }

        wrappedCallback = function(event) {
            fired = true;
            if (event) {
                if (event.target !== event.currentTarget) {
                    return // makes sure the event didn't bubble from "below"
                }
                eventer.off(event.target, endEvent, wrappedCallback)
            } else {
                eventer.off(elm, endEvent, wrappedCallback) // triggered by setTimeout
            }
            styler.css(elm, cssReset);
            if (resetClipAuto) {
 //               styler.css(elm,"clip","auto");
            }
            callback && callback.call(this);
        };

        if (duration > 0) {
            eventer.on(elm, endEvent, wrappedCallback);
            // transitionEnd is not always firing on older Android phones
            // so make sure it gets fired
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, ((duration + delay) * 1000) + 25)();
        }

        // trigger page reflow so new elements can transit
        elm.clientLeft;

        styler.css(elm, cssValues);

        if (duration <= 0) {
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, 0)();
        }

        if (hasScrollTop) {
            geom.scrollToTop(elm, properties["scrollTop"], duration, callback);
        }

        return this;
    }

    return transits.transit = transit;

});
define('skylark-domx-fx/animate',[
    "skylark-langx/langx",
    "skylark-domx-transits/transit",
    "skylark-domx-animates/animation",
    "./fx"
], function(langx, transit,animation,fx) {

    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animate(elm, properties, duration, ease, callback, delay) {
        if (langx.isString(properties)) {
            return animation(elm,properties,duration,ease,callback,delay);
        } else {
            return transit(elm,properties,duration,ease,callback,delay);
        }

    }

    return fx.animate = animate;

});
define('skylark-domx-transits/bounce',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,geom,styler,transits,transit) {

    function bounce(elm, options, done ) {
        var upAnim, downAnim, refValue,
            // Defaults:
            mode = options.mode,
            hide = mode === "hide",
            show = mode === "show",
            direction = options.direction || "up",
            start,
            distance = options.distance,
            times = options.times || 5,

            // Number of internal animations
            anims = times * 2 + ( show || hide ? 1 : 0 ),
            speed = options.duration / anims,
            easing = options.easing,

            // Utility:
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            motion = ( direction === "up" || direction === "left" ),
            i = 0;

        //createPlaceholder(elm);

        var Deferred = langx.Deferred;
        var funcs = [];

        refValue = styler.css(elm,ref );

        // Default distance for the BIGGEST bounce is the outer Distance / 3
        if ( !distance ) {
            var msize = geom.size(elm);
            distance = (ref === "top" ? msize.height : msize.width) / 3;
        }

        start = geom.relativePosition(elm)[ref];

        if ( show ) {
            downAnim = { opacity: 1 };
            downAnim[ ref ] = refValue;

            // If we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            styler.css(elm, "opacity", 0 );
            styler.css(elm, ref, start + (motion ? -distance * 2 : distance * 2 ));

            funcs.push(doAnimate(elm,downAnim, speed, easing));
        }

        // Start at the smallest distance if we are hiding
        if ( hide ) {
            distance = distance / Math.pow( 2, times - 1 );
        }

        downAnim = {};
        downAnim[ ref ] = refValue;


        function doAnimate(elm,properties, duration, easing) {
            return function() {
                var d = new Deferred();

                transit(elm,properties, duration, easing ,function(){
                    d.resolve();
                });
                return d.promise;

            }
        }

        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for ( ; i < times; i++ ) {
            upAnim = {};
            upAnim[ ref ] = start + ( motion ? -distance : distance) ;

            funcs.push(doAnimate(elm,upAnim, speed, easing));

            funcs.push(doAnimate(elm,downAnim, speed, easing));

            distance = hide ? distance * 2 : distance / 2;
        }

        // Last Bounce when Hiding
        if ( hide ) {
            upAnim = { opacity: 0 };
            upAnim[ ref ] = start + ( motion ? -1 * distance : distance) ;

            funcs.push(doAnimate(elm,upAnim, speed, easing ));
        }

        funcs.push(done);
        funcs.reduce(function(prev, curr, index, array) {
            return prev.then(curr);
        }, Deferred.resolve());

        return this;
    } 

    return transits.bounce = bounce;
});
define('skylark-domx-transits/emulate-transition-end',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "./transits"
],function(langx,browser,eventer,transits) {
    
    function emulateTransitionEnd(elm,duration) {
        var called = false;
        eventer.one(elm,'transitionEnd', function () { 
            called = true;
        })
        var callback = function () { 
            if (!called) {
                eventer.trigger(elm,browser.support.transition.end) 
            }
        };
        setTimeout(callback, duration);
        
        return this;
    } 



    return transits.emulateTransitionEnd = emulateTransitionEnd;
});
define('skylark-domx-transits/show',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {
    /*   
     * Display an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function show(elm, speed, callback) {
        styler.show(elm);
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            styler.css(elm, "opacity", 0)
            transit(elm, { opacity: 1, scale: "1,1" }, speed, callback);
        }
        return this;
    }

    return transits.show = show;
});
define('skylark-domx-transits/hide',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {
    /*   
     * Hide an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function hide(elm, speed, callback) {
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            transit(elm, { opacity: 0, scale: "0,0" }, speed, function() {
                styler.hide(elm);
                if (callback) {
                    callback.call(elm);
                }
            });
        } else {
            styler.hide(elm);
        }
        return this;
    }

    return transits.hide = hide;
});
define('skylark-domx-transits/explode',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-geom",
    "skylark-domx-noder",
    "skylark-domx-query",
    "./transits",
    "./transit",
    "./show",
    "./hide"
],function(langx,styler,geom,noder,$,transits,transit,show,hide) {

    function explode( elm,options, done ) {

		// Show and then visibility:hidden the element before calculating offset
		styler.show(elm);
		styler.css(elm, "visibility", "hidden" );

		var i, j, left, top, mx, my,
			rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
			cells = rows,
			mode = options.mode,
			show = mode === "show",
			offset = geom.pagePosition(elm),

			// Width and height of a piece
			size = geom.marginSize(elm),
			width = Math.ceil( size.width / cells ),
			height = Math.ceil( size.height / rows ),
			pieces = [];

		// Children transit complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}

		// Clone the element for each row and cell.
		for ( var i = 0; i < rows; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2;

			for ( j = 0; j < cells; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2;

				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				$(elm)
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css( {
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					} )

					// Select the wrapper - make it overflow: hidden and absolute positioned based on
					// where the original was located +left and +top equal to the size of pieces
					.parent()
						.addClass( options.explodeClass || "ui-effects-explode" )
						.css( {
							position: "absolute",
							overflow: "hidden",
							width: width,
							height: height,
							left: left + ( show ? mx * width : 0 ),
							top: top + ( show ? my * height : 0 ),
							opacity: show ? 0 : 1
						} )
						.transit( {
							left: left + ( show ? 0 : mx * width ),
							top: top + ( show ? 0 : my * height ),
							opacity: show ? 1 : 0
						}, options.duration || 500, options.easing, childComplete );
			}
		}

		function animComplete() {
			styler.css(elm, {
				visibility: "visible"
			} );
			$( pieces ).remove();
			done();
		}

		return this;
	}


	return transits.explode = explode;
});

define('skylark-domx-transits/fade',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {
    /*   
     * Adjust the opacity of an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Number or String} opacity
     * @param {String} easing
     * @param {Function} callback
     */
    function fade(elm, opacity,options, callback) {
        if (langx.isFunction(options)) {
            callback = options;
            options = {};
        }
        options = options || {};
        
        transit(elm, { opacity: opacity }, options.duration, options.easing, callback);
        return this;
    }


    return transits.fade = fade;
});
define('skylark-domx-transits/fade-in',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./fade"
],function(langx,styler,transits,fadeTo) {
    /*   
     * Display an element by fading them to opaque.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeIn(elm, options, callback) {
        var target = styler.css(elm, "opacity");
        if (target > 0) {
            styler.css(elm, "opacity", 0);
        } else {
            target = 1;
        }
        styler.show(elm);

        fadeTo(elm,  target,options, callback);

        return this;
    }


    return transits.fadeIn = fadeIn;
});
define('skylark-domx-transits/fade-out',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./fade"
],function(langx,styler,transits,fadeTo) {
    /*   
     * Hide an element by fading them to transparent.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeOut(elm, options, callback) {

        function complete() {
            styler.css(elm,"opacity",opacity);
            styler.hide(elm);
            if (callback) {
                callback.call(elm);
            }
        }

        fadeTo(elm, 0,options,callback);

        return this;
    }

    return transits.fadeOut = fadeOut;
});
define('skylark-domx-transits/fade-toggle',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./fade-in",
    "./fade-out"
],function(langx,styler,transits,fadeIn,fadeOut) {

    /*   
     * Display or hide an element by animating its opacity.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} ceasing
     * @param {Function} callback
     */
    function fadeToggle(elm, speed, easing, callback) {
        if (styler.isInvisible(elm)) {
            fadeIn(elm, speed, easing, callback);
        } else {
            fadeOut(elm, speed, easing, callback);
        }
        return this;
    }


    return transits.fadeToggle = fadeToggle;
});
define('skylark-domx-transits/pulsate',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,geom,styler,transits,transit) {

	function pulsate(elm, options, done ) {
		var 
			mode = options.mode,
			show = mode === "show" || !mode,
			hide = mode === "hide",
			showhide = show || hide,

			// Showing or hiding leaves off the "last" animation
			anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = options.duration / anims,
			animateTo = 0,
			i = 1;

		if ( show || styler.isInvisible(elm) ) {
			styler.css(elm, "opacity", 0 );
			styler.show(elm);
			animateTo = 1;
		}

		// Anims - 1 opacity "toggles"

		var Deferred = langx.Deferred;
		var funcs = [];

		function doAnimate(elm,properties, duration, ease) {
			return function() {
				var d = new Deferred();

				transit( elm,properties, duration, ease ,function(){
					d.resolve();
				});
				return d.promise;

			}
		}


		for ( ; i < anims; i++ ) {
			funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));
			animateTo = 1 - animateTo;
		}

	    funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));

		funcs.push(done);
		funcs.reduce(function(prev, curr, index, array) {
	  		return prev.then(curr);
		}, Deferred.resolve());

		return this;

	}

	return transits.pulsate = pulsate;

});

define('skylark-domx-transits/shake',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,geom,styler,transits,transit) {
	function shake(elm, options, done ) {

		var i = 1,
			direction = options.direction || "left",
			distance = options.distance || 20,
			times = options.times || 3,
			anims = times * 2 + 1,
			speed = Math.round( options.duration / anims ),
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			positiveMotion = ( direction === "up" || direction === "left" ),
			animation0 = {},
			animation = {},
			animation1 = {},
			animation2 = {};

		var Deferred = langx.Deferred;
			start = geom.relativePosition(elm)[ref],
			funcs = [];

		function doAnimate(elm,properties, duration, ease) {
			return function() {
				var d = new Deferred();

				transit(elm, properties, duration, ease ,function(){
					d.resolve();
				});
				return d.promise;
			}
		}

		// Animation
		animation0[ ref ] = start;
		animation[ ref ] = start + ( positiveMotion ? -1 : 1 ) * distance;
		animation1[ ref ] = animation[ ref ] + ( positiveMotion ? 1 : -1 ) * distance * 2;
		animation2[ ref ] = animation1[ ref ] + ( positiveMotion ? -1 : 1 ) * distance * 2;

		// Animate
	    funcs.push(doAnimate(elm,animation, speed, options.easing ));

		// Shakes
		for ( ; i < times; i++ ) {
		    funcs.push(doAnimate(elm,animation1, speed, options.easing ));
		    funcs.push(doAnimate(elm,animation2, speed, options.easing ));
		}

	    funcs.push(doAnimate(elm,animation0, speed /2 , options.easing ));

		funcs.push(done);
		funcs.reduce(function(prev, curr, index, array) {
	  		return prev.then(curr);
		}, Deferred.resolve());

		return this;
	}

	return transits.shake = shake;

});

define('skylark-domx-transits/slide',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {

    function slide(elm,options,callback ) {
    	if (langx.isFunction(options)) {
    		callback = options;
    		options = {};
    	}
    	options = options || {};
		var direction = options.direction || "down",
			isHide = ( direction === "up" || direction === "left" ),
			isVert = ( direction === "up" || direction === "down" ),
			duration = options.duration || transits.speeds.normal;


        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        if (isHide) {
            // active the function only if the element is visible
        	if (styler.isInvisible(elm)) {
        		return this;
        	}
        } else {
	        // show element if it is hidden
	        styler.show(elm);        	
	        // place it so it displays as usually but hidden
	        styler.css(elm, {
	            position: 'absolute',
	            visibility: 'hidden'
	        });
        }



        if (isVert) { // up--down
	        // get naturally height, margin, padding
	        var marginTop = styler.css(elm, 'margin-top');
	        var marginBottom = styler.css(elm, 'margin-bottom');
	        var paddingTop = styler.css(elm, 'padding-top');
	        var paddingBottom = styler.css(elm, 'padding-bottom');
	        var height = styler.css(elm, 'height');

	        if (isHide) {  	// slideup
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                height: height,
	                marginTop: marginTop,
	                marginBottom: marginBottom,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom
	            });

	            // transit element height, margin and padding to zero
	            transit(elm, {
	                height: 0,
	                marginTop: 0,
	                marginBottom: 0,
	                paddingTop: 0,
	                paddingBottom: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        height: height,
	                        marginTop: marginTop,
	                        marginBottom: marginBottom,
	                        paddingTop: paddingTop,
	                        paddingBottom: paddingBottom
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slidedown
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            height: 0,
		            marginTop: 0,
		            marginBottom: 0,
		            paddingTop: 0,
		            paddingBottom: 0
		        });

		        // transit to gotten height, margin and padding
		        transit(elm, {
		            height: height,
		            marginTop: marginTop,
		            marginBottom: marginBottom,
		            paddingTop: paddingTop,
		            paddingBottom: paddingBottom
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }

        } else { // left--right
	        // get naturally height, margin, padding
	        var marginLeft = styler.css(elm, 'margin-left');
	        var marginRight = styler.css(elm, 'margin-right');
	        var paddingLeft = styler.css(elm, 'padding-left');
	        var paddingRight = styler.css(elm, 'padding-right');
	        var width = styler.css(elm, 'width');

	        if (isHide) {  	// slideleft
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                width: width,
	                marginLeft: marginLeft,
	                marginRight: marginRight,
	                paddingLeft: paddingLeft,
	                paddingRight: paddingRight
	            });

	            // transit element height, margin and padding to zero
	            transit(elm, {
	                width: 0,
	                marginLeft: 0,
	                marginRight: 0,
	                paddingLeft: 0,
	                paddingRight: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        width: width,
	                        marginLeft: marginLeft,
	                        marginRight: marginRight,
	                        paddingLeft: paddingLeft,
	                        paddingRight: paddingRight
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slideright
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            width: 0,
		            marginLeft: 0,
		            marginRight: 0,
		            paddingLeft: 0,
		            paddingRight: 0
		        });

		        // transit to gotten width, margin and padding
		        transit(elm, {
		            width: width,
		            marginLeft: marginLeft,
		            marginRight: marginRight,
		            paddingLeft: paddingLeft,
		            paddingRight: paddingRight
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }       	
        }

        return this;
    }

    return transits.slide = slide;

});

define('skylark-domx-transits/slide-down',[
    "./transits",
    "./slide"
],function(transits,slide) {
    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {
        return slide(elm,{
            direction : "down",
            duration : duration
        },callback);
    }

    return transits.slideDown = slideDown;
});
define('skylark-domx-transits/slide-up',[
    "./transits",
    "./slide"
],function(transits,slide) {
    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        return slide(elm,{
            direction : "up",
            duration : duration
        },callback);
    }



    return transits.slideUp = slideUp;
});
define('skylark-domx-transits/slide-toggle',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "./transits",
    "./slide-down",
    "./slide-up"
],function(langx,geom,transits,slideDown,slideUp) {

    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    return transits.slideToggle = slideToggle;
});
define('skylark-domx-transits/throb',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-noder",
    "./transits",
    "./transit"
],function(langx,styler,noder,transits,transit) {

    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};

        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };

        if (params.style) {
            styler.css(throbber,params.style);
        }

        //throb = noder.createElement("div", {
        //   "class": params.throb && params.throb.className || "throb"
        //}),
        //textNode = noder.createTextNode(text || ""),
 
        var content = params.content ||  '<span class="throb"></span>';

        //throb.appendChild(textNode);
        //throbber.appendChild(throb);

        noder.html(throbber,content);
        
        elm.appendChild(throbber);

        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            throbber : throbber,
            remove: remove,
            update: update
        };
    }

    return transits.throb = throb;
});
define('skylark-domx-transits/toggle',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./show",
    "./hide"
],function(langx,styler,transits,show,hide) {
    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callbacke
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    return transits.toggle = toggle;
});
define('skylark-domx-transits/main',[
	"./transits",
	"skylark-domx-velm",
	"skylark-domx-query",
    "./transit",
    "./bounce",
    "./emulate-transition-end",
    "./explode",
    "./fade-in",
    "./fade-out",
    "./fade",
    "./fade-toggle",
    "./hide",
    "./pulsate",
    "./shake",
    "./show",
    "./slide",
    "./slide-down",
    "./slide-toggle",
    "./slide-up",
    "./throb",
    "./toggle"
],function(transits,velm,$){
    // from ./transits
    velm.delegate([
        "transit",
        "emulateTransitionEnd",
        "fadeIn",
        "fadeOut",
        "fade",
        "fadeToggle",
        "hide",
        "scrollToTop",
        "slideDown",
        "slideToggle",
        "slideUp",
        "show",
        "toggle"
    ], transits);

    $.fn.hide =  $.wraps.wrapper_every_act(transits.hide, transits);

    $.fn.transit = $.wraps.wrapper_every_act(transits.transit, transits);
    $.fn.emulateTransitionEnd = $.wraps.wrapper_every_act(transits.emulateTransitionEnd, transits);

    $.fn.show = $.wraps.wrapper_every_act(transits.show, transits);
    $.fn.hide = $.wraps.wrapper_every_act(transits.hide, transits);
    $.fn.toogle = $.wraps.wrapper_every_act(transits.toogle, transits);
    $.fn.fadeTo = $.wraps.wrapper_every_act(transits.fadeTo, transits);
    $.fn.fadeIn = $.wraps.wrapper_every_act(transits.fadeIn, transits);
    $.fn.fadeOut = $.wraps.wrapper_every_act(transits.fadeOut, transits);
    $.fn.fadeToggle = $.wraps.wrapper_every_act(transits.fadeToggle, transits);

    $.fn.slideDown = $.wraps.wrapper_every_act(transits.slideDown, transits);
    $.fn.slideToggle = $.wraps.wrapper_every_act(transits.slideToggle, transits);
    $.fn.slideUp = $.wraps.wrapper_every_act(transits.slideUp, transits);

	return transits;
});
define('skylark-domx-transits', ['skylark-domx-transits/main'], function (main) { return main; });

define('skylark-domx-fx/bounce',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    return fx.bounce = transits.bounce;
});
define('skylark-domx-fx/emulateTransitionEnd',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    return fx.emulateTransitionEnd = transits.emulateTransitionEnd;
});
define('skylark-domx-fx/explode',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
	return fx.explode = transits.explode;
});

define('skylark-domx-fx/fadeIn',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fadeIn = transits.fadeIn;
});
define('skylark-domx-fx/fadeOut',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fadeOut = transits.fadeOut;
});
define('skylark-domx-fx/fade',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fade = transits.fade;
});
define('skylark-domx-fx/fadeToggle',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fadeToggle = transits.fadeToggle;
});
define('skylark-domx-fx/hide',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.hide = transits.hide;
});
define('skylark-domx-fx/pulsate',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

	return fx.pulsate = transits.pulsate;

});

define('skylark-domx-fx/shake',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

	return fx.shake = transits.shake;

});

define('skylark-domx-fx/show',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.show = transits.show;
});
define('skylark-domx-fx/slide',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    function slide(elm,options,callback ) {
    	if (langx.isFunction(options)) {
    		callback = options;
    		options = {};
    	}
    	options = options || {};
		var direction = options.direction || "down",
			isHide = ( direction === "up" || direction === "left" ),
			isVert = ( direction === "up" || direction === "down" ),
			duration = options.duration || fx.speeds.normal;


        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        if (isHide) {
            // active the function only if the element is visible
        	if (styler.isInvisible(elm)) {
        		return this;
        	}
        } else {
	        // show element if it is hidden
	        styler.show(elm);        	
	        // place it so it displays as usually but hidden
	        styler.css(elm, {
	            position: 'absolute',
	            visibility: 'hidden'
	        });
        }



        if (isVert) { // up--down
	        // get naturally height, margin, padding
	        var marginTop = styler.css(elm, 'margin-top');
	        var marginBottom = styler.css(elm, 'margin-bottom');
	        var paddingTop = styler.css(elm, 'padding-top');
	        var paddingBottom = styler.css(elm, 'padding-bottom');
	        var height = styler.css(elm, 'height');

	        if (isHide) {  	// slideup
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                height: height,
	                marginTop: marginTop,
	                marginBottom: marginBottom,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom
	            });

	            // animate element height, margin and padding to zero
	            animate(elm, {
	                height: 0,
	                marginTop: 0,
	                marginBottom: 0,
	                paddingTop: 0,
	                paddingBottom: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        height: height,
	                        marginTop: marginTop,
	                        marginBottom: marginBottom,
	                        paddingTop: paddingTop,
	                        paddingBottom: paddingBottom
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slidedown
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            height: 0,
		            marginTop: 0,
		            marginBottom: 0,
		            paddingTop: 0,
		            paddingBottom: 0
		        });

		        // animate to gotten height, margin and padding
		        animate(elm, {
		            height: height,
		            marginTop: marginTop,
		            marginBottom: marginBottom,
		            paddingTop: paddingTop,
		            paddingBottom: paddingBottom
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }

        } else { // left--right
	        // get naturally height, margin, padding
	        var marginLeft = styler.css(elm, 'margin-left');
	        var marginRight = styler.css(elm, 'margin-right');
	        var paddingLeft = styler.css(elm, 'padding-left');
	        var paddingRight = styler.css(elm, 'padding-right');
	        var width = styler.css(elm, 'width');

	        if (isHide) {  	// slideleft
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                width: width,
	                marginLeft: marginLeft,
	                marginRight: marginRight,
	                paddingLeft: paddingLeft,
	                paddingRight: paddingRight
	            });

	            // animate element height, margin and padding to zero
	            animate(elm, {
	                width: 0,
	                marginLeft: 0,
	                marginRight: 0,
	                paddingLeft: 0,
	                paddingRight: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        width: width,
	                        marginLeft: marginLeft,
	                        marginRight: marginRight,
	                        paddingLeft: paddingLeft,
	                        paddingRight: paddingRight
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slideright
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            width: 0,
		            marginLeft: 0,
		            marginRight: 0,
		            paddingLeft: 0,
		            paddingRight: 0
		        });

		        // animate to gotten width, margin and padding
		        animate(elm, {
		            width: width,
		            marginLeft: marginLeft,
		            marginRight: marginRight,
		            paddingLeft: paddingLeft,
		            paddingRight: paddingRight
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }       	
        }

        return this;
    }

    return fx.slide = slide;

});

define('skylark-domx-fx/slideDown',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {
        return slide(elm,{
            direction : "down",
            duration : duration
        },callback);
    }

    return fx.slideDown = slideDown;
});
define('skylark-domx-fx/slideToggle',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    return fx.slideToggle = slideToggle;
});
define('skylark-domx-fx/slideUp',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        return slide(elm,{
            direction : "up",
            duration : duration
        },callback);
    }



    return fx.slideUp = slideUp;
});
define('skylark-domx-fx/throb',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};

        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };

        if (params.style) {
            styler.css(throbber,params.style);
        }

        //throb = noder.createElement("div", {
        //   "class": params.throb && params.throb.className || "throb"
        //}),
        //textNode = noder.createTextNode(text || ""),
 
        var content = params.content ||  '<span class="throb"></span>';

        //throb.appendChild(textNode);
        //throbber.appendChild(throb);

        noder.html(throbber,content);
        
        elm.appendChild(throbber);

        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            throbber : throbber,
            remove: remove,
            update: update
        };
    }

    return fx.throb = throb;
});
define('skylark-domx-fx/toggle',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callbacke
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    return fx.toggle = toggle;
});
define('skylark-domx-fx/main',[
	"./fx",
    "./animate",
    "./bounce",
    "./emulateTransitionEnd",
    "./explode",
    "./fadeIn",
    "./fadeOut",
    "./fade",
    "./fadeToggle",
    "./hide",
    "./pulsate",
    "./shake",
    "./show",
    "./slide",
    "./slideDown",
    "./slideToggle",
    "./slideUp",
    "./throb",
    "./toggle"
],function(fx){

	return fx;
});
define('skylark-domx-fx', ['skylark-domx-fx/main'], function (main) { return main; });

define('skylark-domx/fx',[
    "skylark-domx-fx"
], function( fx) {
    return fx;
});
define('skylark-domx/geom',[
    "skylark-domx-geom"
], function( geom) {

    return geom;
});
define('skylark-domx-iframes/iframes',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("domx.iframes");
});
define('skylark-domx-iframes/create',[
  "skylark-domx-noder",
  "./iframes"
],function(noder,iframes){
  'use strict';

  function create(options,parentElm) {
  	  options = options || {
  	  };

  	  let props = {},
  	  	  attrs = {};

  	  if (options.id) {
  	  	props.id = options.id;
  	  };

  	  if (options.url) {
  	  	props.src = options.url;
  	  };

  	  if (options.style) {
  	  	props.style = options.style;
  	  }

  	  if (options.onload) {
  	  	props.onload = options.onload;
  	  }

  	  if (options.onerror) {
  	  	props.onload = options.onerror;
  	  }

  	  if (options.className) {
  	  	props.className = options.className;
  	  }

  	  if (options.sandbox) {
  	  	attrs.sandbox = options.sandbox;
  	  }

  	  if (options.frameBorder) {
  	  	attrs.frameBorder = options.frameBorder;  	  	
  	  }

  	  if (options.name) {
  	  	attrs.name = options.name;
  	  }

  	  /*
      // Basic mode
      // This adds the runner iframe to the page. It's only run once.
      //if (!$live.find('iframe').length) {
        iframe = noder.create("iframe",{
          ///iframe.src = jsbin.runner;
          src : this.options.runnerUrl
        },{
          "class" : "stretch",
          "sandbox", "allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts",
          "frameBorder": '0',
          "name", "<proxy>",
        },this._elm);

        try {
          ///iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;
          iframe.contentWindow.name  = this.options.runnerName;
        } catch (e) {
          // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.
          // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits
          // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview
          // then fail, and jsbin doesn't boot up. Tears all round, so we catch.
        }
      //}

      iframe.onload = () => {
        if (window.postMessage) {
          // setup postMessage listening to the runner
          $window.on('message', (event) => {
            this.handleMessage(event.originalEvent)
          });
          this.setup(iframe);
          this._inited.resolve();
        }
      };

      iframe.onerror = err => {
        this._inited.reject(err);
      };

      */

      let iframe = noder.create("iframe",props,attrs,parentElm);

      if (options.contentWindowName) {
      	iframe.contentWindow.name = options.contentWindowName;
      }

      return iframe;
  }

  return iframes.create = create;
});
define('skylark-domx-iframes/hook-sizing',[
  "skylark-domx-eventer",
  "./iframes"
],function(eventer,iframes){
  'use strict';

  function hookSizing(iframe) {
    var onmessage = function (event) {
      if (!event) { event = window.event; }
      ///TODO : how check message source
      // * 1 to coerse to number, and + 2 to compensate for border
      iframe.style.height = (event.data.height * 1 + 2) + 'px';
    };

    eventer.on(window,'message', onmessage);
  }

  return iframes.hookSizing = hookSizing;

});
define('skylark-domx-iframes/load-real',[
  "skylark-domx-noder",
  "skylark-domx-data",
  "./iframes",
  "./hook-sizing"
],function(noder,datax,iframes,hookSizing){

  function loadReal(iframe,options) {
    options = options || {};
    var clone = noder.clone(iframe);
    var url = options.url;
    if (!url) {
      url = datax.attr(clone,options.urlAttrName || 'data-url');
    }
    url = url.split('&')[0];
    datax.prop(clone,"src",url);
    datax.prop(clone,"_src",url); // support for google slide embed
    noder.replace(clone,ifame);
    ///hookSizing(clone);
  }

  return iframes.loadReal = loadReal;  
});
define('skylark-domx-iframes/lazy-load',[
	"skylark-domx-eventer",
	"skylark-domx-data",
	"skylark-domx-geom",
	"./iframes",
	"./load-real"
],function(eventer,datax,geom,iframes,loadReal){
	var pending;


  	function check() {
	    var i = 0;
	    var todo = [];
	    for (i = 0; i < pending.length; i++) {
	      if (geom.inview(pending[i], 400)) {
	        todo.unshift({ iframe: pending[i], i: i });
	      }
	    }

	    for (i = todo.length -1 ; i >=0 ; i--) {
	      pending.splice(todo[i].i, 1);
	      loadReal(todo[i].iframe);
	    }
  	}

	function init() {
		if (pending) {
			return
		}

		pending = [];

		eventer.on(window,"scroll",function(){
			check();
		});
	}

	function lazyLoad(iframe,options) {
		init();

		options = options || {};
	
      	///iframe.setAttribute('data-url', url);
      	///iframe.src = 'https://jsbin.com/embed-holding';
      	if (options.url) {
      		datax.attr(iframe,(options.urlAttrName || "data-url"),options.url)
      	}

      	if (options.holdingUrl) {
      		datax.prop(iframe,"src",options.holdingUrl)      		
      	}

		pending.push(iframe);
	}

	return iframes.lazyLoad = lazyLoad
});
define('skylark-domx-iframes/replace',[
  "skylark-langx-urls/get-query",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-styler",
  "./iframes",
  "./create",
  "./load-real",
  "./lazy-load"
],function(getQuery,noder,geom,styler,iframes,create,loadReal,lazyLoad){
  'use strict';
  
  function replace(link,options) {
    options = options || {};

    /*
    var iframe = noder.createElement('iframe',{
      "className" : link.className, // inherit all the classes from the link
      "id" : link.id, // also inherit, giving more style control to the user
      "style" : { "border" : '1px solid #aaa'}
    });
    */

    var ifarme =create({
      "className" : link.className, // inherit all the classes from the link
      "id" : link.id, // also inherit, giving more style control to the user
      "style" : { 
        "border" : '1px solid #aaa'
      }
    });
    ///var url = link.href.replace(/edit/, 'embed');
    var url = options.url || link.href,
        size = options.size || getQuery(link.search),
        holdingUrl = options.holdingUrl;

    styler.css(iframe,"width", size.width || '100%');
    styler.css(iframe,"minHeight", size.height || '300px');
    if (size.height) {
      styler.css(iframe,"maxHeight", size.height);
    }

    // track when it comes into view and reload
    if (geom.inview(link, 100)) {
      // the iframe is full view, let's render it
      ///iframe.src = url.split('&')[0];
      ///iframe._src = url.split('&')[0]; // support for google slide embed
      ///hookMessaging(iframe);
      loadReal(iframe,{url})
    } else {
      ///iframe.setAttribute('data-url', url);
      ///iframe.src = 'https://jsbin.com/embed-holding';
      ///pending.push(iframe);
      lazyLoad(iframe,{
        url,
        holdingUrl
      });

    }

    noder.replace(iframe, link);
  }

  return iframes.replace = replace;
});
define('skylark-domx-iframes/main',[
	"./iframes",
	"./create",
	"./lazy-load",
	"./load-real",
	"./replace"
],function(){
	
});
define('skylark-domx-iframes', ['skylark-domx-iframes/main'], function (main) { return main; });

define('skylark-domx/iframes',[
    "skylark-domx-iframes"
], function( iframes) {
    return iframes;
});
define('skylark-domx-lists/lists',[
	"skylark-langx-ns",
	"skylark-domx-query",
	"skylark-domx-data",
	"skylark-domx-geom",
	"skylark-domx-finder",
	"skylark-domx-noder",
	"skylark-domx-styler"
],function(skylark){
	return skylark.attach("domx.lists");
});
define('skylark-domx-lists/multitier',[
	"skylark-langx",
	"skylark-domx-query",
	"./lists"
],function(langx,$,lists){
  'use strict'

	function multitier(elm,options) {
		options = langx.mixin({

			classes : {
				active : "active",
				collapse : "collapse",
				in : "in",
			},

			selectors : {
				item : "li",                   // ".list-group-item"
				sublist : "ul",  // "> .list-group"
				hasSublist : ":has(ul)",
				handler : " > a"
			},


			mode   : "",  // "tree" or "accordion" or "popover"

			levels : 2,

			togglable : false,
			multiExpand : false,

			/*
			show : function($el) {
				$el.show();
			},

			hide : function($el) {
				//$el.hide();
				$el.add
			},

			toggle : function($el) {
				$el.toggle();
			}
			*/
		},options,true);

    var itemSelector = options.selectors.item,
        $items = $(itemSelector,elm),

        activeClass = options.classes.active,
        activeSelector = "." + activeClass,

		multitierMode = options.mode,

        sublistSelector = options.selectors.sublist,  
        togglable = options.togglable,   
        multiExpand = options.multiExpand,
        handlerSelector = options.selectors.handler,

        collapseClass = options.classes.collapse,
        inClass = options.classes.in,
        inSelector = "." + inClass,

        show = options.show || function($el) {
        	$el.addClass(inClass);
        },
        hide = options.hide || function($el) {
        	$el.addClass(collapseClass).removeClass(inClass);

        },
        toggle = options.toggle || function($el) {
			if ($el.hasClass(inClass)) {
				hide($el);
			} else {
				show($el);
			}
        };

     $items.find(handlerSelector).on("click.multitier", function(e) {
          e.preventDefault();

          let $children,
          	  $clickedItem =  $(this).closest(itemSelector);

          if (!multiExpand) {
              ///langx.scall($(this).closest(itemSelector).siblings().removeClass("active").children(sublistSelector+".in").plugin("domx.toggles.collapse"),"hide");
              //$clildren = $(this).closest(itemSelector).siblings().removeClass(activeClass).children(sublistSelector+"."+options.classes.in);
              $children = $clickedItem.siblings().removeClass(activeClass).children(sublistSelector);
              if ($children) {
	              hide($children);
              }
          }
          //$(this).closest(itemSelector).toggleClass(activeClass).children(sublistSelector).plugin("domx.toggles.collapse").toggle();
          let isActiveItem = $clickedItem.hasClass(activeClass);
          if (!isActiveItem || togglable) {
	          $children = $clickedItem.children(options.selectors.sublist);
	          if (isActiveItem) {
				$clickedItem.removeClass(activeClass);
				hide($children)  	
	          } else {
				$clickedItem.addClass(activeClass);
				show($children)  	
	          }

          }
      });

      hide($items.has(sublistSelector).children(sublistSelector));

      show($items.filter(activeSelector).has(sublistSelector).children(sublistSelector))


	}

	return lists.multitier = multitier
});
define('skylark-domx-lists/main',[
	"./lists",
	"./multitier"
],function(lists){
	return lists;
});
define('skylark-domx-lists', ['skylark-domx-lists/main'], function (main) { return main; });

define('skylark-domx/lists',[
    "skylark-domx-lists"
], function( lists) {

    return lists;
});
define('skylark-domx/noder',[
    "skylark-domx-noder"
], function( noder) {

    return noder;
});
define('skylark-domx/styler',[
    "skylark-domx-styler"
], function( styler) {

    return styler;
});
define('skylark-domx/query',[
    "skylark-domx-query",
    "./data",
    "./eventer",
    "./fx",
    "./geom",
    "./styler"
], function( query) {

    return query;

});
define('skylark-domx-transforms/transforms',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-data",
    "skylark-domx-styler"
], function(skylark,langx,browser,datax,styler) {
  var css3Transform = browser.normalizeCssProperty("transform");

  function getMatrix(radian, x, y) {
    var Cos = Math.cos(radian), Sin = Math.sin(radian);
    return {
      M11: Cos * x, 
      M12: -Sin * y,
      M21: Sin * x, 
      M22: Cos * y
    };
  }

  function getZoom(scale, zoom) {
      return scale > 0 && scale > -zoom ? zoom :
        scale < 0 && scale < zoom ? -zoom : 0;
  }

  function change(el,d) {
      var matrix = getMatrix(d.radian, d.y, d.x);
      styler.css(el,css3Transform, "matrix("
        + matrix.M11.toFixed(16) + "," + matrix.M21.toFixed(16) + ","
        + matrix.M12.toFixed(16) + "," + matrix.M22.toFixed(16) + ", 0, 0)"
      );      
  }

  function transformData(el,d) {
    if (d) {
      datax.data(el,"transform",d);
    } else {
      d = datax.data(el,"transform") || {};
      d.radian = d.radian || 0;
      d.x = d.x || 1;
      d.y = d.y || 1;
      d.zoom = d.zoom || 1;
      return d;     
    }
  }

  var calcs = {
    //Vertical flip
    vertical : function (d) {
        d.radian = Math.PI - d.radian; 
        d.y *= -1;
    },

   //Horizontal flip
    horizontal : function (d) {
        d.radian = Math.PI - d.radian; 
        d.x *= -1;
    },

    //Rotate according to angle
    rotate : function (d,degress) {
        d.radian = degress * Math.PI / 180;; 
    },

    //Turn left 90 degrees
    left : function (d) {
        d.radian -= Math.PI / 2; 
    },

    //Turn right 90 degrees
    right : function (d) {
        d.radian += Math.PI / 2; 
    },
 
    //zoom
    scale: function (d,zoom) {
        var hZoom = getZoom(d.y, zoom), vZoom = getZoom(d.x, zoom);
        if (hZoom && vZoom) {
          d.y += hZoom; 
          d.x += vZoom;
        }
    }, 

    //zoom in
    zoomin: function (d) { 
      calcs.scale(d,0.1); 
    },
    
    //zoom out
    zoomout: function (d) { 
      calcs.scale(d,-0.1); 
    }

  };
  
  
  function _createApiMethod(calcFunc) {
    return function() {
      var args = langx.makeArray(arguments),
        el = args.shift(),
          d = transformData(el);
        args.unshift(d);
        calcFunc.apply(this,args)
        change(el,d);
        transformData(el,d);
    }
  }
  

  function matrix(el) {
    var appliedTransforms = '';
    do {
      var transform = styler.css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (el = el.parentElement);

    if (window.DOMMatrix) {
      return new DOMMatrix(appliedTransforms);
    } else if (window.WebKitCSSMatrix) {
      return new WebKitCSSMatrix(appliedTransforms);
    } else if (window.CSSMatrix) {
      return new CSSMatrix(appliedTransforms);
    }
  }
   
  function transforms() {
    return transforms;
  }

  ["vertical","horizontal","rotate","left","right","scale","zoom","zoomin","zoomout"].forEach(function(name){
    transforms[name] = _createApiMethod(calcs[name]);
  });

  langx.mixin(transforms, {
    reset : function(el) {
      var d = {
        x : 1,
        y : 1,
        radian : 0,
      }
      change(el,d);
      transformData(el,d);
    },
    matrix
  });


  return skylark.attach("domx.transforms", transforms);
});

define('skylark-domx-transforms/main',[
	"./transforms"
],function(transforms){
	return transforms;
});
define('skylark-domx-transforms', ['skylark-domx-transforms/main'], function (main) { return main; });

define('skylark-domx/transforms',[
    "skylark-domx-transforms"
], function(transforms) {
  return transforms;
});

define('skylark-domx/transits',[
    "skylark-domx-transits"
], function( transits) {
    return transits;
});
define('skylark-domx/velm',[
    "skylark-domx-velm",
    "./data",
    "./eventer",
    "./fx",
    "./geom",
    "./styler"
], function( velm) {
     return velm;
});
define('skylark-domx/main',[
    "./animates",
    "./browser",
    "./css",
    "./data",
    "./eventer",
    "./finder",
    "./fx",
    "./geom",
    "./iframes",
    "./lists",
    "./noder",
    "./query",
    "./styler",
    "./transforms",
    "./transits",
    "./velm"
], function(animates,browser,css,data,eventer,finder,fx,geom,iframes,lists,noder,query,styler,transforms,transits,velm) {
    return {
        animates,
        browser,
        css,
        data,
        eventer,
        finder,
        geom,
        lists,
        noder,
        iframes,
        query,
        styler,
        transforms,
        transits,
        velm
    };
})
;
define('skylark-domx', ['skylark-domx/main'], function (main) { return main; });

define('skylark-domx-files/files',[
    "skylark-langx/skylark"
], function(skylark) {

    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
    }


    var files = function() {
        return files;
    };

    return skylark.attach("domx.files", files);
});
define('skylark-io-diskfs/diskfs',[
    "skylark-langx/skylark"
], function(skylark) {

    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
    }


    var diskfs = function() {
        return diskfs;
    };

    return skylark.attach("storages.diskfs", diskfs);
});
 define('skylark-io-diskfs/webentry',[
    "skylark-langx-arrays",
    "skylark-langx-async/deferred",
    "./diskfs"
],function(arrays,Deferred, diskfs){
    var concat = Array.prototype.concat;
    var webentry = (function() {
        function one(entry, path) {
            var d = new Deferred(),
                onError = function(e) {
                    d.reject(e);
                };

            path = path || '';
            if (entry.isFile) {
                entry.file(function(file) {
                    file.relativePath = path;
                    d.resolve(file);
                }, onError);
            } else if (entry.isDirectory) {
                var dirReader = entry.createReader();
                dirReader.readEntries(function(entries) {
                    all(
                        entries,
                        path + entry.name + '/'
                    ).then(function(files) {
                        d.resolve(files);
                    }).catch(onError);
                }, onError);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                d.resolve([]);
            }
            return d.promise;
        }

        function all(entries, path) {
            return Deferred.all(
                arrays.map(entries, function(entry) {
                    return one(entry, path);
                })
            ).then(function() {
                return concat.apply([], arguments);
            });
        }

        return {
            one: one,
            all: all
        };
    })();

    return diskfs.webentry = webentry;
});
  define('skylark-domx-files/dropzone',[
    "skylark-langx/arrays",
    "skylark-langx/deferred",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "skylark-domx-velm",
    "skylark-domx-query",   
    "skylark-io-diskfs/webentry",   
    "./files"
],function(arrays,Deferred, styler, eventer, velm, $, webentry, files){  /*
     * Make the specified element to could accept HTML5 file drag and drop.
     * @param {HTMLElement} elm
     * @param {PlainObject} params
     */
    function dropzone(elm, params) {
        params = params || {};
        var hoverClass = params.hoverClass || "hover",
            droppedCallback = params.dropped;

        var enterdCount = 0;
        eventer.on(elm, "dragenter", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                eventer.stop(e);
                enterdCount++;
                styler.addClass(elm, hoverClass)
            }
        });

        eventer.on(elm, "dragover", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                eventer.stop(e);
            }
        });

        eventer.on(elm, "dragleave", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                enterdCount--
                if (enterdCount == 0) {
                    styler.removeClass(elm, hoverClass);
                }
            }
        });

        eventer.on(elm, "drop", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                styler.removeClass(elm, hoverClass)
                eventer.stop(e);
                if (droppedCallback) {
                    var items = e.dataTransfer.items;
                    if (items && items.length && (items[0].webkitGetAsEntry ||
                            items[0].getAsEntry)) {
                        webentry.all(
                            arrays.map(items, function(item) {
                                if (item.webkitGetAsEntry) {
                                    return item.webkitGetAsEntry();
                                }
                                return item.getAsEntry();
                            })
                        ).then(droppedCallback);
                    } else {
                        droppedCallback(e.dataTransfer.files);
                    }
                }
            }
        });

        return this;
    }
    files.dropzone = dropzone;

    velm.delegate([
        "dropzone"
    ],files);


    $.fn.dropzone = $.wraps.wrapper_every_act(files.dropzone, files);

    return dropzone;
});
define('skylark-domx-files/pastezone',[
    "skylark-langx/objects",
    "skylark-domx-eventer",
    "skylark-domx-velm",
    "skylark-domx-query",   
    "./files"
],function(objects, eventer,velm,$, files){
    function pastezone(elm, params) {
        params = params || {};
        var hoverClass = params.hoverClass || "hover",
            pastedCallback = params.pasted;

        eventer.on(elm, "paste", function(e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                e.originalEvent.clipboardData.items,
                files = [];
            if (items && items.length) {
                objects.each(items, function(index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        files.push(file);
                    }
                });
            }
            if (pastedCallback && files.length) {
                pastedCallback(files);
            }
        });

        return this;
    }

    files.pastezone = pastezone;

    velm.delegate([
        "pastezone"
    ],files);

    $.fn.pastezone = $.wraps.wrapper_every_act(files.pastezone, files);

    return pastezone;

});

define('skylark-io-diskfs/select',[
    "./diskfs"
],function(diskfs){
    var fileInput,
        fileInputForm,
        fileSelected,
        maxFileSize = 1 / 0;

    function select(params) {
        params = params || {};
        var directory = params.directory || false,
            multiple = params.multiple || false,
            accept = params.accept || "", //'image/gif,image/jpeg,image/jpg,image/png,image/svg'
            title = params.title || "",
            fileSelected = params.picked;
        if (!fileInput) {
            var input = fileInput = document.createElement("input");

            input.type = "file";
            input.style.position = "fixed";
            input.style.left = 0;
            input.style.top = 0;
            input.style.opacity = .001;
            document.body.appendChild(input);

        }

        function selectFiles(pickedFiles) {
            for (var i = pickedFiles.length; i--;) {
                if (pickedFiles[i].size > maxFileSize) {
                    pickedFiles.splice(i, 1);
                }
            }
            fileSelected(pickedFiles);
        }

        fileInput.onchange = function(e) {
            var entries = e.target.webkitEntries || e.target.entries;

            if (entries && entries.length) {
                webentry.all(entries).then(function(files) {
                    selectFiles(files);
                });
            } else {
                selectFiles(Array.prototype.slice.call(e.target.files));
            }
            // reset to "", so selecting the same file next time still trigger the change handler
            fileInput.value = "";     
            fileInput.onchange = null;
        };
        
        fileInput.multiple = multiple;
        fileInput.accept = accept;
        fileInput.title = title;

        fileInput.webkitdirectory = directory;
        fileInput.click();
    }

    return diskfs.select = select;
});


define('skylark-domx-files/picker',[
    "skylark-langx/objects",
    "skylark-domx-eventer",
    "skylark-domx-velm",
    "skylark-domx-query",   
    "skylark-io-diskfs/select",
    "./files"
],function(objects, eventer, velm, $, select, files){
    /*
     * Make the specified element to pop-up the file selection dialog box when clicked , and read the contents the files selected from client file system by user.
     * @param {HTMLElement} elm
     * @param {PlainObject} params
     */
    function picker(elm, params) {
        eventer.on(elm, "click", function(e) {
            e.preventDefault();
            select(params);
        });
        return this;
    }

    files.picker = picker;

    velm.delegate([
        "picker"
    ],files);

    $.fn.picker = $.wraps.wrapper_every_act(files.picker, files);

    return picker;

});



define('skylark-domx-files/main',[
	"./files",
	"./dropzone",
	"./pastezone",
	"./picker"
],function(files){
	return files;
});
define('skylark-domx-files', ['skylark-domx-files/main'], function (main) { return main; });

define('skylark-domx-images/images',[
    "skylark-langx/skylark"
], function(skylark) {

  function images() {
    return images;
  }

  return skylark.attach("domx.images" , images);
});

define('skylark-domx-images/is-completed',[
	"./images"
],function(images){
  function isCompleted(img) {
     return img.complete && img.naturalWidth !== undefined;
  }

  return images.isCompleted = isCompleted;
});
define('skylark-domx-images/is-loaded',[
	"./images"
],function(images){

  function isLoaded(img) {
    return img.complete && img.naturalWidth !== 0;
  }
  return images.isLoaded = isLoaded;
});
define('skylark-domx-images/watch',[
    "skylark-langx/langx",
    "skylark-domx-eventer",
    "./images",
    "./is-completed",
    "./is-loaded"
], function(langx,eventer,images,isCompleted,isLoaded) {

  function watch(imgs) {
    if (!langx.isArray(imgs)) {
      imgs = [imgs];
    }
    var totalCount = imgs.length,
        progressedCount = 0,
        successedCount = 0,
        faileredCount = 0,
        d = new langx.Deferred();


    function complete() {

      d.resolve({
        "total" : totalCount,
        "successed" : successedCount,
        "failered" : faileredCount,
        "imgs" : imgs 
      });
    }

    function progress(img,isLoaded) {

      progressedCount++;
      if (isLoaded) {
        successedCount ++ ; 
      } else {
        faileredCount ++ ;
      }

      // progress event
      d.progress({
        "img" : img,
        "isLoaded" : isLoaded,
        "progressed" : progressedCount,
        "total" : totalCount,
        "imgs" : imgs 
      });

      // check if completed
      if ( progressedCount == totalCount ) {
        complete();
      }
    }

    function check() {
      if (!imgs.length ) {
        complete();
        return;
      }

      imgs.forEach(function(img) {
        if (isCompleted(img)) {
          progress(img,isLoaded(img));
        } else {
          eventer.on(img,{
            "load" : function() {
              progress(img,true);
            },

            "error" : function() {
              progress(img,false);
            }
          });      
        }
      });
    }

    langx.defer(check);

    d.promise.totalCount = totalCount;
    return d.promise;
  }



  return images.watch = watch;
});

define('skylark-domx-images/loaded',[
	"skylark-domx-finder",
	"./images",
	"./watch"
],function(finder,images,watch){

  function loaded(elm,options) {
    var imgs = [];

    options = options || {};

    function addBackgroundImage (elm1) {

      var reURL = /url\((['"])?(.*?)\1\)/gi;
      var matches = reURL.exec( styler.css(elm1,"background-image"));
      var url = matches && matches[2];
      if ( url ) {
        var img = new Image();
        img.src = url;
        imgs.push(img);
      }
    }

    // filter siblings
    if ( elm.nodeName == 'IMG' ) {
      imgs.push( elm );
    } else {
      // find children
      var childImgs = finder.findAll(elm,'img');
      // concat childElems to filterFound array
      for ( var i=0; i < childImgs.length; i++ ) {
        imgs.push(childImgs[i]);
      }

      // get background image on element
      if ( options.background === true ) {
        addBackgroundImage(elm);
      } else  if ( typeof options.background == 'string' ) {
        var children = finder.findAll(elm, options.background );
        for ( i=0; i < children.length; i++ ) {
          addBackgroundImage( children[i] );
        }
      }
    }

    return watch(imgs);
  }

  return images.loaded = loaded;
});
define('skylark-domx-images/preload',[
    "skylark-langx/langx",
	"./images",
	"./watch"
],function(langx,images,watch){
  function preload(urls,options) {
      if (langx.isString(urls)) {
        urls = [urls];
      }
      var images = [];

      urls.forEach(function(url){
        var img = new Image();
        img.src = url;
        images.push(img);
      });

      return watch(images);
  }

  return images.preload = preload;
});
define('skylark-domx-images/transform',[
    "skylark-domx-transforms",
    "./images"
], function(transforms,images) {


  function transform(el,options) {
  }

  ["vertical","horizontal","rotate","left","right","scale","zoom","zoomin","zoomout","reset"].forEach(
    function(name){
      transform[name] = transforms[name];
    }
  );



  return images.transform = transform;
});

define('skylark-domx-images/viewer',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-transforms",
    "./images"
], function(langx,noder,geom,styler,transforms,images) {




  function viewer(el,options) {
    var img ,
        style = {},
        clientSize = geom.clientSize(el),
        loadedCallback = options.loaded,
        faileredCallback = options.failered;

    function onload() {
        styler.css(img,{//center
          top: (clientSize.height - img.offsetHeight) / 2 + "px",
          left: (clientSize.width - img.offsetWidth) / 2 + "px"
        });

        transforms.reset(img);

        styler.css(img,{
          visibility: "visible"
        });

        if (loadedCallback) {
          loadedCallback();
        }
    }

    function onerror() {

    }
    function _init() {
      style = styler.css(el,["position","overflow"]);
      if (style.position != "relative" && style.position != "absolute") { 
        styler.css(el,"position", "relative" );
      }
      styler.css(el,"overflow", "hidden" );

      img = new Image();

      styler.css(img,{
        position: "absolute",
        border: 0, padding: 0, margin: 0, width: "auto", height: "auto",
        visibility: "hidden"
      });

      img.onload = onload;
      img.onerror = onerror;

      noder.append(el,img);

      if (options.url) {
        _load(options.url);
      }
    }

    function _load(url) {
        img.style.visibility = "hidden";
        img.src = url;
    }

    function _dispose() {
        noder.remove(img);
        styler.css(el,style);
        img = img.onload = img.onerror = null;
    }

    _init();

    var ret =  {
      load : _load,
      dispose : _dispose
    };

    ["vertical","horizontal","rotate","left","right","scale","zoom","zoomin","zoomout","reset"].forEach(
      function(name){
        ret[name] = function() {
          var args = langx.makeArray(arguments);
          args.unshift(img);
          transforms[name].apply(null,args);
        }
      }
    );

    return ret;
  }


  return images.viewer = viewer;
});
define('skylark-domx-images/main',[
	"skylark-domx-query",
	"skylark-domx-velm",
	"./images",
	"./is-completed",
	"./is-loaded",
	"./loaded",
	"./preload",
	"./transform",
	"./viewer",
	"./watch"
],function($,elmx,images,isCompleted,isLoaded,loaded,preload,transform,viewer,watch){

  elmx.delegate([
  	"imageIsCompleted",
  	"imageIsLoaded",
  	"imageLoaded",
  	"imageViewer"
  ],images,{
  	"imageIsCompleted" : "isCompleted",
  	"imageIsLoaded" : "isLoaded",
  	"imageLoaded" : "loaded",
  	"imageViewer" : "viewer"  	
  });

	return images;
});
define('skylark-domx-images', ['skylark-domx-images/main'], function (main) { return main; });

define('skylark-domx-i18n/i18n',[
	"skylark-langx/skylark",
	"skylark-domx-query",
	"skylark-domx-data",
	"skylark-domx-styler"	
],function(skylark){
	return skylark.attach("domx.i18n",{
		/**
		 * Escape translator patterns in text
		 * @param {string} text
		 * @returns {string}
		 */
		escape : function escape(text) {
			return typeof text === 'string' ? text.replace(/\[\[/g, '&lsqb;&lsqb;').replace(/\]\]/g, '&rsqb;&rsqb;') : text;
		},

		/**
		 * Unescape escaped translator patterns in text
		 * @param {string} text
		 * @returns {string}
		 */
		unescape : function unescape(text) {
			return typeof text === 'string' ? text.replace(/&lsqb;|\\\[/g, '[').replace(/&rsqb;|\\\]/g, ']') : text;
		},

		/**
		 * Construct a translator pattern
		 * @param {string} name - Translation name
		 * @param {...string} arg - Optional argument for the pattern
		 */
		compile : function compile() {
			var args = Array.prototype.slice.call(arguments, 0).map(function (text) {
				// escape commas and percent signs in arguments
				return String(text).replace(/%/g, '&#37;').replace(/,/g, '&#44;');
			});

			return '[[' + args.join(', ') + ']]';
		}
	});
});
define('skylark-domx-i18n/Translator',[
	"skylark-langx/langx",
	"./i18n"
],function(langx,i18n) {
	var HTMLEntities = Object.freeze({
		amp: '&',
		gt: '>',
		lt: '<',
		quot: '"',
		apos: "'",
		AElig: 198,
		Aacute: 193,
		Acirc: 194,
		Agrave: 192,
		Aring: 197,
		Atilde: 195,
		Auml: 196,
		Ccedil: 199,
		ETH: 208,
		Eacute: 201,
		Ecirc: 202,
		Egrave: 200,
		Euml: 203,
		Iacute: 205,
		Icirc: 206,
		Igrave: 204,
		Iuml: 207,
		Ntilde: 209,
		Oacute: 211,
		Ocirc: 212,
		Ograve: 210,
		Oslash: 216,
		Otilde: 213,
		Ouml: 214,
		THORN: 222,
		Uacute: 218,
		Ucirc: 219,
		Ugrave: 217,
		Uuml: 220,
		Yacute: 221,
		aacute: 225,
		acirc: 226,
		aelig: 230,
		agrave: 224,
		aring: 229,
		atilde: 227,
		auml: 228,
		ccedil: 231,
		eacute: 233,
		ecirc: 234,
		egrave: 232,
		eth: 240,
		euml: 235,
		iacute: 237,
		icirc: 238,
		igrave: 236,
		iuml: 239,
		ntilde: 241,
		oacute: 243,
		ocirc: 244,
		ograve: 242,
		oslash: 248,
		otilde: 245,
		ouml: 246,
		szlig: 223,
		thorn: 254,
		uacute: 250,
		ucirc: 251,
		ugrave: 249,
		uuml: 252,
		yacute: 253,
		yuml: 255,
		copy: 169,
		reg: 174,
		nbsp: 160,
		iexcl: 161,
		cent: 162,
		pound: 163,
		curren: 164,
		yen: 165,
		brvbar: 166,
		sect: 167,
		uml: 168,
		ordf: 170,
		laquo: 171,
		not: 172,
		shy: 173,
		macr: 175,
		deg: 176,
		plusmn: 177,
		sup1: 185,
		sup2: 178,
		sup3: 179,
		acute: 180,
		micro: 181,
		para: 182,
		middot: 183,
		cedil: 184,
		ordm: 186,
		raquo: 187,
		frac14: 188,
		frac12: 189,
		frac34: 190,
		iquest: 191,
		times: 215,
		divide: 247,
		'OElig;': 338,
		'oelig;': 339,
		'Scaron;': 352,
		'scaron;': 353,
		'Yuml;': 376,
		'fnof;': 402,
		'circ;': 710,
		'tilde;': 732,
		'Alpha;': 913,
		'Beta;': 914,
		'Gamma;': 915,
		'Delta;': 916,
		'Epsilon;': 917,
		'Zeta;': 918,
		'Eta;': 919,
		'Theta;': 920,
		'Iota;': 921,
		'Kappa;': 922,
		'Lambda;': 923,
		'Mu;': 924,
		'Nu;': 925,
		'Xi;': 926,
		'Omicron;': 927,
		'Pi;': 928,
		'Rho;': 929,
		'Sigma;': 931,
		'Tau;': 932,
		'Upsilon;': 933,
		'Phi;': 934,
		'Chi;': 935,
		'Psi;': 936,
		'Omega;': 937,
		'alpha;': 945,
		'beta;': 946,
		'gamma;': 947,
		'delta;': 948,
		'epsilon;': 949,
		'zeta;': 950,
		'eta;': 951,
		'theta;': 952,
		'iota;': 953,
		'kappa;': 954,
		'lambda;': 955,
		'mu;': 956,
		'nu;': 957,
		'xi;': 958,
		'omicron;': 959,
		'pi;': 960,
		'rho;': 961,
		'sigmaf;': 962,
		'sigma;': 963,
		'tau;': 964,
		'upsilon;': 965,
		'phi;': 966,
		'chi;': 967,
		'psi;': 968,
		'omega;': 969,
		'thetasym;': 977,
		'upsih;': 978,
		'piv;': 982,
		'ensp;': 8194,
		'emsp;': 8195,
		'thinsp;': 8201,
		'zwnj;': 8204,
		'zwj;': 8205,
		'lrm;': 8206,
		'rlm;': 8207,
		'ndash;': 8211,
		'mdash;': 8212,
		'lsquo;': 8216,
		'rsquo;': 8217,
		'sbquo;': 8218,
		'ldquo;': 8220,
		'rdquo;': 8221,
		'bdquo;': 8222,
		'dagger;': 8224,
		'Dagger;': 8225,
		'bull;': 8226,
		'hellip;': 8230,
		'permil;': 8240,
		'prime;': 8242,
		'Prime;': 8243,
		'lsaquo;': 8249,
		'rsaquo;': 8250,
		'oline;': 8254,
		'frasl;': 8260,
		'euro;': 8364,
		'image;': 8465,
		'weierp;': 8472,
		'real;': 8476,
		'trade;': 8482,
		'alefsym;': 8501,
		'larr;': 8592,
		'uarr;': 8593,
		'rarr;': 8594,
		'darr;': 8595,
		'harr;': 8596,
		'crarr;': 8629,
		'lArr;': 8656,
		'uArr;': 8657,
		'rArr;': 8658,
		'dArr;': 8659,
		'hArr;': 8660,
		'forall;': 8704,
		'part;': 8706,
		'exist;': 8707,
		'empty;': 8709,
		'nabla;': 8711,
		'isin;': 8712,
		'notin;': 8713,
		'ni;': 8715,
		'prod;': 8719,
		'sum;': 8721,
		'minus;': 8722,
		'lowast;': 8727,
		'radic;': 8730,
		'prop;': 8733,
		'infin;': 8734,
		'ang;': 8736,
		'and;': 8743,
		'or;': 8744,
		'cap;': 8745,
		'cup;': 8746,
		'int;': 8747,
		'there4;': 8756,
		'sim;': 8764,
		'cong;': 8773,
		'asymp;': 8776,
		'ne;': 8800,
		'equiv;': 8801,
		'le;': 8804,
		'ge;': 8805,
		'sub;': 8834,
		'sup;': 8835,
		'nsub;': 8836,
		'sube;': 8838,
		'supe;': 8839,
		'oplus;': 8853,
		'otimes;': 8855,
		'perp;': 8869,
		'sdot;': 8901,
		'lceil;': 8968,
		'rceil;': 8969,
		'lfloor;': 8970,
		'rfloor;': 8971,
		'lang;': 9001,
		'rang;': 9002,
		'loz;': 9674,
		'spades;': 9824,
		'clubs;': 9827,
		'hearts;': 9829,
		'diams;': 9830,
	});

	// https://github.com/substack/node-ent/blob/master/index.js
	function decodeHTMLEntities(html) {
		return String(html)
			.replace(/&#(\d+);?/g, function (_, code) {
				return String.fromCharCode(code);
			})
			.replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {
				return String.fromCharCode(parseInt(hex, 16));
			})
			.replace(/&([^;\W]+;?)/g, function (m, e) {
				var ee = e.replace(/;$/, '');
				var target = HTMLEntities[e] || (e.match(/;$/) && HTMLEntities[ee]);

				if (typeof target === 'number') {
					return String.fromCharCode(target);
				} else if (typeof target === 'string') {
					return target;
				}

				return m;
			});
	}	

	function escapeHTML(str) {
		return langx.escapeHTML(decodeHTMLEntities(
			String(str)
				.replace(/[\s\xa0]+/g, ' ')
				.replace(/^\s+|\s+$/g, '')
		));
	}

	//function load(language, namespace) {
	//	return Promise.resolve(jQuery.getJSON(config.relative_path + '/assets/language/' + language + '/' + namespace + '.json?' + config['cache-buster']));
	//}

	var warn = function () { console.warn.apply(console, arguments); };

	var assign = Object.assign || jQuery.extend;


	/**
	 * Construct a new Translator object
	 * @param {string} language - Language code for this translator instance
	 * @exports translator.Translator
	 */
	function Translator(language,load) {
		var self = this;

		if (!language) {
			throw new TypeError('Parameter `language` must be a language string. Received ' + language + (language === '' ? '(empty string)' : ''));
		}

		self.modules = Object.keys(Translator.moduleFactories).map(function (namespace) {
			var factory = Translator.moduleFactories[namespace];
			return [namespace, factory(language)];
		}).reduce(function (prev, elem) {
			var namespace = elem[0];
			var module = elem[1];
			prev[namespace] = module;

			return prev;
		}, {});

		self.lang = language;
		self.translations = {};
		self.load = load;
	}

	//Translator.prototype.load = load;

	/**
	 * Parse the translation instructions into the language of the Translator instance
	 * @param {string} str - Source string
	 * @returns {Promise<string>}
	 */
	Translator.prototype.translate = function translate(str) {
		// regex for valid text in namespace / key
		var validText = 'a-zA-Z0-9\\-_.\\/';
		var validTextRegex = new RegExp('[' + validText + ']');
		var invalidTextRegex = new RegExp('[^' + validText + '\\]]');

		// current cursor position
		var cursor = 0;
		// last break of the input string
		var lastBreak = 0;
		// length of the input string
		var len = str.length;
		// array to hold the promises for the translations
		// and the strings of untranslated text in between
		var toTranslate = [];

		// to store the state of if we're currently in a top-level token for later
		var inToken = false;

		// split a translator string into an array of tokens
		// but don't split by commas inside other translator strings
		function split(text) {
			var len = text.length;
			var arr = [];
			var i = 0;
			var brk = 0;
			var level = 0;

			while (i + 2 <= len) {
				if (text[i] === '[' && text[i + 1] === '[') {
					level += 1;
					i += 1;
				} else if (text[i] === ']' && text[i + 1] === ']') {
					level -= 1;
					i += 1;
				} else if (level === 0 && text[i] === ',' && text[i - 1] !== '\\') {
					arr.push(text.slice(brk, i).trim());
					i += 1;
					brk = i;
				}
				i += 1;
			}
			arr.push(text.slice(brk, i + 1).trim());
			return arr;
		}

		// move to the first [[
		cursor = str.indexOf('[[', cursor);

		// the loooop, we'll go to where the cursor
		// is equal to the length of the string since
		// slice doesn't include the ending index
		while (cursor + 2 <= len && cursor !== -1) {
			// split the string from the last break
			// to the character before the cursor
			// add that to the result array
			toTranslate.push(str.slice(lastBreak, cursor));
			// set the cursor position past the beginning
			// brackets of the translation string
			cursor += 2;
			// set the last break to our current
			// spot since we just broke the string
			lastBreak = cursor;
			// we're in a token now
			inToken = true;

			// the current level of nesting of the translation strings
			var level = 0;
			var char0;
			var char1;
			// validating the current string is actually a translation
			var textBeforeColonFound = false;
			var colonFound = false;
			var textAfterColonFound = false;
			var commaAfterNameFound = false;

			while (cursor + 2 <= len) {
				char0 = str[cursor];
				char1 = str[cursor + 1];
				// found some text after the double bracket,
				// so this is probably a translation string
				if (!textBeforeColonFound && validTextRegex.test(char0)) {
					textBeforeColonFound = true;
					cursor += 1;
				// found a colon, so this is probably a translation string
				} else if (textBeforeColonFound && !colonFound && char0 === ':') {
					colonFound = true;
					cursor += 1;
				// found some text after the colon,
				// so this is probably a translation string
				} else if (colonFound && !textAfterColonFound && validTextRegex.test(char0)) {
					textAfterColonFound = true;
					cursor += 1;
				} else if (textAfterColonFound && !commaAfterNameFound && char0 === ',') {
					commaAfterNameFound = true;
					cursor += 1;
				// a space or comma was found before the name
				// this isn't a translation string, so back out
				} else if (!(textBeforeColonFound && colonFound && textAfterColonFound && commaAfterNameFound) &&
						invalidTextRegex.test(char0)) {
					cursor += 1;
					lastBreak -= 2;
					// no longer in a token
					inToken = false;
					if (level > 0) {
						level -= 1;
					} else {
						break;
					}
				// if we're at the beginning of another translation string,
				// we're nested, so add to our level
				} else if (char0 === '[' && char1 === '[') {
					level += 1;
					cursor += 2;
				// if we're at the end of a translation string
				} else if (char0 === ']' && char1 === ']') {
					// if we're at the base level, then this is the end
					if (level === 0) {
						// so grab the name and args
						var currentSlice = str.slice(lastBreak, cursor);
						var result = split(currentSlice);
						var name = result[0];
						var args = result.slice(1);

						// make a backup based on the raw string of the token
						// if there are arguments to the token
						var backup = '';
						if (args && args.length) {
							backup = this.translate(currentSlice);
						}
						// add the translation promise to the array
						toTranslate.push(this.translateKey(name, args, backup));
						// skip past the ending brackets
						cursor += 2;
						// set this as our last break
						lastBreak = cursor;
						// and we're no longer in a translation string,
						// so continue with the main loop
						inToken = false;
						break;
					}
					// otherwise we lower the level
					level -= 1;
					// and skip past the ending brackets
					cursor += 2;
				} else {
					// otherwise just move to the next character
					cursor += 1;
				}
			}

			// skip to the next [[
			cursor = str.indexOf('[[', cursor);
		}

		// ending string of source
		var last = str.slice(lastBreak);

		// if we were mid-token, treat it as invalid
		if (inToken) {
			last = this.translate(last);
		}

		// add the remaining text after the last translation string
		toTranslate.push(last);

		// and return a promise for the concatenated translated string
		return Promise.all(toTranslate).then(function (translated) {
			return translated.join('');
		});
	};

	/**
	 * Translates a specific key and array of arguments
	 * @param {string} name - Translation key (ex. 'global:home')
	 * @param {string[]} args - Arguments for `%1`, `%2`, etc
	 * @param {string|Promise<string>} backup - Text to use in case the key can't be found
	 * @returns {Promise<string>}
	 */
	Translator.prototype.translateKey = function translateKey(name, args, backup) {
		var self = this;

		var result = name.split(':', 2);
		var namespace = result[0];
		var key = result[1];

		if (self.modules[namespace]) {
			return Promise.resolve(self.modules[namespace](key, args));
		}

		if (namespace && !key) {
			warn('Missing key in translation token "' + name + '"');
			return Promise.resolve('[[' + namespace + ']]');
		}

		var translation = this.getTranslation(namespace, key);
		return translation.then(function (translated) {
			// check if the translation is missing first
			if (!translated) {
				warn('Missing translation "' + name + '"');
				return backup || key;
			}

			var argsToTranslate = args.map(function (arg) {
				return self.translate(escapeHTML(arg));
			});

			return Promise.all(argsToTranslate).then(function (translatedArgs) {
				var out = translated;
				translatedArgs.forEach(function (arg, i) {
					var escaped = arg.replace(/%(?=\d)/g, '&#37;').replace(/\\,/g, '&#44;');
					out = out.replace(new RegExp('%' + (i + 1), 'g'), escaped);
				});
				return out;
			});
		});
	};

	/**
	 * Load translation file (or use a cached version), and optionally return the translation of a certain key
	 * @param {string} namespace - The file name of the translation namespace
	 * @param {string} [key] - The key of the specific translation to getJSON
	 * @returns {Promise<{ [key: string]: string } | string>}
	 */
	Translator.prototype.getTranslation = function getTranslation(namespace, key) {
		var translation;
		if (!namespace) {
			warn('[translator] Parameter `namespace` is ' + namespace + (namespace === '' ? '(empty string)' : ''));
			translation = Promise.resolve({});
		} else {
			this.translations[namespace] = this.translations[namespace] || this.load(this.lang, namespace).catch(function () { return {}; });
			translation = this.translations[namespace];
		}

		if (key) {
			return translation.then(function (x) {
				return x && x[key]; // modified by lwf
			});
		}
		return translation;
	};

	/**
	 * @param {Node} node
	 * @returns {Node[]}
	 */
	function descendantTextNodes(node) {
		var textNodes = [];

		function helper(node) {
			if (node.nodeType === 3) {
				textNodes.push(node);
			} else {
				for (var i = 0, c = node.childNodes, l = c.length; i < l; i += 1) {
					helper(c[i]);
				}
			}
		}

		helper(node);
		return textNodes;
	}

	/**
	 * Recursively translate a DOM element in place
	 * @param {Element} element - Root element to translate
	 * @param {string[]} [attributes] - Array of node attributes to translate
	 * @returns {Promise<void>}
	 */
	Translator.prototype.translateInPlace = function translateInPlace(element, attributes) {
		attributes = attributes || ['placeholder', 'title'];

		var nodes = descendantTextNodes(element);
		var text = nodes.map(function (node) {
			return node.nodeValue;
		}).join('  ||  ');

		var attrNodes = attributes.reduce(function (prev, attr) {
			var tuples = Array.prototype.map.call(element.querySelectorAll('[' + attr + '*="[["]'), function (el) {
				return [attr, el];
			});
			return prev.concat(tuples);
		}, []);
		var attrText = attrNodes.map(function (node) {
			return node[1].getAttribute(node[0]);
		}).join('  ||  ');

		return Promise.all([
			this.translate(text),
			this.translate(attrText),
		]).then(function (ref) {
			var translated = ref[0];
			var translatedAttrs = ref[1];
			if (translated) {
				translated.split('  ||  ').forEach(function (html, i) {
					$(nodes[i]).replaceWith(html);
				});
			}
			if (translatedAttrs) {
				translatedAttrs.split('  ||  ').forEach(function (text, i) {
					attrNodes[i][1].setAttribute(attrNodes[i][0], text);
				});
			}
		});
	};

	/**
	 * Get the language of the current environment, falling back to defaults
	 * @returns {string}
	 */
	Translator.getLanguage = function getLanguage() {
		//var lang;
		//if (typeof window === 'object' && window.config && window.utils) {
		//	lang = utils.params().lang || config.userLang || config.defaultLang || 'en-GB';
		//} else {
		//	var meta = require('./meta');
		//	lang = meta.config && meta.config.defaultLang ? meta.config.defaultLang : 'en-GB';
		//}
		//return lang;

		return 'en-GB';
	};

	/**
	 * Create and cache a new Translator instance, or return a cached one
	 * @param {string} [language] - ('en-GB') Language string
	 * @returns {Translator}
	 */
	Translator.create = function create(language) {
		if (!language) {
			language = Translator.getLanguage();
		}

		Translator.cache[language] = Translator.cache[language] || new Translator(language);

		return Translator.cache[language];
	};

	Translator.cache = {};

	/**
	 * Register a custom module to handle translations
	 * @param {string} namespace - Namespace to handle translation for
	 * @param {Function} factory - Function to return the translation function for this namespace
	 */
	Translator.registerModule = function registerModule(namespace, factory) {
		Translator.moduleFactories[namespace] = factory;

		Object.keys(Translator.cache).forEach(function (key) {
			var translator = Translator.cache[key];
			translator.modules[namespace] = factory(translator.lang);
		});
	};

	Translator.moduleFactories = {};

	/**
	 * Remove the translator patterns from text
	 * @param {string} text
	 * @returns {string}
	 */
	Translator.removePatterns = function removePatterns(text) {
		var len = text.length;
		var cursor = 0;
		var lastBreak = 0;
		var level = 0;
		var out = '';
		var sub;

		while (cursor < len) {
			sub = text.slice(cursor, cursor + 2);
			if (sub === '[[') {
				if (level === 0) {
					out += text.slice(lastBreak, cursor);
				}
				level += 1;
				cursor += 2;
			} else if (sub === ']]') {
				level -= 1;
				cursor += 2;
				if (level === 0) {
					lastBreak = cursor;
				}
			} else {
				cursor += 1;
			}
		}
		out += text.slice(lastBreak, cursor);
		return out;
	};


	return i18n.Translator = Translator;


});
define('skylark-domx-i18n/translate',[
	"./i18n",
	"./Translator"
],function(i18n,Translator){
	/**
	 * Legacy translator function for backwards compatibility
	 */
	function translate(text, language, callback) {
		// TODO: deprecate?

		var cb = callback;
		var lang = language;
		if (typeof language === 'function') {
			cb = language;
			lang = null;
		}

		if (!(typeof text === 'string' || text instanceof String) || text === '') {
			return cb('');
		}

		return Translator.create(lang).translate(text).then(function (output) {
			if (cb) {
				setTimeout(cb, 0, output);
			}
			return output;
		}, function (err) {
			console.warn('Translation failed: ' + err.stack);
		});
	}

	return i18n.translate = translate;
	
});
define('skylark-domx-i18n/prepareDom',[
	"skylark-domx-query",
	"./i18n",
	"./translate"
],function($,i18n,translate){

	return i18n.prepareDOM = function prepareDOM() {
		// Add directional code if necessary
		translate('[[language:dir]]', function (value) {
			if (value && !$('html').attr('data-dir')) {
				$('html').css('direction', value).attr('data-dir', value);
			}
		});
	};
	
});
define('skylark-domx-i18n/addTranslation',[
	"skylark-domx-query",
	"./i18n",
	"./Translator"
],function($,i18n,Translator){

	/**
	 * Add translations to the cache
	 */
	return i18n.addTranslation = function addTranslation(language, namespace, translation) {
		Translator.create(language).getTranslation(namespace).then(function (translations) {
			assign(translations, translation);
		});
	};
	
});
define('skylark-domx-i18n/getTranslations',[
	"skylark-domx-query",
	"./i18n",
	"./Translator"
],function($,i18n,Translator){

	/**
	 * Get the translations object
	 */
	return i18n.getTranslations =  function getTranslations(language, namespace, callback) {
		callback = callback || function () {};
		Translator.create(language).getTranslation(namespace).then(callback);
	};
	
});
define('skylark-domx-i18n/main',[
	"./i18n",
	"./Translator",
	"./prepareDom",
	"./translate",
	"./addTranslation",
	"./getTranslations"
],function(i18n){
	return i18n;
});
define('skylark-domx-i18n', ['skylark-domx-i18n/main'], function (main) { return main; });

define('skylark-domx-plugins-base/plugins',[
    "skylark-langx-ns"
], function(skylark) {
    "use strict";

    var pluginKlasses = {},
        shortcuts = {};


    return  skylark.attach("domx.plugins",{
        pluginKlasses,
        shortcuts
    });
});
define('skylark-domx-plugins-base/plugin',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "skylark-langx-objects",
    "skylark-langx-funcs",
    "skylark-langx-events/Emitter",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-query",
    "skylark-domx-velm",
    "./plugins"
], function(
    skylark,
    types,
    objects,
    funcs,
    Emitter, 
    noder, 
    datax, 
    eventer, 
    finder, 
    geom, 
    styler, 
    fx, 
    $, 
    elmx,
    plugins
) {
    "use strict";

    var slice = Array.prototype.slice,
        concat = Array.prototype.concat;

    function parentClass(ctor){
        if (ctor.hasOwnProperty("superclass")) {
            return ctor.superclass;
        }

        return Object.getPrototypeOf(ctor);
    }

 
    var Plugin =   Emitter.inherit({
        klassName: "Plugin",

        _construct : function(elm,options) {
           this._elm = elm;
           this._initOptions(options);
        },

        _initOptions : function(options) {
          var ctor = this.constructor,
              cache = ctor.cache = (ctor.hasOwnProperty("cache") ? ctor.cache : {}),
              defaults = cache.defaults;
          if (!defaults) {
            var  ctors = [];
            do {
              ctors.unshift(ctor);
              if (ctor === Plugin) {
                break;
              }
              ctor = parentClass(ctor);
            } while (ctor);

            defaults = cache.defaults = {};
            for (var i=0;i<ctors.length;i++) {
              ctor = ctors[i];
              if (ctor.prototype.hasOwnProperty("options")) {
                objects.mixin(defaults,ctor.prototype.options,true);
              }
              if (ctor.hasOwnProperty("options")) {
                objects.mixin(defaults,ctor.options,true);
              }
            }
          }
          Object.defineProperty(this,"options",{
            value :objects.mixin({},defaults,options,true)
          });

          //return this.options = langx.mixin({},defaults,options);
          return this.options;
        },


        destroy: function() {

            this._destroy();

            // remove all event lisener
            this.unlistenTo();
            // remove data 
            datax.removeData(this._elm,this.pluginName );
        },

        _destroy: funcs.noop,

        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },

        elmx : function(elm) {
            if (elm) {
                return elmx(elm);
            }
            if (!this._velm) {
                this._velm = elmx(this._elm);
            }
            return this._velm;
        },

        $ : function(elm) {
            if (elm) {
                return $(elm,this._elm);
            }
            if (!this._$elm) {
                this._$elm = $(this._elm);
            }            
            return this._$elm;
        },

        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if ( arguments.length === 0 ) {

                // Don't return a reference to the internal hash
                return objects.mixin( {}, this.options );
            }

            if ( typeof key === "string" ) {

                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = objects.mixin( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }

            this._setOptions( options );

            return this;
        },

        _setOptions: function( options ) {
            var key;

            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }

            return this;
        },

        _setOption: function( key, value ) {

            this.options[ key ] = value;

            return this;
        },

        getUID : function (prefix) {
            prefix = prefix || "plugin";
            do prefix += ~~(Math.random() * 1000000)
            while (document.getElementById(prefix))
            return prefix;
        },

        elm : function() {
            return this._elm;
        }

    });


    return  plugins.Plugin = Plugin;
});
define('skylark-domx-plugins-base/instantiate',[
    "skylark-domx-data",
    "./plugins",
    "./plugin"
], function(
    datax, 
    plugins,
    Plugin
) {
    "use strict";

    var pluginKlasses = plugins.pluginKlasses;

    /*
     * Create or get or destory a plugin instance assocated with the element.
     */
    function instantiate(elm,pluginName,options) {
        var pair = pluginName.split(":"),
            instanceDataName = pair[1];
        pluginName = pair[0];

        if (!instanceDataName) {
            instanceDataName = pluginName;
        }

        var pluginInstance = datax.data( elm, instanceDataName );

        if (options === "instance") {
            return pluginInstance;
        } else if (options === "destroy") {
            if (!pluginInstance) {
                throw new Error ("The plugin instance is not existed");
            }
            pluginInstance.destroy();
            //datax.removeData( elm, pluginName);
            pluginInstance = undefined;
        } else {
            if (!pluginInstance) {
                if (options !== undefined && typeof options !== "object") {
                    throw new Error ("The options must be a plain object");
                }
                var pluginKlass = pluginKlasses[pluginName]; 
                pluginInstance = new pluginKlass(elm,options);
                datax.data( elm, instanceDataName,pluginInstance );
            } else if (options) {
                pluginInstance.reset(options);
            }
        }

        return pluginInstance;
    }

    Plugin.instantiate = function(elm,options) {
        return instantiate(elm,this.prototype.pluginName,options);
    };

    return  plugins.instantiate = instantiate;
});
define('skylark-domx-plugins-base/shortcutter',[
    "skylark-langx-types",
    "./plugins",
    "./instantiate"
], function(
    types,
    plugins,
    instantiate
) {
    "use strict";

    var slice = Array.prototype.slice;

    function shortcutter(pluginName,extfn) {
       /*
        * Create or get or destory a plugin instance assocated with the element,
        * and also you can execute the plugin method directory;
        */
        return function (elm,options) {
            var  plugin = instantiate(elm, pluginName,"instance");
            if ( options === "instance" ) {
              return plugin || null;
            }

            if (!plugin) {
                plugin = instantiate(elm, pluginName,typeof options == 'object' && options || {});
                if (typeof options != "string") {
                  return this;
                }
            } 
            if (options) {
                var args = slice.call(arguments,1); //2
                if (extfn) {
                    return extfn.apply(plugin,args);
                } else {
                    if (typeof options == 'string') {
                        var methodName = options;

                        if ( !plugin ) {
                            throw new Error( "cannot call methods on " + pluginName +
                                " prior to initialization; " +
                                "attempted to call method '" + methodName + "'" );
                        }

                        if ( !types.isFunction( plugin[ methodName ] ) || methodName.charAt( 0 ) === "_" ) {
                            throw new Error( "no such method '" + methodName + "' for " + pluginName +
                                " plugin instance" );
                        }

                        args = slice.call(args,1); //remove method name

                        var ret = plugin[methodName].apply(plugin,args);
                        if (ret == plugin) {
                          ret = undefined;
                        }

                        return ret;
                    }                
                }                
            }

        }

    }


    return  plugins.shortcutter = shortcutter;
});
define('skylark-domx-plugins-base/register',[
    "skylark-langx-types",
    "skylark-domx-query",
    "skylark-domx-velm",
    "./plugins",
    "./shortcutter"
], function(
    types,
    $, 
    elmx,
    plugins,
    shortcutter
) {
    "use strict";

    var slice = Array.prototype.slice,
        pluginKlasses = plugins.pluginKlasses,
        shortcuts = plugins.shortcuts;

    /*
     * Register a plugin type
     */
    function register( pluginKlass,shortcutName,instanceDataName,extfn) {
        var pluginName = pluginKlass.prototype.pluginName;
        
        pluginKlasses[pluginName] = pluginKlass;

        if (shortcutName) {
            if (instanceDataName && types.isFunction(instanceDataName)) {
                extfn = instanceDataName;
                instanceDataName = null;
            } 
            if (instanceDataName) {
                pluginName = pluginName + ":" + instanceDataName;
            }

            var shortcut = shortcuts[shortcutName] = shortcutter(pluginName,extfn);
                
            $.fn[shortcutName] = function(options) {
                var returnValue = this;

                if ( !this.length && options === "instance" ) {
                  returnValue = undefined;
                } else {
                  var args = slice.call(arguments);
                  this.each(function () {
                    var args2 = slice.call(args);
                    args2.unshift(this);
                    var  ret  = shortcut.apply(undefined,args2);
                    if (ret !== undefined) {
                        returnValue = ret;
                    }
                  });
                }

                return returnValue;
            };

            elmx.partial(shortcutName,function(options) {
                var  ret  = shortcut(this._elm,options);
                if (ret === undefined) {
                    ret = this;
                }
                return ret;
            });

        }
    }

    return  plugins.register = register;
});
define('skylark-domx-plugins-base/main',[
    "skylark-domx-query",
    "skylark-domx-velm",
	"./plugins",
	"./instantiate",
	"./plugin",
	"./register",
	"./shortcutter"
],function($,elmx,plugins,instantiate,Plugin,register,shortcutter){
    "use strict";

    var slice = Array.prototype.slice;

    $.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue ;

        this.each(function(){
            returnValue = instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };

    elmx.partial("plugin",function(name,options) {
        var args = slice.call( arguments, 1 );
        return instantiate.apply(this,[this._elm,name].concat(args));
    }); 

	return plugins;
});
define('skylark-domx-plugins-base', ['skylark-domx-plugins-base/main'], function (main) { return main; });

define('skylark-domx-plugins-colors/colors',[
    "skylark-domx-plugins-base/plugins"
],function (plugins) {
    'use strict';

    return plugins.colores = {};

});

define('skylark-domx-plugins-popups/popups',[
	"skylark-langx-ns",
	"skylark-domx-geom",
	"skylark-domx-query",
    "skylark-domx-plugins-base/plugins"
],function(skylark,geom,$,plugins){

	var stack = [];



    /**
    * get the offset below/above and left/right element depending on screen position
    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
    */
    function around(ref) {
        var extraY = 0;
        var dpSize = geom.size(popup);
        var dpWidth = dpSize.width;
        var dpHeight = dpSize.height;
        var refHeight = geom.height(ref);
        var doc = ref.ownerDocument;
        var docElem = doc.documentElement;
        var viewWidth = docElem.clientWidth + geom.scrollLeft(doc);
        var viewHeight = docElem.clientHeight + geom.scrollTop(doc);
        var offset = geom.pagePosition(ref);
        var offsetLeft = offset.left;
        var offsetTop = offset.top;

        offsetTop += refHeight;

        offsetLeft -=
            Math.min(offsetLeft, (offsetLeft + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offsetLeft + dpWidth - viewWidth) : 0);

        offsetTop -=
            Math.min(offsetTop, ((offsetTop + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + refHeight - extraY) : extraY));

        return {
            top: offsetTop,
            bottom: offset.bottom,
            left: offsetLeft,
            right: offset.right,
            width: offset.width,
            height: offset.height
        };
    }


	/*
	 * Popup the ui elment at the specified position
	 * @param popup  element to display
	 * @param options
	 *  - around {HtmlEleent}
	 *  - at {x,y}
	 *  - parent {}
	 */

	function open(popup,options) {
		if (options.around) {
			//A DOM node that should be used as a reference point for placing the pop-up. 
		}

		let $popup = $(popup);

		$popup.show()
			  .removeAttr( "aria-hidden" )
   			  .position( options.position );

   		stack.push({
   			popup : $popup[0]
   		})

	}

	/*
	 * Close specified popup and any popups that it parented.
	 * If no popup is specified, closes all popups.
     */
	function close(popup) {
		var count = 0;

		if (popup) {
			popup = $(popup)[0];
			for (var i= stack.length-1; i>=0; i--) {
				if (stack[i].popup == popup) {
					count = stack.length - i; 
					break;
				}
			}
		} else {
			count = stack.length;
		}
		for (var i=0; i<count ; i++ ) {
			var top = stack.pop(),
				$popup = $(top.popup);
			$popup.hide()
				.attr( "aria-hidden", "true" );
		} 
	}
	return plugins.popups = {
		around,
		open,
		close
	};
});
define('skylark-domx-plugins-popups/calc-offset',[
	"skylark-domx-geom",
	"./popups"
],function(
	geom,
	popups
){
    /**
    * checkOffset - get the offset below/above and left/right element depending on screen position
    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
    */
    function calcOffset(popup, ref) {
        var extraY = 0;
        var dpSize = geom.size(popup);
        var dpWidth = dpSize.width;
        var dpHeight = dpSize.height;
        var refHeight = geom.height(ref);
        var doc = popup.ownerDocument;
        var docElem = doc.documentElement;
        var viewWidth = docElem.clientWidth + geom.scrollLeft(doc);
        var viewHeight = docElem.clientHeight + geom.scrollTop(doc);
        var offset = geom.pagePosition(ref);
        var offsetLeft = offset.left;
        var offsetTop = offset.top;

        offsetTop += refHeight;

        offsetLeft -=
            Math.min(offsetLeft, (offsetLeft + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offsetLeft + dpWidth - viewWidth) : 0);

        offsetTop -=
            Math.min(offsetTop, ((offsetTop + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + refHeight - extraY) : extraY));

        return {
            top: offsetTop,
            bottom: offset.bottom,
            left: offsetLeft,
            right: offset.right,
            width: offset.width,
            height: offset.height
        };
    }

    return popups.calcOffset = calcOffset;
		
});
define('skylark-domx-plugins-popups/dropdown',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./popups"
],function(langx,browser,eventer,noder,geom,$,plugins,popups){

  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop';
  var toggle   = '[data-toggle="dropdown"]';

  var Dropdown = plugins.Plugin.inherit({
    klassName: "Dropdown",

    pluginName : "lark.popups.dropdown",

    options : {
      "selectors" : {
        "toggler" : '[data-toggle="dropdown"],.dropdown-menu'
      }

    },

    _construct : function(elm,options) {
      this.overrided(elm,options);

      var $el = this.$element = $(this._elm);
      $el.on('click.dropdown', this.toggle);
      $el.on('keydown.dropdown', this.options.selectors.toggler,this.keydown);
    },

    toggle : function (e) {
      var $this = $(this)

      if ($this.is('.disabled, :disabled')) {
        return;
      }

      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open');

      clearMenus()

      if (!isActive) {
        if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
          // if mobile we use a backdrop because click events don't delegate
          $(document.createElement('div'))
            .addClass('dropdown-backdrop')
            .insertAfter($(this))
            .on('click', clearMenus)
        }

        var relatedTarget = { relatedTarget: this }
        $parent.trigger(e = eventer.create('show.dropdown', relatedTarget))

        if (e.isDefaultPrevented()) {
          return;
        }

        $this
          .trigger('focus')
          .attr('aria-expanded', 'true')

        $parent
          .toggleClass('open')
          .trigger(eventer.create('shown.dropdown', relatedTarget))
      }

      return false
    },

    keydown : function (e) {
      if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) {
        return;
      }

      var $this = $(this);

      e.preventDefault()
      e.stopPropagation()

      if ($this.is('.disabled, :disabled')) {
        return;
      }

      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open')

      if (!isActive && e.which != 27 || isActive && e.which == 27) {
        if (e.which == 27) $parent.find(toggle).trigger('focus')
        return $this.trigger('click')
      }

      var desc = ' li:not(.disabled):visible a'
      var $items = $parent.find('.dropdown-menu' + desc)

      if (!$items.length) return

      var index = $items.index(e.target)

      if (e.which == 38 && index > 0)                 index--         // up
      if (e.which == 40 && index < $items.length - 1) index++         // down
      if (!~index)                                    index = 0

      $items.eq(index).trigger('focus');
    }

  });

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector);

    return $parent && $parent.length ? $parent : $this.parent();
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && noder.contains($parent[0], e.target)) return

      $parent.trigger(e = eventer.create('hide.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger(eventer.create('hidden.dropdown', relatedTarget))
    })
  }



  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================
  $(document)
    .on('click.dropdown.data-api', clearMenus)
    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() });

  plugins.register(Dropdown);

  return popups.Dropdown = Dropdown;

});

define('skylark-domx-plugins-popups/comboBox',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./popups",
  "./dropdown"
],function(langx,browser,eventer,noder,geom,$,plugins,popups,Dropdown){


	// COMBOBOX CONSTRUCTOR AND PROTOTYPE

	var ComboBox = plugins.Plugin.inherit({
		klassName: "ComboBox",

		pluginName : "lark.popups.combobox",

		options : {

			autoResizeMenu: true,
			filterOnKeypress: false,
			showOptionsOnKeypress: false,
			filter: function filter (list, predicate, self) {
				var visible = 0;
				self.$dropMenu.find('.empty-indicator').remove();

				list.each(function (i) {
					var $li = $(this);
					var text = $(this).text().trim();

					$li.removeClass();

					if (text === predicate) {
						$li.addClass('text-success');
						visible++;
					} else if (text.substr(0, predicate.length) === predicate) {
						$li.addClass('text-info');
						visible++;
					} else {
						$li.addClass('hidden');
					}
				});

				if (visible === 0) {
					self.$dropMenu.append('<li class="empty-indicator text-muted"><em>No Matches</em></li>');
				}
			}
		},

    	_construct : function(elm,options) {
      		this.overrided(elm,options);
      		this.$element = this.$();

			this.$dropMenu = this.$element.find('.dropdown-menu');
			this.$input = this.$element.find('input');
			this.$button = this.$element.find('.btn');
			this.$button.plugin("lark.popups.dropdown");
			this.$inputGroupBtn = this.$element.find('.input-group-btn');

			this.$element.on('click.lark', 'a', langx.proxy(this.itemclicked, this));
			this.$element.on('change.lark', 'input', langx.proxy(this.inputchanged, this));
			this.$element.on('shown.bs.dropdown', langx.proxy(this.menuShown, this));
			this.$input.on('keyup.lark', langx.proxy(this.keypress, this));

			// set default selection
			this.setDefaultSelection();

			// if dropdown is empty, disable it
			var items = this.$dropMenu.children('li');
			if( items.length === 0) {
				this.$button.addClass('disabled');
			}

			// filter on load in case the first thing they do is press navigational key to pop open the menu
			if (this.options.filterOnKeypress) {
				this.options.filter(this.$dropMenu.find('li'), this.$input.val(), this);
			}
		},

		_destroy: function () {
			this.$element.remove();
			// remove any external bindings
			// [none]

			// set input value attrbute in markup
			this.$element.find('input').each(function () {
				$(this).attr('value', $(this).val());
			});

			// empty elements to return to original markup
			// [none]

			return this.$element[0].outerHTML;
		},

		doSelect: function ($item) {

			if (typeof $item[0] !== 'undefined') {
				// remove selection from old item, may result in remove and
				// re-addition of class if item is the same
				this.$element.find('li.selected:first').removeClass('selected');

				// add selection to new item
				this.$selectedItem = $item;
				this.$selectedItem.addClass('selected');

				// update input
				this.$input.val(this.$selectedItem.text().trim());
			} else {
				// this is a custom input, not in the menu
				this.$selectedItem = null;
				this.$element.find('li.selected:first').removeClass('selected');
			}
		},

		clearSelection: function () {
			this.$selectedItem = null;
			this.$input.val('');
			this.$dropMenu.find('li').removeClass('selected');
		},

		menuShown: function () {
			if (this.options.autoResizeMenu) {
				this.resizeMenu();
			}
		},

		resizeMenu: function () {
			var width = this.$element.outerWidth();
			this.$dropMenu.outerWidth(width);
		},

		selectedItem: function () {
			var item = this.$selectedItem;
			var data = {};

			if (item) {
				var txt = this.$selectedItem.text().trim();
				data = langx.mixin({
					text: txt
				}, this.$selectedItem.data());
			} else {
				data = {
					text: this.$input.val().trim(),
					notFound: true
				};
			}

			return data;
		},

		selectByText: function (text) {
			var $item = $([]);
			this.$element.find('li').each(function () {
				if ((this.textContent || this.innerText || $(this).text() || '').trim().toLowerCase() === (text || '').trim().toLowerCase()) {
					$item = $(this);
					return false;
				}
			});

			this.doSelect($item);
		},

		selectByValue: function (value) {
			var selector = 'li[data-value="' + value + '"]';
			this.selectBySelector(selector);
		},

		selectByIndex: function (index) {
			// zero-based index
			var selector = 'li:eq(' + index + ')';
			this.selectBySelector(selector);
		},

		selectBySelector: function (selector) {
			var $item = this.$element.find(selector);
			this.doSelect($item);
		},

		setDefaultSelection: function () {
			var selector = 'li[data-selected=true]:first';
			var item = this.$element.find(selector);

			if (item.length > 0) {
				// select by data-attribute
				this.selectBySelector(selector);
				item.removeData('selected');
				item.removeAttr('data-selected');
			}
		},

		enable: function () {
			this.$element.removeClass('disabled');
			this.$input.removeAttr('disabled');
			this.$button.removeClass('disabled');
		},

		disable: function () {
			this.$element.addClass('disabled');
			this.$input.attr('disabled', true);
			this.$button.addClass('disabled');
		},

		itemclicked: function (e) {
			this.$selectedItem = $(e.target).parent();

			// set input text and trigger input change event marked as synthetic
			this.$input.val(this.$selectedItem.text().trim()).trigger('change', {
				synthetic: true
			});

			// pass object including text and any data-attributes
			// to onchange event
			var data = this.selectedItem();

			// trigger changed event
			this.$element.trigger('changed.lark', data);

			e.preventDefault();

			// return focus to control after selecting an option
			this.$element.find('.dropdown-toggle').focus();
		},

		keypress: function (e) {
			var ENTER = 13;
			//var TAB = 9;
			var ESC = 27;
			var LEFT = 37;
			var UP = 38;
			var RIGHT = 39;
			var DOWN = 40;

			var IS_NAVIGATIONAL = (
				e.which === UP ||
				e.which === DOWN ||
				e.which === LEFT ||
				e.which === RIGHT
			);

			if(this.options.showOptionsOnKeypress && !this.$inputGroupBtn.hasClass('open')){
				this.$button.plugin("lark.popups.dropdown").toggle();
				this.$input.focus();
			}

			if (e.which === ENTER) {
				e.preventDefault();

				var selected = this.$dropMenu.find('li.selected').text().trim();
				if(selected.length > 0){
					this.selectByText(selected);
				}else{
					this.selectByText(this.$input.val());
				}

				this.$inputGroupBtn.removeClass('open');
			} else if (e.which === ESC) {
				e.preventDefault();
				this.clearSelection();
				this.$inputGroupBtn.removeClass('open');
			} else if (this.options.showOptionsOnKeypress) {
				if (e.which === DOWN || e.which === UP) {
					e.preventDefault();
					var $selected = this.$dropMenu.find('li.selected');
					if ($selected.length > 0) {
						if (e.which === DOWN) {
							$selected = $selected.next(':not(.hidden)');
						} else {
							$selected = $selected.prev(':not(.hidden)');
						}
					}

					if ($selected.length === 0){
						if (e.which === DOWN) {
							$selected = this.$dropMenu.find('li:not(.hidden):first');
						} else {
							$selected = this.$dropMenu.find('li:not(.hidden):last');
						}
					}
					this.doSelect($selected);
				}
			}

			// Avoid filtering on navigation key presses
			if (this.options.filterOnKeypress && !IS_NAVIGATIONAL) {
				this.options.filter(this.$dropMenu.find('li'), this.$input.val(), this);
			}

			this.previousKeyPress = e.which;
		},

		inputchanged: function (e, extra) {
			var val = $(e.target).val();
			// skip processing for internally-generated synthetic event
			// to avoid double processing
			if (extra && extra.synthetic) {
				this.selectByText(val);
				return;
			}
			this.selectByText(val);

			// find match based on input
			// if no match, pass the input value
			var data = this.selectedItem();
			if (data.text.length === 0) {
				data = {
					text: val
				};
			}

			// trigger changed event
			this.$element.trigger('changed.lark', data);
		}

	});



	ComboBox.prototype.getValue = ComboBox.prototype.selectedItem;

    plugins.register(ComboBox);

	return popups.ComboBox = ComboBox;
});

define('skylark-domx-plugins-popups/select-list',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./popups",
  "./dropdown"
],function(langx,browser,eventer,noder,geom,$,plugins,popups,Dropdown){


	// SELECT CONSTRUCTOR AND PROTOTYPE

	var SelectList = plugins.Plugin.inherit({
		klassName: "SelectList",

		pluginName : "lark.popups.selectlist",
	
		options : {
			emptyLabelHTML: '<li data-value=""><a href="#">No items</a></li>'

		},

    	_construct : function(elm,options) {
      		this.overrided(elm,options);
      		this.$element = this.$();
			//this.options = langx.mixin({}, $.fn.selectlist.defaults, options);


			this.$button = this.$element.find('.btn.dropdown-toggle');
			this.$hiddenField = this.$element.find('.hidden-field');
			this.$label = this.$element.find('.selected-label');
			this.$dropdownMenu = this.$element.find('.dropdown-menu');

			this.$button.plugin("lark.popups.dropdown");

			this.$element.on('click.selectlist', '.dropdown-menu a', langx.proxy(this.itemClicked, this));
			this.setDefaultSelection();

			if (this.options.resize === 'auto' || this.$element.attr('data-resize') === 'auto') {
				this.resize();
			}

			// if selectlist is empty or is one item, disable it
			var items = this.$dropdownMenu.children('li');
			if( items.length === 0) {
				this.disable();
				this.doSelect( $(this.options.emptyLabelHTML));
			}

			// support jumping focus to first letter in dropdown when key is pressed
			this.$element.on('shown.dropdown', function () {
					var $this = $(this);
					// attach key listener when dropdown is shown
					$(document).on('keypress.selectlist', function(e){

						// get the key that was pressed
						var key = String.fromCharCode(e.which);
						// look the items to find the first item with the first character match and set focus
						$this.find("li").each(function(idx,item){
							if ($(item).text().charAt(0).toLowerCase() === key) {
								$(item).children('a').focus();
								return false;
							}
						});

				});
			});

			// unbind key event when dropdown is hidden
			this.$element.on('hide.dropdown', function () {
					$(document).off('keypress.selectlist');
			});
		},

		_destroy: function () {
			this.$element.remove();
			// any external bindings
			// [none]
			// empty elements to return to original markup
			// [none]
			// returns string of markup
			return this.$element[0].outerHTML;
		},

		doSelect: function ($item) {
			var $selectedItem;
			this.$selectedItem = $selectedItem = $item;

			this.$hiddenField.val(this.$selectedItem.attr('data-value'));
			this.$label.html($(this.$selectedItem.children()[0]).html());

			// clear and set selected item to allow declarative init state
			// unlike other controls, selectlist's value is stored internal, not in an input
			this.$element.find('li').each(function () {
				if ($selectedItem.is($(this))) {
					$(this).attr('data-selected', true);
				} else {
					$(this).removeData('selected').removeAttr('data-selected');
				}
			});
		},

		itemClicked: function (e) {
			this.$element.trigger('clicked.selectlist', this.$selectedItem);

			e.preventDefault();
			// ignore if a disabled item is clicked
			if ($(e.currentTarget).parent('li').is('.disabled, :disabled')) { return; }

			// is clicked element different from currently selected element?
			if (!($(e.target).parent().is(this.$selectedItem))) {
				this.itemChanged(e);
			}

			// return focus to control after selecting an option
			this.$element.find('.dropdown-toggle').focus();
		},

		itemChanged: function (e) {
			//selectedItem needs to be <li> since the data is stored there, not in <a>
			this.doSelect($(e.target).closest('li'));

			// pass object including text and any data-attributes
			// to onchange event
			var data = this.selectedItem();
			// trigger changed event
			this.$element.trigger('changed.selectlist', data);
		},

		resize: function () {
			var width = 0;
			var newWidth = 0;
			var sizer = $('<div/>').addClass('selectlist-sizer');


			if (Boolean($(document).find('html').hasClass('fuelux'))) {
				// default behavior for fuel ux setup. means fuelux was a class on the html tag
				$(document.body).append(sizer);
			} else {
				// fuelux is not a class on the html tag. So we'll look for the first one we find so the correct styles get applied to the sizer
				$('.fuelux:first').append(sizer);
			}

			sizer.append(this.$element.clone());

			this.$element.find('a').each(function () {
				sizer.find('.selected-label').text($(this).text());
				newWidth = sizer.find('.selectlist').outerWidth();
				newWidth = newWidth + sizer.find('.sr-only').outerWidth();
				if (newWidth > width) {
					width = newWidth;
				}
			});

			if (width <= 1) {
				return;
			}

			this.$button.css('width', width);
			this.$dropdownMenu.css('width', width);

			sizer.remove();
		},

		selectedItem: function () {
			var txt = this.$selectedItem.text();
			return langx.mixin({
				text: txt
			}, this.$selectedItem.data());
		},

		selectByText: function (text) {
			var $item = $([]);
			this.$element.find('li').each(function () {
				if ((this.textContent || this.innerText || $(this).text() || '').toLowerCase() === (text || '').toLowerCase()) {
					$item = $(this);
					return false;
				}
			});
			this.doSelect($item);
		},

		selectByValue: function (value) {
			var selector = 'li[data-value="' + value + '"]';
			this.selectBySelector(selector);
		},

		selectByIndex: function (index) {
			// zero-based index
			var selector = 'li:eq(' + index + ')';
			this.selectBySelector(selector);
		},

		selectBySelector: function (selector) {
			var $item = this.$element.find(selector);
			this.doSelect($item);
		},

		setDefaultSelection: function () {
			var $item = this.$element.find('li[data-selected=true]').eq(0);

			if ($item.length === 0) {
				$item = this.$element.find('li').has('a').eq(0);
			}

			this.doSelect($item);
		},

		enable: function () {
			this.$element.removeClass('disabled');
			this.$button.removeClass('disabled');
		},

		disable: function () {
			this.$element.addClass('disabled');
			this.$button.addClass('disabled');
		}

	});	


	SelectList.prototype.getValue = SelectList.prototype.selectedItem;


    plugins.register(SelectList);

	return popups.SelectList = SelectList;
});

define('skylark-domx-plugins-popups/main',[
	"./popups",
	"./calc-offset",
	"./dropdown",
	"./comboBox",
	"./select-list"
],function(popups){
	return popups;
});
define('skylark-domx-plugins-popups', ['skylark-domx-plugins-popups/main'], function (main) { return main; });

define('skylark-graphics-colors/colors',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("graphics.colors",{});
});
 define('skylark-graphics-colors/_names',[
],function() {
     // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    return  {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };


});


 define('skylark-graphics-colors/_hexNames',[
    "./_names"
],function(names) {
    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = { };
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }
    return  flip(names);

});


define('skylark-graphics-colors/_conversion',[
    "skylark-langx-strings",
    "./_names"
],function(
    strings,
    names
){
    var math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathRandom = math.random;
            
    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }


    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if(max == min) {
            h = 0; // achromatic
        }
        else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
     function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b and a are contained in the set [0, 255]
    // Returns an 8 character hex
    function rgbaToHex(r, g, b, a) {

        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        return hex.join("");
    }

	function hexToRgb(hex) {
	  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	  return result ? {
	    r: parseInt(result[1], 16),
	    g: parseInt(result[2], 16),
	    b: parseInt(result[3], 16)
	  } : null;
	}


    var matchers = (function() {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex3s: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6s: /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8s: /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();



    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }
        

      // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }

    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }
          
    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function strToRgb(color) {

        color = strings.trim(color).toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color)) || (match = matchers.hex8s.exec(color))) {
            return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color)) || (match = matchers.hex6s.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex3.exec(color)) || (match = matchers.hex3s.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }


	return  {
		bound01,
        rgbToRgb,
		rgbToHsl,
		hslToRgb,
		rgbToHsv,
		hsvToRgb,
		rgbToHex,
		rgbaToHex,
		hexToRgb,
        strToRgb
	};
});
define('skylark-graphics-colors/color',[
    "skylark-langx-types",
    "skylark-langx-klass",
    "./colors",
    "./_names",
    "./_hexNames",
    "./_conversion"
],function(
    types,
    klass,
    colors,
    names,
    hexNames,
    conversion
) {
    var math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathRandom = math.random;

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

     // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }
         
    var Color = klass({
        init : function(rgb, opts) {
            opts = opts || { };

            //var rgb = inputToRGB(color);
            //
            //this._originalInput = color,
            if (types.isString(rgb)) {
                rgb= conversion.hexToRgb(rgb);
            }
            this._r = rgb.r,
            this._g = rgb.g,
            this._b = rgb.b,
            this._a = types.isDefined(rgb.a) ? rgb.a : 1,

            this._roundA = mathRound(1000 * this._a) / 1000,
            this._format = opts.format || rgb.format;
            this._gradientType = opts.gradientType;

            // Don't let the range of [0,255] come back in [0,1].
            // Potentially lose a little bit of precision here, but will fix issues where
            // .5 gets interpreted as half of the total, instead of half of 1
            // If it was supposed to be 128, this was already taken care of by `inputToRgb`
            if (this._r < 1) { this._r = mathRound(this._r); }
            if (this._g < 1) { this._g = mathRound(this._g); }
            if (this._b < 1) { this._b = mathRound(this._b); }

        },

        /*
         * Return a boolean indicating whether the color's perceived brightness is dark.
         */
        isDark: function() {
            return this.getBrightness() < 128;
        },

        /*
         * Return a boolean indicating whether the color's perceived brightness is light.
         */
        isLight: function() {
            return !this.isDark();
        },

        getOriginalInput: function() {
          return this._originalInput;
        },

        getFormat: function() {
            return this._format;
        },

        /*
         * Returns the alpha value of a color, from 0-1
         */
        getAlpha: function() {
            return this._a;
        },

        /*
         * Returns the perceived brightness of a color, from 0-255.
         */
        getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },

        /*
         * Sets the alpha value on a current color. Accepted range is in between 0-1.
         */
        setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(1000 * this._a) / 1000;
            return this;
        },

        toHsv: function() {
            var hsv = conversion.rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },

        toHsvString: function() {
            var hsv = conversion.rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
              "hsv("  + h + ", " + s + "%, " + v + "%)" :
              "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        },

        toHsl: function() {
            var hsl = conversion.rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },

        toHslString: function() {
            var hsl = conversion.rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
              "hsl("  + h + ", " + s + "%, " + l + "%)" :
              "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
        },

        toHex: function(allow3Char) {
            return conversion.rgbToHex(this._r, this._g, this._b, allow3Char);
        },

        toHexString: function(allow3Char) {
            return '#' + this.toHex(allow3Char);
        },

        toHex8: function() {
            return conversion.rgbaToHex(this._r, this._g, this._b, this._a);
        },

        toHex8String: function() {
            return '#' + this.toHex8();
        },

        toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },

        toRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
              "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },

        toPercentageRgb: function() {
            return { r: mathRound(conversion.bound01(this._r, 255) * 100) + "%", g: mathRound(conversion.bound01(this._g, 255) * 100) + "%", b: mathRound(conversion.bound01(this._b, 255) * 100) + "%", a: this._a };
        },

        toPercentageRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(conversion.bound01(this._r, 255) * 100) + "%, " + mathRound(conversion.bound01(this._g, 255) * 100) + "%, " + mathRound(conversion.bound01(this._b, 255) * 100) + "%)" :
              
              "rgba(" + mathRound(conversion.bound01(this._r, 255) * 100) + "%, " + mathRound(conversion.bound01(this._g, 255) * 100) + "%, " + mathRound(conversion.bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },

        toName: function() {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[conversion.rgbToHex(this._r, this._g, this._b, true)] || false;
        },

        toFilter: function(secondColor) {
            var hex8String = '#' + conversion.rgbaToHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = Color(secondColor);
                secondHex8String = s.toHex8String();
            }

            return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
        },

        toNumber : function() {
            return (this._r << 16 ^ this._g << 8 ^ this._b << 0);
        },

        toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },

        // modification methods
        // ----------------------
        // Thanks to less.js for some of the basics here
        // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

        /*
         * Lighten the color a given amount, from 0 to 100. Providing 100 will always return white.
         */
        lighten: function(amount) {
            amount = (amount === 0) ? 0 : (amount || 10);
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return Color.fromHsl(hsl);
        },

        /*
         * Brighten the color a given amount, from 0 to 100
         */
        brighten: function(amount) {
            amount = (amount === 0) ? 0 : (amount || 10);
            var rgb = this.toRgb();
            rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
            rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
            return new Color(rgb);
        },

        /*
         * Darken the color a given amount, from 0 to 100. Providing 100 will always return black.
         */
        darken: function(amount) {
            amount = (amount === 0) ? 0 : (amount || 10);
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return Color.fromHsl(hsl);
        },

        /*
         *  Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale.
         */
        desaturate: function(amount) {
            amount = (amount === 0) ? 0 : (amount || 10);
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return Color.fromHsl(hsl);
        },

        /*
         *  Saturate the color a given amount, from 0 to 100.
         */
        saturate: function(amount) {
            amount = (amount === 0) ? 0 : (amount || 10);
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return Color.fromHsl(hsl);
        },

        /*
         * Completely desaturates a color into greyscale. Same as calling desaturate(100).
         */
        greyscale: function() {
            return this.desaturate(100);
        },

        /*
         * Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing (since it sets the hue back to what it was before).
         */
        spin: function(amount) {
            var hsl = this.toHsl();
            var hue = (mathRound(hsl.h) + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return Color.fromHsl(hsl);
        },


        // combination methods

        /*
         * Finds analogous colors the color.
         */
        analogous: function(results, slices) {
            results = results || 6;
            slices = slices || 30;

            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];

            for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
                hsl.h = (hsl.h + part) % 360;
                ret.push(Color.fromHsl(hsl));
            }
            return ret;
        },

        complement: function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return Color.fromHsl(hsl);
        },

        /*
         * Finds monochromatic colors to the color.
         */
        monochromatic: function(results) {
            results = results || 6;
            var hsv = this.toHsv();
            var h = hsv.h, s = hsv.s, v = hsv.v;
            var ret = [];
            var modification = 1 / results;

            while (results--) {
                ret.push(Color.fromHsv({ h: h, s: s, v: v}));
                v = (v + modification) % 1;
            }

            return ret;
        },


        /*
         * Generates a split complements of the color.
         */
        splitcomplement: function() {
            var hsl = this.toHsl();
            var h = hsl.h;
            return [
                this,
                Color.fromHsl({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
                Color.fromHsl({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
            ];
        },

        /*
         * Generates a color triad of the color.
         */
        triad: function() {
            var hsl = this.toHsl();
            var h = hsl.h;
            return [
                this,
                Color.fromHsl({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
                Color.fromHsl({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
            ];
        },

        tetrad: function() {
            var hsl = this.toHsl();
            var h = hsl.h;
            return [
                this,
                Color.fromHsl({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
                Color.fromHsl({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
                Color.fromHsl({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
            ];
        },


        mix : function(color2,amount) {
            amount = (amount === 0) ? 0 : (amount || 50);

            var rgb1 = this.toRgb();
            var rgb2 = color2.toRgb();

            var p = amount / 100;
            var w = p * 2 - 1;
            var a = rgb2.a - rgb1.a;

            var w1;

            if (w * a == -1) {
                w1 = w;
            } else {
                w1 = (w + a) / (1 + w * a);
            }

            w1 = (w1 + 1) / 2;

            var w2 = 1 - w1;

            var rgba = {
                r: rgb2.r * w1 + rgb1.r * w2,
                g: rgb2.g * w1 + rgb1.g * w2,
                b: rgb2.b * w1 + rgb1.b * w2,
                a: rgb2.a * p  + rgb1.a * (1 - p)
            };

            return new Color(rgba);

        },

        isValid : function(){
            return true;
        }
    });

    // `equals`
    // Can be called with any Color input
    Color.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        color1 = Color.parse(color1);
        color2 = Color.parse(color2);

        return color1.toRgbString() == color2.toRgbString();
    };
    

    Color.random = function() {
        return Color.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };

    Color.fromRgba = function(r,g,b,a) {
        return new Color({
            r,
            g,
            b,
            a
        })  
    };

    Color.fromRgb = function(r,g,b) {
        return new Color({
            r,
            g,
            b
        })  
    };

    Color.fromHsl = function(h,s,l,a) {
        var rgb = conversion.hslToRgb(h,s,l)
        return new Color(rgb)  
    };

    Color.fromHsv = function(h,s,v,a) {
        var rgb = conversion.hsvToRgb(h,s,v)
        return new Color(rgb)  
    }; 

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    Color.parse = function (color) {
        if (color instanceof Color) {
            return color;
        }

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = conversion.strToRgb(color);
        }

        if (typeof color == "object") {
            if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                rgb = conversion.rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb = conversion.hsvToRgb(color.h, color.s, color.v);
                ok = true;
                format = "hsv";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
                color.s = convertToPercentage(color.s);
                color.l = convertToPercentage(color.l);
                rgb =  conversion.hslToRgb(color.h, color.s, color.l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        return new Color(
            {
                ok: ok,
                r: Math.min(255, Math.max(rgb.r, 0)),
                g: Math.min(255, Math.max(rgb.g, 0)),
                b: Math.min(255, Math.max(rgb.b, 0)),
                a: a
            },
            {
                format: color.format || format,                
            }
        );

    }

    /*
    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    Color.fromRatio = function(color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return new Color(color, opts);
    };
    */
    return colors.Color = Color;
});

define('skylark-domx-plugins-colors/helper',[
    "skylark-domx-browser",
    "skylark-domx-query",
    "skylark-graphics-colors/color"    
],function(browser,$,Color){
    function paletteElementClick(e) {
        if (e.data && e.data.ignore) {
            self.set($(e.target).closest(".sp-thumb-el").data("color"));
            move();
        }
        else {
            self.set($(e.target).closest(".sp-thumb-el").data("color"));
            move();

            // If the picker is going to close immediately, a palette selection
            // is a change.  Otherwise, it's a move only.
            if (opts.hideAfterPaletteSelect) {
                self_updateOriginalInput(true);
                self.hide();
            } else {
                self._updateOriginalInput();
            }
        }

        return false;
    }

    var paletteEvent = browser.isIE ? "mousedown.ColorPicker" : "click.ColorPicker touchstart.ColorPicker";	

    function paletteTemplate (p, color, className, opts) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var current = p[i];
            if(current) {
                var tiny = Color.parse(current);
                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
                c += (Color.equals(color, current)) ? " sp-thumb-active" : "";
                var formattedString = tiny.toString(opts.preferredFormat || "rgb");
                var swatchStyle = "background-color:" + tiny.toRgbString();
                html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
            } else {
                var cls = 'sp-clear-display';
                html.push($('<div />')
                    .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>')
                        .attr('title', opts.texts.noColorSelectedText)
                    )
                    .html()
                );
            }
        }
        return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
    }

    return {
    	paletteTemplate
    }
});

define('skylark-domx-plugins-colors/indicator',[
   "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-plugins-base"    
],function(skylark, langx, browser, noder, eventer,finder, $,plugins) {
    /**
    * Lightweight drag helper.  Handles containment within the element, so that
    * when dragging, the x is within [0,element.width] and y is within [0,element.height]
    */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;
        var hasTouch = ('ontouchstart' in window);

        var duringDragEvents = {};
        duringDragEvents["selectstart"] = prevent;
        duringDragEvents["dragstart"] = prevent;
        duringDragEvents["touchmove mousemove"] = move;
        duringDragEvents["touchend mouseup"] = stop;

        function prevent(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }

        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (browser.isIE && doc.documentMode < 9 && !e.button) {
                    return stop();
                }

                var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
                var pageX = t0 && t0.pageX || e.pageX;
                var pageY = t0 && t0.pageY || e.pageY;

                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

                if (hasTouch) {
                    // Stop scrolling in iOS
                    prevent(e);
                }

                onmove.apply(element, [dragX, dragY, e]);
            }
        }

        function start(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

            var onstart = this.options.onstart || funcs.noop;

            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();

                    $(doc).on(duringDragEvents);
                    $(doc.body).addClass("sp-dragging");

                    move(e);

                    prevent(e);
                }
            }
        }

        function stop() {
            if (dragging) {
                $(doc).off(duringDragEvents);
                $(doc.body).removeClass("sp-dragging");

                // Wait a tick before notifying observers to allow the click event
                // to fire in Chrome.
                setTimeout(function() {
                    onstop.apply(element, arguments);
                }, 0);
            }
            dragging = false;
        }

        $(element).on("touchstart mousedown", start);
    }
	

    var Indicator = plugins.Plugin.inherit({
        klassName : "Indicator",

        pluginName : "lark.colors.indicator",

        options : {
        },

        _construct: function(elm, options) {
            plugins.Plugin.prototype._construct.call(this,elm,options);

            this.listenTo(this.elmx(),"mousedown" , (e) => {
                this._start(e);
            });

        },

        _move : function(e) {
            if (this._dragging) {
                var offset = this._offset,
                    pageX = e.pageX,
                    pageY = e.pageY,
                    maxWidth = this._maxWidth,
                    maxHeight = this._maxHeight;

                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

                var onmove = this.options.onmove;
                if (onmove) {
                    onmove.apply(this._elm, [dragX, dragY, e]);
                }
            }
        },

        _start : function(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

            if (!rightclick && !this._dragging) {
                var onstart = this.options.onstart;
                if (!onstart || onstart.apply(this._elm, arguments) !== false) {
                    this._dragging = true;
                    var $el = this.$();

                    this._maxHeight = $el.height();
                    this._maxWidth = $el.width();
                    this._offset = $el.offset();

                    var $doc = this.$(document)

                    this.listenTo($doc,{
                        "mousemove" : (e) => {
                            this._move(e);
                        },
                        "mouseup" : (e) => {
                            this._stop(e);
                        }                
                    });
                    $doc.find("body").addClass("sp-dragging");

                    this._move(e);

                    eventer.stop(e);
                }
            }
        },

        _stop : function(e) {
            var $doc = this.$(document);
            if (this._dragging) {
                this.unlistenTo($doc);
                $doc.find("body").removeClass("sp-dragging");

                onstop = this.options.onstop;

                // Wait a tick before notifying observers to allow the click event
                // to fire in Chrome.
                if (onstop) {
                    this._delay(function() {
                        onstop.apply(this._elm, arguments);
                    });
                }
            }
            this._dragging = false;            
        }
    });

    plugins.register(Indicator);

	return Indicator;
});
define('skylark-domx-plugins-colors/color-picker',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-plugins-base",
    "skylark-graphics-colors/color",
    "./colors",
    "./helper",
    "./indicator"
],function(langx, browser, noder, finder, $,eventer, styler,plugins,Color,colors,helper,Indicator) {
    "use strict";

    var ColorPicker = plugins.Plugin.inherit({
        klassName : "ColorPicker",

        pluginName : "lark.colors.picker",

        options : {
            selectors  : {
                dragger : ".sp-color",
                dragHelper : ".sp-dragger",
                slider : ".sp-hue",
                slideHelper : ".sp-slider",
                alphaSliderInner : ".sp-alpha-inner",
                alphaSlider : ".sp-alpha",
                alphaSlideHelper : ".sp-alpha-handle",
                textInput : ".sp-input",
                initialColorContainer : ".sp-initial",
                cancelButton : ".sp-cancel",
                clearButton : ".sp-clear",
                chooseButton : ".sp-choose"
            },

            draggingClass : "sp-dragging",

            texts : {
                cancelText: "cancel",
                chooseText: "choose",
                clearText: "Clear Color Selection",
                noColorSelectedText: "No Color Selected"
            },

            states : {
                showInput: false,
                allowEmpty: false,
                showButtons: true,
                showInitial: false,
                showAlpha: false
            },

            preferredFormat : "hex",

            // Options
            color: false
        },
        
        _drawInitial : function () {
            var opts = this.options;
            if (this.stating("showInitial")) {
                var initialColor = this._initialColor;
                var currentColor = this.current();
                this.$initialColorContainer.html(
                    helper.paletteTemplate([initialColor, currentColor], currentColor, "sp-palette-row-initial", opts)
                );
            }
        },

        _updateHelperLocations : function () {
            var s = this._currentSaturation;
            var v = this._currentValue;

            if(this.stating("allowEmpty") && this._isEmpty) {
                //if selected color is empty, hide the helpers
                this.$alphaSlideHelper.hide();
                this.$slideHelper.hide();
                this.$dragHelper.hide();
            }
            else {
                //make sure helpers are visible
                this.$alphaSlideHelper.show();
                this.$slideHelper.show();
                this.$dragHelper.show();

                // Where to show the little circle in that displays your current selected color
                var dragX = s * this._dragWidth;
                var dragY = this._dragHeight - (v * this._dragHeight);
                dragX = Math.max(
                    -this._dragHelperHeight,
                    Math.min(this._dragWidth - this._dragHelperHeight, dragX - this._dragHelperHeight)
                );
                dragY = Math.max(
                    -this._dragHelperHeight,
                    Math.min(this._dragHeight - this._dragHelperHeight, dragY - this._dragHelperHeight)
                );
                this.$dragHelper.css({
                    "top": dragY + "px",
                    "left": dragX + "px"
                });

                var alphaX = this._currentAlpha * this._alphaWidth;
                this.$alphaSlideHelper.css({
                    "left": (alphaX - (this._alphaSlideHelperWidth / 2)) + "px"
                });

                // Where to show the bar that displays your current selected hue
                var slideY = (this._currentHue) * this._slideHeight;
                this.$slideHelper.css({
                    "top": (slideY - this._slideHelperHeight) + "px"
                });
            }
        },

        _updateOriginalInput : function (fireCallback) {
            var color = this.current(),
                displayColor = '',
                hasChanged = !Color.equals(color, this._colorOnShow);

            if (color) {
                displayColor = color.toString(this._currentPreferredFormat);
                // Update the selection palette with the current color
                this.emit("picked",color);
            }


        },

        _updateUI : function () {
            var opts = this.options;

            this._dragWidth = this.$dragger.width();
            this._dragHeight = this.$dragger.height();
            this._dragHelperHeight = this.$dragHelper.height();
            this._slideWidth = this.$slider.width();
            this._slideHeight = this.$slider.height();
            this._slideHelperHeight = this.$slideHelper.height();
            this._alphaWidth = this.$alphaSlider.width();
            this._alphaSlideHelperWidth = this.$alphaSlideHelper.width();
            
            this.$textInput.removeClass("sp-validation-error");

            this._updateHelperLocations();

            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = Color.parse({ 
                h: this._currentHue * 360, 
                s: 1, 
                v: 1 
            });
            this.$dragger.css("background-color", flatColor.toHexString());

            // Get a format that alpha will be included in (hex and names ignore alpha)
            var format = this._currentPreferredFormat;
            if (this._currentAlpha < 1 && !(this._currentAlpha === 0 && format === "name")) {
                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                    format = "rgb";
                }
            }

            var realColor = this.current(),
                displayColor = '';

            if (!realColor && this.stating("allowEmpty")) {
            }
            else {
                var realHex = realColor.toHexString(),
                    realRgb = realColor.toRgbString();

                if (this.stating("showAlpha")) {
                    var rgb = realColor.toRgb();
                    rgb.a = 0;
                    var realAlpha = Color.parse(rgb).toRgbString();
                    var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

                    if (browser.isIE) {
                        this.$alphaSliderInner.css("filter", Color.parse(realAlpha).toFilter({ gradientType: 1 }, realHex));
                    }
                    else {
                        this.$alphaSliderInner.css("background", "-webkit-" + gradient);
                        this.$alphaSliderInner.css("background", "-moz-" + gradient);
                        this.$alphaSliderInner.css("background", "-ms-" + gradient);
                        // Use current syntax gradient on unprefixed property.
                        this.$alphaSliderInner.css("background",
                            "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");
                    }
                }

                displayColor = realColor.toString(format);
            }

            // Update the text entry input as it changes happen
            if (this.stating("showInput")) {
                this.$textInput.val(displayColor);
            }

            if (this.stating("showPalette")) {
                this._drawPalette();
            }

            this._drawInitial();
        },


        _applyOptions : function () {
            var opts = this.options;

            this._states = {
                allowEmpty : opts.states.allowEmpty,
                showInput : opts.states.showInput,
                showAlpha : opts.states.showAlpha,
                showButtons : opts.states.showButtons,
                showInitial : opts.states.showInitial
            };


           this._applyStates();

           this.reflow();
        },

         _construct: function(elm, options) {
            plugins.Plugin.prototype._construct.call(this,elm,options);

            var $el = this.$el = this.$();

            var opts = this.options,
                theme = opts.theme;

            var                
                dragger = this.$dragger = $el.find(opts.selectors.dragger),
                dragHelper = this.$dragHelper = $el.find(opts.selectors.dragHelper),
                slider = this.$slider = $el.find(opts.selectors.slider),
                slideHelper = this.$slideHelper =  $el.find(opts.selectors.slideHelper),
                alphaSliderInner = this.$alphaSliderInner = $el.find(opts.selectors.alphaSliderInner),
                alphaSlider = this.$alphaSlider = $el.find(opts.selectors.alphaSlider),
                alphaSlideHelper = this.$alphaSlideHelper = $el.find(opts.selectors.alphaSlideHelper),
                textInput = this.$textInput = $el.find(opts.selectors.textInput),
                initialColorContainer = this.$initialColorContainer = $el.find(opts.selectors.initialColorContainer),
                cancelButton = this.$cancelButton = $el.find(opts.selectors.cancelButton),
                clearButton = this.$clearButton = $el.find(opts.selectors.clearButton),
                chooseButton = this.$chooseButton = $el.find(opts.selectors.chooseButton),
                initialColor = this._initialColor =  opts.color,
                currentPreferredFormat = this._currentPreferredFormat = opts.preferredFormat,
                isEmpty = this._isEmpty =  !initialColor;

            this._init();
        },

        _init : function () {
            var self = this,
                opts = this.options;
             function dragStart() {
                if (self._dragHeight <= 0 || self._dragWidth <= 0 || self._slideHeight <= 0) {
                    self.reflow();
                }
                self._isDragging = true;
                self.$el.addClass(self.options.draggingClass);
                self._shiftMovementDirection = null;
            }

            function dragStop() {
                self._isDragging = false;
                self.$el.removeClass(self.options.draggingClass);
            }           

            function move() {
                self._updateOriginalInput();
                self._updateUI();
            }

            this._applyOptions();

            function setFromTextInput() {
                var value = self.$textInput.val();

                if ((value === null || value === "") && self._allowEmpty) {
                    self.current(null);
                    move();
                }
                else {
                    var tiny = Color.parse(value);
                    if (tiny.isValid()) {
                        self.current(tiny);
                        move();
                    }
                    else {
                        self.$textInput.addClass("sp-validation-error");
                    }
                }
            }
            this.$textInput.change(setFromTextInput);
            this.$textInput.on("paste", function () {
                setTimeout(setFromTextInput, 1);
            });
            this.$textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });

            this.$cancelButton.text(opts.texts.cancelText);
            
            this.listenTo(this.$cancelButton,"click", function (e) {
                eventer.stop(e);
                self.revert();
                self.emit("canceled"); 
            });

            this.$clearButton.attr("title", opts.texts.clearText);
            this.listenTo(this.$clearButton,"click", function (e) {
                eventer.stop(e);
                self._isEmpty = true;
                move();

            });

            this.$chooseButton.text(opts.texts.chooseText);
            this.listenTo(this.$chooseButton,"click", function (e) {
                eventer.stop(e);

                self._updateOriginalInput(true);
                self.emit("choosed"); 
            });
          
            this.$alphaSlider.plugin("lark.colors.indicator", {
                "onmove" :   function (dragX, dragY, e) {
                    self._currentAlpha = (dragX / self._alphaWidth);
                    self._isEmpty = false;
                    if (e.shiftKey) {
                        self._currentAlpha = Math.round(self._currentAlpha * 10) / 10;
                    }

                    move();

                }, 
                "onstart" : dragStart, 
                "onstop" :dragStop
            });

            this.$slider.plugin("lark.colors.indicator", {
                "onmove" :   function (dragX, dragY, e) {
                    self._currentHue = parseFloat(dragY / self._slideHeight);
                    self._isEmpty = false;
                    if (!self.stating("showAlpha")) {
                        self._currentAlpha = 1;
                    }
                    move();
                }, 
                "onstart" : dragStart, 
                "onstop" :dragStop
            });

            this.$dragger.plugin("lark.colors.indicator", {
                "onmove" :   function (dragX, dragY, e) {

                    // shift+drag should snap the movement to either the x or y axis.
                    if (!e.shiftKey) {
                        self._shiftMovementDirection = null;
                    }
                    else if (!self._shiftMovementDirection) {
                        var oldDragX = self._currentSaturation * self._dragWidth;
                        var oldDragY = self._dragHeight - (self._currentValue * self._dragHeight);
                        var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

                        self._shiftMovementDirection = furtherFromX ? "x" : "y";
                    }

                    var setSaturation = !self._shiftMovementDirection || self._shiftMovementDirection === "x";
                    var setValue = !self._shiftMovementDirection || self._shiftMovementDirection === "y";

                    if (setSaturation) {
                        self._currentSaturation = parseFloat(dragX / self._dragWidth);
                    }
                    if (setValue) {
                        self._currentValue = parseFloat((self._dragHeight - dragY) / self._dragHeight);
                    }

                    self._isEmpty = false;
                    if (!self.stating("showAlpha")) {
                        self._currentAlpha = 1;
                    }

                    move();
                }, 
                "onstart" : dragStart, 
                "onstop" :dragStop
            });

            this.current(this._initialColor);

            // In case color was black - update the preview UI and set the format
            // since the set function will not run (default color is black).
            self._updateUI();

            function paletteElementClick(e) {
                if (e.data && e.data.ignore) {
                    self.current($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                }
                else {
                    self.current($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                }

                return false;
            }

            var paletteEvent = browser.isIE ? "mousedown.ColorPicker" : "click.ColorPicker touchstart.ColorPicker";
            this.$initialColorContainer.on(paletteEvent, ".sp-thumb-el:nth-child(1)", { ignore: true }, paletteElementClick);
        },

        revert :  function () {
            this.current(this._initialColor, true);
            this._updateOriginalInput(true);
        },


        current : function(color) {
            if (color === undefined) {
                if (this._allowEmpty && this._isEmpty) {
                    return null;
                }


                return Color.parse({
                    h: this._currentHue * 360,
                    s: this._currentSaturation,
                    v: this._currentValue,
                    a: Math.round(this._currentAlpha * 1000) / 1000
                });

            } else {
                if (Color.equals(color, this.current())) {
                    // Update UI just in case a validation error needs
                    // to be cleared.
                    this._updateUI();
                    return;
                }

                var newColor, newHsv;
                if (!color && this.stating("allowEmpty")) {
                    this._isEmpty = true;
                } else {
                    this._isEmpty = false;
                    newColor = Color.parse(color);
                    newHsv = newColor.toHsv();

                    this._currentHue = (newHsv.h % 360) / 360;
                    this._currentSaturation = newHsv.s;
                    this._currentValue = newHsv.v;
                    this._currentAlpha = newHsv.a;
                }
                this._updateUI();

            }
        },


        _applyStates : function() {
           var states = this._states ;

            this.$el.toggleClass("sp-input-disabled", !states.showInput)
                        .toggleClass("sp-clear-enabled", !!states.allowEmpty)
                        .toggleClass("sp-alpha-enabled", states.showAlpha)
                        .toggleClass("sp-buttons-disabled", !states.showButtons)
                        .toggleClass("sp-initial-disabled", !states.showInitial);

            if (!states.allowEmpty) {
                this.$clearButton.hide();
            }

            this._dragWidth = this.$dragger.width();
            this._dragHeight = this.$dragger.height();
            this._dragHelperHeight = this.$dragHelper.height();
            this._slideWidth = this.$slider.width();
            this._slideHeight = this.$slider.height();
            this._slideHelperHeight = this.$slideHelper.height();
            this._alphaWidth = this.$alphaSlider.width();
            this._alphaSlideHelperWidth = this.$alphaSlideHelper.width();
        },

        stating : function(name,value) {
            if (value !== undefined) {
                this._states[name] = value;
                this._applyStates();
            } else {
                return this._states[name];
            }
        },

        reflow : function () {
            this._updateHelperLocations();
        }

    });


    plugins.register(ColorPicker);

    return colors.ColorPicker = ColorPicker;
});
define('skylark-domx-plugins-colors/color-palette',[
   "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-plugins-base",
    "skylark-graphics-colors/color",
    "./colors",
    "./helper"
],function(skylark, langx, browser, noder, finder, $,eventer, styler,fx,plugins,Color,colors,helper) {
    "use strict";

    var noop = langx.noop;

    var ColorPalette = plugins.Plugin.inherit({
        klassName : "ColorPalette",

        pluginName : "lark.colors.palette",

        options : {
            selectors  : {
            },

            texts : {
            },

            states : {
                showSelectionPalette: true
            },
            palette: [
                ["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]
            ],
            selectionPalette: []

        },

       _addColorToSelectionPalette : function (color) {
            if (this.stating("showSelectionPalette")) {
                var rgb = Color.parse(color).toRgbString();
                if (!this._paletteLookup[rgb] && langx.inArray(rgb, this._selectionPalette) === -1) {
                    this._selectionPalette.push(rgb);
                    while(this._selectionPalette.length > this._maxSelectionSize) {
                        this._selectionPalette.shift();
                    }
                }
            }
        },  

        getUniqueSelectionPalette : function () {
            var unique = [],
                opts = this.options;
            if (this.stating("showPalette")) {
                for (var i = 0; i < this._selectionPalette.length; i++) {
                    var rgb = Color.parse(this._selectionPalette[i]).toRgbString();

                    if (!this._paletteLookup[rgb]) {
                        unique.push(this._selectionPalette[i]);
                    }
                }
            }

            return unique.reverse().slice(0, opts.maxSelectionSize);
        },

        _drawPalette : function () {

            var opts = this.options,
                currentColor = this.current();

            var html = langx.map(this._paletteArray, function (palette, i) {
                return helper.paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);
            });

            if (this._selectionPalette) {
                html.push(helper.paletteTemplate(this.getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
            }

            this.$el.html(html.join(""));
        },


        _updateUI : function () {
           this._drawPalette();
        },


        _applyOptions : function () {
            var opts = this.options;

            this._states = {
                showSelectionPalette: opts.showSelectionPalette
            };            

            if (opts.palette) {
                var  palette = this._palette = opts.palette.slice(0),
                    paletteArray = this._paletteArray = langx.isArray(palette[0]) ? palette : [palette],
                    paletteLookup = this._paletteLookup = {};
                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        var rgb = Color.parse(paletteArray[i][j]).toRgbString();
                        paletteLookup[rgb] = true;
                    }
                }
            }
           this._applyStates();
        },

         _construct: function(elm, options) {
           plugins.Plugin.prototype._construct.call(this,elm,options);

            this.$el = this.$();

            this._init();
        },

        _init : function () {
            var self = this,
                opts = this.options,
                initialColor = this._initialColor =  opts.color,
                selectionPalette = this._selectionPalette =  opts.selectionPalette.slice(0);

            this._applyOptions();


            if (!!this._initialColor) {
                this.current(this._initialColor);

                // In case color was black - update the preview UI and set the format
                // since the set function will not run (default color is black).
                self._addColorToSelectionPalette(this._initialColor);
            } else {
                this._updateUI();
            }

            function paletteElementClick(e) {
                self.current($(e.target).closest(".sp-thumb-el").data("color"));
                self.emit("selected",self.current());
                return false;
            }

            var paletteEvent = browser.isIE ? "mousedown.palette" : "click.palette touchstart.palette";
            this.$el.on(paletteEvent, ".sp-thumb-el", paletteElementClick);
        },


        _applyStates : function() {

        },

        stating : function(name,value) {
        	if (value !== undefined) {
        		this._states[name] = value;
        		this._applyStates();
        	} else {
        		return this._states[name];
        	}
        },

        reflow : function () {
           this._drawPalette();
        },

        current : function(color) {
        	if (color === undefined) {
        		return this._current;
        	} else {
        		this._current = color;
                this._updateUI();
        	}
        }

    });


    plugins.register(ColorPalette);

    return colors.ColorPalette = ColorPalette;

});
define('skylark-domx-plugins-colors/Color-pane',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-popups",
    "skylark-graphics-colors/color",
    "./colors",
    "./color-picker",
    "./color-palette"
],function(langx, browser, noder, finder, $,eventer, styler,fx,plugins,popups,Color,colors,ColorPicker,ColorPalette) {
    "use strict";

    var ColorPane = plugins.Plugin.inherit({
        klassName : "ColorPane",

        pluginName : "lark.colors.pane",

        options : {
            selectors  : {
                pickerContainer : ".sp-picker-container",
                toggleButton : ".sp-palette-toggle",
                paletteContainer : ".sp-palette"
            },

            draggingClass : "sp-dragging",           

            texts : {
                togglePaletteMoreText: "more",
                togglePaletteLessText: "less",
                clearText: "Clear Color Selection",
                noColorSelectedText: "No Color Selected"
            },

            states : {
                showPalette: false,
                showPaletteOnly: false,
                togglePaletteOnly: false,
                showSelectionPalette: true,
                showInput: false,
                allowEmpty: false,
                showButtons: true,
                showInitial: false,
                showAlpha: false
            },

            // Options
            color: false,
            maxSelectionSize: 7

        },

        _updateUI : function () {
            if (this.stating("showPalette")) {
                this.palette._updateUI();
            }
            this.picker._updateUI();
        },


        _applyOptions : function () {
            var opts = this.options;

            this._states = {
                allowEmpty : opts.states.allowEmpty,
                showInput : opts.states.showInput,
                showAlpha : opts.states.showAlpha,
                showButtons : opts.states.showButtons,
                togglePaletteOnly : opts.states.togglePaletteOnly,
                showPalette : opts.states.showPalette,
                showPaletteOnly : opts.states.showPaletteOnly,
                showSelectionPalette: opts.showSelectionPalette,
                showInitial : opts.states.showInitial
            };

           this._applyStates();

           this.reflow();
        },

         _construct: function(elm, options) {
            plugins.Plugin.prototype._construct.call(this,elm,options);

            var $el = this.$el = this.$();

            var opts = this.options,
                theme = opts.theme;


            var 
                //container = this.$container = $(markup,elm.ownerDocument).addClass(theme),
                pickerContainer = this.$pickerContainer =  $el.find(opts.selectors.pickerContainer),
                paletteContainer = this.$paletteContainer =  $el.find(opts.selectors.paletteContainer),
                toggleButton = this.$toggleButton = $el.find(opts.selectors.toggleButton),
                initialColor = this._initialColor =  opts.color,
                isEmpty = this._isEmpty =  !initialColor;

            if (paletteContainer[0]) {
                this.palette = ColorPalette.instantiate(paletteContainer[0],{
                    selectionPalette : opts.selectionPalette,
                    color : opts.color,
                    palette : opts.palette,
                    selectionPalette : opts.selectionPalette
                })
            } 

            if (pickerContainer[0]) {
                this.picker = ColorPicker.instantiate(pickerContainer[0],{
                    color : opts.color,
                    states : {
                        showInput: opts.states.showInput,
                        allowEmpty: opts.states.allowEmpty,
                        showButtons: opts.states.showButtons,
                        showInitial: opts.states.showInitial,
                        showAlpha: opts.states.showAlpha                                            
                    }
                }) ;

                this.listenTo(this.picker,"canceled",(e) => {
                    this.emit("canceled");
                });    
                this.listenTo(this.picker,"choosed",(e) => {
                    this.emit("choosed");
                });    
                this.listenTo(this.picker,"picked",(e,color) => {
                    this.emit("picked",color);
                }); 
            }
            this._init();

        },

        _init : function () {
            var self = this,
                opts = this.options;
           if (browser.isIE) {
                this.$container.find("*:not(input)").attr("unselectable", "on");
            }

            this._applyOptions();


          
            this.listenTo(this.$toggleButton,"click", function (e) {
                eventer.stop(e);

                self.stating("showPaletteOnly",!self.stating("showPaletteOnly"));
            });

            this.listenTo(this.palette,"selected",function(e,color){
                self.picker.current(color);
            });
        },

        revert :  function () {
            this.set(this._colorOnShow, true);
            this._updateOriginalInput(true);
        },


        get : function () {
            return this.picker.current();
        },


        set : function (color) {
            this.picker.current(color);
            this.palette.current(color);
        },

        _applyStates : function() {
           var states = this._states ;

            if (states.showPaletteOnly) {
                states.showPalette = true;
            }

            this.$toggleButton.text(states.showPaletteOnly ? this.option("texts.togglePaletteMoreText"): this.option("texts.togglePaletteLessText"));


            this.$el.toggleClass("sp-input-disabled", !states.showInput)
                            .toggleClass("sp-clear-enabled", !!states.allowEmpty)
                            .toggleClass("sp-alpha-enabled", states.showAlpha)
                            .toggleClass("sp-buttons-disabled", !states.showButtons)
                            .toggleClass("sp-palette-buttons-disabled", !states.togglePaletteOnly)
                            .toggleClass("sp-palette-disabled", !states.showPalette)
                            .toggleClass("sp-palette-only", states.showPaletteOnly)
                            .toggleClass("sp-initial-disabled", !states.showInitial);

            if (states.showPaletteOnly) {
                this.$el.css('left', '-=' + (this.$pickerContainer.outerWidth(true) + 5));
            }
        },

        stating : function(name,value) {
            if (value !== undefined) {
                this._states[name] = value;
                this._applyStates();
            } else {
                return this._states[name];
            }
        },

        reflow : function () {

            if (this.stating("showPalette")) {
                this.palette.reflow();
            }

            this.picker.reflow();

        }
    });


    plugins.register(ColorPane);

    return colors.ColorPane = ColorPane;
});
define('skylark-domx-plugins-colors/color-box',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-popups",
    "skylark-graphics-colors/color",
    "./colors",
    "./Color-pane"
   ],function(langx, noder, finder, $,eventer, styler,plugins,popups,Color,colors,ColorPane) {
    "use strict";

    var ColorBox = plugins.Plugin.inherit({
        klassName : "ColorBox",

        pluginName : "lark.colors.box",

        options : {
            pane : {
                states : {
                    showPalette: false,
                    showPaletteOnly: false,
                    togglePaletteOnly: false,
                    showSelectionPalette: true,
                    showInput: false,
                    allowEmpty: false,
                    showButtons: true,
                    showInitial: false,
                    showAlpha: false
                },                
                maxSelectionSize: 7,

                palette : undefined,
                selectionPalette : undefined
            },

            // Options
            color: false

        },

        _updateUI : function () {
            var realColor = this.get(),
                displayColor = '';
             //reset background info for preview element
            this.$previewElement.removeClass("sp-clear-display");
            this.$previewElement.css('background-color', 'transparent');

            if (!realColor && this.stating("allowEmpty")) {
                // Update the replaced elements background with icon indicating no color selection
                this.$previewElement.addClass("sp-clear-display");
            }
            else {
                var realHex = realColor.toHexString(),
                    realRgb = realColor.toRgbString();

                // Update the replaced elements background color (with actual selected color)
                this.$previewElement.css("background-color", realRgb);

                displayColor = realColor.toString();
            }

            this.pane._updateUI();
        },


        _applyOptions : function () {

           this.reflow();
        },

         _construct: function(elm, options) {
            plugins.Plugin.prototype._construct.call(this,elm,options);

            this.$el = this.$();

            var opts = this.options,
            	$pane = this.$pane = $(opts.pane.template),
                $previewElement = this.$previewElement = this.$el.find(".sp-preview-inner");


            if ($pane[0]) {
                this.pane = ColorPane.instantiate($pane[0],langx.mixin({
                    color : opts.color
                },opts.pane));

            } 

            this._init();

        },

        _init : function () {
            var self = this,
                opts = this.options;

            this._applyOptions();

            var paneIsVisible = false;
            this.$pane.hide();
            function showPane() {
                if (paneIsVisible) {
                    return;
                }
               
                paneIsVisible = true;

                self.$pane.show();

                self.reflow();
                
                self._updateUI();
                
            }

            function hidePane() {
                if (!paneIsVisible) {
                    return;
                }
                paneIsVisible = false;

                self.$pane.hide();
            }


            this.listenTo(this.$el,"click touchstart", function (e) {
                if (paneIsVisible) {
                    hidePane();
                } else {
                    showPane();
                }

              eventer.stop(e);
            });

            this.listenTo(this.pane,"picked",(e,color) => {

                // Update the replaced elements background color (with actual selected color)
                this.$previewElement.css("background-color", color.toRgbString());               
            });

            this.listenTo(this.pane,"canceled choosed",(e) => {
                hidePane();
            });


        },

        revert :  function () {
        	this.pane.revert();
        },


        get : function () {
            return this.pane.get();
        },


        set : function (color) {
        	this.pane.set(color);
        },


        reflow : function () {

            this.$pane.css("position", "absolute");
            this.$pane.offset(popups.calcOffset(this.$pane[0], this.$el[0]));

            this.pane.reflow();

        }


    });

    plugins.register(ColorBox);

    return colors.ColorBox = ColorBox;

});
define('skylark-domx-plugins-colors/color-pane',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-popups",
    "skylark-graphics-colors/color",
    "./colors",
    "./color-picker",
    "./color-palette"
],function(langx, browser, noder, finder, $,eventer, styler,fx,plugins,popups,Color,colors,ColorPicker,ColorPalette) {
    "use strict";

    var ColorPane = plugins.Plugin.inherit({
        klassName : "ColorPane",

        pluginName : "lark.colors.pane",

        options : {
            selectors  : {
                pickerContainer : ".sp-picker-container",
                toggleButton : ".sp-palette-toggle",
                paletteContainer : ".sp-palette"
            },

            draggingClass : "sp-dragging",           

            texts : {
                togglePaletteMoreText: "more",
                togglePaletteLessText: "less",
                clearText: "Clear Color Selection",
                noColorSelectedText: "No Color Selected"
            },

            states : {
                showPalette: false,
                showPaletteOnly: false,
                togglePaletteOnly: false,
                showSelectionPalette: true,
                showInput: false,
                allowEmpty: false,
                showButtons: true,
                showInitial: false,
                showAlpha: false
            },

            // Options
            color: false,
            maxSelectionSize: 7

        },

        _updateUI : function () {
            if (this.stating("showPalette")) {
                this.palette._updateUI();
            }
            this.picker._updateUI();
        },


        _applyOptions : function () {
            var opts = this.options;

            this._states = {
                allowEmpty : opts.states.allowEmpty,
                showInput : opts.states.showInput,
                showAlpha : opts.states.showAlpha,
                showButtons : opts.states.showButtons,
                togglePaletteOnly : opts.states.togglePaletteOnly,
                showPalette : opts.states.showPalette,
                showPaletteOnly : opts.states.showPaletteOnly,
                showSelectionPalette: opts.showSelectionPalette,
                showInitial : opts.states.showInitial
            };

           this._applyStates();

           this.reflow();
        },

         _construct: function(elm, options) {
            plugins.Plugin.prototype._construct.call(this,elm,options);

            var $el = this.$el = this.$();

            var opts = this.options,
                theme = opts.theme;


            var 
                //container = this.$container = $(markup,elm.ownerDocument).addClass(theme),
                pickerContainer = this.$pickerContainer =  $el.find(opts.selectors.pickerContainer),
                paletteContainer = this.$paletteContainer =  $el.find(opts.selectors.paletteContainer),
                toggleButton = this.$toggleButton = $el.find(opts.selectors.toggleButton),
                initialColor = this._initialColor =  opts.color,
                isEmpty = this._isEmpty =  !initialColor;

            if (paletteContainer[0]) {
                this.palette = ColorPalette.instantiate(paletteContainer[0],{
                    selectionPalette : opts.selectionPalette,
                    color : opts.color,
                    palette : opts.palette,
                    selectionPalette : opts.selectionPalette
                })
            } 

            if (pickerContainer[0]) {
                this.picker = ColorPicker.instantiate(pickerContainer[0],{
                    color : opts.color,
                    states : {
                        showInput: opts.states.showInput,
                        allowEmpty: opts.states.allowEmpty,
                        showButtons: opts.states.showButtons,
                        showInitial: opts.states.showInitial,
                        showAlpha: opts.states.showAlpha                                            
                    }
                }) ;

                this.listenTo(this.picker,"canceled",(e) => {
                    this.emit("canceled");
                });    
                this.listenTo(this.picker,"choosed",(e) => {
                    this.emit("choosed");
                });    
                this.listenTo(this.picker,"picked",(e,color) => {
                    this.emit("picked",color);
                }); 
            }
            this._init();

        },

        _init : function () {
            var self = this,
                opts = this.options;
           if (browser.isIE) {
                this.$container.find("*:not(input)").attr("unselectable", "on");
            }

            this._applyOptions();


          
            this.listenTo(this.$toggleButton,"click", function (e) {
                eventer.stop(e);

                self.stating("showPaletteOnly",!self.stating("showPaletteOnly"));
            });

            this.listenTo(this.palette,"selected",function(e,color){
                self.picker.current(color);
            });
        },

        revert :  function () {
            this.set(this._colorOnShow, true);
            this._updateOriginalInput(true);
        },


        get : function () {
            return this.picker.current();
        },


        set : function (color) {
            this.picker.current(color);
            this.palette.current(color);
        },

        _applyStates : function() {
           var states = this._states ;

            if (states.showPaletteOnly) {
                states.showPalette = true;
            }

            this.$toggleButton.text(states.showPaletteOnly ? this.option("texts.togglePaletteMoreText"): this.option("texts.togglePaletteLessText"));


            this.$el.toggleClass("sp-input-disabled", !states.showInput)
                            .toggleClass("sp-clear-enabled", !!states.allowEmpty)
                            .toggleClass("sp-alpha-enabled", states.showAlpha)
                            .toggleClass("sp-buttons-disabled", !states.showButtons)
                            .toggleClass("sp-palette-buttons-disabled", !states.togglePaletteOnly)
                            .toggleClass("sp-palette-disabled", !states.showPalette)
                            .toggleClass("sp-palette-only", states.showPaletteOnly)
                            .toggleClass("sp-initial-disabled", !states.showInitial);

            if (states.showPaletteOnly) {
                this.$el.css('left', '-=' + (this.$pickerContainer.outerWidth(true) + 5));
            }
        },

        stating : function(name,value) {
            if (value !== undefined) {
                this._states[name] = value;
                this._applyStates();
            } else {
                return this._states[name];
            }
        },

        reflow : function () {

            if (this.stating("showPalette")) {
                this.palette.reflow();
            }

            this.picker.reflow();

        }
    });


    plugins.register(ColorPane);

    return colors.ColorPane = ColorPane;
});
define('skylark-domx-plugins-colors/colorer',[
    "skylark-langx/langx",
    "skylark-domx-data",
    "skylark-domx-query",
	"./colors",
	"./color-box",
	"./color-pane"
],function(langx,datax,$,colors,ColorBox,ColorPane){
   var pickers = [],
    replaceInput = [
        "<div class='sp-replacer'>",
            "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
            "<div class='sp-dd'>&#9660;</div>",
        "</div>"
    ].join(''),
    
    markup = (function () {
        return [
            "<div class='sp-container'>",
                "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                    "<div class='sp-palette-button-container sp-cf'>",
                        "<button type='button' class='sp-palette-toggle'></button>",
                    "</div>",
                "</div>",
                "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                        "<div class='sp-fill'></div>",
                        "<div class='sp-top-inner'>",
                            "<div class='sp-color'>",
                                "<div class='sp-sat'>",
                                    "<div class='sp-val'>",
                                        "<div class='sp-dragger'></div>",
                                    "</div>",
                                "</div>",
                            "</div>",
                            "<div class='sp-clear sp-clear-display'>",
                            "</div>",
                            "<div class='sp-hue'>",
                                "<div class='sp-slider'></div>",
                            "</div>",
                        "</div>",
                        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    "</div>",
                    "<div class='sp-input-container sp-cf'>",
                        "<input class='sp-input' type='text' spellcheck='false'  />",
                    "</div>",
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                        "<a class='sp-cancel' href='#'></a>",
                        "<button type='button' class='sp-choose'></button>",
                    "</div>",
                "</div>",
            "</div>"
        ].join("");
    })();


	function colorer(elmInput,options) {
		options = langx.mixin({
            // Options
            color: false,
            flat: false,
            appendTo: "body",
            maxSelectionSize: 7,
            preferredFormat: false,
            containerClassName: "",
            replacerClassName: "",
            theme: "sp-light",

            offset: null,
            pane : {
                
            }
		},options);

		var 
			theme = options.theme,
			flat = options.flat,
			appendTo = options.appendTo,
			$el = $(elmInput),
			$pane = $(markup,elmInput.ownerDocument).addClass(theme),
	        isInput = $el.is("input"),
	        isInputTypeColor = isInput && $el.attr("type") === "color",
	        shouldReplace = this._shouldReplace =  isInput && !flat,
	        $replacer =  (shouldReplace) ? $(replaceInput).addClass(theme)
	                                                      .addClass(options.className)
	                                                      .addClass(options.replacerClassName) 
	                                     : $([]),
	        $offsetElement =  (shouldReplace) ? $replacer : $el;


        delete options.flat;
        delete options.appendTo;

        options.color = options.color || (isInput && $el.val());

        if (shouldReplace) {
            $el.after($replacer).hide();
        }


        $pane.toggleClass("sp-flat", flat)
             .addClass(options.containerClassName);

        if (flat) {
            $el.after($pane).hide();
            var pane = new ColorPane($pane[0],options);
            if (options.picked) {
                pane.on("picked",options.picked);
            }
            if (options.choosed) {
                pane.on("choosed",options.choosed);               
            }
            if (options.canceled) {
                pane.on("canceled",options.canceled);               
            }
            $pane.show();
            return pane;
        } else {
            var $appendTo = appendTo === "parent" ? $el.parent() : $(appendTo);
            if ($appendTo.length !== 1) {
                $appendTo = $("body");
            }

            $appendTo.append($pane);
            options.pane.template = $pane;
            return new ColorBox($replacer[0],options);
        }
	}


   $.fn.colorer =  function (options) {
        var elm = this[0];

        if (elm) {
            var plugin    = datax.data(elm,'domx.colorer')
            if (!plugin) {
                plugin = colorer(elm,options)
                datax.data(elm,'domx.colorer',plugin);
            }

            return plugin;
        }
   };

  
	return colors.colorer = colorer;
});
define('skylark-domx-plugins-colors/drag',[],function() {
    /**************************************************
     * dom-drag.js
     * 09.25.2001
     * www.youngpup.net
     **************************************************
     * 10.28.2001 - fixed minor bug where events
     * sometimes fired off the handle, not the root.
     **************************************************/

    var Drag = {

        obj : null,

        gradx : null,

        init : function(o, oRoot, minX, maxX, minY, maxY, bSwapHorzRef, bSwapVertRef, fXMapper, fYMapper)
        {
            o.onmousedown	= Drag.start;

            o.hmode			= bSwapHorzRef ? false : true ;
            o.vmode			= bSwapVertRef ? false : true ;

            o.root = oRoot && oRoot != null ? oRoot : o ;

            if (o.hmode  && isNaN(parseInt(o.root.style.left  ))) o.root.style.left   = "0px";
           //if (o.vmode  && isNaN(parseInt(o.root.style.top   ))) o.root.style.top    = "0px";
            if (!o.hmode && isNaN(parseInt(o.root.style.right ))) o.root.style.right  = "0px";
           // if (!o.vmode && isNaN(parseInt(o.root.style.bottom))) o.root.style.bottom = "0px";

            o.minX	= typeof minX != 'undefined' ? minX : null;
            o.minY	= typeof minY != 'undefined' ? minY : null;
            o.maxX	= typeof maxX != 'undefined' ? maxX : null;
            o.maxY	= typeof maxY != 'undefined' ? maxY : null;

            o.xMapper = fXMapper ? fXMapper : null;
            o.yMapper = fYMapper ? fYMapper : null;

            o.root.onDragStart	= new Function();
            o.root.onDragEnd	= new Function();
            o.root.onDrag		= new Function();
        },

        start : function(e)
        {
            Drag.gradx.current_slider_id = "#"+this.id;

            var o = Drag.obj = this;
            e = Drag.fixE(e);
            var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
            var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
            o.root.onDragStart(x, y);

            o.lastMouseX	= e.clientX;
            o.lastMouseY	= e.clientY;

            if (o.hmode) {
                if (o.minX != null)	o.minMouseX	= e.clientX - x + o.minX;
                if (o.maxX != null)	o.maxMouseX	= o.minMouseX + o.maxX - o.minX;
            } else {
                if (o.minX != null) o.maxMouseX = -o.minX + e.clientX + x;
                if (o.maxX != null) o.minMouseX = -o.maxX + e.clientX + x;
            }

            if (o.vmode) {
                if (o.minY != null)	o.minMouseY	= e.clientY - y + o.minY;
                if (o.maxY != null)	o.maxMouseY	= o.minMouseY + o.maxY - o.minY;
            }
            else {
                if (o.minY != null) o.maxMouseY = -o.minY + e.clientY + y;
                if (o.maxY != null) o.minMouseY = -o.maxY + e.clientY + y;
            }

            document.onmousemove	= Drag.drag;
            document.onmouseup	= Drag.end;

            return false;
        },

        drag : function(e)
        {
            e = Drag.fixE(e);
            var o = Drag.obj;

            Drag.gradx.update_style_array();
            Drag.gradx.apply_style(Drag.gradx.panel, Drag.gradx.get_style_value());
            var left = Drag.gradx.gx("#"+o.id).css("left");


            if(parseInt(left) > 60 && parseInt(left) < 390) {
                Drag.gradx.gx("#gradx_slider_info") //info element cached before
                .css("left",left)
                .show();
                         
            }/*else {
                if(parseInt(left) > 120) {
                    left = "272px";
                }else{
                    left = "120px";
                }
                    
                gradx.gx("#gradx_slider_info") //info element cached before
                .css("left",left)
                .show();
                     
            }*/
             var color = Drag.gradx.gx("#"+o.id).css("backgroundColor");
            //but what happens if @color is not in RGB ? :(
            var rgb = Drag.gradx.get_rgb_obj(color);
            Drag.gradx.cp.colorer().set(rgb);


            var ey	= e.clientY;
            var ex	= e.clientX;
            var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
            var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
            var nx, ny;

            if (o.minX != null) ex = o.hmode ? Math.max(ex, o.minMouseX) : Math.min(ex, o.maxMouseX);
            if (o.maxX != null) ex = o.hmode ? Math.min(ex, o.maxMouseX) : Math.max(ex, o.minMouseX);
            if (o.minY != null) ey = o.vmode ? Math.max(ey, o.minMouseY) : Math.min(ey, o.maxMouseY);
            if (o.maxY != null) ey = o.vmode ? Math.min(ey, o.maxMouseY) : Math.max(ey, o.minMouseY);

            nx = x + ((ex - o.lastMouseX) * (o.hmode ? 1 : -1));
            ny = y + ((ey - o.lastMouseY) * (o.vmode ? 1 : -1));

            if (o.xMapper)		nx = o.xMapper(y)
            else if (o.yMapper)	ny = o.yMapper(x)

            Drag.obj.root.style[o.hmode ? "left" : "right"] = nx + "px";
            //Drag.obj.root.style[o.vmode ? "top" : "bottom"] = ny + "px";
            Drag.obj.lastMouseX	= ex;
            Drag.obj.lastMouseY	= ey;

            Drag.obj.root.onDrag(nx, ny);
            return false;
        },

        end : function()
        {
            document.onmousemove = null;
            document.onmouseup   = null;
            Drag.obj.root.onDragEnd(	parseInt(Drag.obj.root.style[Drag.obj.hmode ? "left" : "right"]), 
                parseInt(Drag.obj.root.style[Drag.obj.vmode ? "top" : "bottom"]));
            Drag.obj = null;
        },

        fixE : function(e)
        {
            if (typeof e == 'undefined') e = window.event;
            if (typeof e.layerX == 'undefined') e.layerX = e.offsetX;
            if (typeof e.layerY == 'undefined') e.layerY = e.offsetY;
            return e;
        }
    };

    return Drag;
});
define('skylark-domx-plugins-colors/gradienter',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-domx-plugins-base",    
    "skylark-graphics-colors/color",
    "./colors",
    "./colorer",
    "./drag"
],function( langx, browser, noder, eventer,finder, $, plugins,Color, colors,colorer,Drag) {


    /*
     *
     * SAMPLE USAGE DETAILS :
     * 
     * sliders structure :
     *
     * [
     *  {
     *     color: "COLOR",
     *     position: "POSITION" //0 to 100 without % symbol
     *  },
     *  {
     *     ....
     *     ....
     *  },
     *  ....
     * ]
     *
     */

    'use strict';

    //make me jquery UI  independent
    if (typeof $.fn.draggable === "undefined") {

        $.fn.draggable = function() {
            //console.log(this);
            var ele = document.getElementById(this.attr("id"));
            ele.style.top = "121px";
            Drag.init(ele, null, 26, 426, 86, 86);
            return this;
        };


    }


    var gradX  = function(id, _options) {


        var options = {
            targets: [], //[element selector] -> array
            sliders: [],
            direction: 'left',
            //if linear left | top | right | bottom
            //if radial left | center | right , top | center | bottom 
            type: 'linear', //linear | circle | ellipse
            code_shown: false, //false | true
            change: function(sliders, styles) {
                //nothing to do here by default
            }
        },
    	
        //make global	
        gradx = Drag.gradx = {
            rand_RGB: [],
            rand_pos: [],
            id: null,
            slider_ids: [],
            slider_index: 0, //global index for sliders
            sliders: [], //contains styles of each slider
            direction: "left", //direction of gradient or position of centre in case of radial gradients
            type: "linear", //linear or radial
            shape: "cover", //radial gradient size
            slider_hovered: [],
            jQ_present: true,
            code_shown: false,
            load_jQ: function() {

                //handle any library conflicts here
                this.gx = $;
            },
            //very lazy to replace this by jQuery
            add_event: function(el, evt, evt_func) {
                add_event(el, evt, evt_func);
            },
            get_random_position: function() {
                var pos;

                do {
                    pos = parseInt(Math.random() * 100);
                }
                while (this.rand_pos.indexOf(pos) > -1);

                this.rand_pos.push(pos);
                return pos;

            },
            get_random_rgb: function() {

                var R, G, B, color;

                do {
                    R = parseInt(Math.random() * 255);
                    G = parseInt(Math.random() * 255);
                    B = parseInt(Math.random() * 255);

                    color = "rgb(" + R + ", " + G + ", " + B + ")";
                }
                while (this.rand_RGB.indexOf(color) > -1);

                this.rand_RGB.push(color);
                return color;

            },
            //if target element is specified the target's style (background) is updated
            update_target: function(values) {

                if (this.targets.length > 0) {
                    //target elements exist

                    var i, j, ele, len = this.targets.length, v_len = values.length;
                    for (i = 0; i < len; i++) {
                        ele = gradx.gx(this.targets[i]);

                        for (j = 0; j < v_len; j++) {
                            ele.css("background-image", values[j]);
                        }

                    }
                }
            },
            //apply styles on fly
            apply_style: function(ele, value) {

                var type = 'linear';

                if (gradx.type != 'linear') {
                    type = 'radial';
                }

                if (value.indexOf(this.direction) > -1) {
                    //add cross-browser compatibility
                    var values = [
                        "-webkit-" + type + "-gradient(" + value + ")",
                        "-moz-" + type + "-gradient(" + value + ")",
                        "-ms-" + type + "-gradient(" + value + ")",
                        "-o-" + type + "-gradient(" + value + ")",
                        type + "-gradient(" + value + ")"
                    ];
                } else {
                    //normal color
                    values = [value];
                }



                var len = values.length, css = '';

                while (len > 0) {
                    len--;
                    ele.css("background", values[len]);
                    css += "background: " + values[len] + ";\n";
                }

                //call the userdefined change function
                this.change(this.sliders, values);
                this.update_target(values);


                gradx.gx('#gradx_code').html(css);

            },
            //on load
            apply_default_styles: function() {
                this.update_style_array()
                var value = this.get_style_value();
                this.apply_style(this.panel, value);
            },
            //update the slider_values[] while dragging
            update_style_array: function() {

                this.sliders = [];

                var len = gradx.slider_ids.length,
                        i, offset, position, id;

                for (i = 0; i < len; i++) {
                    id = "#" + gradx.slider_ids[i];
                    offset = parseInt(gradx.gx(id).css("left"));
                    position = parseInt((offset / gradx.container_width) * 100);
                    position -= 6; //TODO: find why this is required
                    gradx.sliders.push([gradx.gx(id).css("background-color"), position]);

                }

                this.sliders.sort(function(A, B) {
                    if (A[1] > B[1])
                        return 1;
                    else
                        return -1;
                });
            },
            //creates the complete css background value to later apply style
            get_style_value: function() {

                var len = gradx.slider_ids.length;

                if (len === 1) {
                    //since only one slider , so simple background

                    style_str = this.sliders[0][0];
                } else {
                    var style_str = "", suffix = "";
                    for (var i = 0; i < len; i++) {
                        if (this.sliders[i][1] == "") {
                            style_str += suffix + (this.sliders[i][0]);

                        } else {
                            if (this.sliders[i][1] > 100) {
                                this.sliders[i][1] = 100;
                            }
                            style_str += suffix + (this.sliders[i][0] + " " + this.sliders[i][1] + "%");

                        }
                        suffix = " , "; //add , from next iteration
                    }

                    if (this.type == 'linear') {
                        //direction, [color stoppers]
                        style_str = this.direction + " , " + style_str; //add direction for gradient
                    } else {
                        //position, type size, [color stoppers]
                        style_str = this.direction + " , " + this.type + " " + this.shape + " , " + style_str;
                    }
                }

                return style_str;
            },
            //@input rgb string rgb(<red>,<green>,<blue>)
            //@output rgb object of form { r: <red> , g: <green> , b : <blue>}
            get_rgb_obj: function(rgb) {

                //rgb(r,g,b)
                rgb = rgb.split("(");
                //r,g,b)
                rgb = rgb[1];
                //r g b)
                rgb = rgb.split(",");

                return {
                    r: parseInt(rgb[0]),
                    g: parseInt(rgb[1]),
                    b: parseInt(rgb[2])
                };

            },
            load_info: function(ele) {
                var id = "#" + ele.id;
                this.current_slider_id = id;
                //check if current clicked element is an slider
                if (this.slider_ids.indexOf(ele.id) > -1) { //javascript does not has # in its id

                    var color = gradx.gx(id).css("backgroundColor");
                    //but what happens if @color is not in RGB ? :(
                    var rgb = this.get_rgb_obj(color);

                    var left = gradx.gx(id).css("left");
                    if (parseInt(left) > 26 && parseInt(left) < 426) {
                        gradx.gx("#gradx_slider_info") //info element cached before
                                .css("left", left)
                                .show();

                    } 
                    
                    this.set_colorpicker(rgb);
                    console.log(rgb);
                }

            },
            //add slider
            add_slider: function(sliders) {


                var id, slider, k, position, value, delta;


                if (sliders.length === 0) {
                    sliders = [//default sliders
                        {
                            color: gradx.get_random_rgb(),
                            position: gradx.get_random_position() //x percent of gradient panel(400px)
                        },
                        {
                            color: gradx.get_random_rgb(),
                            position: gradx.get_random_position()
                        }
                    ];

                }


                var obj = sliders;

                for (k in obj) {

                    if (typeof obj[k].position === "undefined")
                        break;

                    //convert % to px based on containers width
                    var delta = 26; //range: 26px tp 426px
                    position = parseInt((obj[k].position * this.container_width) / 100) + delta + "px";

                    id = "gradx_slider_" + (this.slider_index); //create an id for this slider
                    this.sliders.push(
                            [
                                obj[k].color,
                                obj[k].position
                            ]
                            );

                    this.slider_ids.push(id); //for reference wrt to id

                    slider = "<div class='gradx_slider' id='" + id + "'></div>";
                    gradx.gx("#gradx_start_sliders_" + this.id).append(slider);

                    gradx.gx('#' + id).css("backgroundColor", obj[k].color).css("left", position);
                    this.slider_index++;
                }

                for (var i = 0, len = this.slider_ids.length; i < len; i++) {

                    gradx.gx('#' + this.slider_ids[i]).draggable({
                        containment: 'parent',
                        axis: 'x',
                        start: function() {
                            if (gradx.jQ_present)
                                gradx.current_slider_id = "#" + gradx.gx(this).attr("id"); //got full jQuery power here !
                        },
                        drag: function() {

                            gradx.update_style_array();
                            gradx.apply_style(gradx.panel, gradx.get_style_value());
                            var left = gradx.gx(gradx.current_slider_id).css("left");


                            if (parseInt(left) > 26 && parseInt(left) < 426) {
                                gradx.gx("#gradx_slider_info") //info element cached before
                                        .css("left", left)
                                        .show();

                            } /*else {
                             if (parseInt(left) > 120) {
                             left = "272px";
                             } else {
                             left = "120px";
                             }
                             
                             gradx.gx("#gradx_slider_info") //info element cached before
                             .css("left", left)
                             .show();
                             
                             }*/
                            var color = gradx.gx(gradx.current_slider_id).css("backgroundColor");
                            //but what happens if @color is not in RGB ? :(
                            var rgb = gradx.get_rgb_obj(color);
                            gradx.cp.colorer().set(rgb);

                        }

                    }).click(function() {
                        gradx.load_info(this);
                        return false;
                    });
                }


            },
            set_colorpicker: function(clr) {
                gradx.cp.colorer({
                    picked: function(e,color) {
                        if (gradx.current_slider_id != false) {
                            var rgba = color.toRgbString();
                            gradx.gx(gradx.current_slider_id).css('background-color', rgba);
                            gradx.update_style_array();
                            gradx.apply_style(gradx.panel, gradx.get_style_value());
                        }
                    },
                    choosed: function(e) {
                        gradx.gx("#gradx_slider_info").hide();
                    },
                    canceled: function(e) {
                        gradx.gx("#gradx_slider_info").hide();
                    },
                    
                    flat: true,
                    showAlpha: true,
                    color: clr,
                    clickoutFiresChange: true,
                    showInput: true,
                    showButtons: false

                });
            },
            generate_options: function(options) {

                var len = options.length,
                        name, state,
                        str = '';

                for (var i = 0; i < len; i++) {

                    name = options[i].split(" ");

                    name = name[0];

                    if (i < 2) {
                        state = name[1];
                    } else {
                        state = '';
                    }

                    name = name.replace("-", " ");

                    str += '<option value=' + options[i] + ' ' + state + '>' + name + '</option>';

                }

                return str;
            },
            generate_radial_options: function() {

                var options;
                options = ["horizontal-center disabled", "center selected", "left", "right"];
                gradx.gx('#gradx_gradient_subtype').html(gradx.generate_options(options));

                options = ["vertical-center disabled", "center selected", "top", "bottom"];
                gradx.gx('#gradx_gradient_subtype2').html(gradx.generate_options(options)).show();

            },
            generate_linear_options: function() {

                var options;
                options = ["horizontal-center disabled", "left selected", "right", "top", "bottom"];
                gradx.gx('#gradx_gradient_subtype').html(gradx.generate_options(options));

                gradx.gx('#gradx_gradient_subtype2').hide();

            },
            destroy: function() {
                var options = {
                    targets: [], //[element selector] -> array
                    sliders: [],
                    direction: 'left',
                    //if linear left | top | right | bottom
                    //if radial left | center | right , top | center | bottom 
                    type: 'linear', //linear | circle | ellipse
                    code_shown: false, //false | true
                    change: function(sliders, styles) {
                        //nothing to do here by default
                    }
                };

                for (var k in options) {
                    gradx[k] = options[k];
                }
            },
            load_gradx: function(id, sliders) {
                this.me = gradx.gx(id);
                this.id = id.replace("#", "");
                id = this.id;
                this.current_slider_id = false;
                var html = "<div class='gradx'>\n"+
                            "<div id='gradx_add_slider' class='gradx_add_slider gradx_btn'><i class='icon icon-add'></i>add</div>\n"+
                            "<div class='gradx_slectboxes'>\n"+
                            "<select id='gradx_gradient_type' class='gradx_gradient_type'>\n"+
                            "    <option value='linear'>Linear</option>\n"+
                            "    <option value='circle'>Radial - Circle</option>\n"+
                            "    <option value='ellipse'>Radial - Ellipse</option>\n"+
                            "</select>\n"+
                            "<select id='gradx_gradient_subtype' class='gradx_gradient_type'>\n"+
                            "    <option id='gradx_gradient_subtype_desc' value='gradient-direction' disabled>gradient direction</option>\n"+
                            "    <option value='left' selected>Left</option>\n"+
                            "    <option value='right'>Right</option>\n"+
                            "    <option value='top'>Top</option>\n"+
                            "    <option value='bottom'>Bottom</option>\n"+
                            "</select>\n"+
                            "<select id='gradx_gradient_subtype2' class='gradx_gradient_type gradx_hide'>\n"+
                            "</select>\n"+
                            "<select id='gradx_radial_gradient_size' class='gradx_gradient_type gradx_hide'>\n"+
                            "</select>\n"+
                            "</div>\n"+
                            "<div class='gradx_container' id='gradx_" + id + "'>\n"+
                            "    <div id='gradx_stop_sliders_" + id + "'></div>\n"+
                            "    <div class='gradx_panel' id='gradx_panel_" + id + "'></div>\n"+
                            "    <div class='gradx_start_sliders' id='gradx_start_sliders_" + id + "'>\n"+
                            "        <div class='cp-default' id='gradx_slider_info'>\n"+
                            "            <div id='gradx_slider_controls'>\n"+
                            "                <div id='gradx_delete_slider' class='gradx_btn'><i class='icon icon-remove'></i>delete</div>\n"+
                            "            </div>\n"+
                            "            <div id='gradx_slider_content'></div>\n"+
                            "        </div> \n"+
                            "    </div>\n"+
                            "</div>\n"+
                            "<div id='gradx_show_code' class='gradx_show_code gradx_btn'><i class='icon icon-file-css'></i><span>show the code</span></div>\n"+
                            "<div id='gradx_show_presets' style='display:none' class='gradx_show_presets gradx_btn'><i class='icon icon-preset'></i><span>show presets</span></div>\n"+
                            "<textarea class='gradx_code' id='gradx_code'></textarea>\n"+
                        "</div>";

                this.me.html(html);


                //generates html to select the different gradient sizes
                // *only available for radial gradients
                var gradient_size_val = ["gradient-size disabled", "closest-side selected", "closest-corner", "farthest-side", "farthest-corner", "contain", "cover"],
                        option_str = '';


                option_str = gradx.generate_options(gradient_size_val);

                gradx.gx('#gradx_radial_gradient_size').html(option_str);


                //cache divs for fast reference

                this.container = gradx.gx("#gradx_" + id);
                this.panel = gradx.gx("#gradx_panel_" + id);
                //.hide();
                //this.info.hide();
                this.container_width = 400 //HARDCODE;
                this.add_slider(sliders);


                gradx.add_event(document, 'click', function() {
    //            if(!gradx.jQ_present){
                    if (!gradx.slider_hovered[id]) {
                        gradx.gx("#gradx_slider_info").hide();
                        return false;
                    }
                });



                gradx.gx('#gradx_add_slider').click(function() {
                    gradx.add_slider([
                        {
                            color: gradx.get_random_rgb(),
                            position: gradx.get_random_position() //no % symbol
                        }
                    ]);
                    gradx.update_style_array();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                //cache the element
                gradx.cp = gradx.gx('#gradx_slider_content');

                //call the colorpicker plugin
                gradx.set_colorpicker("blue");

                gradx.gx('#gradx_delete_slider').click(function() {
                    gradx.gx(gradx.current_slider_id).remove();
                    gradx.gx("#gradx_slider_info").hide();
                    var id = gradx.current_slider_id.replace("#", "");

                    //remove all references from array for current deleted slider

                    for (var i = 0; i < gradx.slider_ids.length; i++) {
                        if (gradx.slider_ids[i] == id) {
                            gradx.slider_ids.splice(i, 1);
                        }
                    }

                    //apply modified style after removing the slider
                    gradx.update_style_array();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());

                    gradx.current_slider_id = false; //no slider is selected

                });

                gradx.gx('#gradx_code').focus(function() {
                    var $this = gradx.gx(this);
                    $this.select();

                    // Work around Chrome's little problem
                    $this.mouseup(function() {
                        // Prevent further mouseup intervention
                        $this.off("mouseup");
                        return false;
                    });
                });

                gradx.gx('#gradx_gradient_type').change(function() {

                    var type = gradx.gx(this).val(), options, option_str = '';

                    if (type !== "linear") {
                        //gradx.gx('#gradx_radial_gradient_size').show();

                        gradx.generate_radial_options();
                    } else {

                        gradx.generate_linear_options();
                        gradx.gx('#gradx_gradient_subtype').val("left");
                    }

                    gradx.type = type;
                    gradx.direction = gradx.gx('#gradx_gradient_subtype').val();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)
                });

                //change type onload userdefined
                if (this.type !== "linear") {
                    gradx.gx('#gradx_gradient_type').val(this.type);
                    gradx.generate_radial_options();

                    var h, v;

                    if (this.direction !== 'left') {
                        //user has passed his own direction
                        var center;
                        if (this.direction.indexOf(",") > -1) {
                            center = this.direction.split(",");
                        } else {
                            //tolerate user mistakes
                            center = this.direction.split(" ");
                        }

                        h = center[0];
                        v = center[1];

                        //update the center points in the corr. select boxes
                        gradx.gx('#gradx_gradient_subtype').val(h);
                        gradx.gx('#gradx_gradient_subtype2').val(v);
                    } else {
                        var h = gradx.gx('#gradx_gradient_subtype').val();
                        var v = gradx.gx('#gradx_gradient_subtype2').val();
                    }

                    gradx.direction = h + " " + v;
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)
                } else {

                    //change direction if not left
                    if (this.direction !== 'left') {
                        gradx.gx('#gradx_gradient_subtype').val(this.direction);
                    }
                }

                gradx.gx('#gradx_gradient_subtype').change(function() {

                    if (gradx.type === 'linear') {
                        gradx.direction = gradx.gx(this).val();
                    } else {
                        var h = gradx.gx(this).val();
                        var v = gradx.gx('#gradx_gradient_subtype2').val();
                        gradx.direction = h + " " + v;
                    }
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                gradx.gx('#gradx_gradient_subtype2').change(function() {

                    var h = gradx.gx('#gradx_gradient_subtype').val();
                    var v = gradx.gx(this).val();
                    gradx.direction = h + " " + v;
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                //not visible
                gradx.gx('#gradx_radial_gradient_size').change(function() {
                    gradx.shape = gradx.gx(this).val();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                gradx.gx('#gradx_show_code').click(function() {

                    if (gradx.code_shown) {
                        //hide it

                        gradx.code_shown = false;
                        gradx.gx('#gradx_show_code span').text("show the code");
                        gradx.gx("#gradx_code").hide();
                    }
                    else {
                        //show it

                        gradx.gx('#gradx_show_code span').text("hide the code");
                        gradx.gx("#gradx_code").show();
                        gradx.code_shown = true;
                    }
                });

                //show or hide onload
                if (gradx.code_shown) {
                    //show it

                    gradx.gx('#gradx_show_code span').text("hide the code");
                    gradx.gx("#gradx_code").show();

                }

                gradx.add_event(document.getElementById('gradx_slider_info'), 'mouseout', function() {
                    gradx.slider_hovered[id] = false;
                });
                gradx.add_event(document.getElementById('gradx_slider_info'), 'mouseover', function() {
                    gradx.slider_hovered[id] = true;

                });

            }




        };



        function  add_event(element, event, event_function)
        {
            if (element.attachEvent) //Internet Explorer
                element.attachEvent("on" + event, function() {
                    event_function.call(element);
                });
            else if (element.addEventListener) //Firefox & company
                element.addEventListener(event, event_function, false); //don't need the 'call' trick because in FF everything already works in the right way
        }
        ;



        //load jQuery library into gradx.gx
        gradx.load_jQ();


        /* merge _options into options */
        langx.mixin(options, _options);

        //apply options to gradx object

        for (var k in options) {

            //load the options into gradx object
            gradx[k] = options[k];

        }

        gradx.load_gradx(id, gradx.sliders);
        gradx.apply_default_styles();


    };

    return colors.Gradienter = gradX;
});
define('skylark-domx-plugins-colors/main',[
	"skylark-domx-query",
	"./colors",
  "./colorer",
  "./color-palette",
  "./color-picker",
  "./color-pane",
  "./gradienter"
], function($,colors,colorer) {
   
   return colors;

});

define('skylark-domx-plugins-colors', ['skylark-domx-plugins-colors/main'], function (main) { return main; });

define('skylark-domx-plugins-groups/groups',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.groups = {};
});

 define('skylark-domx-plugins-groups/group',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-domx-plugins-base",
  "./groups"
],function(langx,$,elmx,plugins,groups){
  'use strict'

    /*
     * The base plugin class for grouping items.
     */
    var Group = plugins.Plugin.inherit({
        klassName : "Group",

        pluginName : "lark.groups.group",

        options : {
        	classes : {
        	},

        	selectors : {
            //container : "ul", // 
        	},

          item : {
            template : "<span><i class=\"glyphicon\"></i><a href=\"javascript: void(0);\"></a> </span>",
            selector : "li",      // ".list-group-item"

            selectable: false,
            multiSelect: false,

            classes : {
              base : "item",
              selected : "selected",
              active : "active"
            }
          },

          //active : 0,

          //A collection or function that is used to generate the content of the group 
          /*
           * example1
           *itemsSource : [{  
           *  type: 'image',href : "https://xxx.com/1.jpg",title : "1"
           *},{
           *  type: 'image',href : "https://xxx.com/1.jpg",title : "1"
           * }],
           */
          /*
           * example2
           *itemsSource :  function(){},
           */
        },

        selected : null,
 
        _construct : function(elm,options) {
            this.overrided(elm,options);
            var self = this,
                velm = this._velm = elmx(this._elm),
                itemSelector = this.options.item.selector;

            velm.on('click', itemSelector, function () {
                var veItem = elmx(this);
                if (!veItem.hasClass('disabled')) {
                    let value = self.getItemValue(this);
                    self.setActiveItem(value);

                  if (self.options.item.selectable) {

                      if (self.options.item.multiSelect) {
                        self.toggleSelectOneItem(value);
                      } else {
                        self.clearSelectedItems();
                        self.selectOneItem(value);
                      }
                  }

                }


                //veItem.blur();
                return false;
            });

            this.resetItems();

            ///if (this.options.item.multiSelect) {
            ///  this.selected = [];
            ///} else {
            ///  this.selected = null;
            ///}
            ///this.selected = this.options.selected;
        },

        resetItems : function() {
            this._$items = this._velm.$(this.options.item.selector);
        },

        findItem : function (valueOrIdx) {
          var $item;
          if (langx.isNumber(valueOrIdx)) {
            $item = this._$items.eq(valueOrIdx);
          } else if (langx.isString(valueOrIdx)) {
            $item = this._$items.filter('[data-value="' + valueOrIdx + '"]');
          } else {
            $item = $(valueOrIdx);
          }
          return $item[0];
        },

        getItems : function() {
          return this._$items;
        },

        getItemValue : function(item) {
          let $item = $(item),
              value = $item.data("value");
          if (value === undefined) {
            value = this._$items.index($item[0]);
          }
          return value;
        },

        getItemsCount : function() {
            return this._$items.size();
        },

        getItemIndex : function(item) {
            return this._$items.index(item);
        },

        
        isSelectedItem : function(valueOrIdx) {
          return $(this.findItem(valueOrIdx)).hasClass(this.options.item.classes.selected);
        },
                 
        selectOneItem : function (valueOrIdx) {
          $(this.findItem(valueOrIdx)).addClass(this.options.item.classes.selected);
        },

        unselectOneItem : function (valueOrIdx) {
          $(this.findItem(valueOrIdx)).removeClass(this.options.item.classes.selected);
        },

        /*
         * clears the selected items.
         */
        clearSelectedItems : function() {
          let selectedClass = this.options.item.classes.selected;
          this._$items.filter(`.${selectedClass}`).removeClass(selectedClass);
        },

        getSelectedItemValues : function() {
          let selectedClass = this.options.item.classes.selected;
          return  this._$items.filter(`.${selectedClass}`).map( (el) => {
            return this.getItemValue(el);
          });
        },

        getSelectedItems : function() {
          let selectedClass = this.options.item.classes.selected;
          return  this._$items.filter(`.${selectedClass}`);
        },

        getActiveItem : function() {
          let activeClass = this.options.item.classes.active,
              $activeItem = this._$items.filter(`.${activeClass}`);
          return $activeItem[0] || null;
        },

        setActiveItem : function(valueOrIdx) {
          let current = this.getActiveItem(),
              next = this.findItem(valueOrIdx);
          if (next != current) {
            let activeClass = this.options.item.classes.active;
            $(current).removeClass(activeClass);
            $(next).addClass(activeClass);
          }
        },


        getSelectedItem : function() {
          let selectedItems = this.getSelectedItems();
          return selectedItems[0] || null;
        },

        toggleSelectOneItem : function(valueOrIdx) {
          if (this.isSelectedItem(valueOrIdx)) {
            this.unselectOneItem(valueOrIdx);
          } else {
            this.selectOneItem(valueOrIdx);
          }
        },

        renderItemHtml : function(itemData) {
          if (!this._renderItemHtml) {
            let itemTpl = this.options.item.template;
            if (langx.isString(itemTpl)) {
              this._renderItemHtml = langx.template(itemTpl);
            } else if (langx.isFunction(itemTpl)) {
              this._renderItemHtml = itemTpl;
            }
          }

          return this._renderItemHtml(itemData);
        }

  });


  plugins.register(Group);

  return groups.Group = Group;

});




 define('skylark-domx-plugins-groups/_carousel/indicators',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-domx-plugins-base",
  "../groups"
],function(langx,browser,eventer,$,elmx,plugins,groups){


  var Indicators = plugins.Plugin.inherit({
    klassName : "Indicators",

    pluginName : "lark.groups.carousel.indicators",


    options : {
      thumbnail : true,

      indicator : {
	      template : "<li/>",
	      indexAttrName : "data-index",
	      selector : "> li",
	      classes : {
	          active : "active"
	      }
      }
    },

    _construct: function(elm, options) {
    	plugins.Plugin.prototype._construct.call(this,elm,options);

      this._velm = this.elmx();
    	this.$indicators = this._velm.query(this.options.indicator.selector);

      this._velm.on("click", `[${this.options.indicator.indexAttrName}]`, (e) => {
          var $indicator = $(e.target),
              slideIndex = $indicator.attr(this.options.indicator.indexAttrName);

          this.options.carousel.jump(slideIndex);
          e.preventDefault();
      });
    },


    createIndicator: function (itemData) {
      if (!this._renderIndicatorHtml) {
        this._renderIndicatorHtml = langx.template(this.options.indicator.template);
      }

      /*
      var indicator = noder.createElement("li");
      var title = itemData.title;
      var thumbnailUrl
      var thumbnail
      if (this.options.thumbnail) {
        thumbnailUrl = itemData["thumbnail"]

        if (thumbnailUrl) {
          indicator.style.backgroundImage = 'url("' + thumbnailUrl + '")'
        }
      }
      if (title) {
        indicator.title = title;
      }
      */

      return $(this._renderIndicatorHtml(itemData))[0];
    },

    addIndicator: function (index,itemData) {
        var indicator = this.createIndicator(itemData)
        indicator.setAttribute('data-index', index)
        this._velm.append(indicator)
        this.$indicators = this.$indicators.add(indicator);
    },

    clearIndicators : function() {
       this.$indicators.remove();
    },
    
    setActiveIndicator: function (index) {
      if (this.$indicators) {
        let activeIndicatorClass = this.options.indicator.classes.active;
        if (this.activeIndicator) {
          this.activeIndicator.removeClass(activeIndicatorClass)
        }
        this.activeIndicator = $(this.$indicators[index])
        this.activeIndicator.addClass(activeIndicatorClass)
      }
    }

  });

  return Indicators;
});
 define('skylark-domx-plugins-groups/_carousel/mode-slide',[
  "skylark-langx/langx",
  "skylark-langx-events",
  "skylark-domx-eventer"
],function(langx,events,eventer){
  'use strict'


  var ModeSlide = events.Emitter.inherit({


    _construct : function(carsouel) {
    	this.carsouel = carsouel;
    },

    jump : function(toIndex,currentIndex,type,ended) {
    	let carsouel = this.carsouel,
    		velm = carsouel.elmx(),
    		options = carsouel.options,

            $active =  carsouel.$(carsouel.findItem(currentIndex)),
        	$next = carsouel.$(carsouel.findItem(toIndex)),
        	isCycling = carsouel.interval,
        	direction = type == 'next' ? 'left' : 'right';

        ///if ($next.hasClass('active')) {
        ///	return (carsouel.moving = false)
        ///}

        isCycling && carsouel.pause();

        /*
        if (this._$indicators.length) {
            this._$indicators.find('.active').removeClass('active');
            var $nextIndicator = $(this._$indicators.children()[this.getItemIndex($next)]);
            $nextIndicator && $nextIndicator.addClass('active');
        }
        */

        $next.addClass(type);
        $next.reflow(); // [0].offsetWidth; // force reflow
        $active.addClass(direction);
        $next.addClass(direction);
        $next
            .one('transitionEnd', function() {
                ///$next.removeClass([type, direction].join(' ')).addClass('active')
                ///$active.removeClass(['active', direction].join(' '))
                $next.removeClass([type, direction].join(' '));
                $active.removeClass(direction);
                ended();
            })
            .emulateTransitionEnd();

        isCycling && carsouel.cycle();

        return this
    }

  });


  return ModeSlide;	
});
define('skylark-domx-plugins-interact/interact',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.interact = {};
});

define('skylark-domx-plugins-interact/rotatable',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-plugins-base",
    "./interact"
],function(langx,noder,datax,geom,eventer,styler,plugins,interact){
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height,
        some = Array.prototype.some,
        map = Array.prototype.map;



    function applyTranform(obj,tX,tY) {
        // Constrain the angle of camera (between 0 and 180)
        if (tY > 180) tY = 180;
        if (tY < 0) tY = 0;

        // Apply the angle
        obj.style.transform = "rotateX(" + -tY + "deg) rotateY(" + tX + "deg)";
    }


    var Rotatable = plugins.Plugin.inherit({
        klassName: "Rotatable",

        pluginName : "lark.interact.rotatable",


        _construct : function (elm, options) {
            this.overrided(elm,options);


            options = this.options;
            var self = this,
                handleEl = options.handle || elm,
                overlayDiv,
                doc = options.document || document,
                downButton,
                start,
                stop,
                prevX,
                prevY,
                startingCallback = options.starting,
                startedCallback = options.started,
                movingCallback = options.moving,
                stoppedCallback = options.stopped,

                tX = 0,
                tY = 10,
                deltaX = 0,
                deltaY = 0,

                timer,

                start = function(e) {
                    if (e.pointerType=="mouse" &&  e.button !== 0) {
                        return stop(e);
                    }
                    
                    var docSize = geom.getDocumentSize(doc),
                        cursor;

                    if (startingCallback) {
                        var ret = startingCallback(e)
                        if ( ret === false) {
                            return;
                        } else if (langx.isPlainObject(ret)) {
                            if (ret.started) {
                                startedCallback = ret.started;
                            }
                            if (ret.moving) {
                                movingCallback = ret.moving;
                            }                            
                            if (ret.stopped) {
                                stoppedCallback = ret.stopped;
                            }     
                        }
                    }

                    e.preventDefault();

                    downButton = e.button;

                    //handleEl = getHandleEl();
                    prevX = e.clientX;
                    prevY = e.clientY;

                    // Grab cursor from handle so we can place it on overlay
                    cursor = styler.css(handleEl, "cursor");

                    overlayDiv = noder.createElement("div");
                    styler.css(overlayDiv, {
                        position: "absolute",
                        top: 0,
                        left: 0,
                        width: docSize.width,
                        height: docSize.height,
                        zIndex: 0x7FFFFFFF,
                        opacity: 0.0001,
                        cursor: cursor
                    });
                    noder.append(doc.body, overlayDiv);

                    clearInterval(timer);

                    eventer.on(doc, "pointermove", move).on(doc, "pointerup", stop);

                    if (startedCallback) {
                        startedCallback(e);
                    }
                },

                move = function(e) {


                    deltaX = e.deltaX = e.clientX - prevX;
                    deltaY = e.deltaY = e.clientY - prevY;

                    prevX = e.clientX;
                    prevY = e.clientY;


                    tX += deltaX * 0.1;
                    tY += deltaY * 0.1;
                    applyTranform(elm,tX,tY);

                    e.preventDefault();

                    if (movingCallback) {
                        movingCallback(e);
                    }
                },

                stop = function(e) { 
                    eventer.off(doc, "pointermove", move).off(doc, "pointerup", stop);

                    let deta

                    timer = setInterval(function() {
                        deltaX *= 0.95;
                        deltaY *= 0.95;
                        tX += deltaX * 0.1;
                        tY += deltaX * 0.1;
                        applyTranform(elm,tX,tY);

                        ///playSpin(false);
                        if (Math.abs(deltaX) < 0.5 && Math.abs(deltaY) < 0.5) {
                          clearInterval(timer);
                          //playSpin(true);
                        }
                    }, 17);

                    noder.remove(overlayDiv);

                    if (stoppedCallback) {
                        stoppedCallback(e);
                    }
                };

            eventer.on(handleEl, "pointerdown", start);

            this._handleEl = handleEl;

        },

        remove : function() {
            eventer.off(this._handleEl);
        }
    });

    plugins.register(Rotatable,"rotatable");

    return interact.Rotatable = Rotatable;
});

define('skylark-domx-plugins-interact/scalable',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-query",
    "skylark-domx-plugins-base",
    "./interact"
],function(langx,noder,datax,geom,eventer,styler,$,plugins,interact){
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height,
        some = Array.prototype.some,
        map = Array.prototype.map;



    function applyTranform(elms,radius) {
        // Apply the angle
        $(elms).forEach(function(elm){
            let $elm = $(elm);
            var originalTransform = $elm.data("originalTransform");
            if (!originalTransform) {
                originalTransform = $elm.css("transform");
                $elm.data("originalTransform",originalTransform);
            }
            $elm.css("transform",originalTransform +" translateZ(" +  radius +"px");
        });
    }


    var Scalable = plugins.Plugin.inherit({
        klassName: "Scalable",

        pluginName : "lark.interact.scalable",


        _construct : function (elm, options) {
            this.overrided(elm,options);

            let radius = this.options.radius || 0,
                targets = this.options.targets || elm;

            eventer.on(elm,"mousewheel", function(e) {
                var d = e.wheelDelta / 20 || -e.detail;
                radius += d;
                applyTranform(targets,radius);
            });

            applyTranform(targets,radius);
        }
    });

    plugins.register(Scalable,"scalable");

    return interact.Scalable = Scalable;
});

 define('skylark-domx-plugins-groups/_carousel/mode-rotate',[
  "skylark-langx/langx",
  "skylark-langx-events",
  "skylark-domx-eventer",
  "skylark-domx-query",
  "skylark-domx-styler",
  "skylark-domx-plugins-interact/rotatable",
  "skylark-domx-plugins-interact/scalable"
],function(langx,events,eventer,$,styler,Rotatable,Scalable){
  'use strict'


  var ModeRotate = events.Emitter.inherit({

    options : {

    },


    _construct : function(carsouel) {
      this.carsouel = carsouel;

      this.resetItems();

      this._$threedContainer = carsouel.$(`.${carsouel.options.modes.rotate.classes.threedContainer}`)

      this._rotatable = new Rotatable(this._$threedContainer[0],{
          starting : function(e) {
            return $(e.target).closest(carsouel.options.item.selector).length==0;
          },

          started : function() {
              //playSpin(false);
          },

          stopped : function() {
              //playSpin(true);
          }
      });

      this._scalable = new Scalable(this._$threedContainer[0],{
        radius : carsouel.options.modes.rotate.radius,
        targets : carsouel.getItems()
      });

      this._start = 0;

    },

    resetItems : function(delayTime) {
      let items = this.carsouel.getItems();
      if (items) {
        let itemsCount = this._itemsCount = items.length,
          deltaDeg = this._deltaDeg = 360 / itemsCount;

        for (var i = 0; i < itemsCount; i++) {
          styler.css(items[i],{
            transform : "rotateY(" + (i * deltaDeg) + "deg)"
          });
        }       
      }
    },

    jump : function(toIndex,currentIndex,type,ended) {
        let carsouel = this.carsouel,
            velm = carsouel.elmx(),
            options = carsouel.options,

            $active =  carsouel.$(carsouel.findItem(currentIndex)),
            $next = carsouel.$(carsouel.findItem(toIndex));

        $next.addClass(type);
        $next.reflow(); // [0].offsetWidth; // force reflow

        let $itemsContainer = carsouel._$itemsContainer;

        $itemsContainer
            .one('transitionEnd', function() {
                $next.removeClass(type);
                ended();
            })
            .css("transform","rotateY(" + (toIndex * this._deltaDeg) + "deg)")
            .emulateTransitionEnd();

        return this;
    }


  });


  return ModeRotate;  
});
 define('skylark-domx-plugins-groups/_carousel/mode-coverflow',[
  "skylark-langx/langx",
  "skylark-langx-events",
  "skylark-domx-query",
],function(langx,events,$){
  'use strict'


  var ModeCoverflow = events.Emitter.inherit({


    _construct : function(carsouel) {
    	this.carsouel = carsouel;

    	this._itemOffsets = [];
    	this._currentIndex = -1;

    	let classes = this.carsouel.options.modes.coverflow.classes;

        this._classRemover = new RegExp('\\b(' + classes.itemCurrent + '|' + classes.itemPast + '|' + classes.itemFuture + ')(.*?)(\\s|$)', 'g');
        this._whiteSpaceRemover = new RegExp('\\s\\s+', 'g');

    	this.resetItems();
    },


    resetItems : function () {
    	let classes = this.carsouel.options.modes.coverflow.classes,
    		$itemsContainer = this.carsouel._$itemsContainer,
    		$items = this.carsouel.getItems(),
    		spacing = this.carsouel.options.modes.coverflow.spacing;



        function noTransition() {
            $itemsContainer.css('transition', 'none');
            $items.css('transition', 'none');
        }

        function resetTransition() {
            $itemsContainer.css('transition', '');
            $items.css('transition', '');
        }

	    function calculateBiggestItemHeight() {
	        var biggestHeight = 0,
	            itemHeight;

	        $items.each(function() {
	            itemHeight = $(this).height();
	            if ( itemHeight > biggestHeight ) { biggestHeight = itemHeight; }
	        });
	        return biggestHeight;
	    }


        let skipTransition = true;
        if ( skipTransition ) { 
        	noTransition(); 
        }

         $items.each((i,item) => {
            let $item = $(item);

            $item.attr('class', function(i, c) {
                return c && c.replace(this._classRemover, '').replace(this._whiteSpaceRemover, ' ');
            });

            if ( !$item.children('.' + classes.itemContent ).length) {
                $item.wrapInner('<div class="' + classes.itemContent + '" />');
            }
            let width = $item.outerWidth();

            if ( spacing !== 0 ) {
               $item.css('margin-right', ( width * spacing ) + 'px');
             }
        });


        this._itemOffsets = [];
        let containerWidth = $itemsContainer.width();
        $itemsContainer.height(calculateBiggestItemHeight());
        ///$itemsContainer.height("300px");

        $items.each((i,item) => {
            let $item = $(item),
                width,
                left;
            width = $item.outerWidth();
            left = $item.position().left;
            this._itemOffsets[i] = -1 * ((left + (width / 2)) - (containerWidth / 2));

        });

        if ( skipTransition ) { 
        	setTimeout(resetTransition, 1); 
        }
    },

    center : function (currentIndex) {
    	if (currentIndex !== undefined) {
	        this._currentIndex = currentIndex;
    	} else {
    		currentIndex = this._currentIndex;
    	}
    	if (currentIndex>=0)  {
	        var classes = this.carsouel.options.modes.coverflow.classes,
	        	$itemsContainer = this.carsouel._$itemsContainer,
	        	$items =  this.carsouel.getItems(),
	        	total = $items.length;
	        var $item;
	        var newClass;
	        var zIndex;

	        $items.each((i,item) => {
	            $item = $(item);
	            newClass = ' ';

	            if (i === currentIndex)  {
	                newClass += classes.itemCurrent;
	                zIndex = (total + 1);
	            }
	            else if (i < currentIndex) {
	                newClass += classes.itemPast + ' ' +
	                    classes.itemPast + '-' + (currentIndex - i);
	                zIndex = total - (currentIndex - i);
	            } else  {
	                newClass += classes.itemFuture + ' ' +
	                    classes.itemFuture + '-' + (i - currentIndex);
	                
	                zIndex = total -  (i - currentIndex);
	            }

	            $item.css('z-index', zIndex )
	              .attr('class',(i, c) => {
	                return c && c.replace(this._classRemover, '').replace(this._whiteSpaceRemover,' ') + newClass;
	              });
	        });


	        $itemsContainer.css('transform', 'translateX(' + this._itemOffsets[currentIndex] + 'px)');
    	}
    },

    jump : function(toIndex,currentIndex,type,ended) {
        var $itemsContainer = this.carsouel._$itemsContainer;
        this.center(toIndex);
        $itemsContainer
            .one('transitionEnd', function() {
                ended();
            })
            .emulateTransitionEnd();

        return this;
    }

  });


  return ModeCoverflow;	
});
 define('skylark-domx-plugins-groups/carousel',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-domx-plugins-base",
  "./groups",
  "./group",
  "./_carousel/indicators",
  "./_carousel/mode-slide",
  "./_carousel/mode-rotate",
  "./_carousel/mode-coverflow"
],function(langx,browser,eventer,$,elmx,plugins,groups,Group,Indicators,ModeSlide,ModeRotate,ModeCoverflow){
  'use strict'

 
  var Carousel = Group.inherit({
    klassName : "Carousel",

    pluginName : "lark.groups.carousel",

        options : {
            classes : {
             // The class to add when the carousel is visible:
              display: 'display',
              // The class to add when the carousel only displays one item:
              single: 'single',
              // The class to add when the left edge has been reached:
              leftEdge: 'left',
              // The class to add when the right edge has been reached:
              rightEdge: 'right',
              // The class to add when the automatic slideshow is active:
              cycling: 'cycling',

              // The class to add when the carousel controls are visible:
              controls: 'controls',
            },

            cycle : {
              // [milliseconds]
              // If a positive number, Carousel will automatically advance to next item after that number of milliseconds
              interval: 5000,

              pause: 'hover',
            },

            loop : true,

            wrap: true,
            keyboard: true,

            controls : {
              selectors : {
               // The class for the "toggle" control:
                toggle: '.toggle',
                // The class for the "prev" control:
                prev: '.prev',
                // The class for the "next" control:
                next: '.next',
                // The class for the "close" control:
                close: '.close',
                // The class for the "play-pause" toggle control:
                cycleStop: '.cycle-stop'
              }
            },

            indicators : {
                indicator : {
                  template : "<li/>",
                  indexAttrName : "data-index"
                },

            },

            selectors :{
              itemsContainer : ".items",
              indicatorsContainer : ".indicators"
            },

            item : {
              selector : ".item",
              classes : {
                base : "item"
              }
            },

            data : {
              //items : ".carousel-item",  // the items are from dom elements
              //items : [{                 // the items are from json object
              //  type: 'image',href : "https://xxx.com/1.jpg",title : "1"
              //},{
              //  type: 'image',href : "https://xxx.com/1.jpg",title : "1"
              // }],
            },

            mode : "slide",

            //start : "center", //ex:0

            modes : {
              slide : {
                classes : {
                  base : "slide"
                }
              },

              rotate : {
                classes : {
                  base : "rotate",
                  threedContainer : "items-container"
                },
                radius : 240
              },

              coverflow : {
                classes : {
                  base : "coverflow",
                  itemPast : "past",
                  itemFuture : "future",
                  itemCurrent : "current",
                  itemContent : "content"
                },
                spacing :-0.6
              }
            },

            onjumped : null,
            onjumping : null
        },

        _construct: function(elm, options) {
            //this.options = options
            Group.prototype._construct.call(this,elm,options);

            this.options.item.selectable = true;
            this.options.item.multiSelect = false;


            this._$elm = this.$();
            this._$itemsContainer = this._$elm.find(this.options.selectors.itemsContainer);
            
            let $indicators = this._$elm.find(this.options.selectors.indicatorsContainer); 
            if ($indicators.length>0) {
              this._indicators = new Indicators($indicators[0],langx.mixin({
                carousel : this,
                active : 0
              },this.options.indicators));
              this._indicators.setActiveIndicator(0);
            }

            this.paused = null;
            this.moving = null;
            this.interval = null;
            this.$active = null;

            if (this.options.cycle.interval >0) {
              this.cycle(true);
            } else {
              this.cycle(false);
            }

            var self = this;
            this.options.keyboard && this._$elm.on('keydown.lark.carousel', langx.proxy(this.keydown, this))

            this.options.cycle.pause == 'hover' && !('ontouchstart' in document.documentElement) && this._$elm
                .on('mouseenter.lark.carousel', (e) => {
                  this.pause(true);
                }).on('mouseleave.lark.carousel', (e) => {
                  this.pause(false)
                });

            this._$elm.find(this.options.controls.selectors.prev).on("click",(e)=>{
                this.prev();
                eventer.stop(e);
            });

            this._$elm.find(this.options.controls.selectors.next).on("click",(e)=>{
                this.next();
                eventer.stop(e);
            });

            this._$elm.find(this.options.controls.selectors.cycleStop).on("click",(e)=>{
                this.cycle(!this.cycled);
                eventer.stop(e);
            });


            if (this.options.data.items) {
                this.addItems(this.options.data.items);
            }
            
            this._mode = new modes[this.options.mode](this);


            let startIndex = this.options.start;
            if (startIndex !== undefined) {
              if (startIndex === 'center' ) {
                startIndex = Math.floor(this.getItemsCount() / 2)
              } 

              this.jump(startIndex)              
            }

            if (this.options.onjumped) {
              this.on("jumped",this.options.onjumped)
            }

            if (this.options.onjumping) {
              this.on("jumping",this.options.onjumping)
            }
        },

        changeMode : function(mode) {
          if (mode == this.options.mode) {
            return;
          }

          this.options.mode = mode;

          if (this._mode && this._mode.dispose) {
            this._mode.dispose();
          }
          this._mode = null;
          this.clearItems();

          this.$().removeClass("slide rotate coverflow").addClass(this.options.modes[mode].classes.base);
          this.$items

          this.addItems(this.options.data.items);

          this._mode = new modes[this.options.mode](this);

          let startIndex = this.options.start;
          if (startIndex !== undefined) {
            if (startIndex === 'center' ) {
              startIndex = Math.floor(this.getItemsCount() / 2)
            } 
            this.jump(startIndex)              
          }
        },

        keydown : function(e) {
            if (/input|textarea/i.test(e.target.tagName)) return
            switch (e.which) {
                case 37:
                    this.prev();
                    break
                case 39:
                    this.next();
                    break
                default:
                    return
            }

            e.preventDefault()
        },


        /*
         * Cycles through the carousel items from left to right.
         */
        cycle : function(cycling) {
            if (langx.isDefined(cycling)) {
              this.cycled = !!cycling;
             ///  e || (this.paused = false)
              if (this.cycled) {
                 this._velm.addClass(this.options.classes.cycling)
              } else {
                 this._velm.removeClass(this.options.classes.cycling)
              }
            } 

            if (this.interval){
              clearInterval(this.interval);
            }

            if (this.options.cycle.interval && this.cycled && !this.paused ) {
                this.interval = setInterval(langx.proxy(this.next, this), this.options.cycle.interval);
            }

            return this;
        },


        getItemForDirection : function(direction, active) {
            var activeIndex = this.getItemIndex(active)
            var willWrap = (direction == 'prev' && activeIndex === 0) ||
                (direction == 'next' && activeIndex == (this._$items.length - 1))
            if (willWrap && !this.options.wrap) return active
            var delta = direction == 'prev' ? -1 : 1
            var itemIndex = (activeIndex + delta) % this._$items.length
            return this._$items.eq(itemIndex);
        },

        setActiveItem : function(toIndex) {
            Group.prototype.setActiveItem.call(this,toIndex);

            if (this._indicators) {
              this._indicators.setActiveIndicator(toIndex);
            }  
        },

        jump : function (to) {
          if (this.jumping) {
            return
          }

          let itemsCount = this.getItemsCount();
          if (itemsCount<=1) {
            return;
          } 

          let currentItem = this.getActiveItem(),
              currentIndex = currentItem ? this.getItemIndex(currentItem) : -1,
              toItem,
              toIndex,
              type;

          if (to === 'prev') {
              type = to;
              if (currentIndex > 0 ) { 
                toIndex = currentIndex -1; 
              } else if ( this.options.loop ) { 
                toIndex = itemsCount - 1; 
              }
          } else if (to === 'next') {
              type = to;
              if ( currentIndex < itemsCount - 1 ) { 
                toIndex = currentIndex + 1; 
              } else if ( this.options.loop ) { 
                toIndex = 0; 
              }
          } else if (typeof to === 'number') {
              toIndex = to;
          } else if ( typeof to == 'string') {
              toIndex = parseInt(to);
          } else if ( to !== undefined ) {
              // if object is sent, get its index
              toIndex = this.getItemIndex(to);
          }

          if (toIndex<0 || toIndex==currentIndex) {
            return;
          }

          if (!type) {
            type = toIndex > currentIndex ? 'next' : 'prev';
          }

          this.jumping =true;

          var jumpingEvent = eventer.create('jumping.lark.carousel', {
              toIndex,
              currentIndex,
              type
          });

          this.trigger(jumpingEvent);
          if (jumpingEvent.isDefaultPrevented()) {
            this.jumping =false;
            return;
          }

          this._mode.jump(toIndex,currentIndex,type,() => {
            //    $next.removeClass([type, direction].join(' ')).addClass('active')
            //    $active.removeClass(['active', direction].join(' '))
            this.setActiveItem(toIndex);

            var jumpedEvent = eventer.create('jumped.lark.carousel', { 
              toIndex,
              currentIndex,
              type
            });

            setTimeout(()=> {
              this.trigger(jumpedEvent)
            }, 0)


            this.jumping  = false;

          });

          return this;
        },

        /*
         *Cycles the carousel to a particular frame (0 based, similar to an array). Returns to the caller before the target item has been shown
        jump : function(pos) {
            var that = this;

            var activeItem = this.getActiveItem(),
                activeIndex = activeItem ? this.getItemIndex(activeItem) : -1;

            if (pos > (this._$items.length - 1) || pos < 0) return

            if (this.moving) return this._$elm.one('jumped.lark.carousel', function() { that.jump(pos) }) // yes, "slid"
            if (activeIndex == pos)  return this.pause().cycle()

            return this._mode.jump(pos > activeIndex ? 'next' : 'prev', this._$items.eq(pos))
        },
         */

        /*
         * Stops the carousel from cycling through items.
         */
        pause : function(pausing) {
            if (langx.isUndefined(pausing)) {
              pausing = true;
            }
            this.paused = !!pausing;

            ///e || (this.paused = true)

            ///if (this._$elm.find(this.options.controls.selectors.next + ","+ this.options.controls.selectors.prev).length) { //.next,.prev
                ///this._$elm.trigger(browser.support.transition.end)
                ///this.cycle(true)
            ///}

            ///this.interval = clearInterval(this.interval)
            this.cycle();

            return this
        },

        /*
         * Cycles to the next item. Returns to the caller before the next item has been shown
         */
        next : function() {
            return this.jump('next')
        },

        /*
         * Cycles to the previous item. Returns to the caller before the previous item has been shown.
         */
        prev : function() {
            return this.jump('prev')
        },

        resetItems : function() {
          Group.prototype.resetItems.call(this);

          if (this._mode && this._mode.resetItems) {
            this._mode.resetItems();
          }
        },

        addItems : function(items) {
            let index = this.getItemsCount();
            for (var i=0; i<items.length;i++) {
              this.addItem(index++,items[i]);
            }
            this.resetItems();
        },

        addItem : function(index,itemData) {
          let itemHtml = this.renderItemHtml(itemData),
              baseClass = this.options.item.classes.base;


          let $item = $(itemHtml);
          if (baseClass) {
            $item.addClass(baseClass);
          }

          if (this._$itemsContainer) {
            this._$itemsContainer.append($item);
          }
          if (this._indicators) {
            this._indicators.addIndicator(index,itemData);
          }
        },

        clearItems : function() {
          if (this._$itemsContainer) {
            this._$itemsContainer.attr("style","");
          }
          this._$items.remove();
          this._$items = $();

          if (this._indicators) {
            this._indicators.clearIndicators();
          }
        }
  });

  var modes = Carousel.modes = {
    "slide" : ModeSlide,
    "rotate" : ModeRotate,
    "coverflow" : ModeCoverflow
  };

  plugins.register(Carousel);

  return groups.Carousel = Carousel;	
});
define('skylark-domx-plugins-toggles/toggles',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.toggles = {};
});
define('skylark-domx-plugins-toggles/collapse',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-query",
    "skylark-domx-plugins-base",
    "./toggles"
], function(langx, browser, eventer,  $, plugins, toggles) {


  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse =  plugins.Plugin.inherit({
    klassName: "Collapse",

    pluginName : "lark.toggles.collapse",

    options : {
      toggle: true
    },

    _construct : function(elm,options) {
      ////options = langx.mixin({}, Collapse.DEFAULTS, $(element).data(), options)
      this.overrided(elm,options);
      this.$element      = this.$();
      //this.$trigger      = $('[data-toggle="collapse"][href="#' + elm.id + '"],' +
      //                     '[data-toggle="collapse"][data-target="#' + elm.id + '"]')
      this.transitioning = null

      //if (this.options.parent) {
      //  this.$parent = this.getParent()
      //} else {
      //  this.addAriaAndCollapsedClass(this.$element, this.$trigger)
      //}

      if (this.options.toggle) {
        this.toggle();
      }
    },

    dimension : function () {
      var hasWidth = this.$element.hasClass('width');
      return hasWidth ? 'width' : 'height';
    },

    show : function () {
      if (this.transitioning || this.$element.hasClass('in')) {
        return;
      }

      //var activesData;
      //var actives = this.$parent && this.$parent.children('.collapsable').children('.in, .collapsing')

      //if (actives && actives.length) {
      //  activesData = actives.data('collapse')
      //  if (activesData && activesData.transitioning) return
      //}

      var startEvent = eventer.create('show.collapse');
      this.$element.trigger(startEvent)
      if (startEvent.isDefaultPrevented()) return

      //if (actives && actives.length) {
      //  //Plugin.call(actives, 'hide')
      //  actives.plugin("domx.collapse").hide();
      //  activesData || actives.data('collapse', null)
      //}

      var dimension = this.dimension();

      this.$element
        .removeClass('collapse')
        .addClass('collapsing')[dimension](0)
        .attr('aria-expanded', true)

      //this.$trigger
      //  .removeClass('collapsed')
      //  .attr('aria-expanded', true)

      this.transitioning = 1

      var complete = function () {
        this.$element
          .removeClass('collapsing')
          .addClass('collapse in')[dimension]('')
        this.transitioning = 0
        this.$element
          .trigger('shown.collapse')
      }

      if (!browser.support.transition) {
        return complete.call(this);
      }

      var scrollSize = langx.camelCase(['scroll', dimension].join('-'));

      this.$element
        .one('transitionEnd', langx.proxy(complete, this))
        .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    },

    hide : function () {
      if (this.transitioning || !this.$element.hasClass('in')) {
        return ;
      }

      var startEvent = eventer.create('hide.collapse');
      this.$element.trigger(startEvent);
      if (startEvent.isDefaultPrevented()) {
        return ;
      } 

      var dimension = this.dimension();

      this.$element[dimension](this.$element[dimension]())[0].offsetHeight;

      this.$element
        .addClass('collapsing')
        .removeClass('collapse in')
        .attr('aria-expanded', false);

      //this.$trigger
      //  .addClass('collapsed')
      //  .attr('aria-expanded', false);

      this.transitioning = 1;

      var complete = function () {
        this.transitioning = 0;
        this.$element
          .removeClass('collapsing')
          .addClass('collapse')
          .trigger('hidden.collapse');
      }

      if (!browser.support.transition) {
        return complete.call(this);
      }

      this.$element
        [dimension](0)
        .one('transitionEnd', langx.proxy(complete, this))
        .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
    },

    toggle : function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']();
    }

    /*
    getParent : function () {
      return $(this.options.parent)
        .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
        .each(langx.proxy(function (i, element) {
          var $element = $(element)
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this))
        .end()
    },

    addAriaAndCollapsedClass : function ($element, $trigger) {
      var isOpen = $element.hasClass('in');

      $element.attr('aria-expanded', isOpen);
      $trigger
        .toggleClass('collapsed', !isOpen)
        .attr('aria-expanded', isOpen);
    }
    */
  });

  Collapse.TRANSITION_DURATION = 350;

  /*
  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }
  */

  plugins.register(Collapse);

  return toggles.Collapse = Collapse;

});

 define('skylark-domx-plugins-groups/linear',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-domx-plugins-base",
  "skylark-domx-plugins-toggles/collapse",
  "./groups",
  "./group"
],function(langx,$,elmx,plugins,Collapse,groups,Group){
  'use strict'

  var Linear = Group.inherit({
    klassName : "Linear",

    pluginName : "lark.groups.linear",

    options: {
        item : {
          selectable: true
        },
        data : {}
    },

    _construct: function (elm, options) {
      this.overrided(elm, options);

      if (this.options.data.items) {
          this.addItems(this.options.data.items);
      }
    }

  });

  plugins.register(Linear);

  return groups.Linear = Linear;

});




define('skylark-domx-plugins-dnd/dnd',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {

	return plugins.dnd = {};
});


define('skylark-domx-plugins-dnd/manager',[
    "./dnd",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler"
], function(dnd, langx, noder, datax, finder, geom, eventer, styler) {
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height;


    var Manager = dnd.Manager = langx.Evented.inherit({
        klassName: "Manager",

        init: function() {

        },

        prepare: function(draggable) {
            var e = eventer.create("preparing", {
                dragSource: draggable.dragSource,
                dragHandle: draggable.dragHandle
            });
            draggable.trigger(e);
            draggable.dragSource = e.dragSource;
        },

        start: function(draggable, event) {

            var p = geom.pagePosition(draggable.dragSource);
            this.draggingOffsetX = parseInt(event.pageX - p.left);
            this.draggingOffsetY = parseInt(event.pageY - p.top)

            var e = eventer.create("started", {
                elm: draggable.elm,
                dragSource: draggable.dragSource,
                dragHandle: draggable.dragHandle,
                ghost: null,

                transfer: {}
            });

            draggable.trigger(e);


            this.dragging = draggable;

            if (draggable.draggingClass) {
                styler.addClass(draggable.dragSource, draggable.draggingClass);
            }

            this.draggingGhost = e.ghost;
            if (!this.draggingGhost) {
                this.draggingGhost = draggable.elm;
            }

            this.draggingTransfer = e.transfer;
            if (this.draggingTransfer) {

                langx.each(this.draggingTransfer, function(key, value) {
                    event.dataTransfer.setData(key, value);
                });
            }

            event.dataTransfer.setDragImage(this.draggingGhost, this.draggingOffsetX, this.draggingOffsetY);

            event.dataTransfer.effectAllowed = "copyMove";

            var e1 = eventer.create("dndStarted", {
                elm: e.elm,
                dragSource: e.dragSource,
                dragHandle: e.dragHandle,
                ghost: e.ghost,
                transfer: e.transfer
            });

            this.trigger(e1);
        },

        over: function() {

        },

        end: function(dropped) {
            var dragging = this.dragging;
            if (dragging) {
                if (dragging.draggingClass) {
                    styler.removeClass(dragging.dragSource, dragging.draggingClass);
                }
            }

            var e = eventer.create("dndEnded", {});
            this.trigger(e);


            this.dragging = null;
            this.draggingTransfer = null;
            this.draggingGhost = null;
            this.draggingOffsetX = null;
            this.draggingOffsetY = null;
        }
    });

    var manager = new Manager();


    return manager;
});
define('skylark-domx-plugins-dnd/draggable',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-plugins-base",
    "./dnd",
    "./manager"
], function(langx, noder, datax, finder, geom, eventer, styler, plugins, dnd,manager) {
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height;



    var Draggable = plugins.Plugin.inherit({
        klassName: "Draggable",
        
        pluginName : "lark.dnd.draggable",

        options : {
            draggingClass : "dragging"
        },

        _construct: function(elm, options) {
            this.overrided(elm,options);

            var self = this,
                options = this.options;

            self.draggingClass = options.draggingClass;

            ["preparing", "started", "ended", "moving"].forEach(function(eventName) {
                if (langx.isFunction(options[eventName])) {
                    self.on(eventName, options[eventName]);
                }
            });


            eventer.on(elm, {
                "mousedown": function(e) {
                    var options = self.options;
                    if (options.handle) {
                        self.dragHandle = finder.closest(e.target, options.handle);
                        if (!self.dragHandle) {
                            return;
                        }
                    }
                    if (options.source) {
                        self.dragSource = finder.closest(e.target, options.source);
                    } else {
                        self.dragSource = self._elm;
                    }
                    manager.prepare(self);
                    if (self.dragSource) {
                        datax.attr(self.dragSource, "draggable", 'true');
                    }
                },

                "mouseup": function(e) {
                    if (self.dragSource) {
                        //datax.attr(self.dragSource, "draggable", 'false');
                        self.dragSource = null;
                        self.dragHandle = null;
                    }
                },

                "dragstart": function(e) {
                    datax.attr(self.dragSource, "draggable", 'false');
                    manager.start(self, e);
                },

                "dragend": function(e) {
                    eventer.stop(e);

                    if (!manager.dragging) {
                        return;
                    }

                    manager.end(false);
                }
            });

        }

    });

    plugins.register(Draggable,"draggable");

    return dnd.Draggable = Draggable;
});
define('skylark-domx-plugins-dnd/droppable',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-plugins-base",
    "./dnd",
    "./manager"
], function(langx, noder, datax, finder, geom, eventer, styler, plugins, dnd,manager) {
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height;


    var Droppable = plugins.Plugin.inherit({
        klassName: "Droppable",

        pluginName : "lark.dnd.droppable",

        options : {
            draggingClass : "dragging"
        },

        _construct: function(elm, options) {
            this.overrided(elm,options);

            var self = this,
                options = self.options,
                draggingClass = options.draggingClass,
                hoverClass,
                activeClass,
                acceptable = true;

            ["started", "entered", "leaved", "dropped", "overing"].forEach(function(eventName) {
                if (langx.isFunction(options[eventName])) {
                    self.on(eventName, options[eventName]);
                }
            });

            eventer.on(elm, {
                "dragover": function(e) {
                    e.stopPropagation()

                    if (!acceptable) {
                        return
                    }

                    var e2 = eventer.create("overing", {
                        overElm: e.target,
                        transfer: manager.draggingTransfer,
                        acceptable: true
                    });
                    self.trigger(e2);

                    if (e2.acceptable) {
                        e.preventDefault() // allow drop

                        e.dataTransfer.dropEffect = "copyMove";
                    }

                },

                "dragenter": function(e) {
                    var options = self.options,
                        elm = self._elm;

                    var e2 = eventer.create("entered", {
                        transfer: manager.draggingTransfer
                    });

                    self.trigger(e2);

                    e.stopPropagation()

                    if (hoverClass && acceptable) {
                        styler.addClass(elm, hoverClass)
                    }
                },

                "dragleave": function(e) {
                    var options = self.options,
                        elm = self._elm;
                    if (!acceptable) return false

                    var e2 = eventer.create("leaved", {
                        transfer: manager.draggingTransfer
                    });

                    self.trigger(e2);

                    e.stopPropagation()

                    if (hoverClass && acceptable) {
                        styler.removeClass(elm, hoverClass);
                    }
                },

                "drop": function(e) {
                    var options = self.options,
                        elm = self._elm;

                    eventer.stop(e); // stops the browser from redirecting.

                    if (!manager.dragging) return

                    // manager.dragging.elm.removeClass('dragging');

                    if (hoverClass && acceptable) {
                        styler.addClass(elm, hoverClass)
                    }

                    var e2 = eventer.create("dropped", {
                        transfer: manager.draggingTransfer
                    });

                    self.trigger(e2);

                    manager.end(true)
                }
            });

            manager.on("dndStarted", function(e) {
                var e2 = eventer.create("started", {
                    transfer: manager.draggingTransfer,
                    acceptable: false
                });

                self.trigger(e2);

                acceptable = e2.acceptable;
                hoverClass = e2.hoverClass;
                activeClass = e2.activeClass;

                if (activeClass && acceptable) {
                    styler.addClass(elm, activeClass);
                }

            }).on("dndEnded", function(e) {
                var e2 = eventer.create("ended", {
                    transfer: manager.draggingTransfer,
                    acceptable: false
                });

                self.trigger(e2);

                if (hoverClass && acceptable) {
                    styler.removeClass(elm, hoverClass);
                }
                if (activeClass && acceptable) {
                    styler.removeClass(elm, activeClass);
                }

                acceptable = false;
                activeClass = null;
                hoverClass = null;
            });

        }
    });

    plugins.register(Droppable,"droppable");

    return dnd.Droppable = Droppable;
});
define('skylark-domx-plugins-groups/sortable',[
    "./groups",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-query",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-dnd/draggable",
    "skylark-domx-plugins-dnd/droppable"
],function(groups, langx,noder,datax,geom,eventer,styler,$,plugins,Draggable,Droppable){
   'use strict'

    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height,
        some = Array.prototype.some,
        map = Array.prototype.map;

    var Sorter = plugins.Plugin.inherit({
        "klassName" : "Sorter",

        enable : function() {

        },
        
        disable : function() {

        },

        destory : function() {

        }
    });


    var dragging, placeholders = $();


    var Sortable = plugins.Plugin.inherit({
        klassName: "Sortable",

        pluginName : "lark.groups.sortable",
        
        options : {
            connectWith: false,
            placeholder: null,
            placeholderClass: 'sortable-placeholder',
            draggingClass: 'sortable-dragging',
            items : null
        },

        /*
         * @param {HTMLElement} container  the element to use as a sortable container
         * @param {Object} options  options object
         * @param {String} [options.items = ""] 
         * @param {Object} [options.connectWith =] the selector to create connected groups
         * @param {Object} [options
         * @param {Object} [options
         */
        _construct : function (container,options) {
            this.overrided(container,options);

            options = this.options;

            var isHandle, index, 
                $container = $(container), 
                $items = $container.children(options.items);
            var placeholder = $(options.placeholder || noder.createElement(/^(ul|ol)$/i.test(container.tagName) ? 'li' : 'div',{
                "class" : options.placeholderClass
            }));

            Draggable(container,{
                source : options.items,
                handle : options.handle,
                draggingClass : options.draggingClass,
                preparing : function(e) {
                    //e.dragSource = e.handleElm;
                },
                started :function(e) {
                    e.ghost = e.dragSource;
                    e.transfer = {
                        "text": "dummy"
                    };
                    index = (dragging = $(e.dragSource)).index();
                },
                ended : function(e) {
                    if (!dragging) {
                        return;
                    }
                    dragging.show();
                    placeholders.detach();
                    if (index != dragging.index()) {
                        dragging.parent().trigger('sortupdate', {item: dragging});
                    }
                    dragging = null;                
                }

            });

            
            Droppable(container,{
                started: function(e) {
                    e.acceptable = true;
                    e.activeClass = "active";
                    e.hoverClass = "over";
                },
                overing : function(e) {
                    if ($items.is(e.overElm)) {
                        if (options.forcePlaceholderSize) {
                            placeholder.height(dragging.outerHeight());
                        }
                        dragging.hide();
                        $(e.overElm)[placeholder.index() < $(e.overElm).index() ? 'after' : 'before'](placeholder);
                        placeholders.not(placeholder).detach();
                    } else if (!placeholders.is(e.overElm) && !$(e.overElm).children(options.items).length) {
                        placeholders.detach();
                        $(e.overElm).append(placeholder);
                    }                
                },
                dropped : function(e) {
                    placeholders.filter(':visible').after(dragging);
                    dragging.show();
                    placeholders.detach();

                    dragging = null;                
                  }
            });

            $container.data('items', options.items)
            placeholders = placeholders.add(placeholder);
            if (options.connectWith) {
                $(options.connectWith).add(this).data('connectWith', options.connectWith);
            }
            
        }
    });

    plugins.register(Sortable,"sortable");

    return groups.Sortable = Sortable;
});

 define('skylark-domx-plugins-groups/tiler',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-domx-plugins-base",
  "./groups",
  "./group"
],function(langx,$,elmx,plugins,groups,Group){
  'use strict'

  var Tiler = Group.inherit({
    klassName : "Tiler",

    pluginName : "lark.groups.tiler",

    options: {
        alignment: 'left',
        infiniteScroll: false,
        itemRendered: null,
        noItemsHTML: 'no items found',
        selectable: false,
        viewClass: "repeater-tile",
        template : '<div class="clearfix repeater-tile" data-container="true" data-infinite="true" data-preserve="shallow"></div>',
        item : {
            template: '<div class="thumbnail"><img height="75" src="<%= href %>" width="65"><span><%= title %></span></div>',
            selectable : true
        },
        renderItem : null
    },

    _construct: function (elm, options) {
      this.overrided(elm, options);

      this._renderItem = langx.template(this.options.item.template);

      for (var i=0;i<options.items.length;i++) {
        var itemHtml = this._renderItem(options.items[i]);
        this._velm.append($(itemHtml));
      }
    }

  });


  plugins.register(Tiler);

  return groups.Tiler = Tiler;	
});
define('skylark-domx-plugins-groups/main',[
    "./groups",
    "./group",
    "./carousel",
    "./linear",
    "./sortable",
    "./tiler"
], function(groups) {
    return groups;
});
define('skylark-domx-plugins-groups', ['skylark-domx-plugins-groups/main'], function (main) { return main; });

define('skylark-domx-plugins-pictures/pictures',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.pictures = {};
});


define('skylark-domx-plugins-interact/movable',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-plugins-base",
    "./interact"
],function(langx,noder,datax,geom,eventer,styler,plugins,interact){
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height,
        some = Array.prototype.some,
        map = Array.prototype.map;

    var Movable = plugins.Plugin.inherit({
        klassName: "Movable",

        pluginName : "lark.interact.movable",


        _construct : function (elm, options) {
            this.overrided(elm,options);



            function updateWithTouchData(e) {
                var keys, i;

                if (e.changedTouches) {
                    keys = "screenX screenY pageX pageY clientX clientY".split(' ');
                    for (i = 0; i < keys.length; i++) {
                        e[keys[i]] = e.changedTouches[0][keys[i]];
                    }
                }
            }

            function updateWithMoveData(e) {
                e.movable = self;
                e.moveEl = elm;
                e.handleEl = handleEl;
            }

            options = this.options;
            var self = this,
                handleEl = options.handle || elm,
                auto = options.auto === false ? false : true,
                constraints = options.constraints,
                overlayDiv,
                doc = options.document || document,
                downButton,
                start,
                stop,
                startX,
                startY,
                originalPos,
                drag,
                size,
                startingCallback = options.starting,
                startedCallback = options.started,
                movingCallback = options.moving,
                stoppedCallback = options.stopped,

                start = function(e) {
                    var docSize = geom.getDocumentSize(doc),
                        cursor;

                    updateWithTouchData(e);
                    updateWithMoveData(e);

                    if (startingCallback) {
                        var ret = startingCallback(e)
                        if ( ret === false) {
                            return;
                        } else if (langx.isPlainObject(ret)) {
                            if (ret.constraints) {
                                constraints = ret.constraints;
                            }
                            if (ret.started) {
                                startedCallback = ret.started;
                            }
                            if (ret.moving) {
                                movingCallback = ret.moving;
                            }                            
                            if (ret.stopped) {
                                stoppedCallback = ret.stopped;
                            }     
                        }
                    }

                    e.preventDefault();

                    downButton = e.button;
                    //handleEl = getHandleEl();
                    startX = e.screenX;
                    startY = e.screenY;

                    originalPos = geom.relativePosition(elm);
                    size = geom.size(elm);

                    // Grab cursor from handle so we can place it on overlay
                    cursor = styler.css(handleEl, "cursor");

                    overlayDiv = noder.createElement("div");
                    styler.css(overlayDiv, {
                        position: "absolute",
                        top: 0,
                        left: 0,
                        width: docSize.width,
                        height: docSize.height,
                        zIndex: 0x7FFFFFFF,
                        opacity: 0.0001,
                        cursor: cursor
                    });
                    noder.append(doc.body, overlayDiv);

                    eventer.on(doc, "mousemove touchmove", move).on(doc, "mouseup touchend", stop);

                    if (startedCallback) {
                        startedCallback(e);
                    }
                },

                move = function(e) {
                    updateWithTouchData(e);
                    updateWithMoveData(e);

                    if (e.button !== 0) {
                        return stop(e);
                    }

                    e.deltaX = e.screenX - startX;
                    e.deltaY = e.screenY - startY;

                    if (auto) {
                        var l = originalPos.left + e.deltaX,
                            t = originalPos.top + e.deltaY;
                        if (constraints) {

                            if (l < constraints.minX) {
                                l = constraints.minX;
                            }

                            if (l > constraints.maxX) {
                                l = constraints.maxX;
                            }

                            if (t < constraints.minY) {
                                t = constraints.minY;
                            }

                            if (t > constraints.maxY) {
                                t = constraints.maxY;
                            }
                        }
                    }

                    geom.relativePosition(elm, {
                        left: l,
                        top: t
                    })

                    e.preventDefault();
                    if (movingCallback) {
                        movingCallback(e);
                    }
                },

                stop = function(e) {
                    updateWithTouchData(e);

                    eventer.off(doc, "mousemove touchmove", move).off(doc, "mouseup touchend", stop);

                    noder.remove(overlayDiv);

                    if (stoppedCallback) {
                        stoppedCallback(e);
                    }
                };

            eventer.on(handleEl, "mousedown touchstart", start);

            this._handleEl = handleEl;

        },

        remove : function() {
            eventer.off(this._handleEl);
        }
    });

    plugins.register(Movable,"movable");

    return interact.Movable = Movable;
});

define('skylark-domx-plugins-pictures/viewer',[
    "skylark-langx",
    "skylark-domx/eventer",
    "skylark-domx/geom",
    "skylark-domx/query",
    "skylark-domx-images/preload",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-interact/movable",
    "./pictures"
], function (langx,eventer,geom,$,preload,plugins,Movable,pictures) {
    'use strict';

    var PictureViewer = plugins.Plugin.inherit({
        klassName : "PictureViewer",

        pluginName : "lark.pictures.pictureviewer",

        options : {
            ratioThreshold: 0.1,
            minRatio: 0.05,
            maxRatio: 16,
            movable : true,

            classes : {
                grab : null,
                loader : null
            }
        },

        _construct : function(elm,options) {
            plugins.Plugin.prototype._construct.call(this,elm,options);

            this.$stage = this.$();
            this.$image = this.$stage.find("img");
            

            this.$stage.off("wheel").on("wheel", e => {
                this._handleWheel(e);
            });

            if (this.options.movable) {
                this._movable = new Movable(this.$image[0],{
                    starting : (e) => {
                        const imageWidth = this.$image.width();
                        const imageHeight = this.$image.height();
                        const stageWidth = this.$stage.width();
                        const stageHeight = this.$stage.height();
                        let minX,minY,maxX,maxY;

                        if (stageWidth>=imageWidth && stageHeight>=imageHeight) {
                            return false;
                        }

                        if (stageWidth>=imageWidth) {
                            minX=maxX=(stageWidth-imageWidth) / 2;
                        } else {
                            minX = stageWidth - imageWidth;
                            maxX = 0;
                        }

                        if (stageHeight>=imageHeight) {
                            minY=maxY=(stageHeight-imageHeight) / 2;
                        } else {
                            minY = stageHeight - imageHeight;
                            maxY = 0;
                        }

                        return {
                            constraints : {
                                minX,
                                maxX,
                                minY,
                                maxY
                            }
                        };
                    },
                    started : function(e) {
                        eventer.stop(e);
                    }
                });
            }

        }, 

        getImageScaleToStage : function(stageWidth, stageHeight) {
            let scale = 1;
            if (!this.isRotated) {
                scale = Math.min(stageWidth / this.img.width, stageHeight / this.img.height, 1);
            } else {
                scale = Math.min(stageWidth / this.img.height, stageHeight / this.img.width, 1);
            }
            return scale;
        },

        setGrabCursor : function (imageData, stageData, isRotated) {
            const imageWidth = !isRotated ? imageData.w : imageData.h;
            const imageHeight = !isRotated ? imageData.h : imageData.w;
            if (imageHeight > stageData.h || imageWidth > stageData.w) {
                this.$stage.addClass('is-grab');
            }
            if (imageHeight <= stageData.h && imageWidth <= stageData.w) {
                this.$stage.removeClass('is-grab');
            }
        },

        setImageSize: function(img) {
            const stageData = {
                w: this.$stage.width(),
                h: this.$stage.height()
            };
            const scale = this.getImageScaleToStage(stageData.w, stageData.h);
            this.$image.css({
                width: Math.ceil(img.width * scale) + 'px',
                height: Math.ceil(img.height * scale) + 'px',
                left: (stageData.w - Math.ceil(img.width * scale)) / 2 + 'px',
                top: (stageData.h - Math.ceil(img.height * scale)) / 2 + 'px'
            });
            langx.mixin(this.imageData, {
                initWidth: img.width * scale,
                initHeight: img.height * scale,
                initLeft: (stageData.w - img.width * scale) / 2,
                initTop: (stageData.h - img.height * scale) / 2,
                width: img.width * scale,
                height: img.height * scale,
                left: (stageData.w - img.width * scale) / 2,
                top: (stageData.h - img.height * scale) / 2
            });
            this.setGrabCursor({
                w: this.$image.width(),
                h: this.$image.height()
            }, {
                w: this.$stage.width(),
                h: this.$stage.height()
            }, this.isRotated);
            if (!this.imageLoaded) {
                this.$stage.find(".${ this.options.classes.loader }").remove();
                this.$stage.removeClass('stage-ready');
                this.$image.removeClass('image-ready');
                if (this.options.initAnimation && !this.options.progressiveLoading) {
                    this.$image.fadeIn();
                }
                this.imageLoaded = true;
            }
        },

        loadImage : function(imgSrc, fn, err) {
            this.$image.removeAttr('style').attr('src', '');
            this.isRotated = false;
            this.rotateAngle = 0;
            this.imageLoaded = false;
            this.$stage.append(`<div class="${ this.options.classes.loader }"></div>`);
            this.$stage.addClass('stage-ready');
            this.$image.addClass('image-ready');
            if (this.options.initAnimation && !this.options.progressiveLoading) {
                this.$image.hide();
            }
            this.$image.attr('src', imgSrc);
            preload(imgSrc).then((data) => {
                var img = data.imgs[0];
                this.img = img;
                this.imageData = {
                    originalWidth: img.width,
                    originalHeight: img.height
                };
                ///if (this.isMaximized || this.isOpened && this.options.fixedModalPos) {
                ///    this.setImageSize(img);
                ///} else {
                ///    this.setModalSize(img);
                ///}
                if (fn) {
                    fn(img);
                }
            }, () => {
                this.$photoviewer.find(".${ this.options.classes.loader }").remove();
                if (err) {
                    err.call();
                }
            });

        },

        _handleWheel : function(e) {
            e.preventDefault();
            let delta = 1;
            if (e.deltaY) {
                delta = e.deltaY > 0 ? 1 : -1;
            } else if (e.wheelDelta) {
                delta = -e.wheelDelta / 120;
            } else if (e.detail) {
                delta = e.detail > 0 ? 1 : -1;
            }
            const ratio = -delta * this.options.ratioThreshold;
            const pointer = {
                x: e.clientX - this.$stage.offset().left + geom.scrollLeft(document.body),
                y: e.clientY - this.$stage.offset().top + geom.scrollTop(document.body)
            };
            this.zoom(ratio, pointer, e);
        },

        zoom : function(ratio, origin, e) {
            ratio = ratio < 0 ? 1 / (1 - ratio) : 1 + ratio;
            ratio = this.$image.width() / this.imageData.originalWidth * ratio;
            if (ratio > this.options.maxRatio || ratio < this.options.minRatio) {
                return;
            }
            this.zoomTo(ratio, origin, e);
        },

        zoomTo : function(ratio, origin, e) {
            const $image = this.$image;
            const $stage = this.$stage;
            const imgData = {
                w: this.imageData.width,
                h: this.imageData.height,
                x: this.imageData.left,
                y: this.imageData.top
            };
            const stageData = {
                w: $stage.width(),
                h: $stage.height(),
                x: $stage.offset().left,
                y: $stage.offset().top
            };
            const newWidth = this.imageData.originalWidth * ratio;
            const newHeight = this.imageData.originalHeight * ratio;
            let newLeft = origin.x - (origin.x - imgData.x) / imgData.w * newWidth;
            let newTop = origin.y - (origin.y - imgData.y) / imgData.h * newHeight;
            const  = !this.isRotated ? 0 : (newWidth - newHeight) / 2;
            const imgNewWidth = !this.isRotated ? newWidth : newHeight;
            const imgNewHeight = !this.isRotated ? newHeight : newWidth;
            const offsetX = stageData.w - newWidth;
            const offsetY = stageData.h - newHeight;
            if (imgNewHeight <= stageData.h) {
                newTop = (stageData.h - newHeight) / 2;
            } else {
                newTop = newTop >  ?  : newTop > offsetY -  ? newTop : offsetY - ;
            }
            if (imgNewWidth <= stageData.w) {
                newLeft = (stageData.w - newWidth) / 2;
            } else {
                newLeft = newLeft > - ? - : newLeft > offsetX +  ? newLeft : offsetX + ;
            }
            if (Math.abs(this.imageData.initWidth - newWidth) < this.imageData.initWidth * 0.05) {
                this.setImageSize(this.img);
            } else {
                $image.css({
                    width: Math.round(newWidth) + 'px',
                    height: Math.round(newHeight) + 'px',
                    left: Math.round(newLeft) + 'px',
                    top: Math.round(newTop) + 'px'
                });
                this.setGrabCursor({
                    w: Math.round(imgNewWidth),
                    h: Math.round(imgNewHeight)
                }, {
                    w: stageData.w,
                    h: stageData.h
                });
            }
            $.extend(this.imageData, {
                width: newWidth,
                height: newHeight,
                left: newLeft,
                top: newTop
            });
        },

        rotate : function(angle) {
            this.rotateAngle = this.rotateAngle + angle;
            if (this.rotateAngle / 90 % 2 === 0) {
                this.isRotated = false;
            } else {
                this.isRotated = true;
            }
            this.rotateTo(this.rotateAngle);
        },
        rotateTo: function(angle) {
            this.$image.css({ transform: 'rotate(' + angle + 'deg)' });
            this.setImageSize({
                width: this.imageData.originalWidth,
                height: this.imageData.originalHeight
            });
            this.$stage.removeClass('is-grab');
        },
        resize: function() {
            const imageWidth = this.$image.width();
            const imageHeight = this.$image.height();
            const stageWidth = this.$stage.width();
            const stageHeight = this.$stage.height();
            const left = (stageWidth - imageWidth) /2;
            const top = (stageHeight- imageHeight) /2;
            this.$image.css({
                left,
                top
            });
        },

        shortcut: function(keyCode,ctrlKey,altKey) {
            var handled = false;
            switch (keyCode) {
                // +
                case 187:
                    this.zoom(this.options.ratioThreshold * 3, {
                        x: this.$stage.width() / 2,
                        y: this.$stage.height() / 2
                    }, e);
                    handled = true;
                    break;
                // -
                case 189:
                    this.zoom(-this.options.ratioThreshold * 3, {
                        x: this.$stage.width() / 2,
                        y: this.$stage.height() / 2
                    }, e);
                    handled = true;
                    break;
                // + Firefox
                case 61:
                    this.zoom(this.options.ratioThreshold * 3, {
                        x: this.$stage.width() / 2,
                        y: this.$stage.height() / 2
                    }, e);
                    handled = true;
                    break;
                // - Firefox
                case 173:
                    this.zoom(-this.options.ratioThreshold * 3, {
                        x: this.$stage.width() / 2,
                        y: this.$stage.height() / 2
                    }, e);
                    handled = true;
                    break;
                // Ctrl + Alt + 0
                case 48:
                    if (ctrlKey && altKey) {
                        this.zoomTo(1, {
                            x: this.$stage.width() / 2,
                            y: this.$stage.height() / 2
                        }, e);
                    }
                    handled = true;
                    break;
                // Ctrl + ,
                case 188:
                    if (ctrlKey) {
                        this.rotate(-90);
                    }
                    break;
                // Ctrl + .
                case 190:
                    if (ctrlKey) {
                        this.rotate(90);
                    }
                    handled = true;
                    break;
                default:
            }

            return handled;
        }
    });

    return pictures.PictureViewer = PictureViewer;
});
define('skylark-domx-plugins-pictures/main',[
	'./pictures',
	"./viewer"
], function (pictures) {
    'use strict';
    return pictures;
});
define('skylark-domx-plugins-pictures', ['skylark-domx-plugins-pictures/main'], function (main) { return main; });

define('skylark-domx-plugins-players/players',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.players = {};
});

define('skylark-domx-plugins-players/video-player',[
  "skylark-langx/langx",
  "skylark-domx-noder",
  "skylark-domx-eventer",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  './players',
],function(langx,noder, eventer,$ , plugins, players) {

  'use strict'

  var VideoPlayer = plugins.Plugin.inherit({
    klassName : "VideoPlayer",

    pluginName : "lark.players.video",
   
    options : {
      classes : {
        // The class for video content elements:
        videoContent: 'video-content',
        // The class for video when it is loading:
        videoLoading: 'video-loading',
        // The class for video when it is playing:
        videoPlaying: 'video-playing'

      },
      // The list object property (or data attribute) for the video poster URL:
      videoPosterProperty: 'poster',
      // The list object property (or data attribute) for the video sources array:
      videoSourcesProperty: 'sources',

      ///media  : {
      ///  title : null,
      ///  url : null,
      ///  type : null,
      ///  posterUrl : null        
      ///}

    },


    _construct: function(elm, options) {
      //this.options = options
      plugins.Plugin.prototype._construct.call(this,elm,options);

      let $el = this.$(),
          $video = $('<video/>'),
          video = this._video = $video[0],
          isLoading,
          hasControls;

      $el.addClass(this.options.classes.videoContent);

      var $poster = this._$poster = $('<img/>');
      ///$poster.addClass(options.toggleClass)
      $poster.prop("draggable",false);

      $el.append($poster)

      $poster.css({
          "maxWidth" : "100%",
          "maxHeight" : "100%"
      });
            

      var $play = this._$play = $('<a/>');

      $play.prop('target','_blank');
      
      video.controls = true;
     
      this.listenTo($video,'error', function () {
            ///callback(errorArgs[0]);
      });

      this.listenTo($video,'pause', function () {
        if (video.seeking) return
        isLoading = false;
        this.$().removeClass(this.options.classes.videoLoading)
                .removeClass(this.options.classes.videoPlaying);
        this.trigger("pause");
      });


      this.listenTo($video,'playing', () => {
        isLoading = false
        this.$().removeClass(this.options.classes.videoLoading)
                .addClass(this.options.classes.videoPlaying);
        this.trigger("playing");
      });

      this.listenTo($video,'play',  () => {
        //window.clearTimeout(that.timeout)
        isLoading = true
        this.$().addClass(this.options.classes.videoLoading)
        this.trigger("play");
      });


      this.listenTo($play,'click', (e) =>{
        eventer.stop(e)
        if (isLoading) {
          this.pause()
        } else {
          this.play()
        }
      })

      $el.append($video);

      $video.css({
          "maxWidth" : "100%",
          "maxHeight" : "100%"
      });

      $el.append($play);

      if (this.options.media) {
        this.source(this.options.media);
      }
    },


    source : function(media) {
      this._media = media;
      let title = media.title || "",
          url = media.href,
          type = media.type,
          posterUrl = media.poster || "",
          altText = media.altText || "";

      let $el = this.$(),
          video = this._video,
          $play = this._$play,
          $poster = this._$poster;

      $el.prop("title", title);
      
      if (video.canPlayType) {
        if (url && type && video.canPlayType(type)) {
          video.src = url
        }    
      }

      video.poster = posterUrl
      
      $poster.prop({
        "src" : posterUrl,
        "alt" : altText
      });

      $play.prop({
        'download' :  title,
        "href" : url
      });
    
    },

    load : function() {
      this._video.load();
    },

    play : function() {
      this._video.play();

    },

    stop : function() {

    },

    pause : function() {
      this._video.pause();      
    }


  });

  plugins.register(VideoPlayer);

  return players.VideoPlayer = VideoPlayer;
});


define('skylark-domx-plugins-players/main',[
    "./players",
    "./video-player"
], function(players) {
    return players;
})
;
define('skylark-domx-plugins-players', ['skylark-domx-plugins-players/main'], function (main) { return main; });

define('skylark-domx-plugins-panels/panels',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base/plugins"
],function(skylark,langx,browser,eventer,noder,geom,$,plugins){
	var panels = {};

	var CONST = {
		BACKSPACE_KEYCODE: 8,
		COMMA_KEYCODE: 188, // `,` & `<`
		DELETE_KEYCODE: 46,
		DOWN_ARROW_KEYCODE: 40,
		ENTER_KEYCODE: 13,
		TAB_KEYCODE: 9,
		UP_ARROW_KEYCODE: 38
	};

	var isShiftHeld = function isShiftHeld (e) { return e.shiftKey === true; };

	var isKey = function isKey (keyCode) {
		return function compareKeycodes (e) {
			return e.keyCode === keyCode;
		};
	};

	var isBackspaceKey = isKey(CONST.BACKSPACE_KEYCODE);
	var isDeleteKey = isKey(CONST.DELETE_KEYCODE);
	var isTabKey = isKey(CONST.TAB_KEYCODE);
	var isUpArrow = isKey(CONST.UP_ARROW_KEYCODE);
	var isDownArrow = isKey(CONST.DOWN_ARROW_KEYCODE);

	var ENCODED_REGEX = /&[^\s]*;/;
	/*
	 * to prevent double encoding decodes content in loop until content is encoding free
	 */
	var cleanInput = function cleanInput (questionableMarkup) {
		// check for encoding and decode
		while (ENCODED_REGEX.test(questionableMarkup)) {
			questionableMarkup = $('<i>').html(questionableMarkup).text();
		}

		// string completely decoded now encode it
		return $('<i>').text(questionableMarkup).html();
	};

	langx.mixin(panels, {
		CONST: CONST,
		cleanInput: cleanInput,
		isBackspaceKey: isBackspaceKey,
		isDeleteKey: isDeleteKey,
		isShiftHeld: isShiftHeld,
		isTabKey: isTabKey,
		isUpArrow: isUpArrow,
		isDownArrow: isDownArrow
	});

	return plugins.panels = panels;

});

define('skylark-domx-plugins-interact/resizable',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-eventer",
    "skylark-domx-styler",
    "skylark-domx-query",
    "skylark-domx-plugins-base",
    "./interact",
    "./movable"
],function(langx,noder,datax,finder,geom,eventer,styler,$,plugins,interact,Movable){
    var on = eventer.on,
        off = eventer.off,
        attr = datax.attr,
        removeAttr = datax.removeAttr,
        offset = geom.pagePosition,
        addClass = styler.addClass,
        height = geom.height,
        some = Array.prototype.some,
        map = Array.prototype.map;


    var Resizable = plugins.Plugin.inherit({
        klassName: "Resizable",

        "pluginName" : "lark.interact.resizable",
        
        options : {
            // prevents browser level actions like forward back gestures
            touchActionNone: true,
            // selector for handle that starts dragging
            handle : {
                border : {
                    directions : {
                        top: true, //n
                        left: true, //w
                        right: true, //e
                        bottom: true, //s
                        topLeft : true, // nw
                        topRight : true, // ne
                        bottomLeft : true, // sw
                        bottomRight : true // se                         
                    },
                    classes : {
                        all : "resizable-handle",
                        top : "resizable-handle-n",
                        left: "resizable-handle-w",
                        right: "resizable-handle-e",
                        bottom: "resizable-handle-s", 
                        topLeft : "resizable-handle-nw", 
                        topRight : "resizable-handle-ne",
                        bottomLeft : "resizable-handle-sw",             
                        bottomRight : "resizable-handle-se"                         
                    }
                },
                grabber: {
                    selector : "",
                    direction : "bottomRight"
                },
                selector: true
            },

            constraints : {
                minWidth : null,
                minHeight : null,
                maxWidth : null,
                maxHeight : null
            }
        },

        _construct :function (elm, options) {
            this.overrided(elm,options);


            options = this.options;
            var handle = options.handle || {},
                constraints = options.constraints || {},
                startedCallback = options.started,
                movingCallback = options.moving,
                stoppedCallback = options.stopped;

            if (langx.isString(handle)) {
                handleEl = finder.find(elm,handle);
            } else if (langx.isHtmlNode(handle)) {
                handleEl = handle;
            }

            function handleResize(handleEl,dir) {
                let  startRect;

                Movable(handleEl,{
                    auto : false,
                    started : function(e) {
                        startRect = geom.relativeRect(elm);
                        if (startedCallback) {
                            startedCallback(e);
                        }
                    },
                    moving : function(e) {
                        currentRect = {
                        };
                        if (dir == "right" || dir == "topRight" || dir == "bottomRight" ) {
                            currentRect.width = startRect.width + e.deltaX;
                            if (constraints.minWidth && currentRect.width < constraints.minWidth) {
                                currentRect.width = constraints.minWidth;
                            }
                            if (constraints.maxWidth && currentRect.width > constraints.maxWidth) {
                                currentRect.width = constraints.maxWidth;
                            }
                        } 

                        if (dir == "bottom" || dir == "bottomLeft" || dir == "bottomRight" ) {
                            currentRect.height = startRect.height + e.deltaY;
                            if (constraints.minHeight && currentRect.height < constraints.minHeight) {
                                currentRect.height = constraints.minHeight;
                            }
                            if (constraints.maxHeight && currentRect.height > constraints.maxHeight) {
                                currentRect.height = constraints.maxHeight;
                            }
                        } 

                        if (dir == "left" || dir == "topLeft" || dir == "bottomLeft" ) {
                            currentRect.left = startRect.left + e.deltaX;
                            currentRect.width = startRect.width - e.deltaX;
                            if (constraints.minWidth && currentRect.width < constraints.minWidth) {
                                currentRect.left = currentRect.left + currentRect.width - constraints.minWidth;
                                currentRect.width = constraints.minWidth;
                            }
                            if (constraints.maxWidth && currentRect.width > constraints.maxWidth) {
                                currentRect.left = currentRect.left + currentRect.width - constraints.maxWidth;
                                currentRect.width = constraints.maxWidth;
                            }
                        } 

                        if (dir == "top" || dir == "topLeft" || dir == "topRight" ) {
                            currentRect.top = startRect.top + e.deltaY;
                            currentRect.height = startRect.height - e.deltaY;
                            if (constraints.minHeight && currentRect.height < constraints.minHeight) {
                                currentRect.top = currentRect.top + currentRect.height - constraints.minHeight;
                                currentRect.height = constraints.minHeight;
                            }
                            if (constraints.maxHeight && currentRect.height > constraints.maxHeight) {
                                currentRect.top = currentRect.top + currentRect.height - constraints.maxHeight;
                                currentRect.height = constraints.maxHeight;
                            }
                        } 

                        geom.relativeRect(elm,currentRect);

                        if (movingCallback) {
                            movingCallback(e);
                        }
                        eventer.resized(elm);

                    },
                    stopped: function(e) {
                        if (stoppedCallback) {
                            stoppedCallback(e);
                        }                
                    }
                });
            }

            if (handle && handle.border) {
                let borders = []
                for (var dir in handle.border.directions) {
                    if (handle.border.directions[dir]) {
                        let handleEl = noder.createElement("div",{
                            "className": handle.border.classes.all + " " + handle.border.classes[dir],
                            "direction" : dir
                        },elm);   
                        handleResize(handleEl,dir) ; 

                    }

                }
            }

            if (handle && handle.grabber && handle.grabber.selector) {
                 let handleEl = finder.find(elm,handle.grabber.selector);
                 handleResize(handleEl,handle.grabber.direction) ; 
            }

        },

        // destroys the dragger.
        remove: function() {
            eventer.off(this._handleEl);
        }
    });

    plugins.register(Resizable,"resizable");

    return interact.Resizable = Resizable;
});

define('skylark-domx-plugins-panels/panel',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "skylark-domx-plugins-interact/resizable",
  "./panels",
],function(langx,browser,eventer,noder,geom,$,plugins,Resizable,panels){

  var Panel = plugins.Plugin.inherit({
    klassName : "Panel",

    pluginName : "lark.panels.panel",

    options : {
      /*
      resizable : {
          minWidth: 320,
          minHeight: 320,
          border : {
              classes :  {
                  all : "resizable-handle",
                  top : "resizable-handle-n",
                  left: "resizable-handle-w",
                  right: "resizable-handle-e",
                  bottom: "resizable-handle-s", 
                  topLeft : "resizable-handle-nw", 
                  topRight : "resizable-handle-ne",
                  bottomLeft : "resizable-handle-sw",             
                  bottomRight : "resizable-handle-se"     
              }
          }
      }
      */
    },

    _construct : function(elm,options) {
      this.overrided(elm,options);
      this._velm = this.elmx();

      if (this.options.resizable) {

          this._resizable = new Resizable(elm,{
              handle : {
                  border : {
                      directions : {
                          top: true, //n
                          left: true, //w
                          right: true, //e
                          bottom: true, //s
                          topLeft : true, // nw
                          topRight : true, // ne
                          bottomLeft : true, // sw
                          bottomRight : true // se                         
                      },
                      classes : {
                          all : this.options.resizable.border.classes.all,
                          top : this.options.resizable.border.classes.top,
                          left: this.options.resizable.border.classes.left,
                          right: this.options.resizable.border.classes.right,
                          bottom: this.options.resizable.border.classes.bottom, 
                          topLeft : this.options.resizable.border.classes.topLeft, 
                          topRight : this.options.resizable.border.classes.topRight,
                          bottomLeft : this.options.resizable.border.classes.bottomLeft,             
                          bottomRight : this.options.resizable.border.classes.bottomRight                        
                      }                        
                  }
              },
              constraints : {
                  minWidth : this.options.resizable.minWidth,
                  minHeight : this.options.resizable.minHeight
              },
              started : () => {
                  this.isResizing = true;
              },
              moving : function(e) {
                  /*
                  const imageWidth = $(image).width();
                  const imageHeight = $(image).height();
                  const stageWidth = $(stage).width();
                  const stageHeight = $(stage).height();
                  const left = (stageWidth - imageWidth) /2;
                  const top = (stageHeight- imageHeight) /2;
                  $(image).css({
                      left,
                      top
                  });
                  */
              },
              stopped : () => {
                  this.isResizing = false;
              }
          });

      }
    },


  });

  plugins.register(Panel);

  return Panel;

});
define('skylark-domx-plugins-panels/collapsible',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "skylark-domx-plugins-toggles/collapse",
  "./panels",
  "./panel"
],function(langx,browser,eventer,noder,geom,$,plugins,Collapse,panels,Panel){

  var Collapsible = Panel.inherit({
    klassName : "Collapsible",

    pluginName : "lark.panels.collapsible",

    options : {
      toggler : {
        selector : ".panel-heading [data-toggle=\"collapse\"]"
      },

      body : {
        selector : ".panel-body"
      }
    },

    _construct : function(elm,options) {
      Panel.prototype._construct.call(this,elm,options);
      
      this._expanded = false;
      this.$toggle = this._velm.find(this.options.toggler.selector);
      this.$body = this._velm.find(this.options.body.selector);
      this.$toggle.on('click.panel',(e) => {
        this.toggle();
      });

    },

    expand : function() {
      // expand this panel
      this.emit("expanding");
      this.$body.plugin(Collapse.prototype.pluginName).show();
      this._expanded = true;
      this.emit("expanded");
    },

    collapse : function() {
      // collapse this panel
      this.emit("collapsing");
      this.$body.plugin(Collapse.prototype.pluginName).hide();
      this._expanded = false;
      this.emit("collapsed");
    },

    toggle : function() {
      // toggle this panel
      if (this._expanded) {
        this.collapse();
      } else {
        this.expand();
      }
    },

    full : function() {

    },

    unfull : function() {

    },

    toogleFull : function() {

    },
    
    close: function () {
    }


  });

  plugins.register(Collapsible);

  return panels.Collapsible = Collapsible;

});
 define('skylark-domx-plugins-panels/accordion',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-domx-plugins-base",
  "./panels",
  "./panel",
  "./collapsible"
],function(langx,$,elmx,plugins,panels,Panel,Collapsible){

  var Accordion = Panel.inherit({
    klassName : "Accordion",

    pluginName : "lark.panels.accordion",

    options : {
      panel: {
        selector : "> .panel",
        template : null,
      }
    },

     _construct : function(elm,options) {
      Panel.prototype._construct.call(this,elm,options);
      var panels = [];
      this._velm.$(this.options.panel.selector).forEach((panelEl) => {
        var panel = new Accordion.Pane(panelEl,{
          group : this
        });
        panels.push(panel);
      });
      this._panels = panels;
    },

    panels : {
      get : function() {

      }
    },


    addPanel : function() {

    },

    /**
     * Removes a group pane.
     *
     * @method remove
     * @return {Accordion} The current widget.
     */
    remove : function() {

    },

    /**
     * Expands a group pane.
     *
     * @method remove
     * @return {Accordion} The current widget.
     */
    expand : function() {
      // expand a panel

    },

    /**
     * Expands all group panes.
     *
     * @method expandAll
     * @return {Accordion} The current widget.
     */
    expandAll : function() {
      // expand a panel

    },

    /**
     * Collapse a group pane.
     *
     * @method collapse
     * @return {Accordion} The current widget.
     */
    collapse : function() {

    },

    /**
     * Collapses all group pane.
     *
     * @method collapseAll
     * @return {Accordion} The current widget.
     */
    collapseAll : function() {

    }
  });

  Accordion.Pane = Collapsible.inherit({
    klassName : "AccordionPane",

    expand : function() {
      if (this.options.group.active) {
        this.options.group.active.collapse();
      }
      this.overrided();
      this.options.group.active = this;
    },

    collapse : function() {
      this.overrided();
      this.options.group.active = null;
    },

    toggle : function() {
      this.overrided();
    },

    remove : function() {
      this.overrided();
    }

  });

  plugins.register(Accordion);

  return panels.Accordion = Accordion;
});

define('skylark-domx-plugins-panels/floating',[
    "skylark-domx/noder",
    "skylark-domx/eventer",
    "skylark-domx/query",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-interact/movable",
    "./panels",
    "./panel"
], function (noder,eventer,$,plugins,Movable, panels,Panel) {
    'use strict';

    var floatings = [];

    var Floating = Panel.inherit({
        klassName : "Floating",

        pluginName : "lark.panels.floating",

        options : {
            selectors : {
                headerPane  : "",
                contentPane : "",
                footerPane  : "",
                titlebar : "",
                buttons : {
                    "fullscreen" : ".button-fullscreen",
                    "maximize" : ".button-maximize",
                    "minimize" : ".button-minimize",     
                    "close" : ".button-close"
                }
            },

            classes : {
                "maximize" : "maximize"
            },

            fixedContent: true,
            initMaximized: false,

            movable : {
                dragHandle: false,
                dragCancel: null
            }
        },

        _construct : function(elm,options) {
            Panel.prototype._construct.call(this,elm,options);
            this.$pane = $(this._elm);

            this.isOpened = false;
            this.isMaximized = false;

            if (this.options.movable) {
                this._movable = new Movable(elm,{
                    handle : this.options.movable.dragHandle,
                    starting : (e) => {
                        const   dragCancel = this.options.movable.dragCancel, 
                                elemCancel = $(e.target).closest(dragCancel);
                        if (elemCancel.length) {
                            return false;
                        }
                        if (this.isResizing || this.isMaximized) {
                            return false;
                        }

                        return true;
                    }
                });

            }

            this.$close = this._velm.$(this.options.selectors.buttons.close);
            this.$maximize = this._velm.$(this.options.selectors.buttons.maximize);
            this.$minimize = this._velm.$(this.options.selectors.buttons.minimize);
            this.$fullscreen = this._velm.$(this.options.selectors.buttons.fullscreen);


            this.$close.off("click.window").on("click.window", e => {
                this.close();
            });
            this.$fullscreen.off("click.window").on("click.window", () => {
                this.fullscreen();
            });
            this.$maximize.off("click.window").on("click.window", () => {
                this.maximize();
            });
            this.$pane.off("keydown.window").on("keydown.window", e => {
                this._keydown(e);
            });

            floatings.push(this);
        },
        close: function() {
            this.trigger('closing', this);
            this.$pane.remove();
            this.isOpened = false;
            this.isMaximized = false;

            ///if (!$(Constants.CLASS_NS + '-modal').length) {
            ///    if (this.options.fixedContent) {
            ///        $('html').css({
            ///            overflow: '',
            ///            'padding-right': ''
            ///        });
            ///    }
                ///if (this.options.multiInstances) {
                ///    zIndex = this.options.zIndex;
                ///}
            ///    eventer.off(window,"resize.window");
            var idx = floatings.indexOf(this);
            if (idx>-1) {
                floatings.splice(idx,1);
            }
            this.trigger('closed', this);
        },

        maximize: function() {
            this.$pane.get(0).focus();
            if (!this.isMaximized) {
                this.modalData = {
                    width: this.$pane.width(),
                    height: this.$pane.height(),
                    left: this.$pane.offset().left,
                    top: this.$pane.offset().top
                };
                this.$pane.addClass(this.options.classes.maximize);
                this.$pane.css({
                    width: '100%',
                    height: '100%',
                    left: 0,
                    top: 0
                });
                this.isMaximized = true;
            } else {
                let $W = $(window),$D = $(document);
                this.$pane.removeClass(this.options.classes.maximize);
                const initModalLeft = ($W.width() - this.options.modalWidth) / 2 + $D.scrollLeft();
                const initModalTop = ($W.height() - this.options.modalHeight) / 2 + $D.scrollTop();
                this.$pane.css({
                    width: this.modalData.width ? this.modalData.width : this.options.modalWidth,
                    height: this.modalData.height ? this.modalData.height : this.options.modalHeight,
                    left: this.modalData.left ? this.modalData.left : initModalLeft,
                    top: this.modalData.top ? this.modalData.top : initModalTop
                });
                this.isMaximized = false;
            }

            eventer.resized(this._elm);
        },
        fullscreen: function() {
            this.$pane.get(0).focus();
            noder.fullscreen(this.$pane[0]);
        },
        _keydown: function(e) {
            if (!this.options.keyboard) {
                return false;
            }
            const keyCode = e.keyCode || e.which || e.charCode;
            const ctrlKey = e.ctrlKey || e.metaKey;
            const altKey = e.altKey || e.metaKey;
            switch (keyCode) {

                // Q
                case 81:
                    this.close();
                    break;
                default:
            }
        }

    });

    eventer.on(window,"resize.window", ()=>{
        for (let i=0; i<floatings.length; i++ ) {
            eventer.resized(floatings[i]._elm);
        }
    });

    return panels.Floating = Floating;
});
define('skylark-domx-plugins-panels/pagination',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./panels",
  "./panel"
],function(langx,browser,eventer,noder,geom,$,plugins,panels,Panel){

  'use strict';

  var Pagination = Panel.inherit({
      klassName : "Pagination",

      pluginName : "lark.panels.pagination",

      options : {
          tagName : "ul",
          css : "",
          selectors : {
              firstNavi : "li[aria-label='first']",
              prevNavi : "li[aria-label='prev']",
              nextNavi : "li[aria-label='next']",
              lastNavi : "li[aria-label='last']",
              numericNavi : "li:not([aria-label])",
              numericTxt  : "a"
          },
          totalPages: 7,
          maxButtonsVisible: 5,
          currentPage: 1     
      },

      state : {
          totalPages : Number,
          currentPage : Number
      },

      _construct : function(elm,options) {
        Panel.prototype._construct.call(this,elm,options);

        this.$first = this._velm.$(this.options.selectors.firstNavi);
        this.$prev = this._velm.$(this.options.selectors.prevNavi);
        this.$last = this._velm.$(this.options.selectors.lastNavi);
        this.$next = this._velm.$(this.options.selectors.nextNavi);
        this.$numeric = this._velm.$(this.options.selectors.numericNavi);

        var self = this;

        function checkCanAction(elm) {
          var $elm = $(elm);
          if ($elm.is(".disabled,.active")) {
            return false;
          } else {
            return $elm;
          }
        }

        this.$first.click(function(){
          if (!checkCanAction(this)) {
            return;
          }
          self.currentPage(1);
        });

        this.$prev.click(function(){
          if (!checkCanAction(this)) {
            return;
          }
          self.currentPage(self.currentPage()-1);
        });

        this.$last.click(function(){
          if (!checkCanAction(this)) {
            return;
          }
          self.currentPage(self.totalPages());
        });

        this.$next.click(function(){
          if (!checkCanAction(this)) {
            return;
          }
          self.currentPage(self.currentPage()+1);
        });

        this.$numeric.click(function(){
          var ret = checkCanAction(this)
          if (!ret) {
            return;
          }
          var numeric = ret.find(self.options.selectors.numericTxt).text(),
              pageNo = parseInt(numeric);
          self.currentPage(pageNo);

        });

        this._currentPage = this.options.currentPage;
        this._totalPages = this.options.totalPages;

        this._refresh({
          currentPage : true,
          totalPages : true
        });
      },

      _refresh: function (updates) {
        var self = this;

        function changePageNoBtns(currentPage,totalPages) {

          // Create the numeric buttons.
          // Variable of number control in the buttons.
          var totalPageNoBtns = Math.min(totalPages, self.options.maxButtonsVisible);
          var begin = 1;
          var end = begin + totalPageNoBtns - 1;

          /*
           * Align the values in the begin and end variables if the user has the
           * possibility that select a page that doens't appear in the paginador.
           * e.g currentPage = 1, and user go to the 20 page.
           */
          while ((currentPage < begin) || (currentPage > end)) {
            if (currentPage > end) {
               begin += totalPageNoBtns;
               end += totalPageNoBtns;

               if (end > totalPages) {
                 begin = begin - (end - totalPages);
                 end = totalPages;
               }
             } else {
               begin -= totalPageNoBtns;
               end -= totalPageNoBtns;

               if (begin < 0) {
                 end = end + (begin + totalPageNoBtns);
                 begin = 1;
               }
             }
          }
         /*
          * Verify if the user clicks in the last page show by paginator.
          * If yes, the paginator advances.
          */
          if ((currentPage === end) && (totalPages != 1)) {
            begin = currentPage - 1;
            end = begin + totalPageNoBtns - 1;

            if (end >= totalPages) {
              begin = begin - (end - (totalPages));
              end = totalPages;
            }
          }

          /*
           * Verify it the user clicks in the first page show by paginator.
           * If yes, the paginator retrogress
           */
           if ((begin === currentPage) && (totalPages != 1)) {
             if (currentPage != 1) {
               end = currentPage + 1;
               begin = end - (totalPageNoBtns - 1);
             }
           }

           var count = self.$numeric.size(),
               visibles = end-begin + 1,
               i = 0;

           self.$numeric.filter(".active").removeClass("active");
           while (i<visibles) {
             var pageNo = i + begin,
                 $btn = self.$numeric.eq(i);
             $btn.find(self.options.selectors.numericTxt).text(i+begin).show();
             if (pageNo == currentPage) {
              $btn.addClass("active");
             }
             i++;
           }
           while (i<count) {
             self.$numeric.eq(i).find(self.options.selectors.numericTxt).text(i+begin).hide();
             i++;
           }


        }

        function changeLabeldBtns(currentPage,totalPages) {
          if (currentPage < 1) {
            throw('Page can\'t be less than 1');
          } else if (currentPage > totalPages) {
            throw('Page is bigger than total pages');
          }

          if (totalPages < 1) {
            throw('Total Pages can\'t be less than 1');
          }

          if (currentPage == 1 ) {
            self.$first.addClass("disabled");
            self.$prev.addClass("disabled");
          } else {
            self.$first.removeClass("disabled");
            self.$prev.removeClass("disabled");
          }

          if (currentPage == totalPages ) {
            self.$last.addClass("disabled");
            self.$next.addClass("disabled");
          } else {
            self.$last.removeClass("disabled");
            self.$next.removeClass("disabled");
          }
        }

        if (updates.currentPage || updates.totalPages) {
          var currentPage = self.currentPage(),
              totalPages = self.totalPages();

          changePageNoBtns(currentPage,totalPages);
          changeLabeldBtns(currentPage,totalPages);
        }

      },

      currentPage : function(v) {
        if (v !== undefined) {
          this._currentPage = v;
          this._refresh({
            currentPage : true
          });            
          return this;
        } else {
          return this._currentPage;
        }
      },

      totalPages : function(v) {
        if (v !== undefined) {
          this._totalPages = v;
          this._refresh({
            totalPages : true
          });
          return this;
        } else {
          return this._totalPages;
        }
      }
  });

  plugins.register(Pagination);


  return panels.Pagination = Pagination;
});
define('skylark-domx-plugins-popups/Dropdown',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./popups"
],function(langx,browser,eventer,noder,geom,$,plugins,popups){

  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop';
  var toggle   = '[data-toggle="dropdown"]';

  var Dropdown = plugins.Plugin.inherit({
    klassName: "Dropdown",

    pluginName : "lark.popups.dropdown",

    options : {
      "selectors" : {
        "toggler" : '[data-toggle="dropdown"],.dropdown-menu'
      }

    },

    _construct : function(elm,options) {
      this.overrided(elm,options);

      var $el = this.$element = $(this._elm);
      $el.on('click.dropdown', this.toggle);
      $el.on('keydown.dropdown', this.options.selectors.toggler,this.keydown);
    },

    toggle : function (e) {
      var $this = $(this)

      if ($this.is('.disabled, :disabled')) {
        return;
      }

      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open');

      clearMenus()

      if (!isActive) {
        if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
          // if mobile we use a backdrop because click events don't delegate
          $(document.createElement('div'))
            .addClass('dropdown-backdrop')
            .insertAfter($(this))
            .on('click', clearMenus)
        }

        var relatedTarget = { relatedTarget: this }
        $parent.trigger(e = eventer.create('show.dropdown', relatedTarget))

        if (e.isDefaultPrevented()) {
          return;
        }

        $this
          .trigger('focus')
          .attr('aria-expanded', 'true')

        $parent
          .toggleClass('open')
          .trigger(eventer.create('shown.dropdown', relatedTarget))
      }

      return false
    },

    keydown : function (e) {
      if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) {
        return;
      }

      var $this = $(this);

      e.preventDefault()
      e.stopPropagation()

      if ($this.is('.disabled, :disabled')) {
        return;
      }

      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open')

      if (!isActive && e.which != 27 || isActive && e.which == 27) {
        if (e.which == 27) $parent.find(toggle).trigger('focus')
        return $this.trigger('click')
      }

      var desc = ' li:not(.disabled):visible a'
      var $items = $parent.find('.dropdown-menu' + desc)

      if (!$items.length) return

      var index = $items.index(e.target)

      if (e.which == 38 && index > 0)                 index--         // up
      if (e.which == 40 && index < $items.length - 1) index++         // down
      if (!~index)                                    index = 0

      $items.eq(index).trigger('focus');
    }

  });

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector);

    return $parent && $parent.length ? $parent : $this.parent();
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && noder.contains($parent[0], e.target)) return

      $parent.trigger(e = eventer.create('hide.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger(eventer.create('hidden.dropdown', relatedTarget))
    })
  }



  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================
  $(document)
    .on('click.dropdown.data-api', clearMenus)
    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() });

  plugins.register(Dropdown);

  return popups.Dropdown = Dropdown;

});

define('skylark-domx-plugins-toggles/tab',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./toggles"
],function(langx,browser,eventer,noder,geom,$,plugins,toggles){

  'use strict';

  // TAB CLASS DEFINITION
  // ====================


  var Tab =  plugins.Plugin.inherit({
    klassName: "Tab",

    pluginName : "lark.toggles.tab",

    _construct : function(element,options) {
      // jscs:disable requireDollarBeforejQueryAssignment
      this.element = $(element)
      this.target = options && options.target;

      // jscs:enable requireDollarBeforejQueryAssignment
      this.element.on("click.lark.toggles.tab",langx.proxy(function(e){
        e.preventDefault()
        this.show();
      },this));    
    },

    show : function () {
      var $this    = this.element
      var $ul      = $this.closest('ul:not(.dropdown-menu)')
      var selector = this.target || $this.data('target');

      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
      }

      if ($this.parent('li').hasClass('active')) return

      var $previous = $ul.find('.active:last a')
      var hideEvent = eventer.create('hide.lark.toggles.tab', {
        relatedTarget: $this[0]
      })
      var showEvent = eventer.create('show.lark.toggles.tab', {
        relatedTarget: $previous[0]
      })

      $previous.trigger(hideEvent);
      $this.trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

      var $target = $(selector);

      this.activate($this.closest('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $previous.trigger({
          type: 'hidden.lark.toggles.tab',
          relatedTarget: $this[0]
        })
        $this.trigger({
          type: 'shown.lark.toggles.tab',
          relatedTarget: $previous[0]
        })
      })
    },

    activate : function (element, container, callback) {
      var $active    = container.find('> .active')
      var transition = callback
        && browser.support.transition
        && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

      function next() {
        $active
          .removeClass('active')
          .find('> .dropdown-menu > .active')
            .removeClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', false)

        element
          .addClass('active')
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)

        if (transition) {
          element[0].offsetWidth // reflow for transition
          element.addClass('in')
        } else {
          element.removeClass('fade')
        }

        if (element.parent('.dropdown-menu').length) {
          element
            .closest('li.dropdown')
              .addClass('active')
            .end()
            .find('[data-toggle="tab"]')
              .attr('aria-expanded', true)
        }

        callback && callback()
      }

      $active.length && transition ?
        $active
          .one('transitionEnd', next)
          .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
        next()

      $active.removeClass('in')
    }


  });


  Tab.TRANSITION_DURATION = 150


  plugins.register(Tab);

  return toggles.Tab = Tab;
});

define('skylark-domx-plugins-panels/tabstrip',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "skylark-domx-plugins-base",
    "skylark-domx-plugins-popups/Dropdown",
    "skylark-domx-plugins-toggles/tab",
    "./panels",
    "./panel"
], function(langx, browser, eventer, noder, geom,  $, plugins,Dropdown, TabButton,panels,Panel) {

    var TabStrip = Panel.inherit({
        klassName : "TabStrip",
        pluginName : "lark.panels.tabstrip",

        options : {
          selectors : {
            header : ".nav-tabs",
            tab : "[data-toggle=\"tab\"]",
            content : ".tab-content",
            tabpane : ".tab-pane"
          },

          droptabs : {
            selectors : {
              dropdown : "li.droptabs",
              dropdownMenu    : "ul.dropdown-menu",
              dropdownTabs    : "li",
              dropdownCaret   : "b.caret",
              visibleTabs     : ">li:not(.dropdown)",
            },
            auto              : true,
            pullDropdownRight : true,


          }
        },

     _construct : function(elm,options) {
        Panel.prototype._construct.call(this,elm,options);

        this.$header = this._velm.$(this.options.selectors.header); 
        this.$tabs = this.$header.find(this.options.selectors.tab);
        this.$content = this._velm.$(this.options.selectors.content);
        this.$tabpanes = this.$content.find(this.options.selectors.tabpane);

        this.$header.find('[data-toggle="dropdown"]').plugin(Dropdown.prototype.pluginName);

        var self = this;
        this.$tabs.each(function(idx,tabEl){
          $(tabEl).plugin(TabButton.prototype.pluginName, {
            target : self.$tabpanes[idx]
          });
        });

      },

      arrange : function () {

        var dropdownTabsSelector = this.options.droptabs.selectors.dropdownTabs,
            visibleTabsSelector = this.options.droptabs.selectors.visibleTabs;

            $container = this.$header;
        var dropdown = $container.find(this.options.droptabs.selectors.dropdown);
        var dropdownMenu = dropdown.find(this.options.droptabs.selectors.dropdownMenu);
        var dropdownLabel = $('>a', dropdown).clone();
        var dropdownCaret = $(this.options.droptabs.selectors.dropdownCaret, dropdown);

        // We only want the default label, strip the caret out
        $(this.options.droptabs.selectors.dropdownCaret, dropdownLabel).remove();

        if (this.options.droptabs.pullDropdownRight) {
          $(dropdown).addClass('pull-right');
        }

        var $dropdownTabs = function () {
          return $(dropdownTabsSelector, dropdownMenu);
        }

        var $visibleTabs = function () {
          return $(visibleTabsSelector, $container);
        }

        function getFirstHiddenElementWidth() {
          var tempElem=$dropdownTabs().first().clone().appendTo($container).css("position","fixed");
          var hiddenElementWidth = $(tempElem).outerWidth();
          $(tempElem).remove();
          return hiddenElementWidth;
        }

        function getHiddenElementWidth(elem) {
          var tempElem=$(elem).clone().appendTo($container).css("position","fixed");
          var hiddenElementWidth = $(tempElem).outerWidth();
          $(tempElem).remove();
          return hiddenElementWidth;
        }

        function getDropdownLabel() {
          var labelText = 'Dropdown';
          if ($(dropdown).hasClass('active')) {
            labelText = $('>li.active>a', dropdownMenu).html();
          } else if (dropdownLabel.html().length > 0) {
            labelText = dropdownLabel.html();
          }

          labelText = $.trim(labelText);

          if (labelText.length > 10) {
            labelText = labelText.substring(0, 10) + '...';
          }

          return labelText;
        }

        function renderDropdownLabel() {
          $('>a', dropdown).html(getDropdownLabel() + ' ' + dropdownCaret.prop('outerHTML'));
        }

        function manageActive(elem) {
          //fixes a bug where Bootstrap can't remove the 'active' class on elements after they've been hidden inside the dropdown
          $('a', $(elem)).on('show.bs.tab', function (e) {
            $(e.relatedTarget).parent().removeClass('active');
          })
          $('a', $(elem)).on('shown.bs.tab', function (e) {
            renderDropdownLabel();
          })

        }

        function checkDropdownSelection() {
          if ($($dropdownTabs()).filter('.active').length > 0) {
            $(dropdown).addClass('active');
          } else {
            $(dropdown).removeClass('active');
          }

          renderDropdownLabel();
        }


        var visibleTabsWidth = function () {
          var visibleTabsWidth = 0;
          $($visibleTabs()).each(function( index ) {
            visibleTabsWidth += parseInt($(this).outerWidth(), 10);
          });
          visibleTabsWidth = visibleTabsWidth + parseInt($(dropdown).outerWidth(), 10);
          return visibleTabsWidth;
        }

        var availableSpace = function () {
          return $container.outerWidth()-visibleTabsWidth();
        }

        if (availableSpace()<0) {//we will hide tabs here
          var x = availableSpace();
          $($visibleTabs().get().reverse()).each(function( index ){
            if (!($(this).hasClass('always-visible'))){
                $(this).prependTo(dropdownMenu);
                x=x+$(this).outerWidth();
            }
            if (x>=0) {return false;}
          });
        }

        if (availableSpace()>getFirstHiddenElementWidth()) { //and here we bring the tabs out
          var x = availableSpace();
          $($dropdownTabs()).each(function( index ){
            if (getHiddenElementWidth(this) < x && !($(this).hasClass('always-dropdown'))){
              $(this).appendTo($container);
              x = x-$(this).outerWidth();
            } else {return false;}
           });

          if (!this.options.droptabs.pullDropdownRight && !$(dropdown).is(':last-child')) {
            // If not pulling-right, keep the dropdown at the end of the container.
            $(dropdown).detach().insertAfter($container.find('li:last-child'));
          }
        }

        if ($dropdownTabs().length <= 0) {
          dropdown.hide();
        } else {
          dropdown.show();
        }
      },

      //Activates a tab specified as a selector. 
      activateTab : function(tab) {
        if (langx.isNumber(tab)) {
          $(this.$tabs[tab]).plugin(TabButton.prototype.pluginName).show();
        }
      },

      addTab : function() {
        //TODO
      },

      removeTab : function(){
        //TODO
      }
    });

    plugins.register(TabStrip);


    return panels.TabStrip = TabStrip;

});
define('skylark-domx-plugins-panels/toolbar',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./panels",
  "./panel"
],function(langx,$,plugins,panels,Panel){ 


  var Toolbar = Panel.inherit({
    klassName : "Toolbar",

    pluginName : "lark.panels.toolbar",

    options : {
      toolbarFloat: true,
      toolbarHidden: false,
      toolbarFloatOffset: 0,
      template : '<div class="domx-toolbar"><ul></ul></div>',
      separator : {
        template :  '<li><span class="separator"></span></li>'
      }
    },

    _construct : function(elm,options) {
      Panel.prototype._construct.call(this,elm,options);

      var floatInitialized, initToolbarFloat, toolbarHeight;
      //this.editor = editor;

      //this.opts = langx.extend({}, this.opts, opts);
      this.opts = this.options;


      //if (!langx.isArray(this.opts.toolbar)) {
      //  this.opts.toolbar = ['bold', 'italic', 'underline', 'strikethrough', '|', 'ol', 'ul', 'blockquote', 'code', '|', 'link', 'image', '|', 'indent', 'outdent'];
      //}

      this.wrapper = $(this._elm);
      this.list = this.wrapper.find('ul');
      this.list.on('click', function(e) {
        return false;
      });
      this.wrapper.on('mousedown', (function(_this) {
        return function(e) {
          return _this.list.find('.menu-on').removeClass('.menu-on');
        };
      })(this));
      $(document).on('mousedown.toolbar', (function(_this) {
        return function(e) {
          return _this.list.find('.menu-on').removeClass('menu-on');
        };
      })(this));
      if (!this.opts.toolbarHidden && this.opts.toolbarFloat) {
        this.wrapper.css('top', this.opts.toolbarFloatOffset);
        toolbarHeight = 0;
        initToolbarFloat = (function(_this) {
          return function() {
            _this.wrapper.css('position', 'static');
            _this.wrapper.width('auto');
            _this.editor.editable.util.reflow(_this.wrapper);
            _this.wrapper.width(_this.wrapper.outerWidth());
            _this.wrapper.css('left', _this.editor.editable.util.os.mobile ? _this.wrapper.position().left : _this.wrapper.offset().left);
            _this.wrapper.css('position', '');
            toolbarHeight = _this.wrapper.outerHeight();
            _this.editor.placeholderEl.css('top', toolbarHeight);
            return true;
          };
        })(this);
        floatInitialized = null;

        /*
        $(window).on('resize.richeditor-' + this.editor.id, function(e) {
          return floatInitialized = initToolbarFloat();
        });
        $(window).on('scroll.richeditor-' + this.editor.id, (function(_this) {
          return function(e) {
            var bottomEdge, scrollTop, topEdge;
            if (!_this.wrapper.is(':visible')) {
              return;
            }
            topEdge = _this.editor.wrapper.offset().top;
            bottomEdge = topEdge + _this.editor.wrapper.outerHeight() - 80;
            scrollTop = $(document).scrollTop() + _this.opts.toolbarFloatOffset;
            if (scrollTop <= topEdge || scrollTop >= bottomEdge) {
              _this.editor.wrapper.removeClass('toolbar-floating').css('padding-top', '');
              if (_this.editor.editable.util.os.mobile) {
                return _this.wrapper.css('top', _this.opts.toolbarFloatOffset);
              }
            } else {
              floatInitialized || (floatInitialized = initToolbarFloat());
              _this.editor.wrapper.addClass('toolbar-floating').css('padding-top', toolbarHeight);
              if (_this.editor.editable.util.os.mobile) {
                return _this.wrapper.css('top', scrollTop - topEdge + _this.opts.toolbarFloatOffset);
              }
            }
          };
        })(this));
        */
      }

      /*
      this.editor.on('destroy', (function(_this) {
        return function() {
          return _this.buttons.length = 0;
        };
      })(this));
      */

      
    },

    addToolItem : function(itemWidget) {
      $(itemWidget._elm).appendTo(this.list);
      return this;
    },

    addSeparator : function() {
      $(this.options.separator.template).appendTo(this.list);
      return this;
    }

  });

  plugins.register(Toolbar);

  return panels.Toolbar = Toolbar;

});
define('skylark-domx-plugins-panels/wizard',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins-base",
  "./panels",
  "./panel"
 ],function(langx,browser,eventer,noder,geom,$,plugins,panels,Panel){


	var Wizard = Panel.inherit({
		klassName: "Wizard",

	    pluginName : "lark.panels.wizard",

	    options : {
			disablePreviousStep: false,
			selectedItem: {
				step: -1
			}//-1 means it will attempt to look for "active" class in order to set the step
	    },

	    _construct : function(elm,options) {
      		Panel.prototype._construct.call(this,elm,options);

			this.$element = this.$();
			this.options.disablePreviousStep = (this.$element.attr('data-restrict') === 'previous') ? true : this.options.disablePreviousStep;
			this.currentStep = this.options.selectedItem.step;
			this.numSteps = this.$element.find('.steps li').length;
			this.$prevBtn = this.$element.find('button.btn-prev');
			this.$nextBtn = this.$element.find('button.btn-next');

			var kids = this.$nextBtn.children().detach();
			this.nextText = langx.trim(this.$nextBtn.text());
			this.$nextBtn.append(kids);

			var steps = this.$element.children('.steps-container');
			// maintains backwards compatibility with < 3.8, will be removed in the future
			if (steps.length === 0) {
				steps = this.$element;
				this.$element.addClass('no-steps-container');
				if (window && window.console && window.console.warn) {
					window.console.warn('please update your wizard markup to include ".steps-container" as seen in http://getfuelux.com/javascript.html#wizard-usage-markup');
				}
			}
			steps = steps.find('.steps');

			// handle events
			this.$prevBtn.on('click.fu.wizard', langx.proxy(this.previous, this));
			this.$nextBtn.on('click.fu.wizard', langx.proxy(this.next, this));
			steps.on('click.fu.wizard', 'li.complete', langx.proxy(this.stepclicked, this));

			this.selectedItem(this.options.selectedItem);

			if (this.options.disablePreviousStep) {
				this.$prevBtn.attr('disabled', true);
				this.$element.find('.steps').addClass('previous-disabled');
			}
		},

		destroy: function () {
			this.$element.remove();
			// any external bindings [none]
			// empty elements to return to original markup [none]
			// returns string of markup
			return this.$element[0].outerHTML;
		},

		//index is 1 based
		//second parameter can be array of objects [{ ... }, { ... }] or you can pass n additional objects as args
		//object structure is as follows (all params are optional): { badge: '', label: '', pane: '' }
		addSteps: function (index) {
			var items = [].slice.call(arguments).slice(1);
			var $steps = this.$element.find('.steps');
			var $stepContent = this.$element.find('.step-content');
			var i, l, $pane, $startPane, $startStep, $step;

			index = (index === -1 || (index > (this.numSteps + 1))) ? this.numSteps + 1 : index;
			if (items[0] instanceof Array) {
				items = items[0];
			}

			$startStep = $steps.find('li:nth-child(' + index + ')');
			$startPane = $stepContent.find('.step-pane:nth-child(' + index + ')');
			if ($startStep.length < 1) {
				$startStep = null;
			}

			for (i = 0, l = items.length; i < l; i++) {
				$step = $('<li data-step="' + index + '"><span class="badge badge-info"></span></li>');
				$step.append(items[i].label || '').append('<span class="chevron"></span>');
				$step.find('.badge').append(items[i].badge || index);

				$pane = $('<div class="step-pane" data-step="' + index + '"></div>');
				$pane.append(items[i].pane || '');

				if (!$startStep) {
					$steps.append($step);
					$stepContent.append($pane);
				} else {
					$startStep.before($step);
					$startPane.before($pane);
				}

				index++;
			}

			this.syncSteps();
			this.numSteps = $steps.find('li').length;
			this.setState();
		},

		//index is 1 based, howMany is number to remove
		removeSteps: function (index, howMany) {
			var action = 'nextAll';
			var i = 0;
			var $steps = this.$element.find('.steps');
			var $stepContent = this.$element.find('.step-content');
			var $start;

			howMany = (howMany !== undefined) ? howMany : 1;

			if (index > $steps.find('li').length) {
				$start = $steps.find('li:last');
			} else {
				$start = $steps.find('li:nth-child(' + index + ')').prev();
				if ($start.length < 1) {
					action = 'children';
					$start = $steps;
				}

			}

			$start[action]().each(function () {
				var item = $(this);
				var step = item.attr('data-step');
				if (i < howMany) {
					item.remove();
					$stepContent.find('.step-pane[data-step="' + step + '"]:first').remove();
				} else {
					return false;
				}

				i++;
			});

			this.syncSteps();
			this.numSteps = $steps.find('li').length;
			this.setState();
		},

		setState: function () {
			var canMovePrev = (this.currentStep > 1);//remember, steps index is 1 based...
			var isFirstStep = (this.currentStep === 1);
			var isLastStep = (this.currentStep === this.numSteps);

			// disable buttons based on current step
			if (!this.options.disablePreviousStep) {
				this.$prevBtn.attr('disabled', (isFirstStep === true || canMovePrev === false));
			}

			// change button text of last step, if specified
			var last = this.$nextBtn.attr('data-last');
			if (last) {
				this.lastText = last;
				// replace text
				var text = this.nextText;
				if (isLastStep === true) {
					text = this.lastText;
					// add status class to wizard
					this.$element.addClass('complete');
				} else {
					this.$element.removeClass('complete');
				}

				var kids = this.$nextBtn.children().detach();
				this.$nextBtn.text(text).append(kids);
			}

			// reset classes for all steps
			var $steps = this.$element.find('.steps li');
			$steps.removeClass('active').removeClass('complete');
			$steps.find('span.badge').removeClass('badge-info').removeClass('badge-success');

			// set class for all previous steps
			var prevSelector = '.steps li:lt(' + (this.currentStep - 1) + ')';
			var $prevSteps = this.$element.find(prevSelector);
			$prevSteps.addClass('complete');
			$prevSteps.find('span.badge').addClass('badge-success');

			// set class for current step
			var currentSelector = '.steps li:eq(' + (this.currentStep - 1) + ')';
			var $currentStep = this.$element.find(currentSelector);
			$currentStep.addClass('active');
			$currentStep.find('span.badge').addClass('badge-info');

			// set display of target element
			var $stepContent = this.$element.find('.step-content');
			var target = $currentStep.attr('data-step');
			$stepContent.find('.step-pane').removeClass('active');
			$stepContent.find('.step-pane[data-step="' + target + '"]:first').addClass('active');

			// reset the wizard position to the left
			this.$element.find('.steps').first().attr('style', 'margin-left: 0');

			// check if the steps are wider than the container div
			var totalWidth = 0;
			this.$element.find('.steps > li').each(function () {
				totalWidth += $(this).outerWidth();
			});
			var containerWidth = 0;
			if (this.$element.find('.actions').length) {
				containerWidth = this.$element.width() - this.$element.find('.actions').first().outerWidth();
			} else {
				containerWidth = this.$element.width();
			}

			if (totalWidth > containerWidth) {
				// set the position so that the last step is on the right
				var newMargin = totalWidth - containerWidth;
				this.$element.find('.steps').first().attr('style', 'margin-left: -' + newMargin + 'px');

				// set the position so that the active step is in a good
				// position if it has been moved out of view
				if (this.$element.find('li.active').first().position().left < 200) {
					newMargin += this.$element.find('li.active').first().position().left - 200;
					if (newMargin < 1) {
						this.$element.find('.steps').first().attr('style', 'margin-left: 0');
					} else {
						this.$element.find('.steps').first().attr('style', 'margin-left: -' + newMargin + 'px');
					}

				}

			}

			// only fire changed event after initializing
			if (typeof (this.initialized) !== 'undefined') {
				var e = eventer.create('changed.fu.wizard');
				this.$element.trigger(e, {
					step: this.currentStep
				});
			}

			this.initialized = true;
		},

		stepclicked: function (e) {
			var li = $(e.currentTarget);
			var index = this.$element.find('.steps li').index(li);

			if (index < this.currentStep && this.options.disablePreviousStep) {//enforce restrictions
				return;
			} else {
				var evt = eventer.create('stepclicked.fu.wizard');
				this.$element.trigger(evt, {
					step: index + 1
				});
				if (evt.isDefaultPrevented()) {
					return;
				}

				this.currentStep = (index + 1);
				this.setState();
			}
		},

		syncSteps: function () {
			var i = 1;
			var $steps = this.$element.find('.steps');
			var $stepContent = this.$element.find('.step-content');

			$steps.children().each(function () {
				var item = $(this);
				var badge = item.find('.badge');
				var step = item.attr('data-step');

				if (!isNaN(parseInt(badge.html(), 10))) {
					badge.html(i);
				}

				item.attr('data-step', i);
				$stepContent.find('.step-pane[data-step="' + step + '"]:last').attr('data-step', i);
				i++;
			});
		},

		previous: function () {
			if (this.options.disablePreviousStep || this.currentStep === 1) {
				return;
			}

			var e = eventer.create('actionclicked.fu.wizard');
			this.$element.trigger(e, {
				step: this.currentStep,
				direction: 'previous'
			});
			if (e.isDefaultPrevented()) {
				return;
			}// don't increment ...what? Why?

			this.currentStep -= 1;
			this.setState();

			// only set focus if focus is still on the $nextBtn (avoid stomping on a focus set programmatically in actionclicked callback)
			if (this.$prevBtn.is(':focus')) {
				var firstFormField = this.$element.find('.active').find('input, select, textarea')[0];

				if (typeof firstFormField !== 'undefined') {
					// allow user to start typing immediately instead of having to click on the form field.
					$(firstFormField).focus();
				} else if (this.$element.find('.active input:first').length === 0 && this.$prevBtn.is(':disabled')) {
					//only set focus on a button as the last resort if no form fields exist and the just clicked button is now disabled
					this.$nextBtn.focus();
				}

			}
		},

		next: function () {
			var e = eventer.create('actionclicked.fu.wizard');
			this.$element.trigger(e, {
				step: this.currentStep,
				direction: 'next'
			});
			if (e.isDefaultPrevented()) {
				return;
			}// respect preventDefault in case dev has attached validation to step and wants to stop propagation based on it.

			if (this.currentStep < this.numSteps) {
				this.currentStep += 1;
				this.setState();
			} else {//is last step
				this.$element.trigger('finished.fu.wizard');
			}

			// only set focus if focus is still on the $nextBtn (avoid stomping on a focus set programmatically in actionclicked callback)
			if (this.$nextBtn.is(':focus')) {
				var firstFormField = this.$element.find('.active').find('input, select, textarea')[0];

				if (typeof firstFormField !== 'undefined') {
					// allow user to start typing immediately instead of having to click on the form field.
					$(firstFormField).focus();
				} else if (this.$element.find('.active input:first').length === 0 && this.$nextBtn.is(':disabled')) {
					//only set focus on a button as the last resort if no form fields exist and the just clicked button is now disabled
					this.$prevBtn.focus();
				}

			}
		},

		selectedItem: function (selectedItem) {
			var retVal, step;

			if (selectedItem) {
				step = selectedItem.step || -1;
				//allow selection of step by data-name
				step = Number(this.$element.find('.steps li[data-name="' + step + '"]').first().attr('data-step')) || Number(step);

				if (1 <= step && step <= this.numSteps) {
					this.currentStep = step;
					this.setState();
				} else {
					step = this.$element.find('.steps li.active:first').attr('data-step');
					if (!isNaN(step)) {
						this.currentStep = parseInt(step, 10);
						this.setState();
					}

				}

				retVal = this;
			} else {
				retVal = {
					step: this.currentStep
				};
				if (this.$element.find('.steps li.active:first[data-name]').length) {
					retVal.stepname = this.$element.find('.steps li.active:first').attr('data-name');
				}

			}

			return retVal;
		}

	});

   plugins.register(Wizard);

	return panels.Wizard = Wizard;

});

define('skylark-domx-plugins-panels/main',[
    "./panels",
    "./accordion",
    "./collapsible",
    "./floating",
    "./pagination",
    "./panel",
    "./tabstrip",
    "./toolbar",
    "./wizard"
], function(panels) {
    return panels;
});
define('skylark-domx-plugins-panels', ['skylark-domx-plugins-panels/main'], function (main) { return main; });

define('skylark-domx-plugins-embeds/embeds',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.embeds = {};
});


define('skylark-domx-plugins-embeds/embed-runner',[
    "skylark-domx-iframes/create",
    "skylark-domx/query",
    "skylark-domx-plugins-base",
    "./embeds"
], function(createIframe, $, plugins,embeds) {

    'use strict';
    // move from render/live.js

  /** ============================================================================
   * Skylark Html Viewer
   * Messages to and from the runner.
   * ========================================================================== */

  var 
      $window = $(window),
      $document = $(document);


  var EmbedRunner =  plugins.Plugin.inherit({

    klassName: "EmbedRunner",

    pluginName : "lark.embeds.runner",

    options : {
      runnerUrl : "",
      runnerName : ""
    },

    _construct : function(elm,options) {
      this.overrided(elm,options);

       /**
        * Store what runner origin *should* be
        * TODO this should allow anything if x-origin protection should be disabled
       */
       this.runner = {};
       this.runner.origin = '*';

    },

    /**
     * Render live preview.
     * Create the runner iframe, and if postMe wait until the iframe is loaded to
     * start postMessaging the runner.
     */
    prepare :  function () {

      if (this._inited) {
        return this._inited.promise;
      }

      this._inited = new Deferred();

      // Basic mode
      // This adds the runner iframe to the page. It's only run once.
      //if (!$live.find('iframe').length) {
        /*
        iframe = noder.create("iframe",{
          ///iframe.src = jsbin.runner;
          src : this.options.runnerUrl
        },{
          "class" : "stretch",
          "sandbox", "allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts",
          "frameBorder": '0',
          "name", "<proxy>",
        },this._elm);

        try {
          ///iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;
          iframe.contentWindow.name  = this.options.runnerName;
        } catch (e) {
          // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.
          // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits
          // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview
          // then fail, and jsbin doesn't boot up. Tears all round, so we catch.
        }
      //}

      iframe.onload = () => {
        if (window.postMessage) {
          // setup postMessage listening to the runner
          $window.on('message', (event) => {
            this.handleMessage(event.originalEvent)
          });
          this.setup(iframe);
          this._inited.resolve();
        }
      };

      iframe.onerror = (err) => {
        this._inited.reject(err);
      };
      */

      createIframe({
        "url" : this.options.runnerUrl,
        "className" : "stretch",
        "sandbox" : "allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts",
        "frameBorder": '0',
        "name": "<proxy>",
        "contentWindowName": this.options.runnerName,
        "onload" : () => {
          if (window.postMessage) {
            // setup postMessage listening to the runner
            $window.on('message', (event) => {
              this.handleMessage(event.originalEvent)
            });
            this.setup(iframe);
            this._inited.resolve();
          }
        },
        "onerror" : (err) => {
          this._inited.reject(err);
        }
      },this._elm);

      /**
       * Events
       */

      $document.on('codeChange.live', (event, arg) => {
        if (arg.origin === 'setValue' || arg.origin === undefined) {
          return;
        }
        ///store.sessionStorage.removeItem('runnerPending');
      });

      // Listen for console input and post it to the iframe
      $document.on("console:run", (event, cmd)  => {
        this.postMessage('console:run', cmd);
      });

      $document.on('console:load:script', (event, url) => {
        this.postMessage('console:load:script', url);
      });

      $document.on('console:load:dom', (event, html) => {
        this.postMessage('console:load:dom', html);
      });

      /* not need ? // lwf
       * When the iframe resizes, update the size text
      this.resize = (function () {
        var $size = this.$().find('.size');

        var hide = func.debounce(function () {
          $size.fadeOut(200);
        }, 2000);

        var embedResizeDone = false;

        return function (data) {
          
          ///if (!jsbin.embed) {
          ///  // Display the iframe size in px in the JS Bin UI
          ///  size.show().html(data.width + 'px');
          ///  hide();
          ///}
          ///if (jsbin.embed && self !== top && embedResizeDone === false) {
          if (embedResizeDone === false) {
            embedResizeDone = true;
            // Inform the outer page of a size change
            var height = ($body.outerHeight(true) - $(this.runner.iframe).height()) + data.offsetHeight;
           window.parent.postMessage({ height: height }, '*');
          }
        };
      }());
      */
      
      return inited.promise;
    },


    /**
     * Setup the renderer
     */
    setup : function (runnerFrame) {
      this.runner.window = runnerFrame.contentWindow;
      this.runner.iframe = runnerFrame;
    },

    /**
     * Log error messages, indicating that it's from the renderer.
     */
    error : function () {
      // it's quite likely that the error that fires on this handler actually comes
      // from another service on the page, like a browser plugin, which we can
      // safely ignore.
      window.console.warn.apply(console, ['Renderer:'].concat([].slice.call(arguments)));
    },

    /**
     * Handle all incoming postMessages to the renderer
     */
    handleMessage : function (event) {
      if (!event.origin) return;
      var data = event.data;

      if (typeof data !== 'string') {
        // this event isn't for us (i.e. comes from a browser ext)
        return;
      }

      // specific change to handle reveal embedding
      /*
       // Unnecessary? //lwf
      try {
        if (event.data.indexOf('slide:') === 0 || event.data === 'jsbin:refresh') {
          // reset the state of the panel visibility
          jsbin.panels.allEditors(function (p) {
            p.visible = false;
          });
          jsbin.panels.restore();
          return;
        }
      } catch (e) {}
      */

      try {
        data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
      } catch (e) {
        return this.error('Error parsing event data:', e.message);
      }

      /*
       // Unnecessary? //lwf
      if (data.type.indexOf('code:') === 0 && jsbin.embed) {
        var panel = data.type.substr(5);
        if (panel === 'js') { panel = 'javascript'; }
        if (' css javascript html '.indexOf(' ' + panel + ' ') === -1) {
          return renderer.error('No matching event handler:', data.type);
        }

        if (!jsbin.state.metadata.pro) {
          return renderer.error('Code injection is only supported on pro created bins');
        }

        jsbin.panels.named[panel].setCode(data.data);
        renderLivePreview();

        return;
      }
      */

      if (typeof this[data.type] !== 'function') {
        return false; //renderer.error('No matching handler for event', data);
      }
      try {
        this[data.type](data.data);
      } catch (e) {
        this.error(e.message);
      }
    },

    /**
     * Send message to the runner window
     */
    postMessage : function (type, data) {
      if (!this.runner.window) {
        return this.error('postMessage: No connection to runner window.');
      }
      this.runner.window.postMessage(JSON.stringify({
        type: type,
        data: data
      }), this.runner.origin);
    },

    /**
     * When the renderer is complete, it means we didn't hit an initial
     * infinite loop
     */
    complete : function () {
      try {
        store.sessionStorage.removeItem('runnerPending');
      } catch (e) {}
    },

    /**
     * Pass loop protection hit calls up to the error UI
    renderer.loopProtectHit = function (line) {
      var cm = jsbin.panels.named.javascript.editor;

      // grr - more setTimeouts to the rescue. We need this to go in *after*
      // jshint does it's magic, but jshint set on a setTimeout, so we have to
      // schedule after.
      setTimeout(function () {
        var annotations = cm.state.lint.annotations || [];
        if (typeof cm.updateLinting !== 'undefined') {
          // note: this just updated the *source* reference
          annotations = annotations.filter(function (a) {
            return a.source !== 'loopProtectLine:' + line;
          });
          annotations.push({
            from: CodeMirror.Pos(line-1, 0),
            to: CodeMirror.Pos(line-1, 0),
            message: 'Exiting potential infinite loop.\nTo disable loop protection: add "// noprotect" to your code',
            severity: 'warning',
            source: 'loopProtectLine:' + line
          });

          cm.updateLinting(annotations);
        }
      }, cm.state.lint.options.delay || 0);
    };
     */



    /**
     * When the iframe focuses, simulate that here
     */
    focus : function () {
      ///jsbin.panels.focus(jsbin.panels.named.live);
      // also close any open dropdowns
      ///closedropdown();
    },

    /**
     * Proxy console logging to JS Bin's console
     */
    console : function (data) {
      var method = data.method,
          args = data.args;

      if (!window._console) {return;}
      if (!window._console[method]) {method = 'log';}

      // skip the entire console rendering if the console is hidden
      ///if (!jsbin.panels.named.console.visible) { return; }

      window._console[method].apply(window._console, args);
    },

    /**
     * Load scripts into rendered iframe
     */
    'console:load:script:success' : function (url) {
      $document.trigger('console:load:script:success', url);
    },

    'console:load:script:error' : function (err) {
      $document.trigger('console:load:script:error', err);
    },

    /**
     * Load DOME into rendered iframe
     * TODO abstract these so that they are automatically triggered
     */
    'console:load:dom:success' : function (url) {
      $document.trigger('console:load:dom:success', url);
    },

    'console:load:dom:error' : function (err) {
      $document.trigger('console:load:dom:error', err);
    }

  });

  return embeds.EmbedRunner = EmbedRunner;
});

define('skylark-domx-plugins-embeds/embed-vimeo',[
  "skylark-langx/langx",
  "skylark-domx-noder",
  "skylark-domx-query",
    "skylark-domx-plugins-base",
  './embeds'
], function (langx, noder, $, plugins, embeds) {
  'use strict'

  var EmbedVimeo = plugins.Plugin.inherit({
    klassName: "EmbedVimeo",

    pluginName : "lark.embeds.vimeo",

    options : {

    },

    _construct : function(elm,options) {
      //url, videoId, playerId, clickToPlay) 
      plugins.Plugin.prototype._construct.call(this,elm,options);

      this.url = options.url
      this.videoId = options.videoId
      this.playerId = options.playerId
      this.clickToPlay = options.clickToPlay

      ///this.element = document.createElement('div')
    },

    canPlayType: function () {
      return true
    },

    loadAPI: function () {
      var that = this
      var apiUrl = '//f.vimeocdn.com/js/froogaloop2.min.js'
      var scriptTags = document.getElementsByTagName('script')
      var i = scriptTags.length
      var scriptTag
      var called

      function callback() {
        if (!called && that.playOnReady) {
          that.play()
        }
        called = true
      }
      while (i) {
        i -= 1
        if (scriptTags[i].src === apiUrl) {
          scriptTag = scriptTags[i]
          break
        }
      }
      if (!scriptTag) {
        scriptTag = document.createElement('script')
        scriptTag.src = apiUrl
      }
      $(scriptTag).on('load', callback)
      scriptTags[0].parentNode.insertBefore(scriptTag, scriptTags[0])
      // Fix for cached scripts on IE 8:
      if (/loaded|complete/.test(scriptTag.readyState)) {
        callback()
      }
    },

    onReady: function () {
      var that = this
      this.ready = true
      this.player.addEvent('play', function () {
        that.hasPlayed = true
        that.onPlaying()
      })
      this.player.addEvent('pause', function () {
        that.onPause()
      })
      this.player.addEvent('finish', function () {
        that.onPause()
      })
      if (this.playOnReady) {
        this.play()
      }
    },

    onPlaying: function () {
      if (this.playStatus < 2) {
        this.emit("playing");
        this.playStatus = 2
      }
    },

    onPause: function () {
      this.emit("pause");
      delete this.playStatus
    },

    insertIframe: function () {
      var iframe = document.createElement('iframe')
      iframe.src = this.url
        .replace('VIDEO_ID', this.videoId)
        .replace('PLAYER_ID', this.playerId)
      iframe.id = this.playerId
      this._elm.parentNode.replaceChild(iframe, this._elm)
      this._elm = iframe
    },

    play: function () {
      var that = this
      if (!this.playStatus) {
        this.emit("play");
        this.playStatus = 1
      }
      if (this.ready) {
        if (
          !this.hasPlayed &&
          (this.clickToPlay ||
            (window.navigator &&
              /iP(hone|od|ad)/.test(window.navigator.platform)))
        ) {
          // Manually trigger the playing callback if clickToPlay
          // is enabled and to workaround a limitation in iOS,
          // which requires synchronous user interaction to start
          // the video playback:
          this.onPlaying()
        } else {
          this.player.api('play')
        }
      } else {
        this.playOnReady = true
        if (!window.$f) {
          this.loadAPI()
        } else if (!this.player) {
          this.insertIframe()
          this.player = $f(this._elm)
          this.player.addEvent('ready', function () {
            that.onReady()
          })
        }
      }
    },

    pause: function () {
      if (this.ready) {
        this.player.api('pause');
      } else if (this.playStatus) {
        delete this.playOnReady;
        this.emit("pause");
        delete this.playStatus;
      }
    }
  });

  return embeds.EmbedVimeo = EmbedVimeo;

});
define('skylark-domx-plugins-embeds/embed-youtube',[
  "skylark-langx/langx",
  "skylark-domx-noder",
  "skylark-domx-query",
    "skylark-domx-plugins-base",
  './embeds'
], function (langx, noder, $, plugins, embeds) {
  'use strict'

  var EmbedYoutube = plugins.Plugin.inherit({
    klassName: "EmbedYoutube",

    pluginName : "lark.embeds.youtube",

    options : {

    },

    _construct : function(elm,options) {
      // videoId, playerVars, clickToPlay
      plugins.Plugin.prototype._construct.call(this,elm,options);

      this.videoId = options.videoId;
      this.playerVars = options.playerVars;
      this.clickToPlay = options.clickToPlay;
      ///this.element = document.createElement('div');
    },

    canPlayType: function () {
      return true;
    },

    loadAPI: function () {
      var that = this,
        onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady,
        apiUrl = 'https://www.youtube.com/iframe_api',
        scriptTags = document.getElementsByTagName('script'),
        i = scriptTags.length,
        scriptTag;

      window.onYouTubeIframeAPIReady = function () {
        if (onYouTubeIframeAPIReady) {
          onYouTubeIframeAPIReady.apply(this);
        }
        if (that.playOnReady) {
          that.play();
        }
      }
      while (i) {
        i -= 1
        if (scriptTags[i].src === apiUrl) {
          return
        }
      }
      scriptTag = document.createElement('script')
      scriptTag.src = apiUrl
      scriptTags[0].parentNode.insertBefore(scriptTag, scriptTags[0])
    },

    onReady: function () {
      this.ready = true;
      if (this.playOnReady) {
        this.play()
      }
    },

    onPlaying: function () {
      if (this.playStatus < 2) {
        this.emit("playing");
        this.playStatus = 2;
      }
    },

    onPause: function () {
      langx.defer(()=>{
        this.checkSeek();
      },2000)
    },

    checkSeek: function () {
      if (
        this.stateChange === YT.PlayerState.PAUSED ||
        this.stateChange === YT.PlayerState.ENDED
      ) {
        // check if current state change is actually paused
        this.emit("pause");
        delete this.playStatus
      }
    },

    onStateChange: function (event) {
      switch (event.data) {
        case YT.PlayerState.PLAYING:
          this.hasPlayed = true
          this.onPlaying()
          break
        case YT.PlayerState.PAUSED:
        case YT.PlayerState.ENDED:
          this.onPause()
          break
      }
      // Save most recent state change to this.stateChange
      this.stateChange = event.data
    },

    onError: function (event) {
      this.trigger("error", event);
    },

    play: function () {
      var that = this
      if (!this.playStatus) {
        this.emit("play");
        this.playStatus = 1;
      }
      if (this.ready) {
        if (
          !this.hasPlayed &&
          (this.clickToPlay ||
            (window.navigator &&
              /iP(hone|od|ad)/.test(window.navigator.platform)))
        ) {
          // Manually trigger the playing callback if clickToPlay
          // is enabled and to workaround a limitation in iOS,
          // which requires synchronous user interaction to start
          // the video playback:
          this.onPlaying();
        } else {
          this.player.playVideo();
        }
      } else {
        this.playOnReady = true;
        if (!(window.YT && YT.Player)) {
          this.loadAPI();
        } else if (!this.player) {
          this.player = new YT.Player(this._elm, {
            videoId: this.videoId,
            playerVars: this.playerVars,
            events: {
              onReady: function () {
                that.onReady()
              },
              onStateChange: function (event) {
                that.onStateChange(event)
              },
              onError: function (event) {
                that.onError(event)
              }
            }
          })
        }
      }
    },

    pause: function () {
      if (this.ready) {
        this.player.pauseVideo()
      } else if (this.playStatus) {
        delete this.playOnReady
        this.emit("pause");
        delete this.playStatus
      }
    }
  });

  return embeds.EmbedYoutube = EmbedYoutube;
});
define('skylark-domx-plugins-embeds/main',[
	"./embeds",
	"./embed-runner",
	"./embed-vimeo",
	"./embed-youtube"
],function(embeds){
	return embeds;
});
define('skylark-domx-plugins-embeds', ['skylark-domx-plugins-embeds/main'], function (main) { return main; });

define('skylark-domx-plugins-sandboxs/sandboxs',[
    "skylark-domx-plugins-base/plugins"
], function(plugins) {
    'use strict';

	return plugins.sandboxs = {};
});


define('skylark-domx-plugins-sandboxs/sandbox',[
    "skylark-langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-eventer",
    "skylark-domx-query",
    "skylark-domx-plugins-base",
    "./sandboxs"
], function(langx, browser, noder,eventer,  $, plugins, sandboxs) {
    'use strict';
  /** ============================================================================
   * Sandbox
   * Handles creating and insertion of dynamic iframes
   * ========================================================================== */


  var getIframeWindow = function (iframeElement) {
      return iframeElement.contentWindow || iframeElement.contentDocument.parentWindow;
  };

  var Sandbox =  plugins.Plugin.inherit({

    klassName: "Sandbox",

    pluginName : "lark.sandboxs.sandbox",

    options : {
      name: "Output",
      allows : 'allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts',
      frameBorder : "0",
      cssTextTagId : 'sandbox-css'
    },

    _construct : function(elm,options) {
      this.overrided(elm,options);

      /**
       * Save the target container element, plus the old and active iframes.
       */
      this.target = elm;
      this.old = null;
      this.active = null;
      this.state = {};
      this.guid = +new Date(); // id used to keep track of which iframe is active

    },

    /**
     * Create a new sandboxed iframe.
     */
    create : function () {
      var iframe = document.createElement('iframe');
      // iframe.src = window.location.origin + '/runner-inner';
      iframe.setAttribute('sandbox', this.options.allows);
      iframe.setAttribute('frameBorder', this.options.frameBorder);
      iframe.setAttribute('name', this.options.name);
      iframe.id = this.guid++;
      // this.active = iframe;
      return iframe;
    },

    /**
     * Add a new iframe to the page and wait until it has loaded to call the
     * requester back. Also wait until the new iframe has loaded before removing
     * the old one.
     */
    /**
     * Add a new iframe to the page and wait until it has loaded to call the
     * requester back. Also wait until the new iframe has loaded before removing
     * the old one.
     */
    use : function (iframe, done) {
      if (!this.target) {
        throw new Error('Sandbox has no target element.');

      }
      this.old = this.active;
      this.saveState(this.old);
      this.active = iframe;
      noder.prepend(this.target, iframe);
      // setTimeout allows the iframe to be rendered before other code runs,
      // allowing us access to the calculated properties like innerWidth.
      langx.defer((function () {
        // call the code that renders the iframe source
        if (done) {
          done();
        }

        // remove *all* the iframes, baring the active one
        var iframes = this.target.getElementsByTagName('iframe');
        var length = iframes.length;
        var i = 0;
        var id = this.active.id;
        var iframe;

        for (; iframe = iframes[i], i < length; i++) {
          if (iframe.id !== id) {
            noder.remove(iframe);
            length--;
          }
        }
      }).bind(this));
    },

    /**
     * Restore the state of a prvious iframe, like scroll position.
     */
    restoreState : function (iframe, state) {
      if (!iframe) return {};
      var win = getIframeWindow(iframe);
      if (!win) return {};
      if (state.scroll) {
        win.scrollTo(state.scroll.x, state.scroll.y);
      }
    },

    /**
     * Save the state of an iframe, like scroll position.
     */
    saveState : function (iframe) {
      if (!iframe) return {};
      var win = getIframeWindow(iframe);
      if (!win) return {};
      return {
        scroll: {
          x: win.scrollX,
          y: win.scrollY
        }
      };
    },

    /**
     * Attach event listeners and rpevent some default behaviour on the new
     * window during live rendering.
     */
    wrap : function (childWindow, options) {
      if (!childWindow) return;
      options = options || {};

      // Notify the parent of resize events (and send one straight away)
      ///event.on(childWindow, 'resize', utils.throttle(function () {
      ///  runner.postMessage('resize', this.getSizeProperties(childWindow));
      ///}, 25));
      ///runner.postMessage('resize', this.getSizeProperties(childWindow));

      eventer.on(childWindow, 'resize', function () {
        eventer.resized(this._elm);
      });

      // Notify the parent of a focus
      eventer.on(childWindow, 'focus', () => {
        //runner.postMessage('focus');
        eventer.trigger(this._elm,"focused");
      });
    },

    getSizeProperties : function (childWindow) {
      return {
        width: childWindow.innerWidth || childWindow.document.documentElement.clientWidth,
        height: childWindow.innerHeight || childWindow.document.documentElement.clientHeight,
        offsetWidth: childWindow.document.documentElement.offsetWidth,
        offsetHeight: childWindow.document.documentElement.offsetHeight
      };
    },

    /**
     * Evaluate a command against the active iframe, then use the proxy console
     * to fire information up to the parent
     */
    eval : function (cmd) {
      if (!this.active) throw new Error("sandbox.eval: has no active iframe.");

      var re = /(^.|\b)console\.(\S+)/g;

      if (re.test(cmd)) {
        var replaceWith = 'window.runnerWindow.proxyConsole.';
        cmd = cmd.replace(re, function (all, str, arg) {
          return replaceWith + arg;
        });
      }

      var childWindow = this.active.contentWindow;
      var output = null,
          type = 'log';
      try {
        output = childWindow.eval(cmd);
      } catch (e) {
        output = e.message;
        type = 'error';
      }

      return proxyConsole[type](output);
    },

    /**
     * Inject a script via a URL into the page
     */
    injectScript : function (url, cb) {
      if (!this.active) throw new Error("sandbox.injectScript: has no active iframe.");
      var childWindow = this.active.contentWindow,
          childDocument = childWindow.document;
      var script = childDocument.createElement('script');
      script.src = url;
      script.onload = function () {
        cb();
      };
      script.onerror = function () {
        cb('Failed to load "' + url + '"');
      };
      childDocument.body.appendChild(script);
    },

    /**
     * Inject full DOM into the page
     */
    injectDOM : function (html, cb) {
      if (!this.active) throw new Error("sandbox.injectDOM: has no active iframe.");
      var childWindow = this.active.contentWindow,
          childDocument = childWindow.document;
      try {
        childDocument.body.innerHTML = html;
      } catch (e) {
        cb("Failed to load DOM.");
      }
      cb();
    },

    injectCssText : function(cssText) {
      if (this.active) {
        var style = this.active.contentDocument.getElementById(this.options.cssTextTagId);
        if (style) {
          style.innerHTML = cssText;
          return;
        }
      }
    },

    render : function(source,options) {
      var iframe = this.create(options);
      this.use(iframe, () => {
        var childDoc = iframe.contentDocument,
            childWindow = iframe.contentWindow || iframe.contentDocument.parentWindow;
        if (!childDoc) {
          childDoc = childWindow.document;
        }

        // Reset the console to the prototype state
        let proxyConsole = options.proxyConsole,
            loopProtect = options.loopProtect;

        proxyConsole.methods.forEach(function (method) {
          delete proxyConsole[method];
        });          


        // Start writing the page. This will clear any existing document.
        childDoc.open();

        // We need to write a blank line first  Firefox blows away things you add
        // to the child window when you do the fist document.write.
        // Note that each document.write fires a DOMContentLoaded in Firefox.
        // This method exhibits synchronous and asynchronous behaviour, depending
        // on the browser. Urg.
        childDoc.write('');

        // Give the child a reference to things it needs. This has to go here so
        // that the user's code (that runs as a result of the following
        // childDoc.write) can access the objects.
        childWindow.runnerWindow = {
          proxyConsole: proxyConsole,
          protect: loopProtect,
        };

        childWindow.console = proxyConsole;

        // if there's a parse error this will fire
        childWindow.onerror = function (msg, url, line, col, error) {
          // show an error on the jsbin console, but not the browser console
          // (i.e. use _raw), because the browser will throw the native error
          // which (hopefully) includes a link to the JavaScript VM at that time.
          proxyConsole._raw('error', error && error.stack ? error.stack : msg + ' (line ' + line + ')');
        };

        // Write the source out. IE crashes if you have lots of these, so that's
        // why the source is rendered above (processor.render)  it should be one
        // string. IE's a sensitive soul.
        childDoc.write(source);
        // childDoc.documentElement.innerHTML = source;

        // Close the document. This will fire another DOMContentLoaded.
        childDoc.close();

        // Setup the new window
        this.wrap(childWindow, options);
      });      
    }

  });


  plugins.register(Sandbox);


  return sandboxs.Sandbox = Sandbox;

});


define('skylark-domx-plugins-sandboxs/main',[
	"./sandboxs",
	"./sandbox"
],function(sandboxs){
	return sandboxs;
});
define('skylark-domx-plugins-sandboxs', ['skylark-domx-plugins-sandboxs/main'], function (main) { return main; });

define('skylark-domx-plugins-menus/menus',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("domx.plugins.menus");
});
define('skylark-domx-plugins-menus/menu',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
  "./menus"
],function(langx,$,lists,plugins,menus){
  'use strict'


  var Menu = plugins.Plugin.inherit({
    klassName : "Menu",

    pluginName : "lark.menus.menu",

    options : {
      template : "",

      classes : {
        base : "lark-menu"
      },

      selectors : {
        container : null
      },

      item : {
        templates : {
          general : '<li class="menu-item"><a href="#" class="link"><%= title %></a></li>',
          separator : "",
          hasChildren : '<li class="menu-item hasChildren"><a href="#" class="link"><%= title %></a><ul class="submenu"></ul>',
        },

        classes : {
          base : "menu-item",
          active : "active",
          hasChildren : "hasChildren"
        },

        selectors : {
          general : "li",
          hasChildren : ":has(ul)"
        }
      },

      submenu : {
        template : "<ul></ul>",
        classes : {
          base : "submenu"
        },
        selectors : {
          children : "> ul",
          descendant : "ul"
        }
      },

      data : {
        ///items : []
      },

      onAction : null
    },

    _construct : function(elm,options) {
        plugins.Plugin.prototype._construct.call(this,elm,options);

        this._$container = this.$(this.options.selectors.container);

        if (this.options.onAction) {
          this.listenTo(this._$container,"click",`.${this.options.item.classes.base}`,(e)=>{
              var itemData = $(e.currentTarget).data("item");
              this.options.onAction(itemData);

          });
        }

    },

    renderMenuItemHtml : function(itemData) {
      if (!this._renderItemHtml) {
        let itemTpl = this.options.item.template;
        if (langx.isString(itemTpl)) {
          this._renderItemHtml = langx.template(itemTpl);
        } else if (langx.isFunction(itemTpl)) {
          this._renderItemHtml = itemTpl;
        }
      }

      return this._renderItemHtml(itemData);
    },

    renderGeneralMenuItem : function(itemData) {
      if (!this._renderGeneralItemHtml) {
        let itemTpl = this.options.item.templates.general;
        if (langx.isString(itemTpl)) {
          this._renderGeneralItemHtml = langx.template(itemTpl);
        } else if (langx.isFunction(itemTpl)) {
          this._renderGeneralItemHtml = itemTpl;
        }
      }
      return $(this._renderGeneralItemHtml(itemData));
    },

    renderHasChildrenMenuItem : function(itemData) {
      if (!this._renderHasChildrenItemHtml) {
        let itemTpl = this.options.item.templates.hasChildren;
        if (langx.isString(itemTpl)) {
          this._renderHasChildrenItemHtml = langx.template(itemTpl);
        } else if (langx.isFunction(itemTpl)) {
          this._renderHasChildrenItemHtml = itemTpl;
        }
      }

      return $(this._renderHasChildrenItemHtml(itemData));
    }   


  });


  plugins.register(Menu);

  return menus.Menu = Menu; 
});
define('skylark-domx-plugins-menus/accordion-menu',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
  "./menus",
  "./menu"
],function(langx,$,lists,plugins,menus,Menu){
  'use strict'
  
   var AccordionMenu = Menu.inherit({
    klassName : "AccordionMenu",

    pluginName : "lark.menus.accordion",

    _construct : function(elm,options) {
        Menu.prototype._construct.call(this,elm,options);

        lists.multitier(elm, {
          togglable : true,

          classes : {
            active :  this.options.item.classes.active  // active
           /// collapse : "collapse",
           /// in : "in",
          },

          selectors : {
            item : this.options.item.selectors.general,          //li
            sublist : this.options.submenu.selectors.descendant, //"ul",
            hasSublist : this.options.item.selectors.hasChildren//":has(ul)",
            ///handler : " > a"
          },

          multiExpand : false

        });
    }

  });


  plugins.register(AccordionMenu);

  return menus.AccordionMenu = AccordionMenu; 
});
define('skylark-domx-plugins-menus/cascade-menu',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
  "./menus",
  "./menu"
],function(langx,$,lists,plugins,menus,Menu){
  'use strict'

  var CascadeMenu = Menu.inherit({
    klassName : "CascadeMenu",

    pluginName : "lark.menus.cascade",

    _construct : function(elm,options) {
        Menu.prototype._construct.call(this,elm,options);

        lists.multitier(elm, {
          togglable : true,

          classes : {
            active :  this.options.item.classes.active  // active
           /// collapse : "collapse",
           /// in : "in",
          },

          selectors : {
            item : this.options.item.selectors.general,          //li
            sublist : this.options.submenu.selectors.descendant, //"ul",
            hasSublist : this.options.item.selectors.hasChildren//":has(ul)",
            ///handler : " > a"
          },

          multiExpand : false

        });
    }

  });


  plugins.register(CascadeMenu);

  return menus.CascadeMenu = CascadeMenu;	
});
define('skylark-domx-plugins-menus/mega-menu',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
  "./menus",
  "./menu"
],function(langx,$,lists,plugins,menus,Menu){
  'use strict'

  var MegaMenu = Menu.inherit({
    klassName : "MegaMenu",

    pluginName : "lark.menus.mega",

    options : {
      menuBehaviour: "click",
      stickyHeader: true,
      //selector: $(this),
      caret:false,
      caretArrows: [{
        up: "caret-up",
        down: "caret-down",
        upUrl:"",
        downUrl:"",
      }],
      highlighter: true,
      followingHighlighter: false,
      highlightColor:"",
      textHighlighter: false,
      textHighlighterColor: "",
      animation:false,
      animationClass: "",

    },

    _construct : function(elm,options) {
        Menu.prototype._construct.call(this,elm,options);

        let settings = this.options;
        
        var element = settings.selector;
        var mainLinks = $(".main-links ul li a");
        var subMenu = $(".menu-dropdown .menu-item-wrapper");
        var mainLinksDataAttribute = [];
        var iDofSubMenus = [];
        var selectElementwithId = $("#"+subMenu.attr("id"));

        var caretUp = this.options.caretArrows[0].up;
        var caretDown = this.options.caretArrows[0].down;

        // Sticky Heder

        if (settings.stickyHeader === false) {
          $(".mega-menu").removeClass("sticky-header");
        }
        else {
          $(".mega-menu").addClass("sticky-header");
        }

        // If caret: custom then it will exclude default settings mentioned above
        if (settings.caret === true) {
          var caretUp = settings.caretArrows[0].up;
          var caretDown = settings.caretArrows[0].down;
        }

        // If icon caret (up or down) is not empty image caret should be hidden
        if (settings.caretArrows[0].up || settings.caretArrows[0].down ) {
          settings.caretArrows[0].upUrl = null;
          settings.caretArrows[0].downUrl = null;
        }

        // Creating Caret icon for every link which have data-submenu attribute
        $("a[data-submenu]").append('<span class="caret ' + caretDown + '"></span>');

        // Set Initial Image path for carret (Default is down)
        if (settings.caret === true && settings.caretArrows[0].downUrl !== "") {
          $(".mega-menu span.caret").removeClass("undefined");
          $(".mega-menu span.caret").addClass("caret-img down");
          $(".mega-menu span.caret.caret-img.down").css({"background-image" : "url(" +settings.caretArrows[0].downUrl+ ")"});
        }

        // Append Style on DOM
        $(`<style>
            .mega-menu .main-links ul li a:hover{
              border-color:` +settings.highlightColor+
            `}
          </style>`).appendTo("head");

        // Remove Active link Highlight
        mainLinks.on(settings.menuBehaviour, function(){
          mainLinks.removeClass("highlight");
          mainLinks.css({"border-color":""});
        });

        // If a user didn't defined menu behaviour
        if (settings.menuBehaviour === "") {
          settings.menuBehaviour = "click";
        }

        // Menu Toggle Works
        mainLinks.each(function(i){

          var linkID = $(this).attr("data-submenu");

          mainLinksDataAttribute.push($(this).attr("data-submenu"));

          $(this).on(settings.menuBehaviour,function(){
            // Find Position of Menu ULs to help pass index for perticular ID on each menu links
            var findPositionOfSubmenus = langx.inArray( linkID, iDofSubMenus );

            var imageCaret = $(this).find(".caret.caret-img");

            // Sets every links default behavour for caret except currently clicked
            mainLinks.find("span").removeClass(caretUp);
            mainLinks.find("span").addClass(caretDown);

            // $(".caret.caret-img").css("background-image").replace(/\"/g, "") == "url(" +settings.caretArrows[0].downUrl+ ")"

            // Icon Caret toggling
            if (mainLinksDataAttribute[i] == iDofSubMenus[findPositionOfSubmenus] && !$(subMenu[findPositionOfSubmenus]).hasClass("active")) {

              subMenu.removeClass("active");
              $(subMenu[findPositionOfSubmenus]).addClass("active");

              $(this).find("span").removeClass(caretDown);
              $(this).find("span").addClass(caretUp);
            }
            else {
                $(subMenu[findPositionOfSubmenus]).removeClass("active");

                $(this).find("span").removeClass(caretUp);
                $(this).find("span").addClass(caretDown);
            }

            // Sets every links default behavour for image caret except currently clicked
            if ($(".menu-dropdown").find(".menu-item-wrapper").hasClass("active")) {
              $(".mega-menu span.caret").addClass("down");
              $(".mega-menu span.caret").css({"background-image" : "url(" +settings.caretArrows[0].downUrl+ ")"});
            }

            // Image caret toggling
            if (imageCaret.hasClass("down")) {
              imageCaret.removeClass("down");
              imageCaret.addClass("up");
              imageCaret.css({"background-image" : "url(" +settings.caretArrows[0].upUrl+ ")"});
              // console.log(imageCaret[0].className);
            }
            else {
              imageCaret.removeClass("up");
              imageCaret.addClass("down");
              imageCaret.css({"background-image" : "url(" +settings.caretArrows[0].downUrl+ ")"});
              // console.log(imageCaret[0].className);
            }

            // Active link Highlight
            if (mainLinks.find("span").hasClass("caret-up") || $(this).find("span").hasClass("up") && !$(this).hasClass("highlight") ) {
              $(this).addClass("highlight");

              // Changing Highlight Color
              $(this).css({"border-color": settings.highlightColor});
            }

            // Normal Dropdown Positioning
            if (subMenu.hasClass("dropdown") ) {
              var dropDownforClickedLink = $("#"+iDofSubMenus[findPositionOfSubmenus]+".dropdown");
              dropDownforClickedLink.css({"left": $(this).offset().left })
            }

          });

        });


        // If Follow highlighter set true
        if (settings.followingHighlighter === true) {

          // Add a element with class first
          $(".main-links ul").append('<div class="follow-highlighter"></div>');

          // While Mouser Hover
          mainLinks.mouseover(function(e,i){

            var getCurrentElementMousePos = e.pageX - $(this).offset().left;
            var currentElementHalfWidth = $(this).innerWidth() / 2;

            $(".follow-highlighter").css({"display": "block"});
            $(".main-links ul").addClass("follow-highlighter-enabled")
            $(".follow-highlighter").css({"width" : $(this).innerWidth() , "left" : $(this).offset().left , "background-color": settings.highlightColor});

          });
        }

        // While Mouse Unhover
        $(".main-links ul").each(function(){
          $(this).mouseleave(function(){
            $(".main-links ul").removeClass("follow-highlighter-enabled");
            $(".follow-highlighter").css({"display": "none", "left" : $(mainLinks[0]).offset().left});
          })
        })

        // If no need of highighter
        if (settings.highlighter === false) {
          $(".main-links").addClass("disable-highlighter");
          $(".follow-highlighter").remove();
        }

        // If Text Highlighter Set to true
        if (settings.textHighlighter === true) {
          $(".main-links").addClass("text-highlighter");
        }
        // Text Highlighter Color
        if (settings.textHighlighterColor) {
          $("style").append(`.mega-menu .text-highlighter.main-links ul li a:hover{
            color:` + settings.textHighlighterColor +
          `}`);
        }

          // Get menus IDs
          subMenu.each(function(i){
            iDofSubMenus.push($(subMenu[i]).attr("id"));
          });

          // Add Animations
          if (settings.animation === true) {
            subMenu.addClass(settings.animationClass);
          }

          // Mobile Nav icon
          $(".mobile-nav-icon a").click(function(){
            $(".follow-highlighter").remove();
            if ($(".main-links").hasClass("active")) {
              $(".main-links").removeClass("active");
              $(".menu-dropdown").hide();
            }
            else {
              $(".main-links").addClass("active");
              $(".menu-dropdown").show();
            }
          });


          // Responsive options

          $(".menu-item-wrapper").prepend('<a href="#" class="back-link">Back</a>');

          $(window).resize(function() {
           if ($(window).width() < 768) {

             // Get main-links marging top as height of mobile-nav-icon
             if ($(".mega-menu").hasClass("sticky-header")) {
               $(".mega-menu").addClass("responsive-menu");
               $(".main-links").css({"margin-top": $(".mobile-nav-icon").outerHeight()+"px"});

               // $(".menu-item-wrapper").prepend('<a href="#" class="back-link">Back</a>');

             }

           } else {
             $(".main-links").css({"margin-top": "0px"});
             // $(".back-link").remove();
            // $(".mega-menu").removeClass("responsive-menu");
           }
          });

          ///$(document).ready(
          ///  function(){
          ///    $(".back-link").on('click', function(){
          ///      mainLinks.trigger('click');
         ///       $(mainLinks[mainLinks.length - 1]).trigger('click');
          ///    });
          ///  }
          ///)
    }

  });


  plugins.register(MegaMenu);

  return menus.MegaMenu = MegaMenu;	
});
define('skylark-domx-plugins-menus/nav-menu',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
  "./menus",
  "./menu"
],function(langx,$,lists,plugins,menus,Menu){
  'use strict'

  var NavMenu = Menu.inherit({
    klassName : "NavMenu",

    pluginName : "lark.menus.nav",

    options : {
      item : {
        templates : {
        } 
      }
    },

    _construct : function(elm,options) {
        Menu.prototype._construct.call(this,elm,options);

        if (this.options.data.items) {
          this.resetItems(this.options.data.items);
        }

        lists.multitier(elm, {
          togglable : false,

          classes : {
            active :  this.options.item.classes.active  // active
           /// collapse : "collapse",
           /// in : "in",
          },

          selectors : {
            item : this.options.item.selectors.general,          //li
            sublist : this.options.submenu.selectors.descendant, //"ul",
            hasSublist : this.options.item.selectors.hasChildren//":has(ul)",
            ///handler : " > a"
          },

          multiExpand : false

        });
    },

    resetItems : function(itemsData) {
      let self = this;

      function renderItem(itemData,$container) {
        let $item;
        if (itemData.children) {
          $item = self.renderHasChildrenMenuItem(itemData);
        } else {
          $item = self.renderGeneralMenuItem(itemData);
        }

        $item.data("item",itemData);
        $container.append($item)

        if (itemData.children) {
          let $childrenContainer = $item.find(self.options.submenu.selectors.children);
          itemData.children.forEach((childItemData) => {
            renderItem(childItemData,$childrenContainer);            
          });
        }
      }
        
      let $itemsContainer = this.$(this.options.selectors.container)

      itemsData.forEach((itemData)=>{
        renderItem(itemData,$itemsContainer);
      });
    }

  });


  plugins.register(NavMenu);

  return menus.NavMenu = NavMenu;	
});
define('skylark-domx-plugins-toggles/checkbox',[
  "skylark-langx/langx",
  "skylark-domx/browser",
  "skylark-domx/eventer",
  "skylark-domx/noder",
  "skylark-domx/geom",
  "skylark-domx/query",
  "skylark-domx-plugins-base",
  "./toggles"
],function(langx,browser,eventer,noder,geom,$,plugins,toggles){

  var Checkbox = plugins.Plugin.inherit({
    klassName: "Checkbox",

    pluginName : "lark.toggles.checkbox",

    options : {
      ignoreVisibilityCheck: false
    },

    _construct : function(elm,options) {
      this.overrided(elm,options);
      var $element = this.$();

      if (elm.tagName.toLowerCase() !== 'label') {
        throw new Error('Checkbox must be initialized on the `label` that wraps the `input` element. See https://github.com/ExactTarget/fuelux/blob/master/reference/markup/checkbox.html for example of proper markup. Call `.checkbox()` on the `<label>` not the `<input>`');
        return;
      }

      // cache elements
      this.$label = $element;
      this.$chk = this.$label.find('input[type="checkbox"]');
      this.$container = $element.parent('.checkbox'); // the container div

      if (!this.options.ignoreVisibilityCheck && this.$chk.css('visibility').match(/hidden|collapse/)) {
        throw new Error('For accessibility reasons, in order for tab and space to function on checkbox, checkbox `<input />`\'s `visibility` must not be set to `hidden` or `collapse`. See https://github.com/ExactTarget/fuelux/pull/1996 for more details.');
      }

      // determine if a toggle container is specified
      var containerSelector = this.$chk.attr('data-toggle');
      this.$toggleContainer = $(containerSelector);

      // handle internal events
      this.$chk.on('change', langx.proxy(this.itemchecked, this));

      // set default state
      this.setInitialState();
    },

    setInitialState: function setInitialState () {
      var $chk = this.$chk;

      // get current state of input
      var checked = $chk.prop('checked');
      var disabled = $chk.prop('disabled');

      // sync label class with input state
      this.setCheckedState($chk, checked);
      this.setDisabledState($chk, disabled);
    },

    setCheckedState: function setCheckedState (element, checked) {
      var $chk = element;
      var $lbl = this.$label;
      var $containerToggle = this.$toggleContainer;

      if (checked) {
        $chk.prop('checked', true);
        $lbl.addClass('checked');
        $containerToggle.removeClass('hide hidden');
        $lbl.trigger('checked.lark.toggles.checkbox');
      } else {
        $chk.prop('checked', false);
        $lbl.removeClass('checked');
        $containerToggle.addClass('hidden');
        $lbl.trigger('unchecked.lark.toggles.checkbox');
      }

      $lbl.trigger('changed.lark.toggles.checkbox', checked);
    },

    setDisabledState: function (element, disabled) {
      var $chk = $(element);
      var $lbl = this.$label;

      if (disabled) {
        $chk.prop('disabled', true);
        $lbl.addClass('disabled');
        $lbl.trigger('disabled.lark.toggles.checkbox');
      } else {
        $chk.prop('disabled', false);
        $lbl.removeClass('disabled');
        $lbl.trigger('enabled.lark.toggles.checkbox');
      }

      return $chk;
    },

    itemchecked: function (evt) {
      var $chk = $(evt.target);
      var checked = $chk.prop('checked');

      this.setCheckedState($chk, checked);
    },

    toggle: function () {
      var checked = this.isChecked();

      if (checked) {
        this.uncheck();
      } else {
        this.check();
      }
    },

    check: function () {
      this.setCheckedState(this.$chk, true);
    },

    uncheck: function () {
      this.setCheckedState(this.$chk, false);
    },

    isChecked: function () {
      var checked = this.$chk.prop('checked');
      return checked;
    },

    enable: function () {
      this.setDisabledState(this.$chk, false);
    },

    disable: function () {
      this.setDisabledState(this.$chk, true);
    },

    destroy: function () {
      this.$label.remove();
      return this.$label[0].outerHTML;
    }
  });


  Checkbox.prototype.getValue = Checkbox.prototype.isChecked;

  plugins.register(Checkbox);

  return toggles.Checkbox = Checkbox;
});

define('skylark-domx-plugins-toggles/radio',[
  "skylark-langx/langx",
  "skylark-domx/browser",
  "skylark-domx/eventer",
  "skylark-domx/noder",
  "skylark-domx/geom",
  "skylark-domx/query",
  "skylark-domx-plugins-base",
  "./toggles"
],function(langx,browser,eventer,noder,geom,$,plugins,toggles){


  var Radio = plugins.Plugin.inherit({
    klassName: "Radio",

    pluginName : "lark.toggles.radio",

    options : {
      ignoreVisibilityCheck: false
    },

    _construct : function(elm,options) {
      this.overrided(elm,options);
      if (elm.tagName.toLowerCase() !== 'label') {
        throw new Error('Radio must be initialized on the `label` that wraps the `input` element. See https://github.com/ExactTarget/fuelux/blob/master/reference/markup/radio.html for example of proper markup. Call `.radio()` on the `<label>` not the `<input>`');
      }

      // cache elements
      this.$label = this.$();
      this.$radio = this.$label.find('input[type="radio"]');
      this.groupName = this.$radio.attr('name'); // don't cache group itself since items can be added programmatically

      if (!this.options.ignoreVisibilityCheck && this.$radio.css('visibility').match(/hidden|collapse/)) {
        throw new Error('For accessibility reasons, in order for tab and space to function on radio, `visibility` must not be set to `hidden` or `collapse`. See https://github.com/ExactTarget/fuelux/pull/1996 for more details.');
      }

      // determine if a toggle container is specified
      var containerSelector = this.$radio.attr('data-toggle');
      this.$toggleContainer = $(containerSelector);

      // handle internal events
      this.$radio.on('change', langx.proxy(this.itemchecked, this));

      // set default state
      this.setInitialState();
    },

    setInitialState: function () {
      var $radio = this.$radio;

      // get current state of input
      var checked = $radio.prop('checked');
      var disabled = $radio.prop('disabled');

      // sync label class with input state
      this.setCheckedState($radio, checked);
      this.setDisabledState($radio, disabled);
    },

    resetGroup: function () {
      var $radios = $('input[name="' + this.groupName + '"]');
      $radios.each(function resetRadio (index, item) {
        var $radio = $(item);
        var $lbl = $radio.parent();
        var containerSelector = $radio.attr('data-toggle');
        var $containerToggle = $(containerSelector);


        $lbl.removeClass('checked');
        $containerToggle.addClass('hidden');
      });
    },

    setCheckedState: function (element, checked) {
      var $radio = element;
      var $lbl = $radio.parent();
      var containerSelector = $radio.attr('data-toggle');
      var $containerToggle = $(containerSelector);

      if (checked) {
        // reset all items in group
        this.resetGroup();

        $radio.prop('checked', true);
        $lbl.addClass('checked');
        $containerToggle.removeClass('hide hidden');
        $lbl.trigger('checked.lark.toggles.radio');
      } else {
        $radio.prop('checked', false);
        $lbl.removeClass('checked');
        $containerToggle.addClass('hidden');
        $lbl.trigger('unchecked.lark.toggles.radio');
      }

      $lbl.trigger('changed.lark.toggles.radio', checked);
    },

    setDisabledState: function (element, disabled) {
      var $radio = $(element);
      var $lbl = this.$label;

      if (disabled) {
        $radio.prop('disabled', true);
        $lbl.addClass('disabled');
        $lbl.trigger('disabled.lark.toggles.radio');
      } else {
        $radio.prop('disabled', false);
        $lbl.removeClass('disabled');
        $lbl.trigger('enabled.lark.toggles.radio');
      }

      return $radio;
    },

    itemchecked: function (evt) {
      var $radio = $(evt.target);
      this.setCheckedState($radio, true);
    },

    check: function () {
      this.setCheckedState(this.$radio, true);
    },

    uncheck: function () {
      this.setCheckedState(this.$radio, false);
    },

    isChecked: function () {
      var checked = this.$radio.prop('checked');
      return checked;
    },

    enable: function () {
      this.setDisabledState(this.$radio, false);
    },

    disable: function () {
      this.setDisabledState(this.$radio, true);
    },

    destroy: function () {
      this.$label.remove();
      return this.$label[0].outerHTML;
    }

  });


  Radio.prototype.getValue = Radio.prototype.isChecked;

  plugins.register(Radio);

  return toggles.Radio = Radio;
});

define('skylark-domx-plugins-toggles/main',[
	"./toggles",
	"./checkbox",
	"./collapse",
	"./radio",
	"./tab"
],function(toggles){
	return toggles;
});
define('skylark-domx-plugins-toggles', ['skylark-domx-plugins-toggles/main'], function (main) { return main; });

 define('skylark-domx-plugins-menus/tree-menu',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
  "./menus",
  "./menu",
  "skylark-domx-plugins-toggles"
],function(langx,$,lists,plugins,menus,Menu){
  'use strict'

  var TreeMenu = Menu.inherit({
    klassName : "Tree",

    pluginName : "lark.menus.tree",

    _construct : function(elm,options) {
        Menu.prototype._construct.call(this,elm,options);

        lists.multitier(elm,langx.mixin({
          hide : function($el) {
            $el.plugin("lark.toggles.collapse").hide();
          },
          toggle : function($el) {
            $el.plugin("lark.toggles.collapse").toggle();
          }
        },this.options));
    }

  });


  plugins.register(TreeMenu);

  return menus.TreeMenu = TreeMenu;	
});
define('skylark-devices-keyboard/keyboard',[
	"skylark-langx-ns"
],function(skylark){
	var keyboard = {};
	/**
	 * Function: isShiftDown
	 * 
	 * Returns true if the shift key is pressed for the given event.
	 */
	keyboard.isShiftDown = function (evt) {
		return (evt != null) ? evt.shiftKey : false;
	};

	/**
	 * Function: isAltDown
	 * 
	 * Returns true if the alt key is pressed for the given event.
	 */
	keyboard.isAltDown = function (evt) {
		return (evt != null) ? evt.altKey : false;
	};

	/**
	 * Function: isControlDown
	 * 
	 * Returns true if the control key is pressed for the given event.
	 */
	keyboard.isControlDown = function (evt) {
		return (evt != null) ? evt.ctrlKey : false;
	};

	/**
	 * Function: isMetaDown
	 * 
	 * Returns true if the meta key is pressed for the given event.
	 */
	keyboard.isMetaDown = function (evt){
		return (evt != null) ? evt.metaKey : false;
	};


	return skylark.attach("devices.keyboard",keyboard);	
});
define('skylark-devices-keyboard/keys',[
	"./keyboard"
],function(keyboard){
	var keys = {};
	/**
	 * TAB key
	 * @attribute TAB
	 * @type {Number}
	 */
	keys.TAB = 9;

	/**
	 * ENTER key
	 * @attribute ENTER
	 * @type {Number}
	 */
	keys.ENTER = 13;

	/**
	 * SHIFT key
	 * @attribute SHIFT
	 * @type {Number}
	 */
	keys.SHIFT = 16;

	/**
	 * CTRL key
	 * @attribute CTRL
	 * @type {Number}
	 */
	keys.CTRL = 17;

	/**
	 * ALT key
	 * @attribute ALT
	 * @type {Number}
	 */
	keys.ALT = 18;

	/**
	 * CAPS_LOCK key
	 * @attribute CAPS_LOCK
	 * @type {Number}
	 */
	keys.CAPS_LOCK = 20;

	/**
	 * ESC key
	 * @attribute ESC
	 * @type {Number}
	 */
	keys.ESC = 27;

	/**
	 * SPACEBAR key
	 * @attribute SPACEBAR
	 * @type {Number}
	 */
	keys.SPACEBAR = 32;

	/**
	 * PAGE_UP key
	 * @attribute PAGE_UP
	 * @type {Number}
	 */
	keys.PAGE_UP = 33;

	/**
	 * PAGE_DOWN key
	 * @attribute PAGE_DOWN
	 * @type {Number}
	 */
	keys.PAGE_DOWN = 34;

	/**
	 * END key
	 * @attribute END
	 * @type {Number}
	 */
	keys.END = 35;

	/**
	 * HOME key
	 * @attribute HOME
	 * @type {Number}
	 */
	keys.HOME = 36;

	/**
	 * INSERT key
	 * @attribute INSERT
	 * @type {Number}
	 */
	keys.INSERT = 45;

	/**
	 * DEL key
	 * @attribute DEL
	 * @type {Number}
	 */
	keys.DEL = 46;

	/**
	 * LEFT key
	 * @attribute LEFT
	 * @type {Number}
	 */
	keys.LEFT = 37;

	/**
	 * RIGHT key
	 * @attribute RIGHT
	 * @type {Number}
	 */
	keys.RIGHT = 39;

	/**
	 * UP key
	 * @attribute UP
	 * @type {Number}
	 */
	keys.UP = 38;

	/**
	 * DOWN key
	 * @attribute DOWN
	 * @type {Number}
	 */
	keys.DOWN = 40;

	/**
	 * NUM0 key
	 * @attribute NUM0
	 * @type {Number}
	 */
	keys.NUM0 = 48;

	/**
	 * NUM1 key
	 * @attribute NUM1
	 * @type {Number}
	 */
	keys.NUM1 = 49;

	/**
	 * NUM2 key
	 * @attribute NUM2
	 * @type {Number}
	 */
	keys.NUM2 = 50;

	/**
	 * NUM3 key
	 * @attribute NUM3
	 * @type {Number}
	 */
	keys.NUM3 = 51;

	/**
	 * NUM4 key
	 * @attribute NUM4
	 * @type {Number}
	 */
	keys.NUM4 = 52;

	/**
	 * NUM5 key
	 * @attribute NUM5
	 * @type {Number}
	 */
	keys.NUM5 = 53;

	/**
	 * NUM6 key
	 * @attribute NUM6
	 * @type {Number}
	 */
	keys.NUM6 = 54;

	/**
	 * NUM7 key
	 * @attribute NUM7
	 * @type {Number}
	 */
	keys.NUM7 = 55;

	/**
	 * NUM8 key
	 * @attribute NUM8
	 * @type {Number}
	 */
	keys.NUM8 = 56;

	/**
	 * NUM9 key
	 * @attribute NUM9
	 * @type {Number}
	 */
	keys.NUM9 = 57;

	/**
	 * A key
	 * @attribute A
	 * @type {Number}
	 */
	keys.A = 65;

	/**
	 * B key
	 * @attribute B
	 * @type {Number}
	 */
	keys.B = 66;

	/**
	 * C key
	 * @attribute C
	 * @type {Number}
	 */
	keys.C = 67;

	/**
	 * D key
	 * @attribute D
	 * @type {Number}
	 */
	keys.D = 68;

	/**
	 * E key
	 * @attribute E
	 * @type {Number}
	 */
	keys.E = 69;

	/**
	 * F key
	 * @attribute F
	 * @type {Number}
	 */
	keys.F = 70;

	/**
	 * G key
	 * @attribute G
	 * @type {Number}
	 */
	keys.G = 71;

	/**
	 * H key
	 * @attribute H
	 * @type {Number}
	 */
	keys.H = 72;

	/**
	 * I key
	 * @attribute I
	 * @type {Number}
	 */
	keys.I = 73;

	/**
	 * J key
	 * @attribute J
	 * @type {Number}
	 */
	keys.J = 74;

	/**
	 * K key
	 * @attribute K
	 * @type {Number}
	 */
	keys.K = 75;

	/**
	 * L key
	 * @attribute L
	 * @type {Number}
	 */
	keys.L = 76;

	/**
	 * M key
	 * @attribute M
	 * @type {Number}
	 */
	keys.M = 77;

	/**
	 * N key
	 * @attribute N
	 * @type {Number}
	 */
	keys.N = 78;

	/**
	 * O key
	 * @attribute O
	 * @type {Number}
	 */
	keys.O = 79;

	/**
	 * P key
	 * @attribute P
	 * @type {Number}
	 */
	keys.P = 80;

	/**
	 * Q key
	 * @attribute Q
	 * @type {Number}
	 */
	keys.Q = 81;

	/**
	 * R key
	 * @attribute R
	 * @type {Number}
	 */
	keys.R = 82;

	/**
	 * S key
	 * @attribute S
	 * @type {Number}
	 */
	keys.S = 83;

	/**
	 * T key
	 * @attribute T
	 * @type {Number}
	 */
	keys.T = 84;

	/**
	 * U key
	 * @attribute U
	 * @type {Number}
	 */
	keys.U = 85;

	/**
	 * V key
	 * @attribute V
	 * @type {Number}
	 */
	keys.V = 86;

	/**
	 * W key
	 * @attribute W
	 * @type {Number}
	 */
	keys.W = 87;

	/**
	 * X key
	 * @attribute X
	 * @type {Number}
	 */
	keys.X = 88;

	/**
	 * Y key
	 * @attribute Y
	 * @type {Number}
	 */
	keys.Y = 89;

	/**
	 * Z key
	 * @attribute Z
	 * @type {Number}
	 */
	keys.Z = 90;

	/**
	 * F1 key
	 * @attribute F1
	 * @type {Number}
	 */
	keys.F1 = 112;

	/**
	 * F2 key
	 * @attribute F2
	 * @type {Number}
	 */
	keys.F2 = 113;

	/**
	 * F3 key
	 * @attribute F3
	 * @type {Number}
	 */
	keys.F3 = 114;

	/**
	 * F4 key
	 * @attribute F4
	 * @type {Number}
	 */
	keys.F4 = 115;

	/**
	 * F5 key
	 * @attribute F5
	 * @type {Number}
	 */
	keys.F5 = 116;

	/**
	 * F6 key
	 * @attribute F6
	 * @type {Number}
	 */
	keys.F6 = 117;

	/**
	 * F7 key
	 * @attribute F7
	 * @type {Number}
	 */
	keys.F7 = 118;

	/**
	 * F8 key
	 * @attribute F8
	 * @type {Number}
	 */
	keys.F8 = 119;

	/**
	 * F9 key
	 * @attribute F9
	 * @type {Number}
	 */
	keys.F9 = 120;

	/**
	 * F10 key
	 * @attribute F10
	 * @type {Number}
	 */
	keys.F10 = 121;

	/**
	 * F11 key
	 * @attribute F11
	 * @type {Number}
	 */
	keys.F11 = 122;

	/**
	 * F12 key
	 * @attribute F12
	 * @type {Number}
	 */
	keys.F12 = 123;

	return keyboard.keys = keys;
	
});
define('skylark-domx-plugins-menus/popup-menu',[
  "skylark-langx/langx",
  "skylark-devices-keyboard/keys",
  "skylark-domx-noder",
  "skylark-domx-styler",
  "skylark-domx-query",
  "skylark-domx-lists",
  "skylark-domx-plugins-base",
 	"skylark-domx-plugins-popups/popups",
  "./menus",
  "./menu"
],function(langx,keys,noder,styler, $,lists,plugins,popups,menus,Menu){
  'use strict'

  	var PopupMenu = Menu.inherit({

    	klassName : "PopupMenu",

    	pluginName : "lark.menus.popup",

		delay: 300,
		options: {
			icons: {
				submenu: "ui-icon-caret-1-e"
			},
			///items: "> *",
			///menus: "ul",
			position: {
				my: "left top",
				at: "right top"
			},

			role: "menu",


			item : {
				classes : {
					base : "menu-item",
          			active : "active",
          			disabled : "disabled",
          			wrapper : "menu-item-wrapper"
				},
				selector : "> *"
			},

			// Callbacks
			blur: null,
			focus: null,
			select: null
		},

    	_construct : function(elm,options) {
        	Menu.prototype._construct.call(this,elm,options);
			this.element = this.$();

			this.activeMenu = this.element;

			// Flag used to prevent firing of the click handler
			// as the event bubbles up through nested menus
			this.mouseHandled = false;
			this.lastMousePosition = { x: null, y: null };
			this.element
				.attr( {
					role: this.options.role,
					tabIndex: 0
				} );

			this.listenTo(this.element, {

				// Prevent focus from sticking to links inside menu after clicking
				// them (focus should always stay on UL during navigation).
				'mousedown': function( event ) {
					event.preventDefault();

					this._activateItem( event );
				},
				"click": function( event ) {
					var target = $( event.target );
					//var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
					var active = $(noder.active());
					if ( !this.mouseHandled && target.not(`.${this.options.item.classes.disable}`).length ) {
						this.select( event );

						// Only set the mouseHandled flag if the event will bubble, see #9469.
						if ( !event.isPropagationStopped() ) {
							this.mouseHandled = true;
						}

						// Open submenu on click
						if ( target.has(`.${this.options.submenu.classes.base}`).length ) {
							this.expand( event );
						} else if ( !this.element.is( ":focus" ) &&
								active.closest( `.${this.options.submenu.classes.base}` ).length ) {

							// Redirect focus to the menu
							this.element.trigger( "focus", [ true ] );

							// If the active item is on the top level, let it stay active.
							// Otherwise, blur the active item since it is no longer visible.
							if ( this.active && this.active.parents( `.${this.options.submenu.classes.base}` ).length === 1 ) {
								clearTimeout( this.timer );
							}
						}
					}
				},
				"mouseenter": "_activateItem",
				"mousemove": "_activateItem",
			}, `.${this.options.item.classes.base}`);

			this.listenTo(this.element, {
				"mouseleave": "collapseAll",
				"focus": function( event, keepActiveItem ) {

					// If there's already an active item, keep it active
					// If not, activate the first item
					var item = this.active || this._menuItems().first();

					if ( !keepActiveItem ) {
						this.focus( event, item );
					}
				},
				"blur": function( event ) {
					this._delay( function() {
						var notContained = !noder.contains(
							this.element[ 0 ],
							//$.ui.safeActiveElement( this.document[ 0 ] )
							noder.active()
						);
						if ( notContained ) {
							this.collapseAll( event );
						}
					} );
				},
				"keydown": "_keydown"
			} );

			this.listenTo(this.element, "mouseleave",  `.${this.options.submenu.classes.base}`, "collapseAll");

			///this.refresh();

			// Clicks outside of a menu collapse any open menus
			this.listenTo( $(document), {
				click: function( event ) {
					if ( this._closeOnDocumentClick( event ) ) {
						this.collapseAll( event, true );
					}

					// Reset the mouseHandled flag
					this.mouseHandled = false;
				}
			} );
		},

		_activateItem: function( event ) {

			// Ignore mouse events while typeahead is active, see #10458.
			// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
			// is over an item in the menu
			if ( this.previousFilter ) {
				return;
			}

			// If the mouse didn't actually move, but the page was scrolled, ignore the event (#9356)
			if ( event.clientX === this.lastMousePosition.x &&
					event.clientY === this.lastMousePosition.y ) {
				return;
			}

			this.lastMousePosition = {
				x: event.clientX,
				y: event.clientY
			};

			var actualTarget = $( event.target ).closest( `.${this.options.item.classes.base}` ),
				target = $( event.currentTarget );

			// Ignore bubbled events on parent items, see #11641
			if ( actualTarget[ 0 ] !== target[ 0 ] ) {
				return;
			}

			// If the item is already active, there's nothing to do
			if ( target.is(`.${this.options.item.classes.active}`) ) {
				return;
			}

			// Remove ui-state-active class from siblings of the newly focused menu item
			// to avoid a jump caused by adjacent elements both having a class with a border
			///this._removeClass( target.siblings().children( ".ui-state-active" ),
			///	null, "ui-state-active" );
			target.siblings().children( `.${this.options.item.classes.active}` ).removeClass(this.options.item.classes.active);
			this.focus( event, target );
		},

		_keydown: function( event ) {
			var match, prev, character, skip,
				preventDefault = true;

			switch ( event.keyCode ) {
			case keys.PAGE_UP:
				this.previousPage( event );
				break;
			case keys.PAGE_DOWN:
				this.nextPage( event );
				break;
			case keys.HOME:
				this._move( "first", "first", event );
				break;
			case keys.END:
				this._move( "last", "last", event );
				break;
			case keys.UP:
				this.previous( event );
				break;
			case keys.DOWN:
				this.next( event );
				break;
			case keys.LEFT:
				this.collapse( event );
				break;
			case keys.RIGHT:
				if ( this.active && !this.active.is( `.${this.options.item.classes.disabled}`) ) {
					this.expand( event );
				}
				break;
			case keys.ENTER:
			case keys.SPACE:
				this._activate( event );
				break;
			case keys.ESC:
				this.collapse( event );
				break;
			default:
				preventDefault = false;
				prev = this.previousFilter || "";
				skip = false;

				// Support number pad values
				character = event.keyCode >= 96 && event.keyCode <= 105 ?
					( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );

				clearTimeout( this.filterTimer );

				if ( character === prev ) {
					skip = true;
				} else {
					character = prev + character;
				}

				match = this._filterMenuItems( character );
				match = skip && match.index( this.active.next() ) !== -1 ?
					this.active.nextAll( `.${this.options.item.classes.base}` ) :
					match;

				// If no matches on the current filter, reset to the last character pressed
				// to move down the menu to the first item that starts with that character
				if ( !match.length ) {
					character = String.fromCharCode( event.keyCode );
					match = this._filterMenuItems( character );
				}

				if ( match.length ) {
					this.focus( event, match );
					this.previousFilter = character;
					this.filterTimer = this._delay( function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		},

		_activate: function( event ) {
			if ( this.active && !this.active.is( `.${this.options.item.classes.disabled}` ) ) {
				if ( this.active.children( "[aria-haspopup='true']" ).length ) {
					this.expand( event );
				} else {
					this.select( event );
				}
			}
		},

		_itemRole: function() {
			return {
				menu: "menuitem",
				listbox: "option"
			}[ this.options.role ];
		},

		focus: function( event, item ) {
			var nested, focused, activeParent;
			this.blur( event, event && event.type === "focus" );

			this._scrollIntoView( item );

			this.active = item.first();

			focused = this.active.children( `.${this.options.item.classes.wrapper}` );
			///this._addClass( focused, null, "ui-state-active" );
			focused.addClass(this.options.item.classes.active);

			// Only update aria-activedescendant if there's a role
			// otherwise we assume focus is managed elsewhere
			if ( this.options.role ) {
				this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
			}

			// Highlight active parent menu item, if any
			activeParent = this.active
				.parent()
					.closest( `.${this.options.item.classes.base}`)
						.children( `.${this.options.item.classes.wrapper}`);
			///this._addClass( activeParent, null, "ui-state-active" );
			activeParent.addClass(this.options.item.classes.active );

			if ( event && event.type === "keydown" ) {
				this._close();
			} else {
				this.timer = this._delay( function() {
					this._close();
				}, this.delay );
			}

			nested = item.children( `.${this.options.submenu.classes.base}` );
			if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
				this._startOpening( nested );
			}
			this.activeMenu = item.parent();

			///this._trigger( "focus", event, { item: item } );
			this.trigger("focus",{item : item})
		},

		_scrollIntoView: function( item ) {
			var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
			if ( this._hasScroll() ) {
				borderTop = parseFloat( styler.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
				paddingTop = parseFloat( styler.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
				offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
				scroll = this.activeMenu.scrollTop();
				elementHeight = this.activeMenu.height();
				itemHeight = item.outerHeight();

				if ( offset < 0 ) {
					this.activeMenu.scrollTop( scroll + offset );
				} else if ( offset + itemHeight > elementHeight ) {
					this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
				}
			}
		},

		blur: function( event, fromFocus ) {
			if ( !fromFocus ) {
				clearTimeout( this.timer );
			}

			if ( !this.active ) {
				return;
			}

			///this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
			///	null, "ui-state-active" );
			this.active.children( `.${this.options.item.classes.wrapper}` ).removeClass(this.options.item.classes.active);

			///this._trigger( "blur", event, { item: this.active } );
			this.trigger( "blur", { item: this.active } );
			this.active = null;
		},

		_startOpening: function( submenu ) {
			clearTimeout( this.timer );

			// Don't open if already open fixes a Firefox bug that caused a .5 pixel
			// shift in the submenu position when mousing over the caret icon
			///if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			///	return;
			///}

			this.timer = this._delay( function() {
				this._close();
				this._open( submenu );
			}, this.delay );
		},

		_open: function( submenu ) {
			var position = langx.extend( {
				of: this.active
			}, this.options.position );

			clearTimeout( this.timer );
			this.element.find( `.${this.options.submenu.classes.base}`).not( submenu.parents( `.${this.options.submenu.classes.base}` ) )
				.hide()
				.attr( "aria-hidden", "true" );

			//submenu
			//	.show()
			//	.removeAttr( "aria-hidden" )
			//	.attr( "aria-expanded", "true" )
			//	.position( position );
			popups.open(submenu.attr( "aria-expanded", "true" ),{
				position
			});
		},

		collapseAll: function( event, all ) {
			clearTimeout( this.timer );
			this.timer = this._delay( function() {

				// If we were passed an event, look for the submenu that contains the event
				var currentMenu = all ? this.element :
					$( event && event.target ).closest( this.element.find( `.${this.options.submenu.classes.base}`) );

				// If we found no valid submenu ancestor, use the main menu to close all
				// sub menus anyway
				if ( !currentMenu.length ) {
					currentMenu = this.element;
				}

				this._close( currentMenu );

				this.blur( event );

				// Work around active item staying active after menu is blurred
				///this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );
				currentMenu.find( `.${this.options.item.classes.active}`).removeClass(this.options.item.classes.active );

				this.activeMenu = currentMenu;
			}, all ? 0 : this.delay );
		},

		// With no arguments, closes the currently active menu - if nothing is active
		// it closes all menus.  If passed an argument, it will search for menus BELOW
		_close: function( startMenu ) {
			if ( !startMenu ) {
				startMenu = this.active ? this.active.parent() : this.element;
			}

			//startMenu.find(`.${this.options.submenu.classes.base}` )
			//	.hide()
			//	.attr( "aria-hidden", "true" )
			//	.attr( "aria-expanded", "false" );
			popups.close(startMenu.find(`.${this.options.submenu.classes.base}` ).attr( "aria-expanded", "false" ));
		},

		_closeOnDocumentClick: function( event ) {
			return !$( event.target ).closest(`.${this.options.submenu.classes.base}` ).length;
		},

		_isDivider: function( item ) {

			// Match hyphen, em dash, en dash
			return !/[^\-\u2014\u2013\s]/.test( item.text() );
		},

		collapse: function( event ) {
			var newItem = this.active &&
				this.active.parent().closest( `.${this.options.item.classes.base}`, this.element );
			if ( newItem && newItem.length ) {
				this._close();
				this.focus( event, newItem );
			}
		},

		expand: function( event ) {
			var newItem = this.active && this._menuItems( this.active.children( `.${this.options.submenu.classes.base}` ) ).first();

			if ( newItem && newItem.length ) {
				this._open( newItem.parent() );

				// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
				this._delay( function() {
					this.focus( event, newItem );
				} );
			}
		},

		next: function( event ) {
			this._move( "next", "first", event );
		},

		previous: function( event ) {
			this._move( "prev", "last", event );
		},

		isFirstItem: function() {
			return this.active && !this.active.prevAll( `.${this.options.item.classes.base}` ).length;
		},

		isLastItem: function() {
			return this.active && !this.active.nextAll( `.${this.options.item.classes.base}` ).length;
		},

		_menuItems: function( menu ) {
			return ( menu || this.element )
				.find( this.options.items )
				.filter( `.${this.options.item.classes.base}` );
		},

		_move: function( direction, filter, event ) {
			var next;
			if ( this.active ) {
				if ( direction === "first" || direction === "last" ) {
					next = this.active
						[ direction === "first" ? "prevAll" : "nextAll" ]( `.${this.options.item.classes.base}` )
						.last();
				} else {
					next = this.active
						[ direction + "All" ]( `.${this.options.item.classes.base}` )
						.first();
				}
			}
			if ( !next || !next.length || !this.active ) {
				next = this._menuItems( this.activeMenu )[ filter ]();
			}

			this.focus( event, next );
		},

		nextPage: function( event ) {
			var item, base, height;

			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isLastItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.nextAll( `.${this.options.item.classes.base}` ).each( function() {
					item = $( this );
					return item.offset().top - base - height < 0;
				} );

				this.focus( event, item );
			} else {
				this.focus( event, this._menuItems( this.activeMenu )
					[ !this.active ? "first" : "last" ]() );
			}
		},

		previousPage: function( event ) {
			var item, base, height;
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isFirstItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.prevAll( `.${this.options.item.classes.base}` ).each( function() {
					item = $( this );
					return item.offset().top - base + height > 0;
				} );

				this.focus( event, item );
			} else {
				this.focus( event, this._menuItems( this.activeMenu ).first() );
			}
		},

		_hasScroll: function() {
			return this.element.outerHeight() < this.element.prop( "scrollHeight" );
		},

		select: function( event ) {

			// TODO: It should never be possible to not have an active item at this
			// point, but the tests don't trigger mouseenter before click.
			this.active = this.active || $( event.target ).closest( `.${this.options.item.classes.base}` );
			var ui = { item: this.active };
			if ( !this.active.has( `.${this.options.submenu.classes.base}` ).length ) {
				this.collapseAll( event, true );
			}
			///this._trigger( "select", event, ui );
			this.trigger( "select", ui );
		},

		_filterMenuItems: function( character ) {
			var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
				regex = new RegExp( "^" + escapedCharacter, "i" );

			return this.activeMenu
				.find( this.options.items )

					// Only match on items, not dividers or other content (#10571)
					.filter( `.${this.options.item.classes.base}` )
						.filter( function() {
							return regex.test(
								langx.trim( $( this ).children( `.${this.options.item.classes.wrapper}`).text() ) );
						} );
		}
	} );

  plugins.register(PopupMenu);

  return menus.PopupMenu = PopupMenu;	

});

define('skylark-domx-plugins-menus/main',[
    "./menus",
    "./accordion-menu",
    "./cascade-menu",
    "./mega-menu",
    "./nav-menu",
    "./tree-menu",
    "./popup-menu"
], function(menus) {
    return menus;
});
define('skylark-domx-plugins-menus', ['skylark-domx-plugins-menus/main'], function (main) { return main; });

define('skylark-domx-plugins-uploads/uploads',[
    "skylark-domx-plugins-base/plugins",
    "skylark-domx-files/dropzone",
    "skylark-domx-files/pastezone",
    "skylark-domx-files/picker"
], function(plugins) {

    var uploads = function() {
        return uploads;
    };

    return plugins.uploads = uploads;
});
define('skylark-langx-emitter/main',[
	"./emitter",
	"./evented"
],function(Emitter){
	return Emitter;
});
define('skylark-langx-emitter', ['skylark-langx-emitter/main'], function (main) { return main; });

define('skylark-domx-plugins-uploads/single-uploader',[
	"skylark-langx-emitter",
	"skylark-langx-async/deferred",
    "skylark-domx-velm",
    "skylark-domx-plugins-base",
	"./uploads",
],function(
	Emitter, 
	Deferred, 
	elmx,
	plugins,
	uploads
) {
	//import ZipLoader from 'zip-loader';

	/**
	 * Watches an element for file drops, parses to create a filemap hierarchy,
	 * and emits the result.
	 */
	class SingleUploader extends plugins.Plugin {
		get klassName() {
	    	return "SingleUploader";
    	} 

    	get pluginName(){
      		return "lark.uploads.single";
    	} 

		get options () {
      		return {
	            selectors : {
	              picker   : ".file-picker",
	              dropzone : ".file-dropzone",
	              pastezone: ".file-pastezone",

	              startUploads: '.start-uploads',
	              cancelUploads: '.cancel-uploads',
	            }
	     	}
		}


	  /**
	   * @param  {Element} elm
	   * @param  [options] 
	   */
	  constructor (elm, options) {
	  	super(elm,options);

        this._velm = elmx(this._elm);

	  	this._initFileHandlers();

	}

    _initFileHandlers () {
        var self = this;

        var selectors = this.options.selectors,
        	dzSelector = selectors.dropzone,
        	pzSelector = selectors.pastezone,
        	pkSelector = selectors.picker;

        if (dzSelector) {
			this._velm.$(dzSelector).dropzone({
                dropped : function (files) {
                    self._addFile(files[0]);
                }
			});
        }


        if (pzSelector) {
            this._velm.$(pzSelector).pastezone({
                pasted : function (files) {
                    self._addFile(files[0]);
                }
            });                
        }

        if (pkSelector) {
            this._velm.$(pkSelector).picker({
                multiple: true,
                picked : function (files) {
                    self._addFile(files[0]);
                }
            });                
        }
    }

     _addFile(file) {
        this.emit('added', file);	  
     }


	  /**
	   * Destroys the instance.
	   */
	  destroy () {
	  }


	}

	return uploads.SingleUploader = SingleUploader;

});

 
define('skylark-net-http/xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/deferred",
  "skylark-langx-emitter/evented",
  "skylark-langx-urls/is-cross-origin",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,isCrossOrigin,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            traditional : false,
            
            xhrFields : {
                ///withCredentials : false
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                if (type(options.data) != "string") {
                    options.data = param(options.data, options.traditional);
                }
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }
        
        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                if (dataType == "blob" || dataType == "arraybuffer") {
                    xhr.responseType = dataType;
                }

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        //result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(xhr.responseText);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(xhr.responseText) ? null : JSON.parse(xhr.responseText);
                            } else if (dataType == "blob") {
                                result = xhr.response; // new Blob([xhr.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.response;
                            } else {
                                //if (dataType == "text" || dataType=="html")
                                result = xhr.responseText;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };
                
                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    if (!isCrossOrigin(url)) {// for s02
                      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); 
                    }
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

    return http.Xhr = Xhr;  
});
define('skylark-net-http/upload',[
    "skylark-langx-types",
    "skylark-langx-objects",
    "skylark-langx-arrays",
    "skylark-langx-async/deferred",
    "skylark-langx-emitter/evented",    
    "./xhr",
    "./http"
],function(types, objects, arrays, Deferred, Evented,Xhr, http){

    var blobSlice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;


    /*
     *Class for uploading files using xhr.
     */
    var Upload = Evented.inherit({
        klassName : "Upload",

        _construct : function(options) {
            this._options = objects.mixin({
                debug: false,
                url: '/upload',
                headers : {

                },
                // maximum number of concurrent uploads
                maxConnections: 999,
                // To upload large files in smaller chunks, set the following option
                // to a preferred maximum chunk size. If set to 0, null or undefined,
                // or the browser does not support the required Blob API, files will
                // be uploaded as a whole.
                maxChunkSize: undefined,

                onProgress: function(id, fileName, loaded, total){
                },
                onComplete: function(id, fileName,result,status,xhr){
                },
                onCancel: function(id, fileName){
                },
                onFailure : function(id,fileName,e) {                    
                }
            },options);

            this._queue = [];
            // params for files in queue
            this._params = [];

            this._files = [];
            this._xhrs = [];

            // current loaded size in bytes for each file
            this._loaded = [];

        },

        /**
         * Adds file to the queue
         * Returns id to use with upload, cancel
         **/
        add: function(file){
            return this._files.push(file) - 1;
        },

        /**
         * Sends the file identified by id and additional query params to the server.
         */
        send: function(id, params){
            if (!this._files[id]) {
                // Already sended or canceled
                return ;
            }
            if (this._queue.indexOf(id)>-1) {
                // Already in the queue
                return;
            }
            var len = this._queue.push(id);

            var copy = objects.clone(params);

            this._params[id] = copy;

            // if too many active uploads, wait...
            if (len <= this._options.maxConnections){
                this._send(id, this._params[id]);
            }     
        },

        /**
         * Sends all files  and additional query params to the server.
         */
        sendAll: function(params){
           for( var id = 0; id <this._files.length; id++) {
                this.send(id,params);
            }
        },

        /**
         * Cancels file upload by id
         */
        cancel: function(id){
            this._cancel(id);
            this._dequeue(id);
        },

        /**
         * Cancells all uploads
         */
        cancelAll: function(){
            for (var i=0; i<this._queue.length; i++){
                this._cancel(this._queue[i]);
            }
            this._queue = [];
        },

        getName: function(id){
            var file = this._files[id];
            return file.fileName != null ? file.fileName : file.name;
        },

        getSize: function(id){
            var file = this._files[id];
            return file.fileSize != null ? file.fileSize : file.size;
        },

        /**
         * Returns uploaded bytes for file identified by id
         */
        getLoaded: function(id){
            return this._loaded[id] || 0;
        },


        /**
         * Sends the file identified by id and additional query params to the server
         * @param {Object} params name-value string pairs
         */
        _send: function(id, params){
            var options = this._options,
                name = this.getName(id),
                size = this.getSize(id),
                chunkSize = options.maxChunkSize || 0,
                curUploadingSize,
                curLoadedSize = 0,
                file = this._files[id],
                args = {
                    headers : objects.clone(options.headers)                    
                };

            this._loaded[id] = this._loaded[id] || 0;

            var xhr = this._xhrs[id] = new Xhr({
                url : options.url
            });

            if (chunkSize)  {

                args.data = blobSlice.call(
                    file,
                    this._loaded[id],
                    this._loaded[id] + chunkSize,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                curUploadingSize = args.data.size;
                // Expose the chunk bytes position range:
                args.headers["content-range"] = 'bytes ' + this._loaded[id] + '-' +
                    (this._loaded[id] + curUploadingSize - 1) + '/' + size;
                args.headers["Content-Type"] = "application/octet-stream";
            }  else {
                curUploadingSize = size;
                var formParamName =  params.formParamName,
                    formData = params.formData;

                if (formParamName) {
                    if (!formData) {
                        formData = new FormData();
                    }
                    formData.append(formParamName,file);
                    args.data = formData;
    
                } else {
                    args.headers["Content-Type"] = file.type || "application/octet-stream";
                    args.data = file;
                }
            }


            var self = this;
            xhr.post(
                args
            ).progress(function(e){
                if (e.lengthComputable){
                    curLoadedSize = curLoadedSize + e.loaded;
                    self._loaded[id] = self._loaded[id] + e.loaded;
                    self._options.onProgress(id, name, self._loaded[id], size);
                }
            }).then(function(result,status,xhr){
                if (!self._files[id]) {
                    // the request was aborted/cancelled
                    return;
                }

                if (curLoadedSize < curUploadingSize) {
                    // Create a progress event if no final progress event
                    // with loaded equaling total has been triggered
                    // for this chunk:
                    self._loaded[id] = self._loaded[id] + curUploadingSize - curLoadedSize;
                    self._options.onProgress(id, name, self._loaded[id], size);                    
                }

                if (self._loaded[id] <size) {
                    // File upload not yet complete,
                    // continue with the next chunk:
                    self._send(id,params);
                } else {
                    self._options.onComplete(id,name,result,status,xhr);

                    self._files[id] = null;
                    self._xhrs[id] = null;
                    self._dequeue(id);
                }


            }).catch(function(e){
                self._options.onFailure(id,name,e);

                self._files[id] = null;
                self._xhrs[id] = null;
                self._dequeue(id);
            });
        },

        _cancel: function(id){
            this._options.onCancel(id, this.getName(id));

            this._files[id] = null;

            if (this._xhrs[id]){
                this._xhrs[id].abort();
                this._xhrs[id] = null;
            }
        },

        /**
         * Returns id of files being uploaded or
         * waiting for their turn
         */
        getQueue: function(){
            return this._queue;
        },


        /**
         * Removes element from queue, starts upload of next
         */
        _dequeue: function(id){
            var i = arrays.inArray(id,this._queue);
            this._queue.splice(i, 1);

            var max = this._options.maxConnections;

            if (this._queue.length >= max && i < max){
                var nextId = this._queue[max-1];
                this._send(nextId, this._params[nextId]);
            }
        }
    });


  Upload.send = function(file, options) {
    var uploader = new Upload(options);
    var id = uploader.add(file);
    return uploader.send(id,options);
  };

  Upload.sendAll = function(files,options) {
      var uploader = new Upload(options);
      for (var i = 0, len = files.length; i < len; i++) {
        this.add(file[i]);
      }
      return uploader.send(options);
  };

    return http.Upload = Upload;    
});
define('skylark-domx-plugins-uploads/multi-uploader',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-net-http/upload",
  "skylark-domx-plugins-base",
  "./uploads"
]  ,function(skylark,langx,$, elmx,FileUpload, plugins,uploads){

    var fileListTemplate = '<div class="lark-multiuploader">' + 
        '    <h3 class="popover-title">Upload files</h3>' + 
        '    <div class="popover-content container-fluid" class="file-list file-dropzone file-pastezone">' + 
        '        <div class="no-data"><em>Add files.</em></div>' + 
        '    </div>' + 
        '    <footer>' + 
        '        <button class="btn btn-warning pull-right btn-sm" id="cancel-uploads-button"><i class="icon-cancel"></i>Cancel uploads</button>' + 
        '        <span class="btn btn-success fileinput-button btn-sm" id="fileinput-button">' + 
        '            <i class="icon-plus"></i>' + 
        '            <span>Add files...</span>' + 
        '            <input id="fileupload" type="file" name="files[]" multiple="multiple">' + 
        '        </span>' + 
        '        <button class="btn btn-primary btn-sm" id="start-uploads-button"><i class="icon-start"></i>Start uploads</button>' + 
        '    </footer>' + 
        '</div>',
        fileItemTemplate = '<div class="file-item row">' +
        '   <div class="col-md-6"><span class="name"></span></div>' + 
        '   <div class="col-md-3">' +
        '    <span class="size"></span>' +
        '    <div class="progress hidden">' +
        '        <div class="progress-label"></div>' +
        '        <div class="bar"></div>' +
        '    </div>' +
        '    <span class="message hidden"></span>' +
        '   </div>' +
        '   <div class="col-md-3">' +
        '    <button class="btn btn-warning btn-xs cancel"><i class="icon-remove"></i>Cancel</button>' +
        '    <button class="btn btn-xs clear hidden">Clear</button>' +
        '   </div>' +
        '</div>';

    var MultiUploader =  plugins.Plugin.inherit({
        klassName : "MultiUploader",
        pluginName : "lark.uploads.multi",

        options: {
            uploadUrl: '/upload',

        	params: {
                formParamName : "file"
            },

    	    maxConnections: 3,
        	// validation
        	allowedExtensions: [],
        	sizeLimit: 0,
        	minSizeLimit: 0,

            autoUpload: false,
            selectors : {
              fileList : ".file-list",
              fileItem : ".file-item",
              nodata : ".file-list .no-data",

              picker   : ".file-picker",
              dropzone : ".file-dropzone",
              pastezone: ".file-pastezone",

              startUploads: '.start-uploads',
              cancelUploads: '.cancel-uploads',
            },

            template : fileListTemplate,

            dataType: 'json',

            fileItem : {
            	selectors : {
                    name : ".name",
                    size : ".size",
                    cancel: ".cancel",
                    clear : ".clear",
                    progress : ".progress",
                    message : ".message"                   
            	},

            	template : fileItemTemplate
            }
        },


        _construct : function(elm,options) {
            var self = this;


            // Render current files
            /*
            this.files.forEach(function (file) {
                self.renderFile(file);
            });
            */

            //this._refresh({files:true});
        

            //this._files.on('all', function(){
            //  self._refresh({files:true});
            //});


           this.overrided(elm,options);


           this._velm = elmx(this._elm);
        


            this._initEventHandler();
            this._initFileHandlers();
            this._initUpoadHandler();
            this._updateFileList();
        },

        _initFileHandlers : function() {
            var self = this;

            var selectors = this.options.selectors,
            	dzSelector = selectors.dropzone,
            	pzSelector = selectors.pastezone,
            	pkSelector = selectors.picker;

            if (dzSelector) {
				this._velm.$(dzSelector).dropzone({
	                dropped : function (files) {
                        self._addFiles(files);
	                }
				});
            }


            if (pzSelector) {
                this._velm.$(pzSelector).pastezone({
                    pasted : function (files) {
                        self._addFiles(files);
                    }
                });                
            }

            if (pkSelector) {
                this._velm.$(pkSelector).picker({
                    multiple: true,
                    picked : function (files) {
                        self._addFiles(files);
                    }
                });                
            }
        },

        _initUpoadHandler: function(){
            var self = this,
                handlerClass;

            this._handler = new FileUpload({
                url: this.options.uploadUrl,
                maxConnections: this.options.maxConnections,
                onProgress: function(id, fileName, loaded, total){
                    self._onProgress(id, fileName, loaded, total);
                },
                onComplete: function(id, fileName, result){
                    self._onComplete(id, fileName, result);
                },
                onCancel: function(id, fileName){
                    self._onCancel(id, fileName);
                },
                onFailure: function(id,fileName,e){
                    self._onFailure(id,fileName,e);
                }
            });
        },
        
         /**
         * delegate click event for cancel link
         **/
        _initEventHandler: function(){
            var self = this,
               selectors = this.options.selectors,
               itemSelectors = this.options.fileItem.selectors, 
               list = this._listElement;

            // Add cancel handler
            this._velm.$(selectors.fileList).on("click",itemSelectors.cancel,function(e){
                var $fileItem = $(this).closest(selectors.fileItem),
                    fileId = $fileItem.data("fileId");
                self._handler.cancel(fileId);
                $fileItem.remove();
                self._updateFileList();
            });

            // Add clear handler
            this._velm.$(selectors.fileList).on("click",itemSelectors.clear,function(e){
                var $fileItem = $(this).closest(selectors.fileItem),
                    fileId = $fileItem.data("fileId");
                $fileItem.remove();
                self._updateFileList();
            });

            // Add cancel all handler
            this._velm.$(selectors.cancelUploads).click(function(){
                var $files = self._velm.$(selectors.fileList).find(selectors.fileItem);           
                $files.forEach(function(fileItem){
                    var $fileItem = $(fileItem),
                        fileId = $fileItem.data("fileId");
                    self._handler.cancel(fileId);
                    $fileItem.remove();
                });
                self._updateFileList();

            });

            // Add start uploads handler
            this._velm.$(selectors.startUploads).click(function(){
                var $files = self._velm.$(selectors.fileList).find(selectors.fileItem);           
                $files.forEach(function(fileItem){
                    var $fileItem = $(fileItem),
                        fileId = $fileItem.data("fileId");
                    if (!$fileItem.data("status")) {
                        // The file has not yet been sent
                        self._handler.send(fileId,self.options.params);
                    }
                });

            });
            

        },       

        _onProgress: function(id, fileName, loaded, total){          
            var $item = this._getItemByFileId(id);

            var percent = parseInt(loaded / total * 100, 10);
            var progressHTML = this._formatSize(loaded)+' of '+ this._formatSize(total);

            $item.data("status","running");
            $item.find('.progress')
                .find('.bar')
                .css('width', percent+'%')
                .parent()
                .find('.progress-label')
                .html(progressHTML);
            this._updateFile($item);

        },

        _onComplete: function(id, fileName, result){
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","done");
            $item.find('.message').html('<i class="icon-success"></i> ' + (this.doneMsg || 'Uploaded'));
            this._updateFile($item);
        },

        _onFailure : function(id,fileName,e) {
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","error");
            $item.find('.message').html('<i class="icon-error"></i> ');;
            this._updateFile($item)

        },

        _onCancel: function(id, fileName){
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","cancel");
            this._updateFile($item)
        },

        _addToList: function(id, fileName){
            var self = this;


            var fileName = this._handler.getName(id),
                fileSize = this._handler.getSize(id);

            var item = $(this.options.fileItem.template);
            item.data("fileId",id);

            item.find(this.options.fileItem.selectors.name).html(this._formatFileName(fileName));
            item.find(this.options.fileItem.selectors.size).html(this._formatSize(fileSize));

            this._velm.$(this.options.selectors.fileList).append(item);

            this._updateFileList();
        },
    
        _updateFileList : function ()  {
            var selectors = this.options.selectors,
                itemSelectors = this.options.fileItem.selectors,
                files = this._velm.$(selectors.fileList).find(selectors.fileItem);

            var with_files_elements = this._velm.$(selectors.cancelUploads + ',' + selectors.startUploads);
            var without_files_elements = this._velm.$(selectors.nodata);
            if (files.length > 0) {
                with_files_elements.removeClass('hidden');
                without_files_elements.addClass('hidden');
            } else {
                with_files_elements.addClass('hidden');
                without_files_elements.removeClass('hidden');
            }
        },
        
        _updateFile: function ($item) {
            var selectors = this.options.fileItem.selectors,
                when_pending = $item.find(selectors.size + "," + selectors.cancel),
                when_running = $item.find(selectors.progress + "," + selectors.cancel),
                when_done = $item.find(selectors.message + "," + selectors.clear);

            var status = $item.data("status");    
            if (status == "pending") {
                when_running.add(when_done).addClass('hidden');
                when_pending.removeClass('hidden');
            } else if (status == "running") {
                when_pending.add(when_done).addClass('hidden');
                when_running.removeClass('hidden');
            } else if (status == "done" || status == "error") {
                when_pending.add(when_running).addClass('hidden');
                when_done.removeClass('hidden');
            }
        },

        _getItemByFileId: function(id){
            var selectors = this.options.selectors,
                files = this._velm.$(selectors.fileList).find(selectors.fileItem),
                item;

            // there can't be txt nodes in dynamically created list
            // and we can  use nextSibling

            for (var i = 0; i<files.length;i++){
                var item2 = files[i];
                if ($(item2).data("fileId") == id) {
                    item = item2;
                    break;
                }
            }
            if (item) {
                return $(item);
            }
        },


            
        _addFiles: function(files){
            for (var i=0; i<files.length; i++){
                if ( !this._validateFile(files[i])){
                    return;
                }
            }

            for (var i=0; i<files.length; i++){
                this._addFile(files[i]);
            }
        },

        _addFile: function(file){
            var id = this._handler.add(file);

            this._filesInProgress++;
            this._addToList(id);

            //this._handler.upload(id, this.options.params);
        },

        _validateFile: function(file){
            var name, size;

            if (file.value){
                // it is a file input
                // get input value and remove path to normalize
                name = file.value.replace(/.*(\/|\\)/, "");
            } else {
                // fix missing properties in Safari
                name = file.fileName != null ? file.fileName : file.name;
                size = file.fileSize != null ? file.fileSize : file.size;
            }

            if (! this._isAllowedExtension(name)){
                this._error('typeError', name);
                return false;

            } else if (size === 0){
                this._error('emptyError', name);
                return false;

            } else if (size && this.options.sizeLimit && size > this.options.sizeLimit){
                this._error('sizeError', name);
                return false;

            } else if (size && size < this.options.minSizeLimit){
                this._error('minSizeError', name);
                return false;
            }

            return true;
        },

        _error: function(code, fileName){
            var message = this.options.messages[code];
            function r(name, replacement){ message = message.replace(name, replacement); }

            r('{file}', this._formatFileName(fileName));
            r('{extensions}', this.options.allowedExtensions.join(', '));
            r('{sizeLimit}', this._formatSize(this.options.sizeLimit));
            r('{minSizeLimit}', this._formatSize(this.options.minSizeLimit));

            this.options.showMessage(message);
        },

        _formatFileName: function(name){
            if (name.length > 33){
                name = name.slice(0, 19) + '...' + name.slice(-13);
            }
            return name;
        },

        _isAllowedExtension: function(fileName){
            var ext = (-1 !== fileName.indexOf('.')) ? fileName.replace(/.*[.]/, '').toLowerCase() : '';
            var allowed = this.options.allowedExtensions;

            if (!allowed.length){return true;}

            for (var i=0; i<allowed.length; i++){
                if (allowed[i].toLowerCase() == ext){ return true;}
            }

            return false;
        },

        _formatSize: function(bytes){
            var i = -1;
            do {
                bytes = bytes / 1024;
                i++;
            } while (bytes > 99);

            return Math.max(bytes, 0.1).toFixed(1) + ['KB', 'MB', 'GB', 'TB', 'PB', 'EB'][i];
        }

    });

   plugins.register(MultiUploader);



	return uploads.MultiUploader = MultiUploader;
});
define('skylark-domx-plugins-uploads/main',[
	"./uploads",
	"./single-uploader",
	"./multi-uploader"
],function(uploads){
	return uploads;
});
define('skylark-domx-plugins-uploads', ['skylark-domx-plugins-uploads/main'], function (main) { return main; });

define('skylark-devices-keyboard/KeyState',[
	"skylark-langx-klass",
	"./keyboard"
],function(klass,keyboard){
	"use strict";

	/**
	 * KeyState is used by Keyboard, Mouse, etc, to represent a key state.
	 *
	 * @class KeyState
	 * @module Input
	*/
	var KeyState = klass({
		_construct : function() {
			/**
			 * Indicates if this key is currently pressed.
			 * @property pressed
			 * @default false
			 * @type {boolean}
			 */
			this.pressed = false;

			/**
			 * Indicates if this key was just pressed.
			 * @property justPressed
			 * @default false
			 * @type {boolean}
			 */
			this.justPressed = false;
			
			/**
			 * Indicates if this key was just released.
			 * @property justReleased
			 * @default false
			 * @type {boolean}
			 */
			this.justReleased = false;

		},

		/**
		 * Update Key status based on new key state.
		 * 
		 * @method update
		 */
		update : function(action)  {
			this.justPressed = false;
			this.justReleased = false;

			if(action === KeyState.DOWN)
			{
				if(this.pressed === false)
				{
					this.justPressed = true;
				}
				this.pressed = true;
			}
			else if(action === KeyState.UP)
			{
				if(this.pressed)
				{
					this.justReleased = true;
				}
				this.pressed = false;
			}
			else if(action === KeyState.RESET)
			{
				this.justReleased = false;
				this.justPressed = false;
			}
		},

		/**
		 * Set this key attributes manually.
		 * 
		 * @method set
		 */
		set : function(justPressed, pressed, justReleased){
			this.justPressed = justPressed;
			this.pressed = pressed;
			this.justReleased = justReleased;
		},

		/**
		 * Reset key to default values.
		 * 
		 * @method reset
		*/
		reset : function() 	{
			this.justPressed = false;
			this.pressed = false;
			this.justReleased = false;
		}
	});

	/**
	 * Down
	 * @attribute DOWN
	 * @type {Number}
	 */
	KeyState.DOWN = -1;

	/**
	 * Up
	 * @attribute UP
	 * @type {Number}
	 */
	KeyState.UP = 1;

	/**
	 * Reset
	 * @attribute RESET
	 * @type {Number}
	 */
	KeyState.RESET = 0;


	return keyboard.KeyState = KeyState;

});
define('skylark-devices-keyboard/Monitor',[
	"skylark-langx-klass",
	"./keyboard",
	"./KeyState"
],function(
	klass,
	keyboard,
	KeyState
){
	"use strict";

	/**
	 * Keyboard instance for input in sync with the running 3D application.
	 * 
	 * The keyboard object provided by scripts is automatically updated by the runtime handler.
	 * 
	 * @class Keyboard
	 * @module Input
	 * @param {Boolean} dontInitialize If true the mouse events are not created.
	 */
	var Monitor = klass({
		_construct : function (dontInitialize) 	{
			/**
			 * Array with keyboard keys status.
			 *
			 * @property keyStates
			 * @type {Array}
			 */
			this.keyStates = [];


			/**
			 * The actions array serves as a buffer for the key input actions.
			 *
			 * Until the update method is called it stores all the key stroke actions.
			 *
			 * On update the key strokes are updated and the keys array stores the correct values.
			 *
			 * @property actions
			 * @type {Array}
			 */
			this.actions = [];

			var self = this;
			var actions = this.actions;

			/**
			 * Event manager used to handle the keyup, keydown and focus events.
			 *
			 * On each event actions are added to the actions array.
			 *
			 * @property events
			 * @type {EventManager}
			 */
			//this.events = new EventManager();
			/*
			this.events.add(window, "keydown", function(event)
			{
				actions.push(event.keyCode);
				actions.push(Key.DOWN);
			});
			this.events.add(window, "keyup", function(event)
			{
				actions.push(event.keyCode);
				actions.push(Key.UP);
			});
			this.events.add(window, "focus", function(event)
			{
				self.reset();
			});
			*/
			this.handlers = {
				"keydown" : function(event) {
								actions.push(event.keyCode);
								actions.push(Key.DOWN);
							},			
				"keyup" : function(event) {
								actions.push(event.keyCode);
								actions.push(Key.UP);
							},			
				"focus" : function(event) {
								self.reset();
							},			


			};

			if(dontInitialize !== true)
			{
				this.create();
			}


		},

		/**
		 * Update key flags synchronously.
		 * 
		 * @method update
		 */
		update : function() 	{
			var end = 0;

			while(this.actions.length > end)
			{
				var key = this.actions.shift();
				var action = this.actions.shift();

				if(this.keyStates[key] === undefined)
				{
					this.keyStates[key] = new Key();
				}

				this.keyStates[key].update(action);

				if(this.keyStates[key].justReleased || this.keyStates[key].justPressed)
				{
					this.actions.push(key);
					this.actions.push(Key.RESET);
					end += 2;
				}
			}
		},

		/**
		 * Reset keyboard status to default.
		 *
		 * Does not clean the action list.
		 * 
		 * @method reset
		 */
		reset : function() {
			//Reset all keys
			for(var i = 0; i < this.keyStates.length; i++)
			{
				if(this.keyStates[i] !== undefined)
				{
					this.keyStates[i].reset();
				}
			}
		},

		/**
		 * Check if a key is pressed.
		 * 
		 * @method keyPressed
		 * @return {boolean} True is the key is currently pressed
		 */
		keyPressed : function(key){
			return this.keyStates[key] !== undefined && this.keyStates[key].pressed;
		},

		/**
		 * Check is a key as just pressed.
		 * 
		 * @method keyJustPressed
		 * @return {boolean} True is the key was just pressed
		 */
		keyJustPressed : function(key){
			return this.keyStates[key] !== undefined && this.keyStates[key].justPressed;
		},

		/**
		 * Check if a key was just released.
		 * 
		 * @method keyJustReleased
		 * @return {boolean} True is the key was just pressed
		 */
		keyJustReleased : function(key){
			return this.keyStates[key] !== undefined && this.keyStates[key].justReleased;
		},


		/**
		 * Create keyboard events.
		 * 
		 * @method dispose
		 */
		create : function(){
			//this.events.create();
			for (var event in this.handlers) {
				window.addEventListener(event,this.handlers[event]);
			}
		},

		/**
		 * Dispose keyboard events.
		 * 
		 * @method dispose
		 */
		dispose : function()	{
			//this.events.destroy();
			for (var event in this.handlers) {
				window.removeEventListener(event,this.handlers[event]);
			}
		}

	});


	return keyboard.Monitor =  Monitor;
});
define('skylark-devices-keyboard/codes',[
	"./keyboard"
],function(keyboard){

  /**
   * Get by name
   *
   *   exports.code['enter'] // => 13
   */

  var codes =  {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'pause/break': 19,
    'caps lock': 20,
    'esc': 27,
    'space': 32,
    'page up': 33,
    'page down': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    'insert': 45,
    'delete': 46,
    'command': 91,
    'left command': 91,
    'right command': 93,
    'numpad *': 106,
    'numpad +': 107,
    'numpad -': 109,
    'numpad .': 110,
    'numpad /': 111,
    'num lock': 144,
    'scroll lock': 145,
    'my computer': 182,
    'my calculator': 183,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    "'": 222
  };

  /*!
   * Programatically add the following
   */

  // lower case chars a-z
  for (var i = 97; i < 123; i++) {
    codes[String.fromCharCode(i)] = i - 32;
  }

  // numbers 0-9
  for (var i = 48; i < 58; i++) {
    codes[i - 48] = i;
  }

  // function keys f1-f12
  for (var i = 1; i < 13; i++) {
    codes['f'+i] = i + 111;
  }

  // numpad keys
  for (var i = 0; i < 10; i++) {
    codes['numpad '+i] = i + 96;
  }

  // Helper aliases


  return keyboard.codes = codes;
});
define('skylark-devices-keyboard/names',[
	"./keyboard",
	"./codes"
],function(keyboard,codes){

  /**
   * Get by code
   *
   *   exports.name[13] // => 'Enter'
   */

  var names = {} ;

  // Create reverse mapping
  for (var i in codes) {
  	names[codes[i]] = i;
  }

  return keyboard.names = names;
});
define('skylark-devices-keyboard/aliases',[
	"./keyboard",
	"./codes",
    "./names"
],function(keyboard,codes){

  var aliases =  {
    'windows': 91,
    '': 16,
    '': 18,
    '': 17,
    '': 91,
    'ctl': 17,
    'control': 17,
    'option': 18,
    'pause': 19,
    'break': 19,
    'caps': 20,
    'return': 13,
    'escape': 27,
    'spc': 32,
    'spacebar': 32,
    'pgup': 33,
    'pgdn': 34,
    'ins': 45,
    'del': 46,
    'cmd': 91
  }

  return keyboard.aliases = aliases;
});
define('skylark-devices-keyboard/isEventKey',[
  "skylark-langx-types",
  "./keyboard",
  "./aliases",
  "./codes",
  "./names"
],function(types,keyboard,aliases,codes,names){

  /**
   * Compares a keyboard event with a given keyCode or keyName.
   *
   * @param {Event} event Keyboard event that should be tested
   * @param {Mixed} keyCode {Number} or keyName {String}
   * @return {Boolean}
   * @api public
   */
   function isEventKey(event, nameOrCode) {
      var keyCode = event.which || event.keyCode || event.charCode;
      if (keyCode === null || keyCode === undefined) { 
        return false; 
      }

      if (types.isString(nameOrCode)) {
        // check codes
        var foundNamedKey = codes[nameOrCode.toLowerCase()]
        if (foundNamedKey) { return foundNamedKey === keyCode; }
      
        // check aliases
        var foundNamedKey = aliases[nameOrCode.toLowerCase()]
        if (foundNamedKey) { return foundNamedKey === keyCode; }
      } else if (types.isNumber(nameOrCode)) {
        return nameOrCode === keyCode;
      }
      return false;
  }

  return keyboard.isEventKey = isEventKey;

});

define('skylark-devices-keyboard/main',[
	"./keyboard",
	"./KeyState",
	"./keys",
	"./Monitor",
	"./aliases",
	"./codes",
	"./isEventKey",
	"./names"
],function(keyboard){
	return keyboard;
});
define('skylark-devices-keyboard', ['skylark-devices-keyboard/main'], function (main) { return main; });

define('skylark-devices-orientation/orientation',[
  "skylark-langx-ns"
],function(skylark){

  /**
   * @summary Detects if device orientation is supported
   * @description We can only be sure device orientation is supported once received an event with coherent data
   * @returns {Promise<boolean>}
   */
   function isDeviceOrientationSupported() {
    return new Promise(function(resolve) {
      if ('DeviceOrientationEvent' in window) {
        var listener = function(e) {
          if (e && e.alpha !== null && !isNaN(e.alpha)) {
            resolve(true);
          }
          else {
            resolve(false);
          }

          window.removeEventListener('deviceorientation', listener);
        };

        window.addEventListener('deviceorientation', listener, false);

        // after 2 secs, auto-reject the promise
        setTimeout(listener, 2000);
      }
      else {
        resolve(false);
      }
    });
  }

  return skylark.attach("devices.orientation",{
    isDeviceOrientationSupported
  });
	
});
define('skylark-devices-orientation/main',["./orientation"],function(orientation){
	return orientation;
});
define('skylark-devices-orientation', ['skylark-devices-orientation/main'], function (main) { return main; });

define('skylark-devices-points/points',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("devices.points",{});
});
define('skylark-devices-points/mouse',[
	"./points"
],function(points){
	/**
	 * Function: isMouseEvent
	 * 
	 * Returns true if the event was generated using a mouse (not a pen or touch device).
	 */
	function isMouseEvent(evt) 	{
		return (evt.pointerType != null) ? (evt.pointerType == 'mouse' || evt.pointerType ===
			evt.MSPOINTER_TYPE_MOUSE) : ((evt.mozInputSource != null) ?
				evt.mozInputSource == 1 : evt.type.indexOf('mouse') == 0);
	}
	
	/**
	 * Function: isLeftMouseButton
	 * 
	 * Returns true if the left mouse button is pressed for the given event.
	 * To check if a button is pressed during a mouseMove you should use the
	 * <mxGraph.isMouseDown> property. Note that this returns true in Firefox
	 * for control+left-click on the Mac.
	 */
	function isLeftMouseButton(evt) {
		// Special case for mousemove and mousedown we check the buttons
		// if it exists because which is 0 even if no button is pressed
		if ('buttons' in evt && (evt.type == 'mousedown' || evt.type == 'mousemove'))
		{
			return evt.buttons == 1;
		}
		else if ('which' in evt)
		{
	        return evt.which === 1;
	    }
		else
		{
	        return evt.button === 1;
	    }
	}
	
	/**
	 * Function: isMiddleMouseButton
	 * 
	 * Returns true if the middle mouse button is pressed for the given event.
	 * To check if a button is pressed during a mouseMove you should use the
	 * <mxGraph.isMouseDown> property.
	 */
	function isMiddleMouseButton(evt) {
		if ('which' in evt)
		{
	        return evt.which === 2;
	    }
		else
		{
	        return evt.button === 4;
	    }
	}
	
	/**
	 * Function: isRightMouseButton
	 * 
	 * Returns true if the right mouse button was pressed. Note that this
	 * button might not be available on some systems. For handling a popup
	 * trigger <isPopupTrigger> should be used.
	 */
	function isRightMouseButton(evt){
		if ('which' in evt)
		{
	        return evt.which === 3;
	    }
		else
		{
	        return evt.button === 2;
	    }
	}

  /**
   * @summary Gets the event name for mouse wheel
   * @returns {string}
   */
  function mouseWheelEvent() {
    return 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"
      document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
        'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox
  };

  /**
   * @summary Normalize mousewheel values accross browsers
   * @description From Facebook's Fixed Data Table
   * {@link https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js}
   * @copyright Facebook
   * @param {MouseWheelEvent} event
   * @returns {{spinX: number, spinY: number, pixelX: number, pixelY: number}}
   */
  function normalizeWheel(event) {
    var PIXEL_STEP  = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;

    var sX = 0, sY = 0; // spinX, spinY
    var pX = 0, pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail'      in event) { sY = event.detail; }
    if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
    if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
    if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in event) { pY = event.deltaY; }
    if ('deltaX' in event) { pX = event.deltaX; }

    if ((pX || pY) && event.deltaMode) {
      if (event.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      }
      else {                      // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
    if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  };

	return points.mouse = {
		mouseWheelEvent,
		normalizeWheel,

		isMouseEvent,
		isLeftMouseButton,
		isMiddleMouseButton,
		isRightMouseButton
	};
});
define('skylark-devices-points/touch',[
	"./points"
],function(points){

  /**
   * @summary Detects if the user is using a touch screen
   * @returns {Promise<boolean>}
   */
   function isTouchEnabled () {
    return new Promise(function(resolve) {
      var listener = function(e) {
        if (e) {
          resolve(true);
        }
        else {
          resolve(false);
        }

        window.removeEventListener('touchstart', listener);
      };

      window.addEventListener('touchstart', listener, false);

      // after 10 secs auto-reject the promise
      setTimeout(listener, 10000);
    });
  };


  /*
   * Converts single-touch event to mouse event.
   */
  function mousy(elm) {
    var touchToMouse = function(event) {
        if (event.touches.length > 1) return; //allow default multi-touch gestures to work
        var touch = event.changedTouches[0];
        var type = "";
        
        switch (event.type) {
        case "touchstart": 
            type = "mousedown"; break;
        case "touchmove":  
            type="mousemove";   break;
        case "touchend":   
            type="mouseup";     break;
        default: 
            return;
        }
        
        // https://developer.mozilla.org/en/DOM/event.initMouseEvent for API
        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(type, true, true, window, 1, 
                touch.screenX, touch.screenY, 
                touch.clientX, touch.clientY, false, 
                false, false, false, 0, null);
        
        touch.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
    };

    elm = elm || document;

    elm.addEventListener("touchstart",touchToMouse,true);
    elm.addEventListener("touchmove",touchToMouse,true);
    elm.addEventListener("touchend",touchToMouse,true);
  }

  return points.touch = {
  	isTouchEnabled,
    mousy
  };
	
});
define('skylark-devices-points/main',[
	"./points",
	"./mouse",
	"./touch"
],function(points){
	return points;
});
define('skylark-devices-points', ['skylark-devices-points/main'], function (main) { return main; });

define('skylark-devices-webgl/webgl',[
	"skylark-langx-ns"
],function(skylark){

  /**
   * @summary Tries to return a canvas webgl context
   * @returns {WebGLRenderingContext}
   */
  function getWebGLCtx() {
    var canvas = document.createElement('canvas');
    var names = ['webgl', 'experimental-webgl', 'moz-webgl', 'webkit-3d'];
    var context = null;

    if (!canvas.getContext) {
      return null;
    }

    if (names.some(function(name) {
        try {
          context = canvas.getContext(name);
          return (context && typeof context.getParameter === 'function');
        } catch (e) {
          return false;
        }
      })) {
      return context;
    }
    else {
      return null;
    }
  }

  /**
   * @summary Detects if WebGL is supported
   * @returns {boolean}
   */
  function isWebGLSupported() {
    return !!window.WebGLRenderingContext && getWebGLCtx() !== null;
  };


  /**
   * @summary Gets max texture width in WebGL context
   * @returns {int}
   */
   function getMaxTextureWidth() {
    var ctx = getWebGLCtx();
    if (ctx !== null) {
      return ctx.getParameter(ctx.MAX_TEXTURE_SIZE);  
    }
    else {
      return 0;
    }
  };

  return skylark.attach("devices.webgl",{
  	getWebGLCtx,
  	isWebGLSupported,
  	getMaxTextureWidth
  })
	
});
define('skylark-devices-webgl/main',[
	"./webgl"
],function(webgl){
	return webgl;
});
define('skylark-devices-webgl', ['skylark-devices-webgl/main'], function (main) { return main; });

define('skylark-io-mimes/mimes',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("io.mimes",{

	});
});
define('skylark-io-mimes/types',[
	"./mimes"
],function(mimes) {
	return mimes.types = {
	  "application\/x-executable": "exe",
	  "application\/x-jar": "jar",
	  "application\/x-gzip": "gz",
	  "application\/x-bzip2": "tbz",
	  "application\/x-rar": "rar",
	  "application\/x-mpegURL": "m3u8",
	  "application\/dash+xml": "mpd",
	  "application\/andrew-inset": "ez",
	  "application\/applixware": "aw",
	  "application\/atom+xml": "atom",
	  "application\/atomcat+xml": "atomcat",
	  "application\/atomsvc+xml": "atomsvc",
	  "application\/ccxml+xml": "ccxml",
	  "application\/cdmi-capability": "cdmia",
	  "application\/cdmi-container": "cdmic",
	  "application\/cdmi-domain": "cdmid",
	  "application\/cdmi-object": "cdmio",
	  "application\/cdmi-queue": "cdmiq",
	  "application\/cu-seeme": "cu",
	  "application\/davmount+xml": "davmount",
	  "application\/docbook+xml": "dbk",
	  "application\/dssc+der": "dssc",
	  "application\/dssc+xml": "xdssc",
	  "application\/ecmascript": "ecma",
	  "application\/emma+xml": "emma",
	  "application\/epub+zip": "epub",
	  "application\/exi": "exi",
	  "application\/font-tdpfr": "pfr",
	  "application\/gml+xml": "gml",
	  "application\/gpx+xml": "gpx",
	  "application\/gxf": "gxf",
	  "application\/hyperstudio": "stk",
	  "application\/inkml+xml": "ink",
	  "application\/ipfix": "ipfix",
	  "application\/java-serialized-object": "ser",
	  "application\/java-vm": "class",
	  "application\/json": "json",
	  "application\/jsonml+json": "jsonml",
	  "application\/lost+xml": "lostxml",
	  "application\/mac-binhex40": "hqx",
	  "application\/mac-compactpro": "cpt",
	  "application\/mads+xml": "mads",
	  "application\/marc": "mrc",
	  "application\/marcxml+xml": "mrcx",
	  "application\/mathematica": "ma",
	  "application\/mathml+xml": "mathml",
	  "application\/mbox": "mbox",
	  "application\/mediaservercontrol+xml": "mscml",
	  "application\/metalink+xml": "metalink",
	  "application\/metalink4+xml": "meta4",
	  "application\/mets+xml": "mets",
	  "application\/mods+xml": "mods",
	  "application\/mp21": "m21",
	  "application\/mp4": "mp4s",
	  "application\/msword": "doc",
	  "application\/mxf": "mxf",
	  "application\/octet-stream": "bin",
	  "application\/oda": "oda",
	  "application\/oebps-package+xml": "opf",
	  "application\/ogg": "ogx",
	  "application\/omdoc+xml": "omdoc",
	  "application\/onenote": "onetoc",
	  "application\/oxps": "oxps",
	  "application\/patch-ops-error+xml": "xer",
	  "application\/pdf": "pdf",
	  "application\/pgp-encrypted": "pgp",
	  "application\/pgp-signature": "asc",
	  "application\/pics-rules": "prf",
	  "application\/pkcs10": "p10",
	  "application\/pkcs7-mime": "p7m",
	  "application\/pkcs7-signature": "p7s",
	  "application\/pkcs8": "p8",
	  "application\/pkix-attr-cert": "ac",
	  "application\/pkix-cert": "cer",
	  "application\/pkix-crl": "crl",
	  "application\/pkix-pkipath": "pkipath",
	  "application\/pkixcmp": "pki",
	  "application\/pls+xml": "pls",
	  "application\/postscript": "ai",
	  "application\/prs.cww": "cww",
	  "application\/pskc+xml": "pskcxml",
	  "application\/rdf+xml": "rdf",
	  "application\/reginfo+xml": "rif",
	  "application\/relax-ng-compact-syntax": "rnc",
	  "application\/resource-lists+xml": "rl",
	  "application\/resource-lists-diff+xml": "rld",
	  "application\/rls-services+xml": "rs",
	  "application\/rpki-ghostbusters": "gbr",
	  "application\/rpki-manifest": "mft",
	  "application\/rpki-roa": "roa",
	  "application\/rsd+xml": "rsd",
	  "application\/rss+xml": "rss",
	  "application\/rtf": "rtf",
	  "application\/sbml+xml": "sbml",
	  "application\/scvp-cv-request": "scq",
	  "application\/scvp-cv-response": "scs",
	  "application\/scvp-vp-request": "spq",
	  "application\/scvp-vp-response": "spp",
	  "application\/sdp": "sdp",
	  "application\/set-payment-initiation": "setpay",
	  "application\/set-registration-initiation": "setreg",
	  "application\/shf+xml": "shf",
	  "application\/smil+xml": "smi",
	  "application\/sparql-query": "rq",
	  "application\/sparql-results+xml": "srx",
	  "application\/srgs": "gram",
	  "application\/srgs+xml": "grxml",
	  "application\/sru+xml": "sru",
	  "application\/ssdl+xml": "ssdl",
	  "application\/ssml+xml": "ssml",
	  "application\/tei+xml": "tei",
	  "application\/thraud+xml": "tfi",
	  "application\/timestamped-data": "tsd",
	  "application\/vnd.3gpp.pic-bw-large": "plb",
	  "application\/vnd.3gpp.pic-bw-small": "psb",
	  "application\/vnd.3gpp.pic-bw-var": "pvb",
	  "application\/vnd.3gpp2.tcap": "tcap",
	  "application\/vnd.3m.post-it-notes": "pwn",
	  "application\/vnd.accpac.simply.aso": "aso",
	  "application\/vnd.accpac.simply.imp": "imp",
	  "application\/vnd.acucobol": "acu",
	  "application\/vnd.acucorp": "atc",
	  "application\/vnd.adobe.air-application-installer-package+zip": "air",
	  "application\/vnd.adobe.formscentral.fcdt": "fcdt",
	  "application\/vnd.adobe.fxp": "fxp",
	  "application\/vnd.adobe.xdp+xml": "xdp",
	  "application\/vnd.adobe.xfdf": "xfdf",
	  "application\/vnd.ahead.space": "ahead",
	  "application\/vnd.airzip.filesecure.azf": "azf",
	  "application\/vnd.airzip.filesecure.azs": "azs",
	  "application\/vnd.amazon.ebook": "azw",
	  "application\/vnd.americandynamics.acc": "acc",
	  "application\/vnd.amiga.ami": "ami",
	  "application\/vnd.android.package-archive": "apk",
	  "application\/vnd.anser-web-certificate-issue-initiation": "cii",
	  "application\/vnd.anser-web-funds-transfer-initiation": "fti",
	  "application\/vnd.antix.game-component": "atx",
	  "application\/vnd.apple.installer+xml": "mpkg",
	  "application\/vnd.aristanetworks.swi": "swi",
	  "application\/vnd.astraea-software.iota": "iota",
	  "application\/vnd.audiograph": "aep",
	  "application\/vnd.blueice.multipass": "mpm",
	  "application\/vnd.bmi": "bmi",
	  "application\/vnd.businessobjects": "rep",
	  "application\/vnd.chemdraw+xml": "cdxml",
	  "application\/vnd.chipnuts.karaoke-mmd": "mmd",
	  "application\/vnd.cinderella": "cdy",
	  "application\/vnd.claymore": "cla",
	  "application\/vnd.cloanto.rp9": "rp9",
	  "application\/vnd.clonk.c4group": "c4g",
	  "application\/vnd.cluetrust.cartomobile-config": "c11amc",
	  "application\/vnd.cluetrust.cartomobile-config-pkg": "c11amz",
	  "application\/vnd.commonspace": "csp",
	  "application\/vnd.contact.cmsg": "cdbcmsg",
	  "application\/vnd.cosmocaller": "cmc",
	  "application\/vnd.crick.clicker": "clkx",
	  "application\/vnd.crick.clicker.keyboard": "clkk",
	  "application\/vnd.crick.clicker.palette": "clkp",
	  "application\/vnd.crick.clicker.template": "clkt",
	  "application\/vnd.crick.clicker.wordbank": "clkw",
	  "application\/vnd.criticaltools.wbs+xml": "wbs",
	  "application\/vnd.ctc-posml": "pml",
	  "application\/vnd.cups-ppd": "ppd",
	  "application\/vnd.curl.car": "car",
	  "application\/vnd.curl.pcurl": "pcurl",
	  "application\/vnd.dart": "dart",
	  "application\/vnd.data-vision.rdz": "rdz",
	  "application\/vnd.dece.data": "uvf",
	  "application\/vnd.dece.ttml+xml": "uvt",
	  "application\/vnd.dece.unspecified": "uvx",
	  "application\/vnd.dece.zip": "uvz",
	  "application\/vnd.denovo.fcselayout-link": "fe_launch",
	  "application\/vnd.dna": "dna",
	  "application\/vnd.dolby.mlp": "mlp",
	  "application\/vnd.dpgraph": "dpg",
	  "application\/vnd.dreamfactory": "dfac",
	  "application\/vnd.ds-keypoint": "kpxx",
	  "application\/vnd.dvb.ait": "ait",
	  "application\/vnd.dvb.service": "svc",
	  "application\/vnd.dynageo": "geo",
	  "application\/vnd.ecowin.chart": "mag",
	  "application\/vnd.enliven": "nml",
	  "application\/vnd.epson.esf": "esf",
	  "application\/vnd.epson.msf": "msf",
	  "application\/vnd.epson.quickanime": "qam",
	  "application\/vnd.epson.salt": "slt",
	  "application\/vnd.epson.ssf": "ssf",
	  "application\/vnd.eszigno3+xml": "es3",
	  "application\/vnd.ezpix-album": "ez2",
	  "application\/vnd.ezpix-package": "ez3",
	  "application\/vnd.fdf": "fdf",
	  "application\/vnd.fdsn.mseed": "mseed",
	  "application\/vnd.fdsn.seed": "seed",
	  "application\/vnd.flographit": "gph",
	  "application\/vnd.fluxtime.clip": "ftc",
	  "application\/vnd.framemaker": "fm",
	  "application\/vnd.frogans.fnc": "fnc",
	  "application\/vnd.frogans.ltf": "ltf",
	  "application\/vnd.fsc.weblaunch": "fsc",
	  "application\/vnd.fujitsu.oasys": "oas",
	  "application\/vnd.fujitsu.oasys2": "oa2",
	  "application\/vnd.fujitsu.oasys3": "oa3",
	  "application\/vnd.fujitsu.oasysgp": "fg5",
	  "application\/vnd.fujitsu.oasysprs": "bh2",
	  "application\/vnd.fujixerox.ddd": "ddd",
	  "application\/vnd.fujixerox.docuworks": "xdw",
	  "application\/vnd.fujixerox.docuworks.binder": "xbd",
	  "application\/vnd.fuzzysheet": "fzs",
	  "application\/vnd.genomatix.tuxedo": "txd",
	  "application\/vnd.geogebra.file": "ggb",
	  "application\/vnd.geogebra.tool": "ggt",
	  "application\/vnd.geometry-explorer": "gex",
	  "application\/vnd.geonext": "gxt",
	  "application\/vnd.geoplan": "g2w",
	  "application\/vnd.geospace": "g3w",
	  "application\/vnd.gmx": "gmx",
	  "application\/vnd.google-earth.kml+xml": "kml",
	  "application\/vnd.google-earth.kmz": "kmz",
	  "application\/vnd.grafeq": "gqf",
	  "application\/vnd.groove-account": "gac",
	  "application\/vnd.groove-help": "ghf",
	  "application\/vnd.groove-identity-message": "gim",
	  "application\/vnd.groove-injector": "grv",
	  "application\/vnd.groove-tool-message": "gtm",
	  "application\/vnd.groove-tool-template": "tpl",
	  "application\/vnd.groove-vcard": "vcg",
	  "application\/vnd.hal+xml": "hal",
	  "application\/vnd.handheld-entertainment+xml": "zmm",
	  "application\/vnd.hbci": "hbci",
	  "application\/vnd.hhe.lesson-player": "les",
	  "application\/vnd.hp-hpgl": "hpgl",
	  "application\/vnd.hp-hpid": "hpid",
	  "application\/vnd.hp-hps": "hps",
	  "application\/vnd.hp-jlyt": "jlt",
	  "application\/vnd.hp-pcl": "pcl",
	  "application\/vnd.hp-pclxl": "pclxl",
	  "application\/vnd.hydrostatix.sof-data": "sfd-hdstx",
	  "application\/vnd.ibm.minipay": "mpy",
	  "application\/vnd.ibm.modcap": "afp",
	  "application\/vnd.ibm.rights-management": "irm",
	  "application\/vnd.ibm.secure-container": "sc",
	  "application\/vnd.iccprofile": "icc",
	  "application\/vnd.igloader": "igl",
	  "application\/vnd.immervision-ivp": "ivp",
	  "application\/vnd.immervision-ivu": "ivu",
	  "application\/vnd.insors.igm": "igm",
	  "application\/vnd.intercon.formnet": "xpw",
	  "application\/vnd.intergeo": "i2g",
	  "application\/vnd.intu.qbo": "qbo",
	  "application\/vnd.intu.qfx": "qfx",
	  "application\/vnd.ipunplugged.rcprofile": "rcprofile",
	  "application\/vnd.irepository.package+xml": "irp",
	  "application\/vnd.is-xpr": "xpr",
	  "application\/vnd.isac.fcs": "fcs",
	  "application\/vnd.jam": "jam",
	  "application\/vnd.jcp.javame.midlet-rms": "rms",
	  "application\/vnd.jisp": "jisp",
	  "application\/vnd.joost.joda-archive": "joda",
	  "application\/vnd.kahootz": "ktz",
	  "application\/vnd.kde.karbon": "karbon",
	  "application\/vnd.kde.kchart": "chrt",
	  "application\/vnd.kde.kformula": "kfo",
	  "application\/vnd.kde.kivio": "flw",
	  "application\/vnd.kde.kontour": "kon",
	  "application\/vnd.kde.kpresenter": "kpr",
	  "application\/vnd.kde.kspread": "ksp",
	  "application\/vnd.kde.kword": "kwd",
	  "application\/vnd.kenameaapp": "htke",
	  "application\/vnd.kidspiration": "kia",
	  "application\/vnd.kinar": "kne",
	  "application\/vnd.koan": "skp",
	  "application\/vnd.kodak-descriptor": "sse",
	  "application\/vnd.las.las+xml": "lasxml",
	  "application\/vnd.llamagraphics.life-balance.desktop": "lbd",
	  "application\/vnd.llamagraphics.life-balance.exchange+xml": "lbe",
	  "application\/vnd.lotus-1-2-3": 123,
	  "application\/vnd.lotus-approach": "apr",
	  "application\/vnd.lotus-freelance": "pre",
	  "application\/vnd.lotus-notes": "nsf",
	  "application\/vnd.lotus-organizer": "org",
	  "application\/vnd.lotus-screencam": "scm",
	  "application\/vnd.lotus-wordpro": "lwp",
	  "application\/vnd.macports.portpkg": "portpkg",
	  "application\/vnd.mcd": "mcd",
	  "application\/vnd.medcalcdata": "mc1",
	  "application\/vnd.mediastation.cdkey": "cdkey",
	  "application\/vnd.mfer": "mwf",
	  "application\/vnd.mfmp": "mfm",
	  "application\/vnd.micrografx.flo": "flo",
	  "application\/vnd.micrografx.igx": "igx",
	  "application\/vnd.mif": "mif",
	  "application\/vnd.mobius.daf": "daf",
	  "application\/vnd.mobius.dis": "dis",
	  "application\/vnd.mobius.mbk": "mbk",
	  "application\/vnd.mobius.mqy": "mqy",
	  "application\/vnd.mobius.msl": "msl",
	  "application\/vnd.mobius.plc": "plc",
	  "application\/vnd.mobius.txf": "txf",
	  "application\/vnd.mophun.application": "mpn",
	  "application\/vnd.mophun.certificate": "mpc",
	  "application\/vnd.mozilla.xul+xml": "xul",
	  "application\/vnd.ms-artgalry": "cil",
	  "application\/vnd.ms-cab-compressed": "cab",
	  "application\/vnd.ms-excel": "xls",
	  "application\/vnd.ms-excel.addin.macroenabled.12": "xlam",
	  "application\/vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
	  "application\/vnd.ms-excel.sheet.macroenabled.12": "xlsm",
	  "application\/vnd.ms-excel.template.macroenabled.12": "xltm",
	  "application\/vnd.ms-fontobject": "eot",
	  "application\/vnd.ms-htmlhelp": "chm",
	  "application\/vnd.ms-ims": "ims",
	  "application\/vnd.ms-lrm": "lrm",
	  "application\/vnd.ms-officetheme": "thmx",
	  "application\/vnd.ms-pki.seccat": "cat",
	  "application\/vnd.ms-pki.stl": "stl",
	  "application\/vnd.ms-powerpoint": "ppt",
	  "application\/vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
	  "application\/vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
	  "application\/vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
	  "application\/vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
	  "application\/vnd.ms-powerpoint.template.macroenabled.12": "potm",
	  "application\/vnd.ms-project": "mpp",
	  "application\/vnd.ms-word.document.macroenabled.12": "docm",
	  "application\/vnd.ms-word.template.macroenabled.12": "dotm",
	  "application\/vnd.ms-works": "wps",
	  "application\/vnd.ms-wpl": "wpl",
	  "application\/vnd.ms-xpsdocument": "xps",
	  "application\/vnd.mseq": "mseq",
	  "application\/vnd.musician": "mus",
	  "application\/vnd.muvee.style": "msty",
	  "application\/vnd.mynfc": "taglet",
	  "application\/vnd.neurolanguage.nlu": "nlu",
	  "application\/vnd.nitf": "ntf",
	  "application\/vnd.noblenet-directory": "nnd",
	  "application\/vnd.noblenet-sealer": "nns",
	  "application\/vnd.noblenet-web": "nnw",
	  "application\/vnd.nokia.n-gage.data": "ngdat",
	  "application\/vnd.nokia.n-gage.symbian.install": "n-gage",
	  "application\/vnd.nokia.radio-preset": "rpst",
	  "application\/vnd.nokia.radio-presets": "rpss",
	  "application\/vnd.novadigm.edm": "edm",
	  "application\/vnd.novadigm.edx": "edx",
	  "application\/vnd.novadigm.ext": "ext",
	  "application\/vnd.oasis.opendocument.chart": "odc",
	  "application\/vnd.oasis.opendocument.chart-template": "otc",
	  "application\/vnd.oasis.opendocument.database": "odb",
	  "application\/vnd.oasis.opendocument.formula": "odf",
	  "application\/vnd.oasis.opendocument.formula-template": "odft",
	  "application\/vnd.oasis.opendocument.graphics": "odg",
	  "application\/vnd.oasis.opendocument.graphics-template": "otg",
	  "application\/vnd.oasis.opendocument.image": "odi",
	  "application\/vnd.oasis.opendocument.image-template": "oti",
	  "application\/vnd.oasis.opendocument.presentation": "odp",
	  "application\/vnd.oasis.opendocument.presentation-template": "otp",
	  "application\/vnd.oasis.opendocument.spreadsheet": "ods",
	  "application\/vnd.oasis.opendocument.spreadsheet-template": "ots",
	  "application\/vnd.oasis.opendocument.text": "odt",
	  "application\/vnd.oasis.opendocument.text-master": "odm",
	  "application\/vnd.oasis.opendocument.text-template": "ott",
	  "application\/vnd.oasis.opendocument.text-web": "oth",
	  "application\/vnd.olpc-sugar": "xo",
	  "application\/vnd.oma.dd2+xml": "dd2",
	  "application\/vnd.openofficeorg.extension": "oxt",
	  "application\/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
	  "application\/vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
	  "application\/vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
	  "application\/vnd.openxmlformats-officedocument.presentationml.template": "potx",
	  "application\/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
	  "application\/vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
	  "application\/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
	  "application\/vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
	  "application\/vnd.osgeo.mapguide.package": "mgp",
	  "application\/vnd.osgi.dp": "dp",
	  "application\/vnd.osgi.subsystem": "esa",
	  "application\/vnd.palm": "pdb",
	  "application\/vnd.pawaafile": "paw",
	  "application\/vnd.pg.format": "str",
	  "application\/vnd.pg.osasli": "ei6",
	  "application\/vnd.picsel": "efif",
	  "application\/vnd.pmi.widget": "wg",
	  "application\/vnd.pocketlearn": "plf",
	  "application\/vnd.powerbuilder6": "pbd",
	  "application\/vnd.previewsystems.box": "box",
	  "application\/vnd.proteus.magazine": "mgz",
	  "application\/vnd.publishare-delta-tree": "qps",
	  "application\/vnd.pvi.ptid1": "ptid",
	  "application\/vnd.quark.quarkxpress": "qxd",
	  "application\/vnd.realvnc.bed": "bed",
	  "application\/vnd.recordare.musicxml": "mxl",
	  "application\/vnd.recordare.musicxml+xml": "musicxml",
	  "application\/vnd.rig.cryptonote": "cryptonote",
	  "application\/vnd.rim.cod": "cod",
	  "application\/vnd.rn-realmedia": "rm",
	  "application\/vnd.rn-realmedia-vbr": "rmvb",
	  "application\/vnd.route66.link66+xml": "link66",
	  "application\/vnd.sailingtracker.track": "st",
	  "application\/vnd.seemail": "see",
	  "application\/vnd.sema": "sema",
	  "application\/vnd.semd": "semd",
	  "application\/vnd.semf": "semf",
	  "application\/vnd.shana.informed.formdata": "ifm",
	  "application\/vnd.shana.informed.formtemplate": "itp",
	  "application\/vnd.shana.informed.interchange": "iif",
	  "application\/vnd.shana.informed.package": "ipk",
	  "application\/vnd.simtech-mindmapper": "twd",
	  "application\/vnd.smaf": "mmf",
	  "application\/vnd.smart.teacher": "teacher",
	  "application\/vnd.solent.sdkm+xml": "sdkm",
	  "application\/vnd.spotfire.dxp": "dxp",
	  "application\/vnd.spotfire.sfs": "sfs",
	  "application\/vnd.stardivision.calc": "sdc",
	  "application\/vnd.stardivision.draw": "sda",
	  "application\/vnd.stardivision.impress": "sdd",
	  "application\/vnd.stardivision.math": "smf",
	  "application\/vnd.stardivision.writer": "sdw",
	  "application\/vnd.stardivision.writer-global": "sgl",
	  "application\/vnd.stepmania.package": "smzip",
	  "application\/vnd.stepmania.stepchart": "sm",
	  "application\/vnd.sun.xml.calc": "sxc",
	  "application\/vnd.sun.xml.calc.template": "stc",
	  "application\/vnd.sun.xml.draw": "sxd",
	  "application\/vnd.sun.xml.draw.template": "std",
	  "application\/vnd.sun.xml.impress": "sxi",
	  "application\/vnd.sun.xml.impress.template": "sti",
	  "application\/vnd.sun.xml.math": "sxm",
	  "application\/vnd.sun.xml.writer": "sxw",
	  "application\/vnd.sun.xml.writer.global": "sxg",
	  "application\/vnd.sun.xml.writer.template": "stw",
	  "application\/vnd.sus-calendar": "sus",
	  "application\/vnd.svd": "svd",
	  "application\/vnd.symbian.install": "sis",
	  "application\/vnd.syncml+xml": "xsm",
	  "application\/vnd.syncml.dm+wbxml": "bdm",
	  "application\/vnd.syncml.dm+xml": "xdm",
	  "application\/vnd.tao.intent-module-archive": "tao",
	  "application\/vnd.tcpdump.pcap": "pcap",
	  "application\/vnd.tmobile-livetv": "tmo",
	  "application\/vnd.trid.tpt": "tpt",
	  "application\/vnd.triscape.mxs": "mxs",
	  "application\/vnd.trueapp": "tra",
	  "application\/vnd.ufdl": "ufd",
	  "application\/vnd.uiq.theme": "utz",
	  "application\/vnd.umajin": "umj",
	  "application\/vnd.unity": "unityweb",
	  "application\/vnd.uoml+xml": "uoml",
	  "application\/vnd.vcx": "vcx",
	  "application\/vnd.visio": "vsd",
	  "application\/vnd.visionary": "vis",
	  "application\/vnd.vsf": "vsf",
	  "application\/vnd.wap.wbxml": "wbxml",
	  "application\/vnd.wap.wmlc": "wmlc",
	  "application\/vnd.wap.wmlscriptc": "wmlsc",
	  "application\/vnd.webturbo": "wtb",
	  "application\/vnd.wolfram.player": "nbp",
	  "application\/vnd.wordperfect": "wpd",
	  "application\/vnd.wqd": "wqd",
	  "application\/vnd.wt.stf": "stf",
	  "application\/vnd.xara": "xar",
	  "application\/vnd.xfdl": "xfdl",
	  "application\/vnd.yamaha.hv-dic": "hvd",
	  "application\/vnd.yamaha.hv-script": "hvs",
	  "application\/vnd.yamaha.hv-voice": "hvp",
	  "application\/vnd.yamaha.openscoreformat": "osf",
	  "application\/vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
	  "application\/vnd.yamaha.smaf-audio": "saf",
	  "application\/vnd.yamaha.smaf-phrase": "spf",
	  "application\/vnd.yellowriver-custom-menu": "cmp",
	  "application\/vnd.zul": "zir",
	  "application\/vnd.zzazz.deck+xml": "zaz",
	  "application\/voicexml+xml": "vxml",
	  "application\/widget": "wgt",
	  "application\/winhlp": "hlp",
	  "application\/wsdl+xml": "wsdl",
	  "application\/wspolicy+xml": "wspolicy",
	  "application\/x-7z-compressed": "7z",
	  "application\/x-abiword": "abw",
	  "application\/x-ace-compressed": "ace",
	  "application\/x-apple-diskimage": "dmg",
	  "application\/x-authorware-bin": "aab",
	  "application\/x-authorware-map": "aam",
	  "application\/x-authorware-seg": "aas",
	  "application\/x-bcpio": "bcpio",
	  "application\/x-bittorrent": "torrent",
	  "application\/x-blorb": "blb",
	  "application\/x-bzip": "bz",
	  "application\/x-cbr": "cbr",
	  "application\/x-cdlink": "vcd",
	  "application\/x-cfs-compressed": "cfs",
	  "application\/x-chat": "chat",
	  "application\/x-chess-pgn": "pgn",
	  "application\/x-conference": "nsc",
	  "application\/x-cpio": "cpio",
	  "application\/x-csh": "csh",
	  "application\/x-debian-package": "deb",
	  "application\/x-dgc-compressed": "dgc",
	  "application\/x-director": "dir",
	  "application\/x-doom": "wad",
	  "application\/x-dtbncx+xml": "ncx",
	  "application\/x-dtbook+xml": "dtb",
	  "application\/x-dtbresource+xml": "res",
	  "application\/x-dvi": "dvi",
	  "application\/x-envoy": "evy",
	  "application\/x-eva": "eva",
	  "application\/x-font-bdf": "bdf",
	  "application\/x-font-ghostscript": "gsf",
	  "application\/x-font-linux-psf": "psf",
	  "application\/x-font-pcf": "pcf",
	  "application\/x-font-snf": "snf",
	  "application\/x-font-type1": "pfa",
	  "application\/x-freearc": "arc",
	  "application\/x-futuresplash": "spl",
	  "application\/x-gca-compressed": "gca",
	  "application\/x-glulx": "ulx",
	  "application\/x-gnumeric": "gnumeric",
	  "application\/x-gramps-xml": "gramps",
	  "application\/x-gtar": "gtar",
	  "application\/x-hdf": "hdf",
	  "application\/x-install-instructions": "install",
	  "application\/x-iso9660-image": "iso",
	  "application\/x-java-jnlp-file": "jnlp",
	  "application\/x-latex": "latex",
	  "application\/x-lzh-compressed": "lzh",
	  "application\/x-mie": "mie",
	  "application\/x-mobipocket-ebook": "prc",
	  "application\/x-ms-application": "application",
	  "application\/x-ms-shortcut": "lnk",
	  "application\/x-ms-wmd": "wmd",
	  "application\/x-ms-wmz": "wmz",
	  "application\/x-ms-xbap": "xbap",
	  "application\/x-msaccess": "mdb",
	  "application\/x-msbinder": "obd",
	  "application\/x-mscardfile": "crd",
	  "application\/x-msclip": "clp",
	  "application\/x-msdownload": "dll",
	  "application\/x-msmediaview": "mvb",
	  "application\/x-msmetafile": "wmf",
	  "application\/x-msmoney": "mny",
	  "application\/x-mspublisher": "pub",
	  "application\/x-msschedule": "scd",
	  "application\/x-msterminal": "trm",
	  "application\/x-mswrite": "wri",
	  "application\/x-netcdf": "nc",
	  "application\/x-nzb": "nzb",
	  "application\/x-pkcs12": "p12",
	  "application\/x-pkcs7-certificates": "p7b",
	  "application\/x-pkcs7-certreqresp": "p7r",
	  "application\/x-research-info-systems": "ris",
	  "application\/x-shar": "shar",
	  "application\/x-shockwave-flash": "swf",
	  "application\/x-silverlight-app": "xap",
	  "application\/x-sql": "sql",
	  "application\/x-stuffit": "sit",
	  "application\/x-stuffitx": "sitx",
	  "application\/x-subrip": "srt",
	  "application\/x-sv4cpio": "sv4cpio",
	  "application\/x-sv4crc": "sv4crc",
	  "application\/x-t3vm-image": "t3",
	  "application\/x-tads": "gam",
	  "application\/x-tar": "tar",
	  "application\/x-tcl": "tcl",
	  "application\/x-tex": "tex",
	  "application\/x-tex-tfm": "tfm",
	  "application\/x-texinfo": "texinfo",
	  "application\/x-tgif": "obj",
	  "application\/x-ustar": "ustar",
	  "application\/x-wais-source": "src",
	  "application\/x-x509-ca-cert": "der",
	  "application\/x-xfig": "fig",
	  "application\/x-xliff+xml": "xlf",
	  "application\/x-xpinstall": "xpi",
	  "application\/x-xz": "xz",
	  "application\/x-zmachine": "z1",
	  "application\/xaml+xml": "xaml",
	  "application\/xcap-diff+xml": "xdf",
	  "application\/xenc+xml": "xenc",
	  "application\/xhtml+xml": "xhtml",
	  "application\/xml": "xsl",
	  "application\/xml-dtd": "dtd",
	  "application\/xop+xml": "xop",
	  "application\/xproc+xml": "xpl",
	  "application\/xslt+xml": "xslt",
	  "application\/xspf+xml": "xspf",
	  "application\/xv+xml": "mxml",
	  "application\/yang": "yang",
	  "application\/yin+xml": "yin",
	  "application\/zip": "zip",
	  "application\/rtfd": "rtfd",

	  "application\/x-cglap": "cglap",

	  "audio\/wav": "wav",
	  "audio\/adpcm": "adp",
	  "audio\/basic": "au",
	  "audio\/midi": "mid",
	  "audio\/mp4": "m4a",
	  "audio\/mpeg": "mpga",
	  "audio\/ogg": "oga",
	  "audio\/s3m": "s3m",
	  "audio\/silk": "sil",
	  "audio\/vnd.dece.audio": "uva",
	  "audio\/vnd.digital-winds": "eol",
	  "audio\/vnd.dra": "dra",
	  "audio\/vnd.dts": "dts",
	  "audio\/vnd.dts.hd": "dtshd",
	  "audio\/vnd.lucent.voice": "lvp",
	  "audio\/vnd.ms-playready.media.pya": "pya",
	  "audio\/vnd.nuera.ecelp4800": "ecelp4800",
	  "audio\/vnd.nuera.ecelp7470": "ecelp7470",
	  "audio\/vnd.nuera.ecelp9600": "ecelp9600",
	  "audio\/vnd.rip": "rip",
	  "audio\/webm": "weba",
	  "audio\/x-aac": "aac",
	  "audio\/x-aiff": "aif",
	  "audio\/x-caf": "caf",
	  "audio\/x-flac": "flac",
	  "audio\/x-matroska": "mka",
	  "audio\/x-mpegurl": "m3u",
	  "audio\/x-ms-wax": "wax",
	  "audio\/x-ms-wma": "wma",
	  "audio\/x-pn-realaudio": "ram",
	  "audio\/x-pn-realaudio-plugin": "rmp",
	  "audio\/xm": "xm",


	  "chemical\/x-cdx": "cdx",
	  "chemical\/x-cif": "cif",
	  "chemical\/x-cmdf": "cmdf",
	  "chemical\/x-cml": "cml",
	  "chemical\/x-csml": "csml",
	  "chemical\/x-xyz": "xyz",

	  "font\/collection": "ttc",
	  "font\/otf": "otf",
	  "font\/ttf": "ttf",
	  "font\/woff": "woff",
	  "font\/woff2": "woff2",


	  "image\/x-ms-bmp": "bmp",
	  "image\/x-targa": "tga",
	  "image\/xbm": "xbm",
	  "image\/pxm": "pxm",

	  "image\/cgm": "cgm",
	  "image\/g3fax": "g3",
	  "image\/gif": "gif",
	  "image\/ief": "ief",
	  "image\/jpeg": "jpeg",
	  "image\/jpg": "jpg",
	  "image\/ktx": "ktx",
	  "image\/png": "png",
	  "image\/prs.btif": "btif",
	  "image\/sgi": "sgi",
	  "image\/svg+xml": "svg",
	  "image\/tiff": "tiff",
	  "image\/vnd.adobe.photoshop": "psd",
	  "image\/vnd.dece.graphic": "uvi",
	  "image\/vnd.djvu": "djvu",
	  "image\/vnd.dvb.subtitle": "sub",
	  "image\/vnd.dwg": "dwg",
	  "image\/vnd.dxf": "dxf",
	  "image\/vnd.fastbidsheet": "fbs",
	  "image\/vnd.fpx": "fpx",
	  "image\/vnd.fst": "fst",
	  "image\/vnd.fujixerox.edmics-mmr": "mmr",
	  "image\/vnd.fujixerox.edmics-rlc": "rlc",
	  "image\/vnd.ms-modi": "mdi",
	  "image\/vnd.ms-photo": "wdp",
	  "image\/vnd.net-fpx": "npx",
	  "image\/vnd.wap.wbmp": "wbmp",
	  "image\/vnd.xiff": "xif",
	  "image\/webp": "webp",
	  "image\/x-3ds": "3ds",
	  "image\/x-cmu-raster": "ras",
	  "image\/x-cmx": "cmx",
	  "image\/x-freehand": "fh",
	  "image\/x-icon": "ico",
	  "image\/x-mrsid-image": "sid",
	  "image\/x-pcx": "pcx",
	  "image\/x-pict": "pic",
	  "image\/x-portable-anymap": "pnm",
	  "image\/x-portable-bitmap": "pbm",
	  "image\/x-portable-graymap": "pgm",
	  "image\/x-portable-pixmap": "ppm",
	  "image\/x-rgb": "rgb",
	  "image\/x-xpixmap": "xpm",
	  "image\/x-xwindowdump": "xwd",

	  "image\/x-xwindowdump": "xwd",

      "image/panorama+jpeg" :  "jpegp", 
      "image/panorama+jpg" :  "jpgp", 
      "image/panorama+png" :  "pngp", 

	  "message\/rfc822": "eml",


	  "model\/iges": "igs",
	  "model\/mesh": "msh",
	  "model\/vnd.collada+xml": "dae",
	  "model\/vnd.dwf": "dwf",
	  "model\/vnd.gdl": "gdl",
	  "model\/vnd.gtw": "gtw",
	  "model\/vnd.vtu": "vtu",
	  "model\/vrml": "wrl",
	  "model\/x3d+binary": "x3db",
	  "model\/x3d+vrml": "x3dv",
	  "model\/x3d+xml": "x3d",

	  "model\/gltf+json": "gltf",
	  "model\/gltf+binary": "glb",
	  "model\/u-obj+text": "obj",


	  "text\/x-php": "php",
	  "text\/javascript": "js",
	  "text\/x-python": "py",
	  "text\/x-ruby": "rb",
	  "text\/x-shellscript": "sh",
	  "text\/x-perl": "pl",
	  "text\/xml": "xml",
	  "text\/x-csrc": "c",
	  "text\/x-chdr": "h",
	  "text\/x-c++src": "cpp",
	  "text\/x-c++hdr": "hh",
	  "text\/x-markdown": "md",
	  "text\/x-yaml": "yml",
	  "text\/cache-manifest": "appcache",
	  "text\/calendar": "ics",
	  "text\/css": "css",
	  "text\/csv": "csv",
	  "text\/html": "html",
	  "text\/n3": "n3",
	  "text\/plain": "txt",
	  "text\/prs.lines.tag": "dsc",
	  "text\/richtext": "rtx",
	  "text\/sgml": "sgml",
	  "text\/tab-separated-values": "tsv",
	  "text\/troff": "t",
	  "text\/turtle": "ttl",
	  "text\/uri-list": "uri",
	  "text\/vcard": "vcard",
	  "text\/vnd.curl": "curl",
	  "text\/vnd.curl.dcurl": "dcurl",
	  "text\/vnd.curl.mcurl": "mcurl",
	  "text\/vnd.curl.scurl": "scurl",
	  "text\/vnd.fly": "fly",
	  "text\/vnd.fmi.flexstor": "flx",
	  "text\/vnd.graphviz": "gv",
	  "text\/vnd.in3d.3dml": "3dml",
	  "text\/vnd.in3d.spot": "spot",
	  "text\/vnd.sun.j2me.app-descriptor": "jad",
	  "text\/vnd.wap.wml": "wml",
	  "text\/vnd.wap.wmlscript": "wmls",
	  "text\/x-asm": "s",
	  "text\/x-c": "cc",
	  "text\/x-fortran": "f",
	  "text\/x-java-source": "java",
	  "text\/x-nfo": "nfo",
	  "text\/x-opml": "opml",
	  "text\/x-pascal": "p",
	  "text\/x-setext": "etx",
	  "text\/x-sfv": "sfv",
	  "text\/x-sql": "sql",
	  "text\/x-uuencode": "uu",
	  "text\/x-vcalendar": "vcs",
	  "text\/x-vcard": "vcf",
	  "text\/x-httpd-cgi": "cgi",
	  "text\/x-asap": "asp",
	  "text\/x-jsp": "jsp",

	  "video\/3gpp": "3gp",
	  "video\/3gpp2": "3g2",
	  "video\/h261": "h261",
	  "video\/h263": "h263",
	  "video\/h264": "h264",
	  "video\/jpeg": "jpgv",
	  "video\/jpm": "jpm",
	  "video\/mj2": "mj2",
	  "video\/MP2T": "m2ts",
	  "video\/mp4": "mp4",
	  "video\/mpeg": "mpeg",
	  "video\/ogg": "ogm",
	  "video\/quicktime": "qt",
	  "video\/vnd.dece.hd": "uvh",
	  "video\/vnd.dece.mobile": "uvm",
	  "video\/vnd.dece.pd": "uvp",
	  "video\/vnd.dece.sd": "uvs",
	  "video\/vnd.dece.video": "uvv",
	  "video\/vnd.dvb.file": "dvb",
	  "video\/vnd.fvt": "fvt",
	  "video\/vnd.mpegurl": "mxu",
	  "video\/vnd.ms-playready.media.pyv": "pyv",
	  "video\/vnd.uvvu.mp4": "uvu",
	  "video\/vnd.vivo": "viv",
	  "video\/webm": "webm",
	  "video\/x-dv": "dv",
	  "video\/x-f4v": "f4v",
	  "video\/x-fli": "fli",
	  "video\/x-flv": "flv",
	  "video\/x-m4v": "m4v",
	  "video\/x-matroska": "mkv",
	  "video\/x-mng": "mng",
	  "video\/x-ms-asf": "asf",
	  "video\/x-ms-vob": "vob",
	  "video\/x-ms-wmx": "wmx",
	  "video\/x-ms-wvx": "wvx",
	  "video\/x-msvideo": "avi",
	  "video\/x-sgi-movie": "movie",
	  "video\/x-smv": "smv",
	  "video\/x-ms-wmv": "wm",

	  "video\/panorama+mp4": "mp4p",

	  "x-conference\/x-cooltalk": "ice",
	  "image\/x-pixlr-data": "pxd",
	  "image\/x-adobe-dng": "dng",
	  "image\/x-sketch": "sketch",
	  "image\/x-xcf": "xcf",
	  "audio\/amr": "amr",
	  "image\/vnd-ms.dds": "dds",
	  "application\/plt": "plt",
	  "application\/sat": "sat",
	  "application\/step": "step"
	};


});

define('skylark-io-mimes/extensions',[
	"skylark-langx-types",
	"./mimes",
	"./types"
],function(ltypes,mimes,types) { 
	var extenstions = {};

	for (var type in types)  {
		var extNames = types[type];
		if (ltypes.isString(extNames)) {
			extNames = [extNames];
		}
		for (var i=0;i<extNames.length;i++) {
			var extName = extNames[i];
			
			if (!extenstions[extName]) {
				extenstions[extName] = type;
			} else if (ltypes.isString(extenstions[extName])) {
				extenstions[extName] = [extenstions[extName],type]
			} else {
				extenstions[extName].push(type);
			}
		}

	}


	return mimes.extenstions = extenstions;

});
define('skylark-io-mimes/getMimeType',[
	"./mimes",
	"./types"
],function(mimes,types) { 
	function getMimeType(ext,category) {
		for (var t in types) {
			if (types[t] === ext && (!category || t.startsWith(category))) {
				return t;
			}
		}
	}	

	return mimes.getMimeType = getMimeType;
});
define('skylark-io-mimes/main',[
	"./mimes",
	"./extensions",
	"./getMimeType",
	"./types"
],function(mimes){
	return mimes;
});
define('skylark-io-mimes', ['skylark-io-mimes/main'], function (main) { return main; });

define('skylark-io-diskfs/download',[
    "skylark-langx/types",
    "./diskfs"
],function(types,diskfs){

    function downloadFile(data, name) {
        if (window.navigator.msSaveBlob) {
            if (types.isString(data)) {
                data = dataURItoBlob(data);
            }
            window.navigator.msSaveBlob(data, name);
        } else {
            var a = document.createElement('a');
            if (data instanceof Blob) {
                data = URL.createObjectURL(data);
            }
            a.href = data;
            a.setAttribute('download', name || 'noname');
            //a.dispatchEvent(new CustomEvent('click'));
            a.click();
        }
    }

    return diskfs.downlad = downloadFile;

});

define('skylark-io-diskfs/read',[
    "skylark-langx-async/deferred",
    "./diskfs"
],function(Deferred, diskfs){

    function readFile(file, params) {
        params = params || {};
        var d = new Deferred,
            reader = new FileReader();

        reader.onload = function(evt) {
            d.resolve(evt.target.result);
        };
        reader.onerror = function(e) {
            var code = e.target.error.code;
            if (code === 2) {
                alert('please don\'t open this page using protocol fill:///');
            } else {
                alert('error code: ' + code);
            }
        };

        if (params.asArrayBuffer) {
            reader.readAsArrayBuffer(file);
        } else if (params.asDataUrl) {
            reader.readAsDataURL(file);
        } else if (params.asText) {
            reader.readAsText(file);
        } else {
            reader.readAsArrayBuffer(file);
        }

        return d.promise;
    }

    return diskfs.read = diskfs.readFile = readFile;
    
});

define('skylark-io-diskfs/read-image',[
    "skylark-langx-async/deferred",
    "./diskfs",
    "./read"
],function(Deferred, diskfs,read){

	function readImage(fileObj) {
        var d = new Deferred,
	    	img = new Image();

	    img.onload = function() {
	      d.resolve(img);
	    };
	    img.onerror = function(e) {
	      d.reject(e);
	    };

	    read(fileObj,{
	    	asDataUrl : true
	    }).then(function(dataUrl){
	        img.src = dataUrl;
	    }).catch(function(e){
	    	d.reject(e);
	    });

	    return d.promise;
	}

	return diskfs.readImage = readImage;

});
define('skylark-io-diskfs/main',[
	"./diskfs",
	"./download",
	"./read",
	"./read-image",
	"./select",
	"./webentry"
],function(diskfs){
	return diskfs;
});
define('skylark-io-diskfs', ['skylark-io-diskfs/main'], function (main) { return main; });

define('skylark-io-streams/streams',[
    "skylark-langx-ns"
], function(skylark) {

    return skylark.attach("io.streams");
});

define('skylark-langx-chars/chars',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){

    function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 13 || ch === 10;
    }

    return skylark.attach("langx.chars",{
        isWhiteSpace
    });


});
define('skylark-langx-chars/main',[
	"./chars"
],function(chars){
	return chars;
});
define('skylark-langx-chars', ['skylark-langx-chars/main'], function (main) { return main; });

define('skylark-io-streams/decode-stream',[
    "skylark-langx-events",
    "skylark-langx-chars",
    "./streams"
], function(events, chars, streams) {
    var emptyBuffer = new Uint8Array(0);


    var DecodeStream = events.Emitter.inherit({
        klassName : "DecodeStream",

        _construct : function(maybeMinBufferLength) {
            this._rawMinBufferLength = maybeMinBufferLength || 0;
            this.pos = 0;
            this.bufferLength = 0;
            this.eof = false;
            this.buffer = emptyBuffer;
            this.minBufferLength = 512;
            if (maybeMinBufferLength) {
                while (this.minBufferLength < maybeMinBufferLength) {
                    this.minBufferLength *= 2;
                }
            }
        },
        length : {
            get : function () {
                //util.unreachable('Should not access DecodeStream.length');    
                throw new Error('Should not access DecodeStream.length') ;               
            }
        },

        isEmpty : {
            get : function () {
                while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                }
                return this.bufferLength === 0;
            }
        },

        ensureBuffer: function DecodeStream_ensureBuffer(requested) {
            var buffer = this.buffer;
            if (requested <= buffer.byteLength) {
                return buffer;
            }
            var size = this.minBufferLength;
            while (size < requested) {
                size *= 2;
            }
            var buffer2 = new Uint8Array(size);
            buffer2.set(buffer);
            return this.buffer = buffer2;
        },
        getByte: function DecodeStream_getByte() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof) {
                    return -1;
                }
                this.readBlock();
            }
            return this.buffer[this.pos++];
        },
        getUint16: function DecodeStream_getUint16() {
            var b0 = this.getByte();
            var b1 = this.getByte();
            if (b0 === -1 || b1 === -1) {
                return -1;
            }
            return (b0 << 8) + b1;
        },
        getInt32: function DecodeStream_getInt32() {
            var b0 = this.getByte();
            var b1 = this.getByte();
            var b2 = this.getByte();
            var b3 = this.getByte();
            return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
        },
        getBytes(length, forceClamped = false) {
            var end, pos = this.pos;
            if (length) {
                this.ensureBuffer(pos + length);
                end = pos + length;
                while (!this.eof && this.bufferLength < end) {
                    this.readBlock();
                }
                var bufEnd = this.bufferLength;
                if (end > bufEnd) {
                    end = bufEnd;
                }
            } else {
                while (!this.eof) {
                    this.readBlock();
                }
                end = this.bufferLength;
            }
            this.pos = end;
            const subarray = this.buffer.subarray(pos, end);
            return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
        },
        peekByte: function DecodeStream_peekByte() {
            var peekedByte = this.getByte();
            if (peekedByte !== -1) {
                this.pos--;
            }
            return peekedByte;
        },
        peekBytes(length, forceClamped = false) {
            var bytes = this.getBytes(length, forceClamped);
            this.pos -= bytes.length;
            return bytes;
        },
        makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
            var end = start + length;
            while (this.bufferLength <= end && !this.eof) {
                this.readBlock();
            }
            return new Stream(this.buffer, start, length, dict);
        },
        getByteRange(begin, end) {
            throw new Error("Should not call DecodeStream.getByteRange") ;               
            //util.unreachable('Should not call DecodeStream.getByteRange');
        },
        skip: function DecodeStream_skip(n) {
            if (!n) {
                n = 1;
            }
            this.pos += n;
        },
        reset: function DecodeStream_reset() {
            this.pos = 0;
        },
        getBaseStreams: function DecodeStream_getBaseStreams() {
            if (this.str && this.str.getBaseStreams) {
                return this.str.getBaseStreams();
            }
            return [];
        }

    });

    return streams.DecodeStream = DecodeStream;

});

define('skylark-io-streams/ascii85-stream',[
    "skylark-langx-chars",
    "./streams",
    "./decode-stream"
], function(chars, streams, DecodeStream) {


    var Ascii85Stream = DecodeStream.inherit({
        klassName : "Ascii85Stream",

        _construct : function(str) {
            this.str = str;
            this.dict = str.dict;
            this.input = new Uint8Array(5);
            if (maybeLength) {
                maybeLength = 0.8 * maybeLength;
            }
            DecodeStream.prototype._construct.call(this, maybeLength);       
        },

        readBlock : function Ascii85Stream_readBlock() {
            var TILDA_CHAR = 126;
            var Z_LOWER_CHAR = 122;
            var EOF = -1;
            var str = this.str;
            var c = str.getByte();
            while (chars.isWhiteSpace(c)) {
                c = str.getByte();
            }
            if (c === EOF || c === TILDA_CHAR) {
                this.eof = true;
                return;
            }
            var bufferLength = this.bufferLength, buffer;
            var i;
            if (c === Z_LOWER_CHAR) {
                buffer = this.ensureBuffer(bufferLength + 4);
                for (i = 0; i < 4; ++i) {
                    buffer[bufferLength + i] = 0;
                }
                this.bufferLength += 4;
            } else {
                var input = this.input;
                input[0] = c;
                for (i = 1; i < 5; ++i) {
                    c = str.getByte();
                    while (chars.isWhiteSpace(c)) {
                        c = str.getByte();
                    }
                    input[i] = c;
                    if (c === EOF || c === TILDA_CHAR) {
                        break;
                    }
                }
                buffer = this.ensureBuffer(bufferLength + i - 1);
                this.bufferLength += i - 1;
                if (i < 5) {
                    for (; i < 5; ++i) {
                        input[i] = 33 + 84;
                    }
                    this.eof = true;
                }
                var t = 0;
                for (i = 0; i < 5; ++i) {
                    t = t * 85 + (input[i] - 33);
                }
                for (i = 3; i >= 0; --i) {
                    buffer[bufferLength + i] = t & 255;
                    t >>= 8;
                }
            }
        }

    });

    return streams.Ascii85Stream = Ascii85Stream;

});

define('skylark-io-streams/ascii-hex-stream',[
    "./streams",
    "./decode-stream"
], function(streams, DecodeStream) {

    var AsciiHexStream = DecodeStream.inherit({
        klassName : "AsciiHexStream",

        _construct : function AsciiHexStream(str, maybeLength) {
            this.str = str;
            this.dict = str.dict;
            this.firstDigit = -1;
            if (maybeLength) {
                maybeLength = 0.5 * maybeLength;
            }

            DecodeStream.prototype._construct.call(this,maybeLength);          
        },

        readBlock : function AsciiHexStream_readBlock() {
            var UPSTREAM_BLOCK_SIZE = 8000;
            var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
            if (!bytes.length) {
                this.eof = true;
                return;
            }
            var maxDecodeLength = bytes.length + 1 >> 1;
            var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
            var bufferLength = this.bufferLength;
            var firstDigit = this.firstDigit;
            for (var i = 0, ii = bytes.length; i < ii; i++) {
                var ch = bytes[i], digit;
                if (ch >= 48 && ch <= 57) {
                    digit = ch & 15;
                } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                    digit = (ch & 15) + 9;
                } else if (ch === 62) {
                    this.eof = true;
                    break;
                } else {
                    continue;
                }
                if (firstDigit < 0) {
                    firstDigit = digit;
                } else {
                    buffer[bufferLength++] = firstDigit << 4 | digit;
                    firstDigit = -1;
                }
            }
            if (firstDigit >= 0 && this.eof) {
                buffer[bufferLength++] = firstDigit << 4;
                firstDigit = -1;
            }
            this.firstDigit = firstDigit;
            this.bufferLength = bufferLength;
        }
    });

    return streams.AsciiHexStream = AsciiHexStream;
});

define('skylark-io-streams/_stream',[
    "skylark-langx-events",
    "./streams"
], function(events,streams) {

   	var Stream = events.Emitter.inherit({
        klassName: "Stream",
        
        _construct: function(arrayBuffer, start, length, dict) {
            this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
            this.start = start || 0;
            this.pos = this.start;
            this.end = start + length || this.bytes.length;
            this.dict = dict;
        },


        length : {
        	get : function() {
                return this.end - this.start;
        	}
        },

        getByte: function () {
            if (this.pos >= this.end) {
                return -1;
            }
            return this.bytes[this.pos++];
        },

        getUint16: function Stream_getUint16() {
            var b0 = this.getByte();
            var b1 = this.getByte();
            if (b0 === -1 || b1 === -1) {
                return -1;
            }
            return (b0 << 8) + b1;
        },

        getInt32: function Stream_getInt32() {
            var b0 = this.getByte();
            var b1 = this.getByte();
            var b2 = this.getByte();
            var b3 = this.getByte();
            return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
        },

        getBytes(length, forceClamped = false) {
            var bytes = this.bytes;
            var pos = this.pos;
            var strEnd = this.end;
            if (!length) {
                const subarray = bytes.subarray(pos, strEnd);
                return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
            }
            var end = pos + length;
            if (end > strEnd) {
                end = strEnd;
            }
            this.pos = end;
            const subarray = bytes.subarray(pos, end);
            return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
        },

        peekByte: function Stream_peekByte() {
            var peekedByte = this.getByte();
            if (peekedByte !== -1) {
                this.pos--;
            }
            return peekedByte;
        },

        peekBytes(length, forceClamped = false) {
            var bytes = this.getBytes(length, forceClamped);
            this.pos -= bytes.length;
            return bytes;
        },

        getByteRange(begin, end) {
            if (begin < 0) {
                begin = 0;
            }
            if (end > this.end) {
                end = this.end;
            }
            return this.bytes.subarray(begin, end);
        },

        skip: function Stream_skip(n) {
            if (!n) {
                n = 1;
            }
            this.pos += n;
        },

        reset: function Stream_reset() {
            this.pos = this.start;
        },

        moveStart: function Stream_moveStart() {
            this.start = this.pos;
        },
        
        makeSubStream: function Stream_makeSubStream(start, length, dict) {
            return new Stream(this.bytes.buffer, start, length, dict);
        }
    });
    
    return streams.Stream = Stream;
	
});

define('skylark-io-streams/chunked-stream',[
    "./streams",
    "./_stream"
], function(streams,Stream) {


    var ChunkedStream = Stream.inherit({
        klassName : "ChunkedStream",

        "numChunks": 0,
        "numChunksLoaded": 0,

        _construct : function(str) {
            var length = str.length;
            var bytes = new Uint8Array(length);
            for (var n = 0; n < length; ++n)
                bytes[n] = str.charCodeAt(n);
            DecodeStream.prototype._construct.call(bytes);          
            this.dict = stream.dict;
        },

        "numChunks": function() {

        },


        getMissingChunks: function ChunkedStream_getMissingChunks() {
            var chunks = [];
            for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    chunks.push(chunk);
                }
            }
            return chunks;
        },

        getBaseStreams: function ChunkedStream_getBaseStreams() {
            return [this];
        },

        allChunksLoaded: function ChunkedStream_allChunksLoaded() {
            var _ = this._;
            return _.numChunksLoaded === _.numChunks;
        },

        onReceiveData: function(begin, chunk) {
            var end = begin + chunk.byteLength;

            assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);
            // Using this.length is inaccurate here since this.start can be moved
            // See ChunkedStream.moveStart()
            var length = this.bytes.length;
            assert(end % this.chunkSize === 0 || end === length,
                'Bad end offset: ' + end);

            this.bytes.set(new Uint8Array(chunk), begin);
            var chunkSize = this.chunkSize;
            var beginChunk = Math.floor(begin / chunkSize);
            var endChunk = Math.floor((end - 1) / chunkSize) + 1;

            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    this.loadedChunks[chunk] = true;
                    ++this.numChunksLoaded;
                }
            }
        },

        onReceiveInitialData: function(data) {
            this.bytes.set(data);
            this.initialDataLength = data.length;
            var endChunk = this.end === data.length ?
                this.numChunks : Math.floor(data.length / this.chunkSize);
            for (var i = 0; i < endChunk; i++) {
                this.loadedChunks[i] = true;
                ++this.numChunksLoaded;
            }
        },

        ensureRange: function ChunkedStream_ensureRange(begin, end) {
            if (begin >= end) {
                return;
            }

            if (end <= this.initialDataLength) {
                return;
            }

            var chunkSize = this.chunkSize;
            var beginChunk = Math.floor(begin / chunkSize);
            var endChunk = Math.floor((end - 1) / chunkSize) + 1;
            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    throw new MissingDataException(begin, end);
                }
            }
        },

        nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
            for (var chunk = beginChunk, n = this.numChunks; chunk < n; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    return chunk;
                }
            }
            // Wrap around to beginning
            for (var chunk = 0; chunk < beginChunk; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    return chunk;
                }
            }
            return null;
        },

        hasChunk: function ChunkedStream_hasChunk(chunk) {
            return chunk in this._.loadedChunks;
        },

        getByte: function ChunkedStream_getByte() {
            var pos = this.pos;
            if (pos >= this.end) {
                return -1;
            }
            this.ensureRange(pos, pos + 1);
            return this.bytes[this.pos++];
        },

        // returns subarray of original buffer
        // should only be read
        getBytes: function ChunkedStream_getBytes(length) {
            var bytes = this.bytes;
            var pos = this.pos;
            var strEnd = this.end;

            if (!length) {
                this.ensureRange(pos, strEnd);
                return bytes.subarray(pos, strEnd);
            }

            var end = pos + length;
            if (end > strEnd)
                end = strEnd;
            this.ensureRange(pos, end);

            this.pos = end;
            return bytes.subarray(pos, end);
        },

        peekBytes: function ChunkedStream_peekBytes(length) {
            var bytes = this.getBytes(length);
            this.pos -= bytes.length;
            return bytes;
        },

        getByteRange: function ChunkedStream_getBytes(begin, end) {
            this.ensureRange(begin, end);
            return this.bytes.subarray(begin, end);
        },

        skip: function ChunkedStream_skip(n) {
            if (!n)
                n = 1;
            this.pos += n;
        },

        reset: function ChunkedStream_reset() {
            this.pos = this.start;
        },

        moveStart: function ChunkedStream_moveStart() {
            this.start = this.pos;
        },

        makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
            function ChunkedStreamSubstream() {}
            ChunkedStreamSubstream.prototype = Object.create(this);
            ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                var chunkSize = this.chunkSize;
                var beginChunk = Math.floor(this.start / chunkSize);
                var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                var missingChunks = [];
                for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!(chunk in this.loadedChunks)) {
                        missingChunks.push(chunk);
                    }
                }
                return missingChunks;
            };
            var subStream = new ChunkedStreamSubstream();
            subStream.pos = subStream.start = start;
            subStream.end = start + length || this.end;
            subStream.dict = dict;
            return subStream;
        }
    });

    return streams.ChunkedStream = ChunkedStream;

});

define('skylark-io-streams/decrypt-stream',[
    "./streams",
    "./decode-stream"
], function(streams, DecodeStream) {

    var chunkSize = 512;


    var DecryptStream = DecodeStream.inherit({
        klassName : "DecryptStream",

        _construct : function (str, maybeLength, decrypt) {
            this.str = str;
            this.dict = str.dict;
            this.decrypt = decrypt;
            this.nextChunk = null;
            this.initialized = false;

            DecodeStream.prototype._construct.call(this, maybeLength);
        },

        readBlock : function DecryptStream_readBlock() {
            var chunk;
            if (this.initialized) {
                chunk = this.nextChunk;
            } else {
                chunk = this.str.getBytes(chunkSize);
                this.initialized = true;
            }
            if (!chunk || chunk.length === 0) {
                this.eof = true;
                return;
            }
            this.nextChunk = this.str.getBytes(chunkSize);
            var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
            var decrypt = this.decrypt;
            chunk = decrypt(chunk, !hasMoreData);
            var bufferLength = this.bufferLength;
            var i, n = chunk.length;
            var buffer = this.ensureBuffer(bufferLength + n);
            for (i = 0; i < n; i++) {
                buffer[bufferLength++] = chunk[i];
            }
            this.bufferLength = bufferLength;
        }
    });

    return streams.DecryptStream = DecryptStream;
});

define('skylark-io-streams/fake-stream',[
    "./streams",
    "./decode-stream"
], function(streams, DecodeStream) {

    var FakeStream = DecodeStream.inherit({
        klassName : "FakeStream",

        _construct : function(stream) {
            this.dict = stream.dict;
            DecodeStream.prototype._construct.call(this);          
        },

        readBlock : function() {
            var bufferLength = this.bufferLength;
            bufferLength += 1024;
            var buffer = this.ensureBuffer(bufferLength);
            this.bufferLength = bufferLength;
        },

        getBytes : function (length) {
            var end, pos = this.pos;

            if (length) {
                this.ensureBuffer(pos + length);
                end = pos + length;

                while (!this.eof && this.bufferLength < end)
                    this.readBlock();

                var bufEnd = this.bufferLength;
                if (end > bufEnd)
                    end = bufEnd;
            } else {
                this.eof = true;
                end = this.bufferLength;
            }

            this.pos = end;
            return this.buffer.subarray(pos, end);
        }

    });

    return streams.FakeStream = FakeStream;
});

define('skylark-io-streams/flate-stream',[
    "./streams",
    "./decode-stream"
], function(streams, DecodeStream) {
    
    var codeLenCodeMap = new Int32Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]);
    var lengthDecode = new Int32Array([
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        65547,
        65549,
        65551,
        65553,
        131091,
        131095,
        131099,
        131103,
        196643,
        196651,
        196659,
        196667,
        262211,
        262227,
        262243,
        262259,
        327811,
        327843,
        327875,
        327907,
        258,
        258,
        258
    ]);
    var distDecode = new Int32Array([
        1,
        2,
        3,
        4,
        65541,
        65543,
        131081,
        131085,
        196625,
        196633,
        262177,
        262193,
        327745,
        327777,
        393345,
        393409,
        459009,
        459137,
        524801,
        525057,
        590849,
        591361,
        657409,
        658433,
        724993,
        727041,
        794625,
        798721,
        868353,
        876545
    ]);
    var fixedLitCodeTab = [
        new Int32Array([
            459008,
            524368,
            524304,
            524568,
            459024,
            524400,
            524336,
            590016,
            459016,
            524384,
            524320,
            589984,
            524288,
            524416,
            524352,
            590048,
            459012,
            524376,
            524312,
            589968,
            459028,
            524408,
            524344,
            590032,
            459020,
            524392,
            524328,
            590000,
            524296,
            524424,
            524360,
            590064,
            459010,
            524372,
            524308,
            524572,
            459026,
            524404,
            524340,
            590024,
            459018,
            524388,
            524324,
            589992,
            524292,
            524420,
            524356,
            590056,
            459014,
            524380,
            524316,
            589976,
            459030,
            524412,
            524348,
            590040,
            459022,
            524396,
            524332,
            590008,
            524300,
            524428,
            524364,
            590072,
            459009,
            524370,
            524306,
            524570,
            459025,
            524402,
            524338,
            590020,
            459017,
            524386,
            524322,
            589988,
            524290,
            524418,
            524354,
            590052,
            459013,
            524378,
            524314,
            589972,
            459029,
            524410,
            524346,
            590036,
            459021,
            524394,
            524330,
            590004,
            524298,
            524426,
            524362,
            590068,
            459011,
            524374,
            524310,
            524574,
            459027,
            524406,
            524342,
            590028,
            459019,
            524390,
            524326,
            589996,
            524294,
            524422,
            524358,
            590060,
            459015,
            524382,
            524318,
            589980,
            459031,
            524414,
            524350,
            590044,
            459023,
            524398,
            524334,
            590012,
            524302,
            524430,
            524366,
            590076,
            459008,
            524369,
            524305,
            524569,
            459024,
            524401,
            524337,
            590018,
            459016,
            524385,
            524321,
            589986,
            524289,
            524417,
            524353,
            590050,
            459012,
            524377,
            524313,
            589970,
            459028,
            524409,
            524345,
            590034,
            459020,
            524393,
            524329,
            590002,
            524297,
            524425,
            524361,
            590066,
            459010,
            524373,
            524309,
            524573,
            459026,
            524405,
            524341,
            590026,
            459018,
            524389,
            524325,
            589994,
            524293,
            524421,
            524357,
            590058,
            459014,
            524381,
            524317,
            589978,
            459030,
            524413,
            524349,
            590042,
            459022,
            524397,
            524333,
            590010,
            524301,
            524429,
            524365,
            590074,
            459009,
            524371,
            524307,
            524571,
            459025,
            524403,
            524339,
            590022,
            459017,
            524387,
            524323,
            589990,
            524291,
            524419,
            524355,
            590054,
            459013,
            524379,
            524315,
            589974,
            459029,
            524411,
            524347,
            590038,
            459021,
            524395,
            524331,
            590006,
            524299,
            524427,
            524363,
            590070,
            459011,
            524375,
            524311,
            524575,
            459027,
            524407,
            524343,
            590030,
            459019,
            524391,
            524327,
            589998,
            524295,
            524423,
            524359,
            590062,
            459015,
            524383,
            524319,
            589982,
            459031,
            524415,
            524351,
            590046,
            459023,
            524399,
            524335,
            590014,
            524303,
            524431,
            524367,
            590078,
            459008,
            524368,
            524304,
            524568,
            459024,
            524400,
            524336,
            590017,
            459016,
            524384,
            524320,
            589985,
            524288,
            524416,
            524352,
            590049,
            459012,
            524376,
            524312,
            589969,
            459028,
            524408,
            524344,
            590033,
            459020,
            524392,
            524328,
            590001,
            524296,
            524424,
            524360,
            590065,
            459010,
            524372,
            524308,
            524572,
            459026,
            524404,
            524340,
            590025,
            459018,
            524388,
            524324,
            589993,
            524292,
            524420,
            524356,
            590057,
            459014,
            524380,
            524316,
            589977,
            459030,
            524412,
            524348,
            590041,
            459022,
            524396,
            524332,
            590009,
            524300,
            524428,
            524364,
            590073,
            459009,
            524370,
            524306,
            524570,
            459025,
            524402,
            524338,
            590021,
            459017,
            524386,
            524322,
            589989,
            524290,
            524418,
            524354,
            590053,
            459013,
            524378,
            524314,
            589973,
            459029,
            524410,
            524346,
            590037,
            459021,
            524394,
            524330,
            590005,
            524298,
            524426,
            524362,
            590069,
            459011,
            524374,
            524310,
            524574,
            459027,
            524406,
            524342,
            590029,
            459019,
            524390,
            524326,
            589997,
            524294,
            524422,
            524358,
            590061,
            459015,
            524382,
            524318,
            589981,
            459031,
            524414,
            524350,
            590045,
            459023,
            524398,
            524334,
            590013,
            524302,
            524430,
            524366,
            590077,
            459008,
            524369,
            524305,
            524569,
            459024,
            524401,
            524337,
            590019,
            459016,
            524385,
            524321,
            589987,
            524289,
            524417,
            524353,
            590051,
            459012,
            524377,
            524313,
            589971,
            459028,
            524409,
            524345,
            590035,
            459020,
            524393,
            524329,
            590003,
            524297,
            524425,
            524361,
            590067,
            459010,
            524373,
            524309,
            524573,
            459026,
            524405,
            524341,
            590027,
            459018,
            524389,
            524325,
            589995,
            524293,
            524421,
            524357,
            590059,
            459014,
            524381,
            524317,
            589979,
            459030,
            524413,
            524349,
            590043,
            459022,
            524397,
            524333,
            590011,
            524301,
            524429,
            524365,
            590075,
            459009,
            524371,
            524307,
            524571,
            459025,
            524403,
            524339,
            590023,
            459017,
            524387,
            524323,
            589991,
            524291,
            524419,
            524355,
            590055,
            459013,
            524379,
            524315,
            589975,
            459029,
            524411,
            524347,
            590039,
            459021,
            524395,
            524331,
            590007,
            524299,
            524427,
            524363,
            590071,
            459011,
            524375,
            524311,
            524575,
            459027,
            524407,
            524343,
            590031,
            459019,
            524391,
            524327,
            589999,
            524295,
            524423,
            524359,
            590063,
            459015,
            524383,
            524319,
            589983,
            459031,
            524415,
            524351,
            590047,
            459023,
            524399,
            524335,
            590015,
            524303,
            524431,
            524367,
            590079
        ]),
        9
    ];
    var fixedDistCodeTab = [
        new Int32Array([
            327680,
            327696,
            327688,
            327704,
            327684,
            327700,
            327692,
            327708,
            327682,
            327698,
            327690,
            327706,
            327686,
            327702,
            327694,
            0,
            327681,
            327697,
            327689,
            327705,
            327685,
            327701,
            327693,
            327709,
            327683,
            327699,
            327691,
            327707,
            327687,
            327703,
            327695,
            0
        ]),
        5
    ];


    var FlateStream = DecodeStream.inherit({
        klassName : "FlateStream",

        _construct :function (str, maybeLength) {
            this.str = str;
            this.dict = str.dict;
            var cmf = str.getByte();
            var flg = str.getByte();
            if (cmf === -1 || flg === -1) {
                throw new util.FormatError(`Invalid header in flate stream: ${ cmf }, ${ flg }`);
            }
            if ((cmf & 15) !== 8) {
                throw new util.FormatError(`Unknown compression method in flate stream: ${ cmf }, ${ flg }`);
            }
            if (((cmf << 8) + flg) % 31 !== 0) {
                throw new util.FormatError(`Bad FCHECK in flate stream: ${ cmf }, ${ flg }`);
            }
            if (flg & 32) {
                throw new util.FormatError(`FDICT bit set in flate stream: ${ cmf }, ${ flg }`);
            }
            this.codeSize = 0;
            this.codeBuf = 0;

            DecodeStream.prototype._construct.call(this, maybeLength);
        },

        getBits : function FlateStream_getBits(bits) {
            var str = this.str;
            var codeSize = this.codeSize;
            var codeBuf = this.codeBuf;
            var b;
            while (codeSize < bits) {
                if ((b = str.getByte()) === -1) {
                    throw new util.FormatError('Bad encoding in flate stream');
                }
                codeBuf |= b << codeSize;
                codeSize += 8;
            }
            b = codeBuf & (1 << bits) - 1;
            this.codeBuf = codeBuf >> bits;
            this.codeSize = codeSize -= bits;
            return b;
        },

        getCode : function FlateStream_getCode(table) {
            var str = this.str;
            var codes = table[0];
            var maxLen = table[1];
            var codeSize = this.codeSize;
            var codeBuf = this.codeBuf;
            var b;
            while (codeSize < maxLen) {
                if ((b = str.getByte()) === -1) {
                    break;
                }
                codeBuf |= b << codeSize;
                codeSize += 8;
            }
            var code = codes[codeBuf & (1 << maxLen) - 1];
            var codeLen = code >> 16;
            var codeVal = code & 65535;
            if (codeLen < 1 || codeSize < codeLen) {
                throw new util.FormatError('Bad encoding in flate stream');
            }
            this.codeBuf = codeBuf >> codeLen;
            this.codeSize = codeSize - codeLen;
            return codeVal;
        },

        generateHuffmanTable : function flateStreamGenerateHuffmanTable(lengths) {
            var n = lengths.length;
            var maxLen = 0;
            var i;
            for (i = 0; i < n; ++i) {
                if (lengths[i] > maxLen) {
                    maxLen = lengths[i];
                }
            }
            var size = 1 << maxLen;
            var codes = new Int32Array(size);
            for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                for (var val = 0; val < n; ++val) {
                    if (lengths[val] === len) {
                        var code2 = 0;
                        var t = code;
                        for (i = 0; i < len; ++i) {
                            code2 = code2 << 1 | t & 1;
                            t >>= 1;
                        }
                        for (i = code2; i < size; i += skip) {
                            codes[i] = len << 16 | val;
                        }
                        ++code;
                    }
                }
            }
            return [
                codes,
                maxLen
            ];
        },

        readBlock : function FlateStream_readBlock() {
            var buffer, len;
            var str = this.str;
            var hdr = this.getBits(3);
            if (hdr & 1) {
                this.eof = true;
            }
            hdr >>= 1;
            if (hdr === 0) {
                var b;
                if ((b = str.getByte()) === -1) {
                    throw new util.FormatError('Bad block header in flate stream');
                }
                var blockLen = b;
                if ((b = str.getByte()) === -1) {
                    throw new util.FormatError('Bad block header in flate stream');
                }
                blockLen |= b << 8;
                if ((b = str.getByte()) === -1) {
                    throw new util.FormatError('Bad block header in flate stream');
                }
                var check = b;
                if ((b = str.getByte()) === -1) {
                    throw new util.FormatError('Bad block header in flate stream');
                }
                check |= b << 8;
                if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                    throw new util.FormatError('Bad uncompressed block length in flate stream');
                }
                this.codeBuf = 0;
                this.codeSize = 0;
                const bufferLength = this.bufferLength, end = bufferLength + blockLen;
                buffer = this.ensureBuffer(end);
                this.bufferLength = end;
                if (blockLen === 0) {
                    if (str.peekByte() === -1) {
                        this.eof = true;
                    }
                } else {
                    const block = str.getBytes(blockLen);
                    buffer.set(block, bufferLength);
                    if (block.length < blockLen) {
                        this.eof = true;
                    }
                }
                return;
            }
            var litCodeTable;
            var distCodeTable;
            if (hdr === 1) {
                litCodeTable = fixedLitCodeTab;
                distCodeTable = fixedDistCodeTab;
            } else if (hdr === 2) {
                var numLitCodes = this.getBits(5) + 257;
                var numDistCodes = this.getBits(5) + 1;
                var numCodeLenCodes = this.getBits(4) + 4;
                var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                var i;
                for (i = 0; i < numCodeLenCodes; ++i) {
                    codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                }
                var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                len = 0;
                i = 0;
                var codes = numLitCodes + numDistCodes;
                var codeLengths = new Uint8Array(codes);
                var bitsLength, bitsOffset, what;
                while (i < codes) {
                    var code = this.getCode(codeLenCodeTab);
                    if (code === 16) {
                        bitsLength = 2;
                        bitsOffset = 3;
                        what = len;
                    } else if (code === 17) {
                        bitsLength = 3;
                        bitsOffset = 3;
                        what = len = 0;
                    } else if (code === 18) {
                        bitsLength = 7;
                        bitsOffset = 11;
                        what = len = 0;
                    } else {
                        codeLengths[i++] = len = code;
                        continue;
                    }
                    var repeatLength = this.getBits(bitsLength) + bitsOffset;
                    while (repeatLength-- > 0) {
                        codeLengths[i++] = what;
                    }
                }
                litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
            } else {
                throw new util.FormatError('Unknown block type in flate stream');
            }
            buffer = this.buffer;
            var limit = buffer ? buffer.length : 0;
            var pos = this.bufferLength;
            while (true) {
                var code1 = this.getCode(litCodeTable);
                if (code1 < 256) {
                    if (pos + 1 >= limit) {
                        buffer = this.ensureBuffer(pos + 1);
                        limit = buffer.length;
                    }
                    buffer[pos++] = code1;
                    continue;
                }
                if (code1 === 256) {
                    this.bufferLength = pos;
                    return;
                }
                code1 -= 257;
                code1 = lengthDecode[code1];
                var code2 = code1 >> 16;
                if (code2 > 0) {
                    code2 = this.getBits(code2);
                }
                len = (code1 & 65535) + code2;
                code1 = this.getCode(distCodeTable);
                code1 = distDecode[code1];
                code2 = code1 >> 16;
                if (code2 > 0) {
                    code2 = this.getBits(code2);
                }
                var dist = (code1 & 65535) + code2;
                if (pos + len >= limit) {
                    buffer = this.ensureBuffer(pos + len);
                    limit = buffer.length;
                }
                for (var k = 0; k < len; ++k, ++pos) {
                    buffer[pos] = buffer[pos - dist];
                }
            }
        }
    });


    return streams.FlateStream = FlateStream;
});

define('skylark-io-streams/lzw-stream',[
    "./streams",
    "./decode-stream"
], function(streams, DecodeStream) {

    var LZWStream = DecodeStream.inherit({
        klassName : "LZWStream",

        _construct : function (str, maybeLength, earlyChange) {
            this.str = str;
            this.dict = str.dict;
            this.cachedData = 0;
            this.bitsCached = 0;
            var maxLzwDictionarySize = 4096;
            var lzwState = {
                earlyChange,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                currentSequence: new Uint8Array(maxLzwDictionarySize),
                currentSequenceLength: 0
            };
            for (var i = 0; i < 256; ++i) {
                lzwState.dictionaryValues[i] = i;
                lzwState.dictionaryLengths[i] = 1;
            }
            this.lzwState = lzwState;

            DecodeStream.prototype._construct.call(this, maybeLength);
        },

        readBits: function LZWStream_readBits(n) {
            var bitsCached = this.bitsCached;
            var cachedData = this.cachedData;
            while (bitsCached < n) {
                var c = this.str.getByte();
                if (c === -1) {
                    this.eof = true;
                    return null;
                }
                cachedData = cachedData << 8 | c;
                bitsCached += 8;
            }
            this.bitsCached = bitsCached -= n;
            this.cachedData = cachedData;
            this.lastCode = null;
            return cachedData >>> bitsCached & (1 << n) - 1;
        },

        readBlock : function LZWStream_readBlock() {
            var blockSize = 512;
            var estimatedDecodedSize = blockSize * 2, decodedSizeDelta = blockSize;
            var i, j, q;
            var lzwState = this.lzwState;
            if (!lzwState) {
                return;
            }
            var earlyChange = lzwState.earlyChange;
            var nextCode = lzwState.nextCode;
            var dictionaryValues = lzwState.dictionaryValues;
            var dictionaryLengths = lzwState.dictionaryLengths;
            var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
            var codeLength = lzwState.codeLength;
            var prevCode = lzwState.prevCode;
            var currentSequence = lzwState.currentSequence;
            var currentSequenceLength = lzwState.currentSequenceLength;
            var decodedLength = 0;
            var currentBufferLength = this.bufferLength;
            var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
            for (i = 0; i < blockSize; i++) {
                var code = this.readBits(codeLength);
                var hasPrev = currentSequenceLength > 0;
                if (code < 256) {
                    currentSequence[0] = code;
                    currentSequenceLength = 1;
                } else if (code >= 258) {
                    if (code < nextCode) {
                        currentSequenceLength = dictionaryLengths[code];
                        for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                            currentSequence[j] = dictionaryValues[q];
                            q = dictionaryPrevCodes[q];
                        }
                    } else {
                        currentSequence[currentSequenceLength++] = currentSequence[0];
                    }
                } else if (code === 256) {
                    codeLength = 9;
                    nextCode = 258;
                    currentSequenceLength = 0;
                    continue;
                } else {
                    this.eof = true;
                    delete this.lzwState;
                    break;
                }
                if (hasPrev) {
                    dictionaryPrevCodes[nextCode] = prevCode;
                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                    dictionaryValues[nextCode] = currentSequence[0];
                    nextCode++;
                    codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                }
                prevCode = code;
                decodedLength += currentSequenceLength;
                if (estimatedDecodedSize < decodedLength) {
                    do {
                        estimatedDecodedSize += decodedSizeDelta;
                    } while (estimatedDecodedSize < decodedLength);
                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                }
                for (j = 0; j < currentSequenceLength; j++) {
                    buffer[currentBufferLength++] = currentSequence[j];
                }
            }
            lzwState.nextCode = nextCode;
            lzwState.codeLength = codeLength;
            lzwState.prevCode = prevCode;
            lzwState.currentSequenceLength = currentSequenceLength;
            this.bufferLength = currentBufferLength;
        }
    });

    return streams.LZWStream = LZWStream;
});

define('skylark-io-streams/null-stream',[
    "./streams",
    "./_stream"
], function( streams, Stream) {

    var NullStream = Stream.inherit({
        klassName : "NullStream",

        _construct : function() {
            Stream.prototype._construct.call(this, new Uint8Array(0));        
        }
    });


    return streams.NullStream = NullStream;

});

define('skylark-io-streams/predictor-stream',[
    "./streams",
    "./decode-stream"
], function(streams, DecodeStream) {


    var PredictorStream = DecodeStream.inherit({
        klassName : "PredictorStream",

        _construct : function (str, maybeLength, params) {
            if (!primitives.isDict(params)) {
                return str;
            }
            var predictor = this.predictor = params.get('Predictor') || 1;
            if (predictor <= 1) {
                return str;
            }
            if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                //throw new util.FormatError(`Unsupported predictor: ${ predictor }`);
                throw new Error(`Unsupported predictor: ${ predictor }`);
            }
            if (predictor === 2) {
                this.readBlock = this.readBlockTiff;
            } else {
                this.readBlock = this.readBlockPng;
            }
            this.str = str;
            this.dict = str.dict;
            var colors = this.colors = params.get('Colors') || 1;
            var bits = this.bits = params.get('BitsPerComponent') || 8;
            var columns = this.columns = params.get('Columns') || 1;
            this.pixBytes = colors * bits + 7 >> 3;
            this.rowBytes = columns * colors * bits + 7 >> 3;
            DecodeStream.call(this, maybeLength);
            return this;
        },

        readBlockTiff : function predictorStreamReadBlockTiff() {
            var rowBytes = this.rowBytes;
            var bufferLength = this.bufferLength;
            var buffer = this.ensureBuffer(bufferLength + rowBytes);
            var bits = this.bits;
            var colors = this.colors;
            var rawBytes = this.str.getBytes(rowBytes);
            this.eof = !rawBytes.length;
            if (this.eof) {
                return;
            }
            var inbuf = 0, outbuf = 0;
            var inbits = 0, outbits = 0;
            var pos = bufferLength;
            var i;
            if (bits === 1 && colors === 1) {
                for (i = 0; i < rowBytes; ++i) {
                    var c = rawBytes[i] ^ inbuf;
                    c ^= c >> 1;
                    c ^= c >> 2;
                    c ^= c >> 4;
                    inbuf = (c & 1) << 7;
                    buffer[pos++] = c;
                }
            } else if (bits === 8) {
                for (i = 0; i < colors; ++i) {
                    buffer[pos++] = rawBytes[i];
                }
                for (; i < rowBytes; ++i) {
                    buffer[pos] = buffer[pos - colors] + rawBytes[i];
                    pos++;
                }
            } else if (bits === 16) {
                var bytesPerPixel = colors * 2;
                for (i = 0; i < bytesPerPixel; ++i) {
                    buffer[pos++] = rawBytes[i];
                }
                for (; i < rowBytes; i += 2) {
                    var sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                    buffer[pos++] = sum >> 8 & 255;
                    buffer[pos++] = sum & 255;
                }
            } else {
                var compArray = new Uint8Array(colors + 1);
                var bitMask = (1 << bits) - 1;
                var j = 0, k = bufferLength;
                var columns = this.columns;
                for (i = 0; i < columns; ++i) {
                    for (var kk = 0; kk < colors; ++kk) {
                        if (inbits < bits) {
                            inbuf = inbuf << 8 | rawBytes[j++] & 255;
                            inbits += 8;
                        }
                        compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                        inbits -= bits;
                        outbuf = outbuf << bits | compArray[kk];
                        outbits += bits;
                        if (outbits >= 8) {
                            buffer[k++] = outbuf >> outbits - 8 & 255;
                            outbits -= 8;
                        }
                    }
                }
                if (outbits > 0) {
                    buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                }
            }
            this.bufferLength += rowBytes;
        },

        readBlockPng : function predictorStreamReadBlockPng() {
            var rowBytes = this.rowBytes;
            var pixBytes = this.pixBytes;
            var predictor = this.str.getByte();
            var rawBytes = this.str.getBytes(rowBytes);
            this.eof = !rawBytes.length;
            if (this.eof) {
                return;
            }
            var bufferLength = this.bufferLength;
            var buffer = this.ensureBuffer(bufferLength + rowBytes);
            var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
            if (prevRow.length === 0) {
                prevRow = new Uint8Array(rowBytes);
            }
            var i, j = bufferLength, up, c;
            switch (predictor) {
            case 0:
                for (i = 0; i < rowBytes; ++i) {
                    buffer[j++] = rawBytes[i];
                }
                break;
            case 1:
                for (i = 0; i < pixBytes; ++i) {
                    buffer[j++] = rawBytes[i];
                }
                for (; i < rowBytes; ++i) {
                    buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                    j++;
                }
                break;
            case 2:
                for (i = 0; i < rowBytes; ++i) {
                    buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                }
                break;
            case 3:
                for (i = 0; i < pixBytes; ++i) {
                    buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                }
                for (; i < rowBytes; ++i) {
                    buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                    j++;
                }
                break;
            case 4:
                for (i = 0; i < pixBytes; ++i) {
                    up = prevRow[i];
                    c = rawBytes[i];
                    buffer[j++] = up + c;
                }
                for (; i < rowBytes; ++i) {
                    up = prevRow[i];
                    var upLeft = prevRow[i - pixBytes];
                    var left = buffer[j - pixBytes];
                    var p = left + up - upLeft;
                    var pa = p - left;
                    if (pa < 0) {
                        pa = -pa;
                    }
                    var pb = p - up;
                    if (pb < 0) {
                        pb = -pb;
                    }
                    var pc = p - upLeft;
                    if (pc < 0) {
                        pc = -pc;
                    }
                    c = rawBytes[i];
                    if (pa <= pb && pa <= pc) {
                        buffer[j++] = left + c;
                    } else if (pb <= pc) {
                        buffer[j++] = up + c;
                    } else {
                        buffer[j++] = upLeft + c;
                    }
                }
                break;
            default:
                //throw new util.FormatError(`Unsupported predictor: ${ predictor }`);
                throw new Error(`Unsupported predictor: ${ predictor }`);
            }
            this.bufferLength += rowBytes;
        }
    });

    return streams.PredictorStream = PredictorStream;
});

define('skylark-io-streams/run-length-stream',[
    "skylark-langx-chars",
    "./streams",
    "./decode-stream"
], function(chars, streams, DecodeStream) {

    var RunLengthStream = DecodeStream.inherit({
        klassName : "RunLengthStream",

        _construct : function (str, maybeLength) {
            this.str = str;
            this.dict = str.dict;
            DecodeStream.prototype._construct.call(this, maybeLength);       
        },

        readBlock : function RunLengthStream_readBlock() {
            var repeatHeader = this.str.getBytes(2);
            if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                this.eof = true;
                return;
            }
            var buffer;
            var bufferLength = this.bufferLength;
            var n = repeatHeader[0];
            if (n < 128) {
                buffer = this.ensureBuffer(bufferLength + n + 1);
                buffer[bufferLength++] = repeatHeader[1];
                if (n > 0) {
                    var source = this.str.getBytes(n);
                    buffer.set(source, bufferLength);
                    bufferLength += n;
                }
            } else {
                n = 257 - n;
                var b = repeatHeader[1];
                buffer = this.ensureBuffer(bufferLength + n + 1);
                for (var i = 0; i < n; i++) {
                    buffer[bufferLength++] = b;
                }
            }
            this.bufferLength = bufferLength;
        }
    });

    return streams.RunLengthStream = RunLengthStream;

});

define('skylark-io-streams/streams-sequence-stream',[
    "skylark-langx-chars",
    "./streams",
    "./decode-stream"
], function(chars, streams, DecodeStream) {


    var StreamsSequenceStream = DecodeStream.inherit({
        klassName : "StreamsSequenceStream",

        _construct : function(_streams) {
            this.streams = _streams;
            let maybeLength = 0;
            for (let i = 0, ii = _streams.length; i < ii; i++) {
                const stream = _streams[i];
                if (stream instanceof DecodeStream) {
                    maybeLength += stream._rawMinBufferLength;
                } else {
                    maybeLength += stream.length;
                }
            }
            DecodeStream.prototype._construct.call(this, maybeLength);       
        },

        readBlock : function streamSequenceStreamReadBlock() {
            var _streams = this.streams;
            if (streams.length === 0) {
                this.eof = true;
                return;
            }
            var stream = _streams.shift();
            var chunk = _streams.getBytes();
            var bufferLength = this.bufferLength;
            var newLength = bufferLength + chunk.length;
            var buffer = this.ensureBuffer(newLength);
            buffer.set(chunk, bufferLength);
            this.bufferLength = newLength;
        },

        getBaseStreams : function StreamsSequenceStream_getBaseStreams() {
            var baseStreams = [];
            for (var i = 0, ii = this.streams.length; i < ii; i++) {
                var stream = this.streams[i];
                if (stream.getBaseStreams) {
                    baseStreams.push(...stream.getBaseStreams());
                }
            }
            return baseStreams;
        }
    });

    return streams.StreamsSequenceStream = StreamsSequenceStream;

});

define('skylark-io-streams/string-stream',[
    "./streams",
    "./_stream"
], function(streams, Stream) {

    var StringStream = Stream.inherit({
        klassName : "StringStream",

        _construct : function(str) {
            //const bytes = util.stringToBytes(str);
            //TODO: chartCodeAt() >255
            var length = str.length;
            var bytes = new Uint8Array(length);
            for (var n = 0; n < length; ++n)
                bytes[n] = str.charCodeAt(n);

            Stream.prototype._construct.call(this,bytes);          
        }
    });


    return streams.StringStream = StringStream;

});

define('skylark-io-streams/main',[
    "./streams",
    "./ascii85-stream",
    "./ascii-hex-stream",
    "./chunked-stream",
    "./decode-stream",
    "./decrypt-stream",
    "./fake-stream",
    "./flate-stream",
    "./lzw-stream",
    "./null-stream",
    "./predictor-stream",
    "./run-length-stream",
    "./_stream",
    "./streams-sequence-stream",
    "./string-stream"
], function(streams) {

	return streams;
});
define('skylark-io-streams', ['skylark-io-streams/main'], function (main) { return main; });

define('skylark-net-http/restful',[
    "skylark-langx-objects",
    "skylark-langx-strings",
    "skylark-langx-emitter/evented",    
    "./xhr"
],function(objects,strings,Evented,Xhr){
    var mixin = objects.mixin,
        substitute = strings.substitute;

    var Restful = Evented.inherit({
        "klassName" : "Restful",

        "idAttribute": "id",
        
        getBaseUrl : function(args) {
            //$$baseEndpoint : "/files/${fileId}/comments",
            var baseEndpoint = substitute(this.baseEndpoint,args),
                baseUrl = this.server + this.basePath + baseEndpoint;
            if (args[this.idAttribute]!==undefined) {
                baseUrl = baseUrl + "/" + args[this.idAttribute]; 
            }
            return baseUrl;
        },
        _head : function(args) {
            //get resource metadata .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
        },
        _get : function(args) {
            //get resource ,one or list .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, null if list
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            return Xhr.get(this.getBaseUrl(args),args);
        },
        _post  : function(args,verb) {
            //create or move resource .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "data" : body // the own data,required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            //verb : the verb ,ex: copy,touch,trash,untrash,watch
            var url = this.getBaseUrl(args);
            if (verb) {
                url = url + "/" + verb;
            }
            return Xhr.post(url, args);
        },

        _put  : function(args,verb) {
            //update resource .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "data" : body // the own data,required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            //verb : the verb ,ex: copy,touch,trash,untrash,watch
            var url = this.getBaseUrl(args);
            if (verb) {
                url = url + "/" + verb;
            }
            return Xhr.put(url, args);
        },

        _delete : function(args) {
            //delete resource . 
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}         

            // HTTP request : DELETE http://center.utilhub.com/registry/v1/apps/{appid}
            var url = this.getBaseUrl(args);
            return Xhr.del(url);
        },

        _patch : function(args){
            //update resource metadata. 
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "data" : body // the own data,required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            var url = this.getBaseUrl(args);
            return Xhr.patch(url, args);
        },
        query: function(params) {
            
            return this._post(params);
        },

        retrieve: function(params) {
            return this._get(params);
        },

        create: function(params) {
            return this._post(params);
        },

        update: function(params) {
            return this._put(params);
        },

        delete: function(params) {
            // HTTP request : DELETE http://center.utilhub.com/registry/v1/apps/{appid}
            return this._delete(params);
        },

        patch: function(params) {
           // HTTP request : PATCH http://center.utilhub.com/registry/v1/apps/{appid}
            return this._patch(params);
        },
        init: function(params) {
            mixin(this,params);
 //           this._xhr = XHRx();
       }
    });

    return Restful;
});
define('skylark-net-http/main',[
	"./http",
	"./restful",
	"./Xhr",
	"./upload"
],function(http){
	return http;
});
define('skylark-net-http', ['skylark-net-http/main'], function (main) { return main; });

define('skylark-appify-routers/routers',[
	"skylark-langx/skylark",
	"skylark-langx/langx"	
],function(skylark,langx){

	return skylark.attach("appify.routers",{
        createEvent : function (type,props) {
            var e = new CustomEvent(type,props);
            return langx.safeMixin(e, props);
        }

	});	
});

define('skylark-appify-routers/route',[
	"skylark-langx/langx",
	"./routers"
],function(langx,routers){
    var createEvent = routers.createEvent;
    
    var Route = langx.Evented.inherit({
        klassName: "Route",
        init: function(name, setting) {
            setting = langx.mixin({}, setting);
            var pathto = setting.pathto || "",
                pattern = pathto,
                paramNames = pattern.match(/\:([a-zA-Z0-9_]+)/g);
            if (paramNames !== null) {
                paramNames = paramNames.map(function(paramName) {
                    return paramName.substring(1);
                });
                pattern = pattern.replace(/\:([a-zA-Z0-9_]+)/g, '(.*?)');
            } else {
                paramNames = [];
            }
            if (pattern === "*") {
                pattern = "(.*)";
            } else {
                pattern = pattern.replace("/", "\\/");
            }

            this._setting = setting;
            this.name = name;
            this.pathto = pathto;
            this.paramNames = paramNames;
            this.params = pattern;
            this.regex = new RegExp("^" + pattern + "$", "");

            var self = this;
            ["entering", "entered", "exiting", "exited"].forEach(function(eventName) {
                if (langx.isFunction(setting[eventName])) {
                    self.on(eventName, setting[eventName]);
                }
            });
        },

        enter: function(ctx,query) {
            if (query) {
                var r = this._entering(ctx),
                    self = this;

                return langx.Deferred.when(r).then(function(){
                    var e = createEvent("entering", {
                        route: self,
                        result: true
                    });

                    self.trigger(e);

                    return e.result;
                });
            } else {
                this._entered(ctx);

                this.trigger(createEvent("entered", langx.safeMixin({
                    route: this
                }, ctx)));
                return this;
            }
        },

        exit: function(ctx, query) {
            if (query) {
                var ok = this._exiting(ctx);
                if (!ok) {
                    return false;
                }

                var e = createEvent("exiting", {
                    route: this,
                    result: true
                });

                this.trigger(e);

                return e.result;
            } else {
                this._exited(ctx);
                this.trigger(createEvent("exited", langx.safeMixin({
                    route: this
                }, ctx)));

                return this;
            }
        },

        match: function(path) {
            var names = this.paramNames,
                x = path.indexOf('?'),
                path = ~x ? path.slice(0, x) : decodeURIComponent(path),
                m = this.regex.exec(path);

            if (!m) {
                return false
            };

            var params = {};
            for (var i = 1, len = m.length; i < len; ++i) {
                var name = names[i - 1],
                    val = decodeURIComponent(m[i]);
                params[name] = val;
            }

            return params;
        },

        path: function(params) {
            var path = this.pathto;
            if (params) {
                path = path.replace(/:([a-zA-Z0-9_]+)/g, function(match, paramName) {
                    return params[paramName];
                });
            }
            return path;
        },

        _entering: function(ctx) {
            return true;
        },
        _entered: function(ctx) {
            return true;
        },
        _exiting: function(ctx) {
            return true;
        },
        _exited: function(ctx) {
            return true;
        }
    });

	return routers.Route = Route;	
});
define('skylark-appify-routers/router',[
    "skylark-langx/langx",
    "./routers",
    "./route"
],function(langx,routers,Route){
    var createEvent = routers.createEvent;

    function Router() {
        var _curCtx,
            _prevCtx,
            _baseUrl,
            _homePath,
            _routes = {},
            _cache = {},
            _hub = new langx.Evented();

        var router = this;


        function current() {
            return _curCtx;
        }

        // refresh the current route
        function dispatch(ctx) {

            if (_curCtx) {
                var ret = _curCtx.route.exit({
                    path: _curCtx.path,
                    params: _curCtx.params
                }, true);
                if (!ret) {
                    return;
                }
            }

            _prevCtx = _curCtx;
            _curCtx = ctx;
            if (!_curCtx.route) {
                var m = map(_curCtx.path);
                _curCtx.route = m.route;
                _curCtx.params = m.params;
            }

            var r = _curCtx.route.enter({
                force: _curCtx.force,
                path: _curCtx.path,
                params: _curCtx.params
            },true);

            langx.Deferred.when(r).then(function() {
                _hub.trigger(createEvent("routing", {
                    current: _curCtx,
                    previous: _prevCtx
                }));

                _curCtx.route.enter({
                    path: _curCtx.path,
                    params: _curCtx.params
                },false);

                if (_prevCtx) {
                    _prevCtx.route.exit({
                        path: _prevCtx.path,
                        params: _prevCtx.params
                    }, false);
                }

                _hub.trigger(createEvent("routed", {
                    current: _curCtx,
                    previous: _prevCtx
                }));
            });
        }

        function go(path, force) {
            if (!force && _curCtx && _curCtx.path == path) {
                return false;
            }
            var ctx = map(path);
            if (ctx) {
                ctx.path = path;

                if (router.useHistoryApi) {
                    var state = {
                        force: force,
                        path: path
                    }

                    window.history.pushState(state, document.title, (_baseUrl + path).replace("//", "/"));
                    window.dispatchEvent(createEvent("popstate", {
                        state: state
                    }));
                } else if (router.useHashbang) {
                    var newHash = "#!" + path;
                    if (window.location.hash !== newHash) {
                        window.location.hash = newHash;
                    } else {
                        dispatch(ctx);
                    };
                } else {
                    dispatch(ctx);
                }
            }
            return true;
        }

        function map(path, noCache) {
            var finded = false;
            if (!noCache) {
                finded = _cache[path];
                if (finded) {
                    return finded;
                }
            }
            langx.each(_routes, function(name, route) {
                var ret = route.match(path);
                if (ret) {
                    finded = {
                        route: route,
                        params: ret
                    }
                    return false;
                }
                return true;
            });
            if (finded && !noCache) {
                _cache[path] = finded;
            }
            return finded;
        }

        function path(routeName, params) {
            var route = _routes[routeName],
                path;
            if (route) {
                path = route.path(params);
            }
            return path;
        }

        function previous() {
            return _prevCtx;
        }

        function baseUrl(path) {
            if (langx.isDefined(path)) {
                _baseUrl = path;
                return this;
            } else {
                return _baseUrl;
            }
        }

        function hub(){
            return _hub;
        }

        function homePath(path) {
            if (langx.isDefined(path)) {
                _homePath = path;
                return this;
            } else {
                return _homePath;
            }
        }

        function route(name, setting) {
            if (langx.isDefined(setting)) {
                var settings = {};
                settings[name] = setting;
                routes(settings);
                return this;
            } else {
                return _routes[name];
            }
        }

        function routes(settings) {
            if (!langx.isDefined(settings)) {
                return langx.mixin({}, _routes);
            } else {
                for (var name in settings) {
                    _routes[name] = new router.Route(name, settings[name]);
                }
            }
        }

        //starts routing urls
        function start() {
            if (router.useHashbang == null && router.useHistoryApi == null) {
                if (window.location.host  && window.history.pushState) {
                    //web access
                    router.useHistoryApi = true;
                } else {
                    // local access
                    router.useHashbang = true;
                }
            }

            var initPath = "";

            if (router.useHistoryApi) {
                initPath = window.location.pathname;
                if (_baseUrl === undefined) {
                    _baseUrl = initPath.replace(/\/$/, "");
                }
                initPath = initPath.replace(_baseUrl, "") || _homePath || "/";
            } else if (router.useHashbang) {
                initPath = window.location.hash.replace("#!", "") || _homePath || "/";
            } else {
                initPath = "/";
            }

            if (!initPath.startsWith("/")) {
                initPath = "/" + initPath;
            }
            /*
            eventer.on(document.body, "click", "a[href]", function(e) {
                var elm = e.currentTarget,
                    url = elm.getAttribute("href");

                if (url == "#") {
                    return;
                }
                if (url && langx.isSameOrigin(elm.href)) {
                    if (url.indexOf(_baseUrl) === 0) {
                        url = url.substr(_baseUrl.length);
                        eventer.stop(e);
                        url = url.replace('#!', '');
                        go(url);
                    }
                }
            });
            */
            if (router.useHistoryApi) {
                window.addEventListener("popstate", function(e) {
                    if(e.state) dispatch(e.state);
                    e.preventDefault();
                });
            } else if (router.useHashbang) {
                window.addEventListener("hashchange", function(e) {
                    dispatch({
                        path: window.location.hash.replace(/^#!/, "")
                    });
                    e.preventDefault();
                });
            }

            go(initPath);
        }

        langx.mixin(router, {
            "Route": Route,

            // Current path being processed
            "current": current,

            // Changes the current path
            "go": go,

            "map": map,

            "hub": hub,

            "off": function() {
                _hub.off.apply(_hub, arguments);
            },

            "on": function() {
                _hub.on.apply(_hub, arguments);
            },

            "one": function() {
                _hub.one.apply(_hub, arguments);
            },

            // Returns the path of the named route
            "path": path,

            "previous": previous,

            "baseUrl": baseUrl,

            "homePath": homePath,

            "route": route,

            "routes": routes,

            //starts routing urls
            "start": start,

            "trigger": function(e) {
                _hub.trigger(e);
                return this;
            },

            "useHistoryApi": null,
            "useHashbang": null
        });

    }

    return routers.Router = Router;
});

define('skylark-appify-routers/main',[
    "./routers",
    "./router",
    "./route"
], function(routers) {
    return routers;
});

define('skylark-appify-routers', ['skylark-appify-routers/main'], function (main) { return main; });

define('skylark-appify-spa/spa',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-appify-routers"
], function(skylark, langx, routers) {
    var Deferred = langx.Deferred;

    function createEvent(type, props) {
        var e = new CustomEvent(type, props);
        return langx.safeMixin(e, props);
    }

    var router = new routers.Router();

    var Route = router.Route = router.Route.inherit({
        klassName: "SpaRoute",

        init: function(name, setting) {
            this.overrided(name, setting);
            this.content = setting.content;
            this.forceRefresh = setting.forceRefresh;
            this.data = setting.data;
            //this.lazy = !!setting.lazy;
            var self = this;
            ["preparing", "rendering", "rendered"].forEach(function(eventName) {
                if (langx.isFunction(setting[eventName])) {
                    self.on(eventName, setting[eventName]);
                }
            });
        },

        _entering: function(ctx) {
            if (this.forceRefresh || ctx.force || !this._prepared) {
                return this.prepare();
            }
            return this;
        },

        getConfigData: function(key) {
            return key ? this.data[key] : this.data;
        },

        getNamedValue: function() {
            return window.location.pathname.match(this.regex);
        },

        prepare: function() {
            var d = new Deferred(),
                setting = this._setting,
                controllerSetting = setting.controller,
                controller = this.controller,

                self = this,
                content = setting.content,
                contentPath = setting.contentPath;

            require([controllerSetting.type], function(type) {
                controller = self.controller = new type(controllerSetting);
                d.resolve();
            });

            return d.then(function() {
                var e = createEvent("preparing", {
                    route: self,
                    result: true
                });
                self.trigger(e);
                return Deferred.when(e.result).then(function() {
                    self._prepared = true;
                });
            });
        },

        render: function(ctx) {
            var e = createEvent("rendering", {
                route: this,
                context: ctx,
                content: this.content
            });
            this.trigger(e);
            return e.content;
        },

        trigger: function(e) {
            var controller = this.controller;
            if (controller) {
                return controller.perform(e);
            } else {
                return this.overrided(e);
            }
        }
    });


    var RouteController = langx.Evented.inherit({
        klassName: "SpaRouteController",

        init: function(route, setting) {
            setting = setting || {};
            this.content = setting.content;
            this.data = setting.data;
        },

        getConfigData: function(key) {
            return key ? this.data[key] : this.data;
        },

        perform: function(e) {
            var eventName = e.type;
            if (this[eventName]) {
                return this[eventName].call(this, e);
            }

        }
    });

    var Page = langx.Evented.inherit({
        klassName: "SpaPage",

        init: function(params) {
            params = langx.mixin({
                "routeViewer": "body"
            }, params);

            this._params = params;
            this._rvc = document.querySelector(params.routeViewer);
            this._router = router;

            router.on("routed", langx.proxy(this, "refresh"));
        },

        prepare: function() {

        },

        //Refreshes the route
        refresh: function() {
            var curCtx = router.current(),
                prevCtx = router.previous();
            var content = curCtx.route.render(curCtx);
            if (content===undefined || content===null) {
                return;
            }
            if (langx.isString(content)) {
                this._rvc.innerHTML = content;
            } else {
                this._rvc.innerHTML = "";
                this._rvc.appendChild(content);
            }
            curCtx.route.trigger(createEvent("rendered", {
                route: curCtx.route,
                content: content
            }));
        }
    });

    var Plugin = langx.Evented.inherit({
        klassName: "SpaPlugin",

        init: function(name, setting) {
            this.name = name;

            if (langx.isString(setting.hookers)) {
                setting.hookers = setting.hookers.split(" ");
            }
            this._setting = setting;
        },

        isHooked: function(eventName) {
            var hookers = this._setting.hookers || [];
            return hookers.indexOf(eventName) > -1;
        },

        prepare: function() {
            var d = new Deferred(),
                setting = this._setting,
                controllerSetting = setting.controller,
                controller = this.controller,
                self = this;
            require([controllerSetting.type], function(type) {
                controller = self.controller = new type(controllerSetting);
                router.on(setting.hookers, {
                    plugin: self
                }, langx.proxy(controller.perform, controller));
                d.resolve();
            });
            return d.then(function() {
                var e = createEvent("preparing", {
                    plugin: self,
                    result: true
                });
                self.trigger(e);
                return Deferred.when(e.result).then(function() {
                    self._prepared = true;
                });
            });
        },

        trigger: function(e) {
            var controller = this.controller;
            if (controller) {
                return controller.perform(e);
            } else {
                return this.overrided(e);
            }
        }
    });

    var PluginController = langx.Evented.inherit({
        klassName: "SpaPluginController",

        init: function(plugin) {
            this.plugin = plugin;
        },

        perform: function(e) {
            var eventName = e.type;
            if (this[eventName]) {
                return this[eventName].call(this, e);
            }

        }
    });

    var Application = langx.Evented.inherit({
        klassName: "SpaApplication",

        init: function(config) {
            if (app) {
                return app;
            }
            var plugins = this._plugins = {};

            config = this._config = langx.mixin({
                plugins: {}
            }, config, true);

            langx.each(config.plugins, function(pluginName, setting) {
                plugins[pluginName] = new Plugin(pluginName, setting);
            });

            router.routes(config.routes);

            this._router = router;

            this._page = new spa.Page(config.page);

            document.title = config.title;
            var baseUrl = config.baseUrl;
            if (baseUrl === undefined) {
                baseUrl = config.baseUrl = (new langx.URL(document.baseURI)).pathname;
            }
            router.baseUrl(baseUrl);

            if (config.homePath) {
                router.homePath(config.homePath);
            }

            app = this;
        },

        baseUrl : function() {
            return router.baseUrl();
        },

        getConfig: function(key) {
            return key ? this._config[key] : this._config;
        },

        go: function(path, force) {
            router.go(path, force);
            return this;
        },

        page: function() {
            return this._page;
        },

        prepare: function() {
            if (this._prepared) {
                return Deferred.resolve();
            }
            var self = this;

            var promises0 = langx.map(this._plugins, function(plugin, name) {
                if (plugin.isHooked("starting")) {
                    return plugin.prepare();
                }
            });

            return Deferred.all(promises0).then(function() {
                router.trigger(createEvent("starting", {
                    spa: self
                }));
                var promises1 = langx.map(router.routes(), function(route, name) {
                        if (route.lazy === false) {
                            return route.prepare();
                        }
                    }),
                    promises2 = langx.map(self._plugins, function(plugin, name) {
                        if (!plugin.isHooked("starting")) {
                            return plugin.prepare();
                        }
                    });


                return Deferred.all(promises1.concat(promises2)).then(function() {
                    self._prepared = true;
                });
            });
        },

        run: function() {
            this._router.start();
            router.trigger(createEvent("started", {
                spa: this
            }));
        }
    });

    var app;
    var spa = function(config) {
        if (!app) {
            window[config.name || "app"] = app = new spa.Application(config);
        }

        return app;
    }

    langx.mixin(spa, {
        "Application": Application,

        "Page": Page,

        "Plugin": Plugin,
        "PluginController": PluginController,

        "Route": Route,

        "router" : router,
        
        "RouteController": RouteController

    });

    return skylark.attach("appify.spa",spa);
});

define('skylark-appify-spa/main',[
    "./spa"
], function(spa) {
    return spa;
});

define('skylark-appify-spa', ['skylark-appify-spa/main'], function (main) { return main; });

define('skylark-data-entities/entities',[
    "skylark-langx/langx"
], function(langx) {
    function entities() {
        return entities;
    }

    langx.mixin(entities, {
        // set a `X-Http-Method-Override` header.
        emulateHTTP : false,

        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... this will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        emulateJSON : false,

        backends : {
            
        }
    });


    return entities;
});

define('skylark-data-entities/Entity',[
	"skylark-langx/langx",
	"./entities"
],function(langx,entities){
   // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

 
  var Entity = langx.Stateful.inherit({
    sync: function() {
      return entities.sync.apply(this, arguments);
    },

    // Get the HTML-escaped value of an attribute.
    //escape: function(attr) {
    //  return _.escape(this.get(attr));
    //},

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return langx.isMatch(this.attributes,attrs);
    },

    // Fetch the entity from the server, merging the response with the entity's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = langx.mixin({parse: true}, options);
      var entity = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;
        if (!entity.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, entity, resp, options);
        entity.trigger('sync', entity, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of entity attributes, and sync the entity to the server.
    // If the server returns an attributes hash that differs, the entity's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = langx.mixin({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the entity will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var entity = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        entity.attributes = attributes;
        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;
        if (wait) serverAttrs = langx.mixin({}, attrs, serverAttrs);
        if (serverAttrs && !entity.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, entity, resp, options);
        entity.trigger('sync', entity, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = langx.mixin({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this entity on the server if it was already persisted.
    // Optimistically removes the entity from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? langx.clone(options) : {};
      var entity = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        entity.stopListening();
        entity.trigger('destroy', entity, entity.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, entity, resp, options);
        if (!entity.isNew()) entity.trigger('sync', entity, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        langx.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the entity's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        langx.result(this, 'urlRoot') ||
        langx.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the entity. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    }
  });

  return entities.Entity = Entity;

});
define('skylark-data-entities/Collection',[
	"skylark-langx/langx",
	"./entities",
	"./Entity"
],function(langx,entities,Entity){
  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };


	var Collection  = langx.Evented.inherit({
		"_construct" : function(entities, options) {
			options || (options = {});
			if (options.entity) this.entity = options.entity;
			if (options.comparator !== void 0) this.comparator = options.comparator;
			this._reset();
			if (entities) this.reset(entities, langx.mixin({silent: true}, options));
		}
	}); 

	// Default options for `Collection#set`.
	var setOptions = {add: true, remove: true, merge: true};
	var addOptions = {add: true, remove: false};

	// Splices `insert` into `array` at index `at`.
	var splice = function(array, insert, at) {
		at = Math.min(Math.max(at, 0), array.length);
		var tail = Array(array.length - at);
		var length = insert.length;
		var i;
		for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
		for (i = 0; i < length; i++) array[i + at] = insert[i];
		for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	};

  // Define the Collection's inheritable methods.
	Collection.partial({

		// The default entity for a collection is just a **Entity**.
		// This should be overridden in most cases.
		entity: Entity,

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// The JSON representation of a Collection is an array of the
		// entities' attributes.
		toJSON: function(options) {
		  return this.map(function(entity) { return entity.toJSON(options); });
		},

		// Proxy `entities.sync` by default.
		sync: function() {
		  return entities.sync.apply(this, arguments);
		},

		// Add a entity, or list of entities to the set. `entities` may be Backbone
		// Entitys or raw JavaScript objects to be converted to Entitys, or any
		// combination of the two.
		add: function(entities, options) {
		  return this.set(entities, langx.mixin({merge: false}, options, addOptions));
		},

		// Remove a entity, or a list of entities from the set.
		remove: function(entities, options) {
		  options = langx.mixin({}, options);
		  var singular = !langx.isArray(entities);
		  entities = singular ? [entities] : entities.slice();
		  var removed = this._removeEntitys(entities, options);
		  if (!options.silent && removed.length) {
		    options.changes = {added: [], merged: [], removed: removed};
		    this.trigger('update', this, options);
		  }
		  return singular ? removed[0] : removed;
		},

		// Update a collection by `set`-ing a new list of entities, adding new ones,
		// removing entities that are no longer present, and merging entities that
		// already exist in the collection, as necessary. Similar to **Entity#set**,
		// the core operation for updating the data contained by the collection.
		set: function(entities, options) {
		  if (entities == null) return;

		  options = langx.mixin({}, setOptions, options);
		  if (options.parse && !this._isEntity(entities)) {
		    entities = this.parse(entities, options) || [];
		  }

		  var singular = !langx.isArray(entities);
		  entities = singular ? [entities] : entities.slice();

		  var at = options.at;
		  if (at != null) at = +at;
		  if (at > this.length) at = this.length;
		  if (at < 0) at += this.length + 1;

		  var set = [];
		  var toAdd = [];
		  var toMerge = [];
		  var toRemove = [];
		  var modelMap = {};

		  var add = options.add;
		  var merge = options.merge;
		  var remove = options.remove;

		  var sort = false;
		  var sortable = this.comparator && at == null && options.sort !== false;
		  var sortAttr = langx.isString(this.comparator) ? this.comparator : null;

		  // Turn bare objects into entity references, and prevent invalid entities
		  // from being added.
		  var entity, i;
		  for (i = 0; i < entities.length; i++) {
		    entity = entities[i];

		    // If a duplicate is found, prevent it from being added and
		    // optionally merge it into the existing entity.
		    var existing = this.get(entity);
		    if (existing) {
		      if (merge && entity !== existing) {
		        var attrs = this._isEntity(entity) ? entity.attributes : entity;
		        if (options.parse) attrs = existing.parse(attrs, options);
		        existing.set(attrs, options);
		        toMerge.push(existing);
		        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
		      }
		      if (!modelMap[existing.cid]) {
		        modelMap[existing.cid] = true;
		        set.push(existing);
		      }
		      entities[i] = existing;

		    // If this is a new, valid entity, push it to the `toAdd` list.
		    } else if (add) {
		      entity = entities[i] = this._prepareEntity(entity, options);
		      if (entity) {
		        toAdd.push(entity);
		        this._addReference(entity, options);
		        modelMap[entity.cid] = true;
		        set.push(entity);
		      }
		    }
		  }

		  // Remove stale entities.
		  if (remove) {
		    for (i = 0; i < this.length; i++) {
		      entity = this.entities[i];
		      if (!modelMap[entity.cid]) toRemove.push(entity);
		    }
		    if (toRemove.length) this._removeEntitys(toRemove, options);
		  }

		  // See if sorting is needed, update `length` and splice in new entities.
		  var orderChanged = false;
		  var replace = !sortable && add && remove;
		  if (set.length && replace) {
		    orderChanged = this.length !== set.length || this.entities.some(function(m, index) {
		      return m !== set[index];
		    });
		    this.entities.length = 0;
		    splice(this.entities, set, 0);
		    this.length = this.entities.length;
		  } else if (toAdd.length) {
		    if (sortable) sort = true;
		    splice(this.entities, toAdd, at == null ? this.length : at);
		    this.length = this.entities.length;
		  }

		  // Silently sort the collection if appropriate.
		  if (sort) this.sort({silent: true});

		  // Unless silenced, it's time to fire all appropriate add/sort/update events.
		  if (!options.silent) {
		    for (i = 0; i < toAdd.length; i++) {
		      if (at != null) options.index = at + i;
		      entity = toAdd[i];
		      entity.trigger('add', entity, this, options);
		    }
		    if (sort || orderChanged) this.trigger('sort', this, options);
		    if (toAdd.length || toRemove.length || toMerge.length) {
		      options.changes = {
		        added: toAdd,
		        removed: toRemove,
		        merged: toMerge
		      };
		      this.trigger('update', this, options);
		    }
		  }

		  // Return the added (or merged) entity (or entities).
		  return singular ? entities[0] : entities;
		},

		// When you have more items than you want to add or remove individually,
		// you can reset the entire set with a new list of entities, without firing
		// any granular `add` or `remove` events. Fires `reset` when finished.
		// Useful for bulk operations and optimizations.
		reset: function(entities, options) {
		  options = options ? langx.clone(options) : {};
		  for (var i = 0; i < this.entities.length; i++) {
		    this._removeReference(this.entities[i], options);
		  }
		  options.previousEntitys = this.entities;
		  this._reset();
		  entities = this.add(entities, langx.mixin({silent: true}, options));
		  if (!options.silent) this.trigger('reset', this, options);
		  return entities;
		},

		// Add a entity to the end of the collection.
		push: function(entity, options) {
		  return this.add(entity, langx.mixin({at: this.length}, options));
		},

		// Remove a entity from the end of the collection.
		pop: function(options) {
		  var entity = this.at(this.length - 1);
		  return this.remove(entity, options);
		},

		// Add a entity to the beginning of the collection.
		unshift: function(entity, options) {
		  return this.add(entity, langx.mixin({at: 0}, options));
		},

		// Remove a entity from the beginning of the collection.
		shift: function(options) {
		  var entity = this.at(0);
		  return this.remove(entity, options);
		},

		// Slice out a sub-array of entities from the collection.
		slice: function() {
		  return slice.apply(this.entities, arguments);
		},

		// Get a entity from the set by id, cid, entity object with id or cid
		// properties, or an attributes object that is transformed through entityId.
		get: function(obj) {
		  if (obj == null) return void 0;
		  return this._byId[obj] ||
		    this._byId[this.entityId(obj.attributes || obj)] ||
		    obj.cid && this._byId[obj.cid];
		},

		// Returns `true` if the entity is in the collection.
		has: function(obj) {
		  return this.get(obj) != null;
		},

		// Get the entity at the given index.
		at: function(index) {
		  if (index < 0) index += this.length;
		  return this.entities[index];
		},

		// Return entities with matching attributes. Useful for simple cases of
		// `filter`.
		where: function(attrs, first) {
		  return this[first ? 'find' : 'filter'](attrs);
		},

		// Return the first entity with matching attributes. Useful for simple cases
		// of `find`.
		findWhere: function(attrs) {
		  return this.where(attrs, true);
		},

		// Force the collection to re-sort itself. You don't need to call this under
		// normal circumstances, as the set will maintain sort order as each item
		// is added.
		sort: function(options) {
		  var comparator = this.comparator;
		  if (!comparator) throw new Error('Cannot sort a set without a comparator');
		  options || (options = {});

		  var length = comparator.length;
		  if (langx.isFunction(comparator)) comparator = langx.proxy(comparator, this);

		  // Run sort based on type of `comparator`.
		  if (length === 1 || langx.isString(comparator)) {
		    this.entities = this.sortBy(comparator);
		  } else {
		    this.entities.sort(comparator);
		  }
		  if (!options.silent) this.trigger('sort', this, options);
		  return this;
		},

		// Pluck an attribute from each entity in the collection.
		pluck: function(attr) {
		  return this.map(attr + '');
		},

		// Fetch the default set of entities for this collection, resetting the
		// collection when they arrive. If `reset: true` is passed, the response
		// data will be passed through the `reset` method instead of `set`.
		fetch: function(options) {
		  options = langx.mixin({parse: true}, options);
		  var success = options.success;
		  var collection = this;
		  options.success = function(resp) {
		    var method = options.reset ? 'reset' : 'set';
		    collection[method](resp, options);
		    if (success) success.call(options.context, collection, resp, options);
		    collection.trigger('sync', collection, resp, options);
		  };
		  wrapError(this, options);
		  return this.sync('read', this, options);
		},

		// Create a new instance of a entity in this collection. Add the entity to the
		// collection immediately, unless `wait: true` is passed, in which case we
		// wait for the server to agree.
		create: function(entity, options) {
		  options = options ? langx.clone(options) : {};
		  var wait = options.wait;
		  entity = this._prepareEntity(entity, options);
		  if (!entity) return false;
		  if (!wait) this.add(entity, options);
		  var collection = this;
		  var success = options.success;
		  options.success = function(m, resp, callbackOpts) {
		    if (wait) collection.add(m, callbackOpts);
		    if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
		  };
		  entity.save(null, options);
		  return entity;
		},

		// **parse** converts a response into a list of entities to be added to the
		// collection. The default implementation is just to pass it through.
		parse: function(resp, options) {
		  return resp;
		},

		// Create a new collection with an identical list of entities as this one.
		clone: function() {
		  return new this.constructor(this.entities, {
		    entity: this.entity,
		    comparator: this.comparator
		  });
		},

		// Define how to uniquely identify entities in the collection.
		entityId: function(attrs) {
		  return attrs[this.entity.prototype.idAttribute || 'id'];
		},

		// Private method to reset all internal state. Called when the collection
		// is first initialized or reset.
		_reset: function() {
		  this.length = 0;
		  this.entities = [];
		  this._byId  = {};
		},

		// Prepare a hash of attributes (or other entity) to be added to this
		// collection.
		_prepareEntity: function(attrs, options) {
		  if (this._isEntity(attrs)) {
		    if (!attrs.collection) attrs.collection = this;
		    return attrs;
		  }
		  options = options ? langx.clone(options) : {};
		  options.collection = this;
		  var entity = new this.entity(attrs, options);
		  if (!entity.validationError) return entity;
		  this.trigger('invalid', this, entity.validationError, options);
		  return false;
		},

		// Internal method called by both remove and set.
		_removeEntitys: function(entities, options) {
		  var removed = [];
		  for (var i = 0; i < entities.length; i++) {
		    var entity = this.get(entities[i]);
		    if (!entity) continue;

		    var index = this.indexOf(entity);
		    this.entities.splice(index, 1);
		    this.length--;

		    // Remove references before triggering 'remove' event to prevent an
		    // infinite loop. #3693
		    delete this._byId[entity.cid];
		    var id = this.entityId(entity.attributes);
		    if (id != null) delete this._byId[id];

		    if (!options.silent) {
		      options.index = index;
		      entity.trigger('remove', entity, this, options);
		    }

		    removed.push(entity);
		    this._removeReference(entity, options);
		  }
		  return removed;
		},

		// Method for checking whether an object should be considered a entity for
		// the purposes of adding to the collection.
		_isEntity: function(entity) {
		  return entity instanceof Entity;
		},

		// Internal method to create a entity's ties to a collection.
		_addReference: function(entity, options) {
		  this._byId[entity.cid] = entity;
		  var id = this.entityId(entity.attributes);
		  if (id != null) this._byId[id] = entity;
		  entity.on('all', this._onEntityEvent, this);
		},

		// Internal method to sever a entity's ties to a collection.
		_removeReference: function(entity, options) {
		  delete this._byId[entity.cid];
		  var id = this.entityId(entity.attributes);
		  if (id != null) delete this._byId[id];
		  if (this === entity.collection) delete entity.collection;
		  entity.off('all', this._onEntityEvent, this);
		},

		// Internal method called every time a entity in the set fires an event.
		// Sets need to update their indexes when entities change ids. All other
		// events simply proxy through. "add" and "remove" events that originate
		// in other collections are ignored.
		_onEntityEvent: function(event, entity, collection, options) {
		  if (entity) {
		    if ((event === 'add' || event === 'remove') && collection !== this) return;
		    if (event === 'destroy') this.remove(entity, options);
		    if (event === 'change') {
		      var prevId = this.entityId(entity.previousAttributes());
		      var id = this.entityId(entity.attributes);
		      if (prevId !== id) {
		        if (prevId != null) delete this._byId[prevId];
		        if (id != null) this._byId[id] = entity;
		      }
		    }
		  }
		  this.trigger.apply(this, arguments);
		}

  	});

	return entities.Collection = Collection;
});
define('skylark-data-entities/backends/registry',[
	
],function(){
	var providers = {

	};

	function add(name,setting) {
		providers[name] = setting;
	}

	function remove(name) {
		delete provides[name];
	}

	function get(name) {
		return providers[name];
	}

	return {
		add : add,
		remove: remove,
		get : get
	}
});
define('skylark-data-entities/sync',[
	"skylark-langx/langx",
	"./entities",
  	"./backends/registry"
],function(langx,entities,registry){

	// Override 'Backbone.sync' to default to localSync,
	// the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'
	function sync(method, model, options) {
		if (!options.backend) {
			throw new Error("The backend is not specified")
		}
		var setting = registry.get(options.backend);
		if (!setting) {
			throw new Error("The backend is not defined:" + options.backend);
		}
		var syncMethod = setting.sync;
		if (!syncMethod) {
			throw new Error("The backend sync method is not defined:" + options.backend);
		}

		var options2 = langx.mixin({},setting.options,options);
	  	return syncMethod.apply(this, [method, model, options2]);
	};

  
   return entities.sync = sync;

});
define('skylark-data-entities/backends/ajaxSync',[
	"skylark-langx/langx",
	"../entities"
],function(langx,entities){
// Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  };
  

  var sync = function(method, entity, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    langx.defaults(options || (options = {}), {
      emulateHTTP: entities.emulateHTTP,
      emulateJSON: entities.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = langx.result(entity, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && entity && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || entity.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {entity: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = langx.Xhr.request(langx.mixin(params, options));
    entity.trigger('request', entity, xhr, options);
    return xhr;
  };

 
  
  return entities.backends.ajaxSync = sync;

});
define('skylark-data-entities/backends/localSync',[
  "skylark-langx/langx",
  "../entities"
],function(langx,entities){

  // A simple module to replace `Backbone.sync` with *localStorage*-based
  // persistence. Models are given GUIDS, and saved into a JSON object. Simple
  // as that.

  // Hold reference to Underscore.js and Backbone.js in the closure in order
  // to make things work even if they are removed from the global namespace

  // Generate four random hex digits.
  function S4() {
     return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
  };

  // Generate a pseudo-GUID by concatenating random hexadecimal.
  function guid() {
     return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
  };

  // Our Store is represented by a single JS object in *localStorage*. Create it
  // with a meaningful name, like the name you'd give a table.
  // window.Store is deprecated, use Backbone.LocalStorage instead
  var LocalStorage = langx.klass({
    _construct : function(name) {
      this.name = name;
      var store = this.localStorage().getItem(this.name);
      this.records = (store && store.split(",")) || [];
    },

    // Save the current state of the **Store** to *localStorage*.
    save: function() {
      this.localStorage().setItem(this.name, this.records.join(","));
    },

    // Add a model, giving it a (hopefully)-unique GUID, if it doesn't already
    // have an id of it's own.
    create: function(model) {
      if (!model.id) {
        model.id = guid();
        model.set(model.idAttribute, model.id);
      }
      this.localStorage().setItem(this.name+"-"+model.id, JSON.stringify(model));
      this.records.push(model.id.toString());
      this.save();
      return this.find(model);
    },

    // Update a model by replacing its copy in `this.data`.
    update: function(model) {
      this.localStorage().setItem(this.name+"-"+model.id, JSON.stringify(model));
      if (!_.include(this.records, model.id.toString()))
        this.records.push(model.id.toString()); this.save();
      return this.find(model);
    },

    // Retrieve a model from `this.data` by id.
    find: function(model) {
      return this.jsonData(this.localStorage().getItem(this.name+"-"+model.id));
    },

    // Return the array of all entities currently in storage.
    findAll: function() {
      return _(this.records).chain()
        .map(function(id){
          return this.jsonData(this.localStorage().getItem(this.name+"-"+id));
        }, this)
        .compact()
        .value();
    },

    // Delete a model from `this.data`, returning it.
    destroy: function(model) {
      if (model.isNew())
        return false
      this.localStorage().removeItem(this.name+"-"+model.id);
      this.records = _.reject(this.records, function(id){
        return id === model.id.toString();
      });
      this.save();
      return model;
    },

    localStorage: function() {
      return localStorage;
    },

    // fix for "illegal access" error on Android when JSON.parse is passed null
    jsonData: function (data) {
        return data && JSON.parse(data);
    }

  });

  // localSync delegate to the model or collection's
  // *localStorage* property, which should be an instance of `Store`.
  function sync(method, model, options) {
    var store = model.localStorage || model.collection.localStorage;

    var resp, errorMessage, syncDfd = langx.Deferred(); //If $ is having Deferred - use it.

    try {

      switch (method) {
        case "read":
          resp = model.id != undefined ? store.find(model) : store.findAll();
          break;
        case "create":
          resp = store.create(model);
          break;
        case "update":
          resp = store.update(model);
          break;
        case "delete":
          resp = store.destroy(model);
          break;
      }

    } catch(error) {
      if (error.code === DOMException.QUOTA_EXCEEDED_ERR && window.localStorage.length === 0)
        errorMessage = "Private browsing is unsupported";
      else
        errorMessage = error.message;
    }

    if (resp) {
      model.trigger("sync", model, resp, options);
      if (options && options.success)
        options.success(resp);
      if (syncDfd)
        syncDfd.resolve(resp);

    } else {
      errorMessage = errorMessage ? errorMessage
                                  : "Record Not Found";

      if (options && options.error)
        options.error(errorMessage);
      if (syncDfd)
        syncDfd.reject(errorMessage);
    }

    // add compatibility with $.ajax
    // always execute callback for success and error
    if (options && options.complete) options.complete(resp);

    return syncDfd && syncDfd.promise();
  };

  entities.backends.LocalStorage = sync.LocalStorage = LocalStorage;
  
  return entities.backends.localSync = sync;

});
define('skylark-data-entities/main',[
	"./entities",
	"./Collection",
	"./Entity",
	"./sync",
	"./backends/ajaxSync",
	"./backends/localSync",
	"./backends/registry"
],function(entities){
	return entities;
});
define('skylark-data-entities', ['skylark-data-entities/main'], function (main) { return main; });

define('skylark-domx-forms/forms',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("domx.forms",{});
});
define('skylark-domx-forms/deserialize',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./forms"
],function(langx,$,forms){
  /**
   * Updates a key/valueArray with the given property and value. Values will always be stored as arrays.
   *
   * @param prop The property to add the value to.
   * @param value The value to add.
   * @param obj The object to update.
   * @returns {object} Updated object.
   */
  function updateKeyValueArray( prop, value, obj ) {
    var current = obj[ prop ];

    if ( current === undefined ) {
      obj[ prop ] = [ value ];
    } else {
      current.push( value );
    }

    return obj;
  }

  /**
   * Get all of the fields contained within the given elements by name.
   *
   * @param formElm The form element.
   * @param filter Custom filter to apply to the list of fields.
   * @returns {object} All of the fields contained within the given elements, keyed by name.
   */
  function getFieldsByName(formElm, filter ) {
    var elementsByName = {};

    // Extract fields from elements
    var fields = $(formElm)
      .map(function convertFormToElements() {
        return this.elements ? langx.makeArray( this.elements ) : this;
      })
      .filter( filter || ":input:not(:disabled)" )
      .get();

    langx.each( fields, function( index, field ) {
      updateKeyValueArray( field.name, field, elementsByName );
    });

    return elementsByName;
  }

  /**
   * Figure out the type of an element. Input type will be used first, falling back to nodeName.
   *
   * @param element DOM element to check type of.
   * @returns {string} The element's type.
   */
  function getElementType( element ) {
    return ( element.type || element.nodeName ).toLowerCase();
  }

  /**
   * Normalize the provided data into a key/valueArray store.
   *
   * @param data The data provided by the user to the plugin.
   * @returns {object} The data normalized into a key/valueArray store.
   */
  function normalizeData( data ) {
    var normalized = {};
    var rPlus = /\+/g;

    // Convert data from .serializeObject() notation
    if ( langx.isPlainObject( data ) ) {
      langx.extend( normalized, data );

      // Convert non-array values into an array
      langx.each( normalized, function( name, value ) {
        if ( !langx.isArray( value ) ) {
          normalized[ name ] = [ value ];
        }
      });

    // Convert data from .serializeArray() notation
    } else if ( langx.isArray( data ) ) {
      langx.each( data, function( index, field ) {
        updateKeyValueArray( field.name, field.value, normalized );
      });

    // Convert data from .serialize() notation
    } else if ( typeof data === "string" ) {
      langx.each( data.split( "&" ), function( index, field ) {
        var current = field.split( "=" );
        var name = decodeURIComponent( current[ 0 ].replace( rPlus, "%20" ) );
        var value = decodeURIComponent( current[ 1 ].replace( rPlus, "%20" ) );
        updateKeyValueArray( name, value, normalized );
      });
    }

    return normalized;
  }

  /**
   * Map of property name -> element types.
   *
   * @type {object}
   */
  var updateTypes = {
    checked: [
      "radio",
      "checkbox"
    ],
    selected: [
      "option",
      "select-one",
      "select-multiple"
    ],
    value: [
      "button",
      "color",
      "date",
      "datetime",
      "datetime-local",
      "email",
      "hidden",
      "month",
      "number",
      "password",
      "range",
      "reset",
      "search",
      "submit",
      "tel",
      "text",
      "textarea",
      "time",
      "url",
      "week"
    ]
  };

  /**
   * Get the property to update on an element being updated.
   *
   * @param element The DOM element to get the property for.
   * @returns The name of the property to update if element is supported, otherwise `undefined`.
   */
  function getPropertyToUpdate( element ) {
    var type = getElementType( element );
    var elementProperty = undefined;

    langx.each( updateTypes, function( property, types ) {
      if ( langx.inArray( type, types ) > -1 ) {
        elementProperty = property;
        return false;
      }
    });

    return elementProperty;
  }

  /**
   * Update the element based on the provided data.
   *
   * @param element The DOM element to update.
   * @param elementIndex The index of this element in the list of elements with the same name.
   * @param value The serialized element value.
   * @param valueIndex The index of the value in the list of values for elements with the same name.
   * @param callback A function to call if the value of an element was updated.
   */
  function update( element, elementIndex, value, valueIndex, callback ) {
    var property = getPropertyToUpdate( element );

    // Handle value inputs
    // If there are multiple value inputs with the same name, they will be populated by matching indexes.
    if ( property == "value" && elementIndex == valueIndex ) {
      element.value = value;
      callback.call( element, value );

    // Handle select menus, checkboxes and radio buttons
    } else if ( property == "checked" || property == "selected" ) {
      var fields = [];

      // Extract option fields from select menus
      if ( element.options ) {
        langx.each( element.options, function( index, option ) {
          fields.push( option );
        });

      } else {
        fields.push( element );
      }

      // #37: Remove selection from multiple select menus before deserialization
      if ( element.multiple && valueIndex == 0 ) {
        element.selectedIndex = -1;
      }

      langx.each( fields, function( index, field ) {
        if ( field.value == value ) {
          field[ property ] = true;
          callback.call( field, value );
        }
      });
    }
  }

  /**
   * Default plugin options.
   *
   * @type {object}
   */
  var defaultOptions = {
    change: langx.noop,
    complete: langx.noop
  };

  /**
   * The $.deserialize function.
   *
   * @param data The data to deserialize.
   * @param options Additional options.
   * @returns {jQuery} The jQuery object that was provided to the plugin.
   */
  function deserialize(formElm,data, options ) {

    // Backwards compatible with old arguments: data, callback
    if ( langx.isFunction( options ) ) {
      options = { complete: options };
    }

    options = langx.extend( defaultOptions, options || {} );
    data = normalizeData( data );

    var elementsByName = getFieldsByName( formElm, options.filter );

    langx.each( data, function( name, values ) {
      langx.each( elementsByName[ name ], function( elementIndex, element ) {
        langx.each( values, function( valueIndex, value ) {
          update( element, elementIndex, value, valueIndex, options.change );
        });
      });
    });

    options.complete.call( formElm );

    return this;
  };

  return forms.deserialize = deserialize;
});
define('skylark-domx-forms/serialize-array',[
  "skylark-langx/langx",
  "skylark-domx-data",
  "./forms"
],function(langx,datax,forms){
    function serializeArray(formElm) {
        var name, type, result = [],
            add = function(value) {
                if (value.forEach) return value.forEach(add)
                result.push({ name: name, value: value })
            }
        langx.each(formElm.elements, function(_, field) {
            type = field.type, name = field.name
            if (name && field.nodeName.toLowerCase() != 'fieldset' &&
                !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&
                ((type != 'radio' && type != 'checkbox') || field.checked))
                add(datax.val(field))
        })
        return result
    };

    return forms.serializeArray = serializeArray;
});

define('skylark-domx-forms/serialize-object',[
  "skylark-langx/langx",
  "./forms",
  "./serialize-array"
],function(langx,forms,serializeArray){

  function serializeObject(formElm){
    var obj = {};
    
    langx.each(serializeArray(formElm), function(i,o){
      var n = o.name,
        v = o.value;
        
        obj[n] = obj[n] === undefined ? v
          : langx.isArray( obj[n] ) ? obj[n].concat( v )
          : [ obj[n], v ];
    });
    
    return obj;
  }

  return forms.serializeObject = serializeObject;
});  
define('skylark-domx-forms/serialize',[
  "skylark-langx/langx",
  "./forms",
  "./serialize-array"
],function(langx,forms,serializeArray){
    function serialize(formElm) {
        var result = []
        serializeArray(formElm).forEach(function(elm) {
            result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))
        })
        return result.join('&')
    }

    return forms.serialize = serialize;
});
define('skylark-domx-forms/main',[
	"./forms",
    "skylark-domx-velm",
    "skylark-domx-query",
    "./deserialize",
    "./serialize-array",
    "./serialize-object",
    "./serialize"
],function(forms,velm,$){

    // from ./data
    velm.delegate([
        "deserialize",
        "serializeArray",
        "serializeObject",
        "serialize"
    ], forms);

    $.fn.deserialize = $.wraps.wrapper_value(forms.deserialize, forms, forms.deserialize);
    $.fn.serializeArray = $.wraps.wrapper_value(forms.serializeArray, forms, forms.serializeArray);
    $.fn.serializeObject = $.wraps.wrapper_value(forms.serializeObject, forms, forms.serializeObject);
    $.fn.serialize = $.wraps.wrapper_value(forms.serialize, forms, forms.serialize);


	return forms;
});
define('skylark-domx-forms', ['skylark-domx-forms/main'], function (main) { return main; });

define('skylark-jquery/core',[
	"skylark-langx/skylark",
	"skylark-langx/langx",
	"skylark-domx-browser",
	"skylark-domx-noder",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-finder",
	"skylark-domx-forms",
	"skylark-domx-fx",
	"skylark-domx-styler",
	"skylark-domx-query",
	"skylark-langx-scripter"
],function(skylark,langx,browser,noder,datax,eventer,finder,forms,fx,styler,query,scripter){
	var filter = Array.prototype.filter,
		slice = Array.prototype.slice;

    (function($){
	    $.fn.jquery = '2.2.0';

	    $.browser = browser;
	    
	    $.camelCase = langx.camelCase;

		$.cleanData = function( elems ) {
			var elem,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				datax.cleanData(elem);
			}
		};

		$.removeData = function(elm,name) {
			datax.removeData(elm,name);
		}
	
	    $.each = langx.each;

	    $.extend = langx.extend;

	    $.grep = function(elements, callback) {
	        return filter.call(elements, callback)
	    };

	    $.attr = function(elm,name) {
	    	return datax.attr(elm,name);
	    };

	    $.isArray = langx.isArray;
	    $.isEmptyObject = langx.isEmptyObject;
	    $.isFunction = langx.isFunction;
	    $.isWindow = langx.isWindow;
	    $.isPlainObject = langx.isPlainObject;
        $.isNumeric = langx.isNumber;

	    $.inArray = langx.inArray;

	    $.makeArray = langx.makeArray;
	    $.map = langx.map;  // The behavior is somewhat different from the original jquery.

	    $.noop = function() {
	    };

	    $.parseJSON = window.JSON.parse;

	    $.proxy = langx.proxy;

	    $.trim = langx.trim;
	    $.type = langx.type;

	    $.fn.extend = function(props) {
	        langx.mixin($.fn, props);
	    };


    })(query);

    (function($){
        $.Event = function Event(src, props) {
            if (langx.isString(src)) {
            	var type = src;
            	return eventer.create(type, props);
	        }
            return eventer.proxy(src, props);
        };

        $.event = {};

	    $.event.special = eventer.special;

	    $.fn.submit = function(callback) {
	        if (0 in arguments) this.bind('submit', callback)
	        else if (this.length) {
	            var event = $.Event('submit')
	            this.eq(0).trigger(event)
	            if (!event.isDefaultPrevented()) this.get(0).submit()
	        }
	        return this
	    };

	    // event
	    $.fn.triggerHandler = $.fn.trigger;

	    $.fn.delegate = function(selector, event, callback) {
	        return this.on(event, selector, callback)
	    };

	    $.fn.undelegate = function(selector, event, callback) {
	        return this.off(event, selector, callback)
	    };

	    $.fn.live = function(event, callback) {
	        $(document.body).delegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.die = function(event, callback) {
	        $(document.body).undelegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.bind = function(event, selector, data, callback) {
	        return this.on(event, selector, data, callback)
	    };

	    $.fn.unbind = function(event, callback) {
	        return this.off(event, callback)
	    };

	    $.fn.ready = function(callback) {
	        eventer.ready(callback);
	        return this;
	    };

	    $.fn.stop = function() {
	        // todo
	        return this;
	    };

	    $.fn.moveto = function(x, y) {
	        return this.animate({
	            left: x + "px",
	            top: y + "px"
	        }, 0.4);

	    };

	    $.ready = eventer.ready;

	    $.on = eventer.on;

	    $.off = eventer.off;
    })(query);

    (function($){
	    // plugin compatibility
	    $.uuid = 0;
	    $.support = browser.support;
	    $.expr = {};

	    $.expr[":"] = $.expr.pseudos = $.expr.filters = finder.pseudos;

	    $.expr.createPseudo = function(fn) {
	    	return fn;
	    };

	    $.cssHooks = styler.cssHooks;

	    $.contains = noder.contains;

	    $.css = styler.css;

	    $.data = datax.data;

	    $.fx = fx;
	    $.fx.step = {

        };

        $.speed = function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? $.extend( {}, speed ) : {
                complete: fn || !fn && easing ||
                    $.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !$.isFunction( easing ) && easing
            };

            // Go to the end state if fx are off
            if ( $.fx.off ) {
                opt.duration = 0;

            } else {
                if ( typeof opt.duration !== "number" ) {
                    if ( opt.duration in $.fx.speeds ) {
                        opt.duration = $.fx.speeds[ opt.duration ];

                    } else {
                        opt.duration = $.fx.speeds._default;
                    }
                }
            }

            // Normalize opt.queue - true/undefined/null -> "fx"
            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }

            // Queueing
            opt.old = opt.complete;

            opt.complete = function() {
                if ( $.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue ) {
                    $.dequeue( this, opt.queue );
                }
            };

            return opt;
        };

        $.easing = {};

	    $.offset = {};
	    $.offset.setOffset = function(elem, options, i) {
	        var position = $.css(elem, "position");

	        // set position first, in-case top/left are set even on static elem
	        if (position === "static") {
	            elem.style.position = "relative";
	        }

	        var curElem = $(elem),
	            curOffset = curElem.offset(),
	            curCSSTop = $.css(elem, "top"),
	            curCSSLeft = $.css(elem, "left"),
	            calculatePosition = (position === "absolute" || position === "fixed") && $.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
	            props = {},
	            curPosition = {},
	            curTop, curLeft;

	        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
	        if (calculatePosition) {
	            curPosition = curElem.position();
	            curTop = curPosition.top;
	            curLeft = curPosition.left;
	        } else {
	            curTop = parseFloat(curCSSTop) || 0;
	            curLeft = parseFloat(curCSSLeft) || 0;
	        }

	        if ($.isFunction(options)) {
	            options = options.call(elem, i, curOffset);
	        }

	        if (options.top != null) {
	            props.top = (options.top - curOffset.top) + curTop;
	        }
	        if (options.left != null) {
	            props.left = (options.left - curOffset.left) + curLeft;
	        }

	        if ("using" in options) {
	            options.using.call(elem, props);
	        } else {
	            curElem.css(props);
	        }
	    };

        $._data = function(elm,propName) {
            if (elm.hasAttribute) {
                return datax.data(elm,propName);
            } else {
                return {};
            }
        };

     	var t = $.fn.text;  
	    $.fn.text = function(v) {
	        var r = t.apply(this,arguments);
	        if (r === undefined) {
	            r = "";
	        }  
	        return r;
	    };       

	    $.fn.pos = $.fn.position;
        	    
    })(query);

    query.parseHTML = function(html) {
        return  noder.createFragment(html);
    };

    query.uniqueSort = query.unique = langx.uniq;

    query.skylark = skylark;

    return window.jQuery = window.$ = query;
});

define('skylark-jquery/ajax',[
    "skylark-langx/langx",
    "skylark-net-http/xhr",
    "./core",
], function(langx,Xhr,$) {
    var jsonpID = 0;

     // Attach a bunch of functions for handling common AJAX events
    $.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( i, type ) {
        $.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );
   

    function appendQuery(url, query) {
        if (query == '') return url
        return (url + '&' + query).replace(/[&?]{1,2}/, '?')
    }
    
    $.ajaxJSONP = function(options) {
        var deferred = new langx.Deferred();
        var _callbackName = options.jsonpCallback,
            callbackName = ($.isFunction(_callbackName) ?
                _callbackName() : _callbackName) || ('jsonp' + (++jsonpID)),
            script = document.createElement('script'),
            originalCallback = window[callbackName],
            responseData,
            abort = function(errorType) {
                $(script).triggerHandler('error', errorType || 'abort')
            },
            xhr = { abort: abort },
            abortTimeout;

        for (var key in options.data) {
            options.url = appendQuery(options.url, key + "=" + options.data[key]);
        }
         
//        if (deferred) deferred.promise(xhr)

        $(script).on('load error', function(e, errorType) {
            clearTimeout(abortTimeout)
            $(script).off().remove()

            if (e.type == 'error' || !responseData) {
                deferred.reject(e);
            } else {
                deferred.resolve(responseData[0],200,xhr);
            }

            window[callbackName] = originalCallback
            if (responseData && $.isFunction(originalCallback))
                originalCallback(responseData[0])

            originalCallback = responseData = undefined
        })

        window[callbackName] = function() {
            responseData = arguments
        }

        script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
        document.head.appendChild(script)

        if (options.timeout > 0) abortTimeout = setTimeout(function() {
            abort('timeout')
        }, options.timeout)

        return deferred;
    }

    //$.ajaxSettings = Xhr.defaultOptions;
    //$.ajaxSettings.xhr = function() {
    //    return new window.XMLHttpRequest()
    //};

    $.ajaxSettings = {
        processData : true
    };


    $.ajax = function(url,options) {
        if (!url) {
            options = {
                url :  "./"
            };
        } else if (!options) {
            if (langx.isString(url)) {
                options = {
                    url :  url
                };
            } else {
                options = url;
            }
        } else {
            options.url = url;
        }

        options = langx.mixin({},$.ajaxSettings,options);

        if ('jsonp' == options.dataType) {
            var hasPlaceholder = /\?.+=\?/.test(options.url);

            if (!hasPlaceholder)
                options.url = appendQuery(options.url,
                    options.jsonp ? (options.jsonp + '=?') : options.jsonp === false ? '' : 'callback=?')
            return $.ajaxJSONP(options);
        }

        function ajaxSuccess(data,status,xhr) {
            $(document).trigger("ajaxSucess");
            if (options.success) {
                options.success.apply(this,arguments);
            }
            if (options.complete) {
                options.complete.apply(this,arguments);
            }
            return data;
        }

        function ajaxError() {
            $(document).trigger("ajaxError");
            if (options.error) {
                options.error.apply(this,arguments);
            }
        }

        var p = Xhr.request(options.url,options);
        p = p.then(ajaxSuccess,ajaxError);
        p.success = p.done;
        p.error = p.fail;
        p.complete = p.always;
        
        return p;
    };

    // handle optional data/success arguments
    function parseArguments(url, data, success, dataType) {
        if ($.isFunction(url)) {
            dataType = data, success = url, data = undefined,url = undefined;
        } else if ($.isFunction(data)) {
            dataType = success, success = data, data = undefined;
        } 
        if (!$.isFunction(success)) dataType = success, success = undefined
        return {
            url: url,
            data: data,
            success: success,
            dataType: dataType
        }
    }

    $.get = function( /* url, data, success, dataType */ ) {
        return $.ajax(parseArguments.apply(null, arguments))
    }

    $.post = function( /* url, data, success, dataType */ ) {
        var options = parseArguments.apply(null, arguments)
        options.type = 'POST'
        return $.ajax(options)
    }

    $.getJSON = function( /* url, data, success */ ) {
        var options = parseArguments.apply(null, arguments)
        options.dataType = 'json'
        return $.ajax(options)
    }

    var originalLoad = $.fn.load;

    $.fn.load = function(url, data, success) {
        if ("string" != typeof url && originalLoad) {
            return originalLoad.apply(this, arguments);
        }
        if (!this.length) return this
        var self = this,
            options = parseArguments(url, data, success),
            parts = options.url && options.url.split(/\s/),
            selector,
            callback = options.success
        if (parts && parts.length > 1) options.url = parts[0], selector = parts[1]

        if (options.data && typeof options.data === "object") {
            options.type = "POST";
        }
        options.success = function(response) {
            self.html(selector ?
                $('<div>').html(response.replace(rscript, "")).find(selector) : response)
            callback && callback.apply(self, arguments)
        }
        $.ajax(options)
        return this
    }

    $.param = Xhr.param;


    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    var
        prefilters = {},
        transports = {},
        rnotwhite = (/\S+/g);

    $.ajaxPrefilter = addToPrefiltersOrTransports(prefilters);
    $.ajaxTransport = addToPrefiltersOrTransports(transports);
    $.ajaxSetup = function(target, settings) {
        langx.mixin(Xhr.defaultOptions,target,settings);
    };

    $.getScript = function( url, callback ) {
        return $.get( url, undefined, callback, "script" );
    };

    return $;

});

define('skylark-jquery/callbacks',[
    "./core"
], function($) {

    //     This module is borrow from zepto.callback.js
    //     (c) 2010-2014 Thomas Fuchs
    //     Zepto.js may be freely distributed under the MIT license.

    // Create a collection of callbacks to be fired in a sequence, with configurable behaviour
    // Option flags:
    //   - once: Callbacks fired at most one time.
    //   - memory: Remember the most recent context and arguments
    //   - stopOnFalse: Cease iterating over callback list
    //   - unique: Permit adding at most one instance of the same callback
    $.Callbacks = function(options) {
        options = $.extend({}, options)

        var memory, // Last fire value (for non-forgettable lists)
            fired, // Flag to know if list was already fired
            firing, // Flag to know if list is currently firing
            firingStart, // First callback to fire (used internally by add and fireWith)
            firingLength, // End of the loop when firing
            firingIndex, // Index of currently firing callback (modified by remove if needed)
            list = [], // Actual callback list
            stack = !options.once && [], // Stack of fire calls for repeatable lists
            fire = function(data) {
                memory = options.memory && data
                fired = true
                firingIndex = firingStart || 0
                firingStart = 0
                firingLength = list.length
                firing = true
                for (; list && firingIndex < firingLength; ++firingIndex) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false
                        break
                    }
                }
                firing = false
                if (list) {
                    if (stack) stack.length && fire(stack.shift())
                    else if (memory) list.length = 0
                    else Callbacks.disable()
                }
            },

            Callbacks = {
                add: function() {
                    if (list) {
                        var start = list.length,
                            add = function(args) {
                                $.each(args, function(_, arg) {
                                    if (typeof arg === "function") {
                                        if (!options.unique || !Callbacks.has(arg)) list.push(arg)
                                    } else if (arg && arg.length && typeof arg !== 'string') add(arg)
                                })
                            }
                        add(arguments)
                        if (firing) firingLength = list.length
                        else if (memory) {
                            firingStart = start
                            fire(memory)
                        }
                    }
                    return this
                },
                remove: function() {
                    if (list) {
                        $.each(arguments, function(_, arg) {
                            var index
                            while ((index = $.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1)
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) --firingLength
                                    if (index <= firingIndex) --firingIndex
                                }
                            }
                        })
                    }
                    return this
                },
                has: function(fn) {
                    return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))
                },
                empty: function() {
                    firingLength = list.length = 0
                    return this
                },
                disable: function() {
                    list = stack = memory = undefined
                    return this
                },
                disabled: function() {
                    return !list
                },
                lock: function() {
                    stack = undefined;
                    if (!memory) Callbacks.disable()
                    return this
                },
                locked: function() {
                    return !stack
                },
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || []
                        args = [context, args.slice ? args.slice() : args]
                        if (firing) stack.push(args)
                        else fire(args)
                    }
                    return this
                },
                fire: function() {
                    return Callbacks.fireWith(this, arguments)
                },
                fired: function() {
                    return !!fired
                }
            }

        return Callbacks
    };

    return $;

});

define('skylark-jquery/deferred',[
    "./core",
    "skylark-langx/langx"
], function($,langx) {

    $.Deferred = function() {
        var d = new langx.Deferred(),
            ret = {
                promise : function() {
                    return d.promise;
                }
            };

        ["resolve","resolveWith","reject","rejectWith","notify","then","done","fail","progress","always","state"].forEach(function(name){
            ret[name] = function() {
              var ret2 =   d[name].apply(d,arguments);
              if (ret2 == d) {
                ret2 = ret;
              }
              return ret2;
            }
        });

        return ret;
    };
    
    $.when = function(){
        var p = langx.Deferred.all(langx.makeArray(arguments)),
            originThen = p.then;
        p.then = function(onResolved,onRejected) {
            var handler = function(results) {
                //results = results.map(function(result){
                //    return [result];
                //});
                return onResolved && onResolved.apply(null,results);
            };
            return originThen.call(p,handler,onRejected);
        };
        return p;
    };

    return $;

});

define('skylark-jquery/queue',[
    "skylark-langx/langx",
    "./core",
    "./callbacks"
], function(langx, $) {

 // jQuery Data object
  var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
      rmultiDash = /([A-Z])/g,
      expando = "Sky" + ( '1.0' + Math.random() ).replace( /\D/g, ""),
      optionsCache = {},
      core_rnotwhite = /\S+/g,
      core_deletedIds = [],
      core_push = core_deletedIds.push;

// Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
      object[ flag ] = true;
    });
    return object;
  }

  function isArraylike( obj ) {
    var length = obj.length,
        type = $.type( obj );

    if ( $.isWindow( obj ) ) {
      return false;
    }

    if ( obj.nodeType === 1 && length ) {
      return true;
    }

    return type === "array" || type !== "function" &&
        ( length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj );
  }

  

  function Data() {
    // Support: Android < 4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    Object.defineProperty( this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });

    this.expando = expando + Math.random();
  }

  Data.uid = 1;

  Data.accepts = function( owner ) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType ?
        owner.nodeType === 1 || owner.nodeType === 9 : true;
  };

  Data.prototype = {
    key: function( owner ) {
      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return the key for a frozen object.
      if ( !Data.accepts( owner ) ) {
        return 0;
      }

      var descriptor = {},
      // Check if the owner object already has a cache key
          unlock = owner[ this.expando ];

      // If not, create one
      if ( !unlock ) {
        unlock = Data.uid++;

        // Secure it in a non-enumerable, non-writable property
        try {
          descriptor[ this.expando ] = { value: unlock };
          Object.defineProperties( owner, descriptor );

          // Support: Android < 4
          // Fallback to a less secure definition
        } catch ( e ) {
          descriptor[ this.expando ] = unlock;
          $.extend( owner, descriptor );
        }
      }

      // Ensure the cache object
      if ( !this.cache[ unlock ] ) {
        this.cache[ unlock ] = {};
      }

      return unlock;
    },
    set: function( owner, data, value ) {
      var prop,
      // There may be an unlock assigned to this node,
      // if there is no entry for this "owner", create one inline
      // and set the unlock as though an owner entry had always existed
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      // Handle: [ owner, key, value ] args
      if ( typeof data === "string" ) {
        cache[ data ] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Fresh assignments by object are shallow copied
        if ( $.isEmptyObject( cache ) ) {
          $.extend( this.cache[ unlock ], data );
          // Otherwise, copy the properties one-by-one to the cache object
        } else {
          for ( prop in data ) {
            cache[ prop ] = data[ prop ];
          }
        }
      }
      return cache;
    },
    get: function( owner, key ) {
      // Either a valid cache is found, or will be created.
      // New caches will be created and the unlock returned,
      // allowing direct access to the newly created
      // empty data object. A valid owner object must be provided.
      var cache = this.cache[ this.key( owner ) ];

      return key === undefined ?
          cache : cache[ key ];
    },
    access: function( owner, key, value ) {
      var stored;
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if ( key === undefined ||
          ((key && typeof key === "string") && value === undefined) ) {

        stored = this.get( owner, key );

        return stored !== undefined ?
            stored : this.get( owner, $.camelCase(key) );
      }

      // [*]When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set( owner, key, value );

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function( owner, key ) {
      var i, name, camel,
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      if ( key === undefined ) {
        this.cache[ unlock ] = {};

      } else {
        // Support array or space separated string of keys
        if ( $.isArray( key ) ) {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = key.concat( key.map( $.camelCase ) );
        } else {
          camel = $.camelCase( key );
          // Try the string as a key before any manipulation
          if ( key in cache ) {
            name = [ key, camel ];
          } else {
            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            name = camel;
            name = name in cache ?
                [ name ] : ( name.match( core_rnotwhite ) || [] );
          }
        }

        i = name.length;
        while ( i-- ) {
          delete cache[ name[ i ] ];
        }
      }
    },
    hasData: function( owner ) {
      return !$.isEmptyObject(
          this.cache[ owner[ this.expando ] ] || {}
      );
    },
    discard: function( owner ) {
      if ( owner[ this.expando ] ) {
        delete this.cache[ owner[ this.expando ] ];
      }
    }
  };

  var data_priv = new Data();

  $.extend($, {
    queue: function( elem, type, data ) {
      var queue;

      if ( elem ) {
        type = ( type || "fx" ) + "queue";
        queue = data_priv.get( elem, type );

        // Speed up dequeue by getting out quickly if this is just a lookup
        if ( data ) {
          if ( !queue || $.isArray( data ) ) {
            queue = data_priv.access( elem, type, $.makeArray(data) );
          } else {
            queue.push( data );
          }
        }
        return queue || [];
      }
    },

    dequeue: function( elem, type ) {
      type = type || "fx";

      var queue = $.queue( elem, type ),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = $._queueHooks( elem, type ),
          next = function() {
            $.dequeue( elem, type );
          };

      // If the fx queue is dequeued, always remove the progress sentinel
      if ( fn === "inprogress" ) {
        fn = queue.shift();
        startLength--;
      }

      if ( fn ) {

        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if ( type === "fx" ) {
          queue.unshift( "inprogress" );
        }

        // clear up the last queue stop function
        delete hooks.stop;
        fn.call( elem, next, hooks );
      }

      if ( !startLength && hooks ) {
        hooks.empty.fire();
      }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
      var key = type + "queueHooks";
      return data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: $.Callbacks("once memory").add(function() {
          data_priv.remove( elem, [ type + "queue", key ] );
        })
      });
    },

    // array operations
    makeArray: function( arr, results ) {
      var ret = results || [];

      if ( arr != null ) {
        if ( isArraylike( Object(arr) ) ) {
          $.merge( ret,
              typeof arr === "string" ?
                  [ arr ] : arr
          );
        } else {
          core_push.call( ret, arr );
        }
      }

      return ret;
    },
    merge: function( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }
  });

  $.extend($.fn, {
    queue: function( type, data ) {
      var setter = 2;

      if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
      }

      if ( arguments.length < setter ) {
        return $.queue( this[0], type );
      }

      return data === undefined ?
          this :
          this.each(function() {
            var queue = $.queue( this, type, data );

            // ensure a hooks for this queue
            $._queueHooks( this, type );

            if ( type === "fx" && queue[0] !== "inprogress" ) {
              $.dequeue( this, type );
            }
          });
    },
    dequeue: function( type ) {
      return this.each(function() {
        $.dequeue( this, type );
      });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
      time = $.fx ? $.fx.speeds[ time ] || time : time;
      type = type || "fx";

      return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
          clearTimeout( timeout );
        };
      });
    },
    clearQueue: function( type ) {
      return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
      var tmp,
          count = 1,
          defer = $.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if ( !( --count ) ) {
              defer.resolveWith( elements, [ elements ] );
            }
          };

      if ( typeof type !== "string" ) {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while( i-- ) {
        tmp = data_priv.get( elements[ i ], type + "queueHooks" );
        if ( tmp && tmp.empty ) {
          count++;
          tmp.empty.add( resolve );
        }
      }
      resolve();
      return defer.promise( obj );
    }
  });

  return $;

});

define('skylark-jquery/jquery-plugin',[
	"skylark-langx-types",
	"skylark-langx-objects",
	"skylark-langx-arrays",
	"skylark-langx/langx",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-plugins-base",
	"skylark-domx-query",
],function(types, objects, arrays, langx, datax, eventer, plugins, $){

    var pluginUuid = 0;

	var JqPlugin = plugins.Plugin.inherit({
		klassName : "JqPlugin",

        pluginEventPrefix: "",

        options: {
            // Callbacks
            create: null
        },

        destroy: function() {
            this.overrided();

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off( this.eventNamespace );

            // Clean up events and states
            this.bindings.off( this.eventNamespace );
        },

        _construct : function(element,options) {
            //this.options = langx.mixin( {}, this.options );

            element = $( element || this.defaultElement || this )[ 0 ];
            this.element = $( element );
            this.uuid = pluginUuid++;
            this.eventNamespace = "." + this.pluginName + this.uuid;

            this.bindings = $();
            this.classesElementLookup = {};

			this.hoverable = $();
			this.focusable = $();

            if ( element !== this ) {
                datax.data( element, this.pluginName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                } );
                this.document = $( element.style ?

                    // Element within the document
                    element.ownerDocument :

                    // Element is window or document
                    element.document || element );
                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
            }

            this.overrided(element,options);

//            this.options = langx.mixin( {},
//                this.options,
//                this._getCreateOptions(),
//                options );

            this._create();

            this._trigger( "create", null, this._getCreateEventData() );

            this._init();
        },


	     _initOptions : function(options) {
	     	options = langx.mixin(this._getCreateOptions(),options);

			this.overrided(options);
		},

        _getCreateOptions: function() {
            return {};
        },

        _getCreateEventData: langx.noop,

		_super : function() {
			if (this.overrided) {
				return this.overrided.apply(this,arguments);
			}
		},

		_superApply : function ( args ) {
			if (this.overrided) {
				return this.overrided.apply(this,args);
			}
		},

        _create: langx.noop,

        _init: langx.noop,

		_classes: function( options ) {
			var full = [];
			var that = this;

			options = objects.mixin( {
				element: this.element,
				classes: this.options.classes || {}
			}, options );


			function bindRemoveEvent() {
				options.element.each( function( _, element ) {
					var isTracked = langx.map( that.classesElementLookup, function( elements ) {
						return elements;
					} )
						.some( function(elements ) {
							return $(elements).is( element );
						} );

					if ( !isTracked ) {
						that._on( $( element ), {
							remove: "_untrackClassesElement"
						} );
					}
				} );
			}

			function processClassString( classes, checkOption ) {
				var current, i;
				for ( i = 0; i < classes.length; i++ ) {
					current = that.classesElementLookup[ classes[ i ] ] || $();
					if ( options.add ) {
						bindRemoveEvent();
						current = $( langx.uniq( current.get().concat( options.element.get() ) ) );
					} else {
						current = $( current.not( options.element ).get() );
					}
					that.classesElementLookup[ classes[ i ] ] = current;
					full.push( classes[ i ] );
					if ( checkOption && options.classes[ classes[ i ] ] ) {
						full.push( options.classes[ classes[ i ] ] );
					}
				}
			}

			if ( options.keys ) {
				processClassString( options.keys.match( /\S+/g ) || [], true );
			}
			if ( options.extra ) {
				processClassString( options.extra.match( /\S+/g ) || [] );
			}

			return full.join( " " );
		},

		_untrackClassesElement: function( event ) {
			var that = this;
			langx.each( that.classesElementLookup, function( key, value ) {
				if ( arrays.inArray( event.target, value ) !== -1 ) {
					that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
				}
			} );

			this._off( $( event.target ) );
		},

		_removeClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, false );
		},

		_addClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, true );
		},

		_toggleClass: function( element, keys, extra, add ) {
			add = ( typeof add === "boolean" ) ? add : extra;
			var shift = ( typeof element === "string" || element === null ),
				options = {
					extra: shift ? keys : extra,
					keys: shift ? element : keys,
					element: shift ? this.element : element,
					add: add
				};
			options.element.toggleClass( this._classes( options ), add );
			return this;
		},

		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement;
			var instance = this;

			// No suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// No element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}

			objects.each( handlers, function( event, handler ) {
				function handlerProxy() {

					// Allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}

				// Copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match( /^([\w:-]*)\s*(.*)$/ );
				var eventName = match[ 1 ] + instance.eventNamespace;
				var selector = match[ 2 ];

				if ( selector ) {
					delegateElement.on( eventName, selector, handlerProxy );
				} else {
					element.on( eventName, handlerProxy );
				}
			} );
		},

		_off: function( element, eventName ) {
			eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.off( eventName );

			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},

		_trigger: function( type, event, data ) {
			var prop, orig;
			var callback = this.options[ type ];

			data = data || {};
			event = eventer.proxy( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();

			// The original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];

			// Copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}

			this.element.trigger( event, data );
			return !( types.isFunction( callback ) &&
				callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		},


	    enable: function() {
	      return this._setOptions( { disabled: false } );
	    },

	    disable: function() {
	      return this._setOptions( { disabled: true } );
	    }


	});

	return JqPlugin;
});
/*!
 * jQuery UI Widget @VERSION
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

define( 'skylark-jquery/widget',[ 
	"skylark-langx/langx",
	"skylark-domx-plugins-base",
	"./core",
	"./jquery-plugin"
],  function(langx,splugins, $,JqPlugin ) {

	var widgetUuid = 0;
	var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
	var widgetSlice = Array.prototype.slice;

	$.cleanData = ( function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}
			}
			orig( elems );
		};
	} )( $.cleanData );
	
	$.widget = function( name, base, prototype ) {
		var existingConstructor, constructor, basePrototype;

		// ProxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		var proxiedPrototype = {};

		var namespace = name.split( "." )[ 0 ];
		name = name.split( "." )[ 1 ];
		var fullName = namespace + "-" + name;

		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}

		if ( $.isArray( prototype ) ) {
			prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
		}

		// Create selector for plugin
		$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};

		$[ namespace ] = $[ namespace ] || {};

		existingConstructor = $[ namespace ][ name ];

		var basePrototype = base.prototype,
			newPrototype = {};

		for (var key in prototype) {
			var value = prototype[key];

			if ( $.isPlainObject( value ) ) {
				newPrototype[ key ] = $.isPlainObject( basePrototype[ key ] ) ?
					$.widget.extend( {}, basePrototype[ key ], value ) :

					// Don't extend strings, arrays, etc. with objects
					$.widget.extend( {}, value );
			} else {
				newPrototype[key] = value;
			}
		}

		var _proto = $.widget.extend({

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( base.prototype.widgetEventPrefix || name ) : name
		}, {
			options : base.prototype.options
		},newPrototype, {
			name : fullName,
			namespace: namespace,
			widgetName: name,
			pluginName : "jqueryui." + (namespace ? namespace + "." : "") + name,
			widgetFullName: fullName
		} );

		constructor = $[ namespace ][ name ] = base.inherit(_proto);
		/*

		constructor = $[ namespace ][ name ] = function( options, element ) {

			// Allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}

			// Allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		*/
		// Extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,

			// Copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: _proto,

			// Track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		} );

		/*
		basePrototype = new base();

		// We need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = ( function() {
				function _super() {
					return base.prototype[ prop ].apply( this, arguments );
				}

				function _superApply( args ) {
					return base.prototype[ prop ].apply( this, args );
				}

				return function() {
					var __super = this._super;
					var __superApply = this._superApply;
					var returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			} )();
		} );
		constructor.prototype = $.widget.extend( basePrototype, {

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		} );
		*/
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;

				// Redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
					child._proto );
			} );

			// Remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			if (base._childConstructors) {
				base._childConstructors.push( constructor );
			}
		}

		//$.widget.bridge( name, constructor );

		splugins.register(constructor,name,fullName);

		return constructor;
	};

	$.widget.extend = function( target ) {
		var input = widgetSlice.call( arguments, 1 );
		var inputIndex = 0;
		var inputLength = input.length;
		var key;
		var value;

		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {

					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :

							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );

					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};


	$.Widget = 	 JqPlugin.inherit({
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",

		options: {
			classes: {},
			disabled: false,

			// Callbacks
			create: null
		},

		widget: function() {
			return this.element;
		},

		_setOption: function( key, value ) {
			if ( key === "classes" ) {
				this._setOptionClasses( value );
			}

			this.options[ key ] = value;

			if ( key === "disabled" ) {
				this._setOptionDisabled( value );
			}

			return this;
		},

		_setOptionClasses: function( value ) {
			var classKey, elements, currentElements;

			for ( classKey in value ) {
				currentElements = this.classesElementLookup[ classKey ];
				if ( value[ classKey ] === this.options.classes[ classKey ] ||
						!currentElements ||
						!currentElements.length ) {
					continue;
				}

				// We are doing this to create a new jQuery object because the _removeClass() call
				// on the next line is going to destroy the reference to the current elements being
				// tracked. We need to save a copy of this collection so that we can add the new classes
				// below.
				elements = $( currentElements.get() );
				this._removeClass( currentElements, classKey );

				// We don't use _addClass() here, because that uses this.options.classes
				// for generating the string of classes. We want to use the value passed in from
				// _setOption(), this is the new value of the classes option which was passed to
				// _setOption(). We pass this value directly to _classes().
				elements.addClass( this._classes( {
					element: elements,
					keys: classKey,
					classes: value,
					add: true
				} ));
			}
		},

		_setOptionDisabled: function( value ) {
			this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this._removeClass( this.hoverable, null, "ui-state-hover" );
				this._removeClass( this.focusable, null, "ui-state-focus" );
			}
		},

		enable: function() {
			return this._setOptions( { disabled: false } );
		},

		disable: function() {
			return this._setOptions( { disabled: true } );
		},


		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},

		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
				},
				mouseleave: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
				}
			} );
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
				},
				focusout: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
				}
			} );
		}

	});

	$.Widget._childConstructors = [];

	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}

			var hasOptions;
			var effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;

			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}

			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;

			if ( options.delay ) {
				element.delay( options.delay );
			}

			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue( function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				} );
			}
		};
	} );

	return $.widget;

});

define('skylark-jquery/main',[
    "./core",
    "./ajax",
    "./callbacks",
    "./deferred",
    "./queue",
    "./jquery-plugin",
    "./widget"
], function($) {
    return $;
});

define('skylark-jquery', ['skylark-jquery/main'], function (main) { return main; });

define('skylark-slax-runtime/skylark',[
	"./slax",
	"skylark-langx-ns",
	"skylark-langx",
	"skylark-langx-logging",
	"skylark-domx",
	"skylark-domx-files",
	"skylark-domx-images",
	"skylark-domx-i18n",
	"skylark-domx-plugins-base",
	"skylark-domx-plugins-colors",
	"skylark-domx-plugins-groups",
	"skylark-domx-plugins-pictures",
	"skylark-domx-plugins-players",
	"skylark-domx-plugins-panels",
	"skylark-domx-plugins-embeds",
	"skylark-domx-plugins-sandboxs",
	"skylark-domx-plugins-menus",	
	"skylark-domx-plugins-popups",	
	"skylark-domx-plugins-uploads",
	"skylark-devices-keyboard",	
	"skylark-devices-orientation",	
	"skylark-devices-points",	
	"skylark-devices-webgl",
	"skylark-io-mimes",
	"skylark-io-caches",
	"skylark-io-diskfs",
	"skylark-io-streams",
	"skylark-net-http",
	"skylark-appify-routers",
	"skylark-appify-spa",
	"skylark-data-entities",
	"skylark-jquery"
	
],function(slax,skylark){
	return slax.skylark = skylark;
});
define('skylark-slax-runtime/main',[
	"./slax",
	"./caches",
	"./skylark"
],function(slax){
	return slax;
});
define('skylark-slax-runtime', ['skylark-slax-runtime/main'], function (main) { return main; });


},this);
//# sourceMappingURL=sourcemaps/skylark-slax-runtime-all.js.map
