/**
 * skylark-slax-runtime - The skylark shells widget
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-slax/skylark-slax-runtime/
 * @license MIT
 */
(function(factory,globals) {
  var define = globals.define,
      require = globals.require,
      isAmd = (typeof define === 'function' && define.amd),
      isCmd = (!isAmd && typeof exports !== 'undefined');

  if (!isAmd && !define) {
    var map = {};
    function absolute(relative, base) {
        if (relative[0]!==".") {
          return relative;
        }
        var stack = base.split("/"),
            parts = relative.split("/");
        stack.pop(); 
        for (var i=0; i<parts.length; i++) {
            if (parts[i] == ".")
                continue;
            if (parts[i] == "..")
                stack.pop();
            else
                stack.push(parts[i]);
        }
        return stack.join("/");
    }
    define = globals.define = function(id, deps, factory) {
        if (typeof factory == 'function') {
            map[id] = {
                factory: factory,
                deps: deps.map(function(dep){
                  return absolute(dep,id);
                }),
                resolved: false,
                exports: null
            };
            require(id);
        } else {
            map[id] = {
                factory : null,
                resolved : true,
                exports : factory
            };
        }
    };
    require = globals.require = function(id) {
        if (!map.hasOwnProperty(id)) {
            throw new Error('Module ' + id + ' has not been defined');
        }
        var module = map[id];
        if (!module.resolved) {
            var args = [];

            module.deps.forEach(function(dep){
                args.push(require(dep));
            })

            module.exports = module.factory.apply(globals, args) || null;
            module.resolved = true;
        }
        return module.exports;
    };
  }
  
  if (!define) {
     throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
  }

  factory(define,require);

  if (!isAmd) {
    var skylarkjs = require("skylark-langx/skylark");

    if (isCmd) {
      module.exports = skylarkjs;
    } else {
      globals.skylarkjs  = skylarkjs;
    }
  }

})(function(define,require) {

define('skylark-langx-ns/_attach',[],function(){
    return  function attach(obj1,path,obj2) {
        if (typeof path == "string") {
            path = path.split(".");//[path]
        };
        var length = path.length,
            ns=obj1,
            i=0,
            name = path[i++];

        while (i < length) {
            ns = ns[name] = ns[name] || {};
            name = path[i++];
        }

        return ns[name] = obj2;
    }
});
define('skylark-langx-ns/ns',[
    "./_attach"
], function(_attach) {
    var skylark = {
    	attach : function(path,obj) {
    		return _attach(skylark,path,obj);
    	}
    };
    return skylark;
});

define('skylark-langx-ns/main',[
	"./ns"
],function(skylark){
	return skylark;
});
define('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });

define('skylark-langx-types/types',[
    "skylark-langx-ns"
],function(skylark){
    var toString = {}.toString;
    
    var type = (function() {
        var class2type = {};

        // Populate the class2type map
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" ").forEach(function(name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        return function type(obj) {
            return obj == null ? String(obj) :
                class2type[toString.call(obj)] || "object";
        };
    })();

    function isArray(object) {
        return object && object.constructor === Array;
    }


    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function/string/element and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * isArrayLike([1, 2, 3])
     * // => true
     *
     * isArrayLike(document.body.children)
     * // => false
     *
     * isArrayLike('abc')
     * // => true
     *
     * isArrayLike(Function)
     * // => false
     */    
    function isArrayLike(obj) {
        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * isBoolean(false)
     * // => true
     *
     * isBoolean(null)
     * // => false
     */
    function isBoolean(obj) {
        return typeof(obj) === "boolean";
    }

    function isDefined(obj) {
        return typeof obj !== 'undefined';
    }

    function isDocument(obj) {
        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
    }

    function isEmptyObject(obj) {
        var name;
        for (name in obj) {
            if (obj[name] !== null) {
                return false;
            }
        }
        return true;
    }


    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * isFunction(parseInt)
     * // => true
     *
     * isFunction(/abc/)
     * // => false
     */
    function isFunction(value) {
        return type(value) == "function";
    }

    function isHtmlNode(obj) {
        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME
    }

    function isInstanceOf( /*Object*/ value, /*Type*/ type) {
        //Tests whether the value is an instance of a type.
        if (value === undefined) {
            return false;
        } else if (value === null || type == Object) {
            return true;
        } else if (typeof value === "number") {
            return type === Number;
        } else if (typeof value === "string") {
            return type === String;
        } else if (typeof value === "boolean") {
            return type === Boolean;
        } else if (typeof value === "string") {
            return type === String;
        } else {
            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);
        }
    }

    function isNull(value) {
      return type(value) === "null";
    }

    function isNumber(obj) {
        return typeof obj == 'number';
    }

    function isObject(obj) {
        return type(obj) == "object";
    }

    function isPlainObject(obj) {
        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
    }

    function isString(obj) {
        return typeof obj === 'string';
    }

    function isWindow(obj) {
        return obj && obj == obj.window;
    }

    function isSameOrigin(href) {
        if (href) {
            var origin = location.protocol + '//' + location.hostname;
            if (location.port) {
                origin += ':' + location.port;
            }
            return href.startsWith(origin);
        }
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    function isUndefined(value) {
      return value === undefined
    }

    return skylark.attach("langx.types",{

        isArray: isArray,

        isArrayLike: isArrayLike,

        isBoolean: isBoolean,

        isDefined: isDefined,

        isDocument: isDocument,

        isEmpty : isEmptyObject,

        isEmptyObject: isEmptyObject,

        isFunction: isFunction,

        isHtmlNode: isHtmlNode,

        isNull: isNull,

        isNumber: isNumber,

        isNumeric: isNumber,

        isObject: isObject,

        isPlainObject: isPlainObject,

        isString: isString,

        isSameOrigin: isSameOrigin,

        isSymbol : isSymbol,

        isUndefined: isUndefined,

        isWindow: isWindow,

        type: type
    });

});
define('skylark-langx-types/main',[
	"./types"
],function(types){
	return types;
});
define('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });

define('skylark-langx-numbers/numbers',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){
	var isObject = types.isObject,
		isSymbol = types.isSymbol;

	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}	

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	return  skylark.attach("langx.numbers",{
		toFinite : toFinite,
		toNumber : toNumber,
		toInteger : toInteger
	});
});
define('skylark-langx-numbers/main',[
	"./numbers"
],function(numbers){
	return numbers;
});
define('skylark-langx-numbers', ['skylark-langx-numbers/main'], function (main) { return main; });

define('skylark-langx-objects/objects',[
    "skylark-langx-ns/ns",
    "skylark-langx-ns/_attach",
	"skylark-langx-types",
    "skylark-langx-numbers"
],function(skylark,_attach,types,numbers){
	var hasOwnProperty = Object.prototype.hasOwnProperty,
        slice = Array.prototype.slice,
        isBoolean = types.isBoolean,
        isFunction = types.isFunction,
		isObject = types.isObject,
		isPlainObject = types.isPlainObject,
		isArray = types.isArray,
        isArrayLike = types.isArrayLike,
        isString = types.isString,
        toInteger = numbers.toInteger;

     // An internal function for creating assigner functions.
    function createAssigner(keysFunc, defaults) {
        return function(obj) {
          var length = arguments.length;
          if (defaults) obj = Object(obj);  
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
       };
    }

    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // `null` or `undefined` only equal to itself (strict comparison).
        if (a == null || b == null) return false;
        // `NaN`s are equivalent, but non-reflexive.
        if (a !== a) return b !== b;
        // Exhaust primitive checks
        var type = typeof a;
        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
        return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
        // Unwrap any wrapped objects.
        //if (a instanceof _) a = a._wrapped;
        //if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b;
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN.
                if (+a !== +a) return +b !== +b;
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b;
            case '[object Symbol]':
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }

        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object') return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
                               isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
        }

        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);

        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length) return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            // Deep compare objects.
            var keys = Object.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (Object.keys(b).length !== length) return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    };

    // Retrieve all the property names of an object.
    function allKeys(obj) {
        if (!isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }

    function each(obj, callback) {
        var length, key, i, undef, value;

        if (obj) {
            length = obj.length;

            if (length === undef) {
                // Loop object items
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        value = obj[key];
                        if (callback.call(value, key, value) === false) {
                            break;
                        }
                    }
                }
            } else {
                // Loop array items
                for (i = 0; i < length; i++) {
                    value = obj[i];
                    if (callback.call(value, i, value) === false) {
                        break;
                    }
                }
            }
        }

        return this;
    }

    function extend(target) {
        var deep, args = slice.call(arguments, 1);
        if (typeof target == 'boolean') {
            deep = target
            target = args.shift()
        }
        if (args.length == 0) {
            args = [target];
            target = this;
        }
        args.forEach(function(arg) {
            mixin(target, arg, deep);
        });
        return target;
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys(obj) {
        if (isObject(obj)) return [];
        var keys = [];
        for (var key in obj) if (has(obj, key)) keys.push(key);
        return keys;
    }

    function has(obj, path) {
        if (!isArray(path)) {
            return obj != null && hasOwnProperty.call(obj, path);
        }
        var length = path.length;
        for (var i = 0; i < length; i++) {
            var key = path[i];
            if (obj == null || !hasOwnProperty.call(obj, key)) {
                return false;
            }
            obj = obj[key];
        }
        return !!length;
    }

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }


   // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
        return eq(a, b);
    }

    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
        var keys = keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    }    

    function _mixin(target, source, deep, safe) {
        for (var key in source) {
            //if (!source.hasOwnProperty(key)) {
            //    continue;
            //}
            if (safe && target[key] !== undefined) {
                continue;
            }
            if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
                if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                    target[key] = {};
                }
                if (isArray(source[key]) && !isArray(target[key])) {
                    target[key] = [];
                }
                _mixin(target[key], source[key], deep, safe);
            } else if (source[key] !== undefined) {
                target[key] = source[key]
            }
        }
        return target;
    }

    function _parseMixinArgs(args) {
        var params = slice.call(arguments, 0),
            target = params.shift(),
            deep = false;
        if (isBoolean(params[params.length - 1])) {
            deep = params.pop();
        }

        return {
            target: target,
            sources: params,
            deep: deep
        };
    }

    function mixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, false);
        });
        return args.target;
    }

   // Return a copy of the object without the blacklisted properties.
    function omit(obj, prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = mixin({},obj);
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                delete result[pn];
            }
        }
        return result;

    }

   // Return a copy of the object only containing the whitelisted properties.
    function pick(obj,prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = {};
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                result[pn] = obj[pn];
            }
        }
        return result;
    }

    function removeItem(items, item) {
        if (isArray(items)) {
            var idx = items.indexOf(item);
            if (idx != -1) {
                items.splice(idx, 1);
            }
        } else if (isPlainObject(items)) {
            for (var key in items) {
                if (items[key] == item) {
                    delete items[key];
                    break;
                }
            }
        }

        return this;
    }

    function result(obj, path, fallback) {
        if (!isArray(path)) {
            path = path.split(".");//[path]
        };
        var length = path.length;
        if (!length) {
          return isFunction(fallback) ? fallback.call(obj) : fallback;
        }
        for (var i = 0; i < length; i++) {
          var prop = obj == null ? void 0 : obj[path[i]];
          if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
          }
          obj = isFunction(prop) ? prop.call(obj) : prop;
        }

        return obj;
    }

    function safeMixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, true);
        });
        return args.target;
    }

    // Retrieve the values of an object's properties.
    function values(obj) {
        var keys = allKeys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }

    function clone( /*anything*/ src,checkCloneMethod) {
        var copy;
        if (src === undefined || src === null) {
            copy = src;
        } else if (checkCloneMethod && src.clone) {
            copy = src.clone();
        } else if (isArray(src)) {
            copy = [];
            for (var i = 0; i < src.length; i++) {
                copy.push(clone(src[i]));
            }
        } else if (isPlainObject(src)) {
            copy = {};
            for (var key in src) {
                copy[key] = clone(src[key]);
            }
        } else {
            copy = src;
        }

        return copy;

    }

    return skylark.attach("langx.objects",{
        allKeys: allKeys,

        attach : _attach,

        clone: clone,

        defaults : createAssigner(allKeys, true),

        each : each,

        extend : extend,

        has: has,

        isEqual: isEqual,   

        includes: includes,

        isMatch: isMatch,

        keys: keys,

        mixin: mixin,

        omit: omit,

        pick: pick,

        removeItem: removeItem,

        result : result,
        
        safeMixin: safeMixin,

        values: values
    });


});
define('skylark-langx-objects/main',[
	"./objects"
],function(objects){
	return objects;
});
define('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });

define('skylark-langx-hoster/hoster',[
    "skylark-langx-ns"
],function(skylark){
	// The javascript host environment, brower and nodejs are supported.
	var hoster = {
		"isBrowser" : true, // default
		"isNode" : null,
		"global" : this,
		"browser" : null,
		"node" : null
	};

	if (typeof process == "object" && process.versions && process.versions.node && process.versions.v8) {
		hoster.isNode = true;
		hoster.isBrowser = false;
	}

	hoster.global = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	var _document = null;

	Object.defineProperty(hoster,"document",function(){
		if (!_document) {
			var w = typeof window === 'undefined' ? require('html-element') : window;
			_document = w.document;
		}

		return _document;
	});

	if (hoster.isBrowser) {
	    function uaMatch( ua ) {
		    ua = ua.toLowerCase();

		    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		      /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		      /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		      /(msie) ([\w.]+)/.exec( ua ) ||
		      ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		      [];

		    return {
		      browser: match[ 1 ] || '',
		      version: match[ 2 ] || '0'
		    };
	  	};

	    var matched = uaMatch( navigator.userAgent );

	    var browser = hoster.browser = {};

	    if ( matched.browser ) {
	      browser[ matched.browser ] = true;
	      browser.version = matched.version;
	    }

	    // Chrome is Webkit, but Webkit is also Safari.
	    if ( browser.chrome ) {
	      browser.webkit = true;
	    } else if ( browser.webkit ) {
	      browser.safari = true;
	    }
	}

	return  skylark.attach("langx.hoster",hoster);
});
define('skylark-langx-hoster/main',[
	"./hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx-hoster', ['skylark-langx-hoster/main'], function (main) { return main; });

define('skylark-langx-arrays/arrays',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects"
],function(skylark,types,objects){
	var filter = Array.prototype.filter,
		isArrayLike = types.isArrayLike;

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }


    function compact(array) {
        return filter.call(array, function(item) {
            return item != null;
        });
    }

    function filter2(array,func) {
      return filter.call(array,func);
    }

    function flatten(array) {
        if (isArrayLike(array)) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                if (isArrayLike(item)) {
                    for (var j = 0; j < item.length; j++) {
                        result.push(item[j]);
                    }
                } else {
                    result.push(item);
                }
            }
            return result;
        } else {
            return array;
        }
        //return array.length > 0 ? concat.apply([], array) : array;
    }

    function grep(array, callback) {
        var out = [];

        objects.each(array, function(i, item) {
            if (callback(item, i)) {
                out.push(item);
            }
        });

        return out;
    }

    function inArray(item, array) {
        if (!array) {
            return -1;
        }
        var i;

        if (array.indexOf) {
            return array.indexOf(item);
        }

        i = array.length;
        while (i--) {
            if (array[i] === item) {
                return i;
            }
        }

        return -1;
    }

    function makeArray(obj, offset, startWith) {
       if (isArrayLike(obj) ) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }

      // array of single index
      return [ obj ];             
    }


    function forEach (arr, fn) {
      if (arr.forEach) return arr.forEach(fn)
      for (var i = 0; i < arr.length; i++) fn(arr[i], i);
    }

    function map(elements, callback) {
        var value, values = [],
            i, key
        if (isArrayLike(elements))
            for (i = 0; i < elements.length; i++) {
                value = callback.call(elements[i], elements[i], i);
                if (value != null) values.push(value)
            }
        else
            for (key in elements) {
                value = callback.call(elements[key], elements[key], key);
                if (value != null) values.push(value)
            }
        return flatten(values)
    }


    function merge( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }

    function reduce(array,callback,initialValue) {
        return Array.prototype.reduce.call(array,callback,initialValue);
    }

    function uniq(array) {
        return filter.call(array, function(item, idx) {
            return array.indexOf(item) == idx;
        })
    }

    return skylark.attach("langx.arrays",{
        baseFindIndex: baseFindIndex,

        baseIndexOf : baseIndexOf,
        
        compact: compact,

        first : function(items,n) {
            if (n) {
                return items.slice(0,n);
            } else {
                return items[0];
            }
        },

        filter : filter2,
        
        flatten: flatten,

        grep: grep,

        inArray: inArray,

        makeArray: makeArray,

        merge : merge,

        forEach : forEach,

        map : map,
        
        reduce : reduce,

        uniq : uniq

    });
});
define('skylark-langx-arrays/main',[
	"./arrays"
],function(arrays){
	return arrays;
});
define('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });

define('skylark-langx-funcs/funcs',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects"
],function(skylark,types,objects){
	var mixin = objects.mixin,
        slice = Array.prototype.slice,
        isFunction = types.isFunction,
        isString = types.isString;

    function defer(fn) {
        if (requestAnimationFrame) {
            requestAnimationFrame(fn);
        } else {
            setTimeoutout(fn);
        }
        return this;
    }

    function noop() {
    }

    function proxy(fn, context) {
        var args = (2 in arguments) && slice.call(arguments, 2)
        if (isFunction(fn)) {
            var proxyFn = function() {
                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
            }
            return proxyFn;
        } else if (isString(context)) {
            if (args) {
                args.unshift(fn[context], fn)
                return proxy.apply(null, args)
            } else {
                return proxy(fn[context], fn);
            }
        } else {
            throw new TypeError("expected function");
        }
    }

    function debounce(fn, wait) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                fn.apply(context, args);
            };
            if (timeout) clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
   
    var delegate = (function() {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {}
        return function(obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();

  var templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };


  function template(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = objects.defaults({}, settings,templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

    return skylark.attach("langx.funcs",{
        debounce: debounce,

        delegate: delegate,

        defer: defer,

        noop : noop,

        proxy: proxy,

        returnTrue: function() {
            return true;
        },

        returnFalse: function() {
            return false;
        },

        templateSettings : templateSettings,
        template : template
    });
});
define('skylark-langx-funcs/main',[
	"./funcs"
],function(funcs){
	return funcs;
});
define('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });

define('skylark-langx-async/Deferred',[
    "skylark-langx-arrays",
	"skylark-langx-funcs",
    "skylark-langx-objects"
],function(arrays,funcs,objects){
    "use strict";
    
    var  PGLISTENERS = Symbol ? Symbol() : '__pglisteners',
         PGNOTIFIES = Symbol ? Symbol() : '__pgnotifies';

    var slice = Array.prototype.slice,
        proxy = funcs.proxy,
        makeArray = arrays.makeArray,
        result = objects.result,
        mixin = objects.mixin;

    mixin(Promise.prototype,{
        always: function(handler) {
            //this.done(handler);
            //this.fail(handler);
            this.then(handler,handler);
            return this;
        },
        done : function() {
            for (var i = 0;i<arguments.length;i++) {
                this.then(arguments[i]);
            }
            return this;
        },
        fail : function(handler) { 
            //return mixin(Promise.prototype.catch.call(this,handler),added);
            //return this.then(null,handler);
            this.catch(handler);
            return this;
         }
    });


    var Deferred = function() {
        var self = this,
            p = this.promise = new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            });

        wrapPromise(p,self);

        this[PGLISTENERS] = [];
        this[PGNOTIFIES] = [];

        //this.resolve = Deferred.prototype.resolve.bind(this);
        //this.reject = Deferred.prototype.reject.bind(this);
        //this.progress = Deferred.prototype.progress.bind(this);

    };

    function wrapPromise(p,d) {
        var   added = {
                state : function() {
                    if (d.isResolved()) {
                        return 'resolved';
                    }
                    if (d.isRejected()) {
                        return 'rejected';
                    }
                    return 'pending';
                },
                then : function(onResolved,onRejected,onProgress) {
                    if (onProgress) {
                        this.progress(onProgress);
                    }
                    return wrapPromise(Promise.prototype.then.call(this,
                            onResolved && function(args) {
                                if (args && args.__ctx__ !== undefined) {
                                    return onResolved.apply(args.__ctx__,args);
                                } else {
                                    return onResolved(args);
                                }
                            },
                            onRejected && function(args){
                                if (args && args.__ctx__ !== undefined) {
                                    return onRejected.apply(args.__ctx__,args);
                                } else {
                                    return onRejected(args);
                                }
                            }));
                },
                progress : function(handler) {
                    d[PGNOTIFIES].forEach(function (value) {
                        handler(value);
                    });
                    d[PGLISTENERS].push(handler);
                    return this;
                }

            };

        added.pipe = added.then;
        return mixin(p,added);

    }

    Deferred.prototype.resolve = function(value) {
        var args = slice.call(arguments);
        return this.resolveWith(null,args);
    };

    Deferred.prototype.resolveWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._resolve(args);
        this._resolved = true;
        return this;
    };

    Deferred.prototype.notify = function(value) {
        try {
            this[PGNOTIFIES].push(value);

            return this[PGLISTENERS].forEach(function (listener) {
                return listener(value);
            });
        } catch (error) {
          this.reject(error);
        }
        return this;
    };

    Deferred.prototype.reject = function(reason) {
        var args = slice.call(arguments);
        return this.rejectWith(null,args);
    };

    Deferred.prototype.rejectWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._reject(args);
        this._rejected = true;
        return this;
    };

    Deferred.prototype.isResolved = function() {
        return !!this._resolved;
    };

    Deferred.prototype.isRejected = function() {
        return !!this._rejected;
    };

    Deferred.prototype.then = function(callback, errback, progback) {
        var p = result(this,"promise");
        return p.then(callback, errback, progback);
    };

    Deferred.prototype.progress = function(progback){
        var p = result(this,"promise");
        return p.progress(progback);
    };
   
    Deferred.prototype.catch = function(errback) {
        var p = result(this,"promise");
        return p.catch(errback);
    };


    Deferred.prototype.done  = function() {
        var p = result(this,"promise");
        return p.done.apply(p,arguments);
    };

    Deferred.prototype.fail = function(errback) {
        var p = result(this,"promise");
        return p.fail(errback);
    };


    Deferred.all = function(array) {
        //return wrapPromise(Promise.all(array));
        var d = new Deferred();
        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));
        return result(d,"promise");
    };

    Deferred.first = function(array) {
        return wrapPromise(Promise.race(array));
    };


    Deferred.when = function(valueOrPromise, callback, errback, progback) {
        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

        if (!receivedPromise) {
            if (arguments.length > 1) {
                return callback ? callback(valueOrPromise) : valueOrPromise;
            } else {
                return new Deferred().resolve(valueOrPromise);
            }
        } else if (!nativePromise) {
            var deferred = new Deferred(valueOrPromise.cancel);
            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);
            valueOrPromise = deferred.promise;
        }

        if (callback || errback || progback) {
            return valueOrPromise.then(callback, errback, progback);
        }
        return valueOrPromise;
    };

    Deferred.reject = function(err) {
        var d = new Deferred();
        d.reject(err);
        return d.promise;
    };

    Deferred.resolve = function(data) {
        var d = new Deferred();
        d.resolve.apply(d,arguments);
        return d.promise;
    };

    Deferred.immediate = Deferred.resolve;

    return Deferred;
});
define('skylark-langx-async/async',[
    "skylark-langx-ns",
    "skylark-langx-objects",
    "./Deferred"
],function(skylark,objects,Deferred){
    var each = objects.each;
    
    var async = {
        Deferred : Deferred,

        parallel : function(arr,args,ctx) {
            var rets = [];
            ctx = ctx || null;
            args = args || [];

            each(arr,function(i,func){
                rets.push(func.apply(ctx,args));
            });

            return Deferred.all(rets);
        },

        series : function(arr,args,ctx) {
            var rets = [],
                d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolve();
            each(arr,function(i,func){
                p = p.then(function(){
                    return func.apply(ctx,args);
                });
                rets.push(p);
            });

            return Deferred.all(rets);
        },

        waterful : function(arr,args,ctx) {
            var d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolveWith(ctx,args);

            each(arr,function(i,func){
                p = p.then(func);
            });
            return p;
        }
    };

	return skylark.attach("langx.async",async);	
});
define('skylark-langx-async/main',[
	"./async"
],function(async){
	return async;
});
define('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });

define('skylark-langx-klass/klass',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
],function(skylark,types,objects,arrays){
    var uniq = arrays.uniq,
        has = objects.has,
        mixin = objects.mixin,
        isArray = types.isArray,
        isDefined = types.isDefined;

/* for reference 
 function klass(props,parent) {
    var ctor = function(){
        this._construct();
    };
    ctor.prototype = props;
    if (parent) {
        ctor._proto_ = parent;
        props.__proto__ = parent.prototype;
    }
    return ctor;
}

// Type some JavaScript code here.
let animal = klass({
  _construct(){
      this.name = this.name + ",hi";
  },
    
  name: "Animal",
  eat() {         // [[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
    
    
});


let rabbit = klass({
  name: "Rabbit",
  _construct(){
      super._construct();
  },
  eat() {         // [[HomeObject]] == rabbit
    super.eat();
  }
},animal);

let longEar = klass({
  name: "Long Ear",
  eat() {         // [[HomeObject]] == longEar
    super.eat();
  }
},rabbit);
*/
    
    function inherit(ctor, base) {
        var f = function() {};
        f.prototype = base.prototype;

        ctor.prototype = new f();
    }

    var f1 = function() {
        function extendClass(ctor, props, options) {
            // Copy the properties to the prototype of the class.
            var proto = ctor.prototype,
                _super = ctor.superclass.prototype,
                noOverrided = options && options.noOverrided,
                overrides = options && options.overrides || {};

            for (var name in props) {
                if (name === "constructor") {
                    continue;
                }

                // Check if we're overwriting an existing function
                var prop = props[name];
                if (typeof props[name] == "function") {
                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == "function" ?
                          (function(name, fn, superFn) {
                            return function() {
                                var tmp = this.overrided;

                                // Add a new ._super() method that is the same method
                                // but on the super-class
                                this.overrided = superFn;

                                // The method only need to be bound temporarily, so we
                                // remove it when we're done executing
                                var ret = fn.apply(this, arguments);

                                this.overrided = tmp;

                                return ret;
                            };
                        })(name, prop, _super[name]) :
                        prop;
                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {
                    Object.defineProperty(proto,name,prop);
                } else {
                    proto[name] = prop;
                }
            }
            return ctor;
        }

        function serialMixins(ctor,mixins) {
            var result = [];

            mixins.forEach(function(mixin){
                if (has(mixin,"__mixins__")) {
                     throw new Error("nested mixins");
                }
                var clss = [];
                while (mixin) {
                    clss.unshift(mixin);
                    mixin = mixin.superclass;
                }
                result = result.concat(clss);
            });

            result = uniq(result);

            result = result.filter(function(mixin){
                var cls = ctor;
                while (cls) {
                    if (mixin === cls) {
                        return false;
                    }
                    if (has(cls,"__mixins__")) {
                        var clsMixines = cls["__mixins__"];
                        for (var i=0; i<clsMixines.length;i++) {
                            if (clsMixines[i]===mixin) {
                                return false;
                            }
                        }
                    }
                    cls = cls.superclass;
                }
                return true;
            });

            if (result.length>0) {
                return result;
            } else {
                return false;
            }
        }

        function mergeMixins(ctor,mixins) {
            var newCtor =ctor;
            for (var i=0;i<mixins.length;i++) {
                var xtor = new Function();
                xtor.prototype = Object.create(newCtor.prototype);
                xtor.__proto__ = newCtor;
                xtor.superclass = null;
                mixin(xtor.prototype,mixins[i].prototype);
                xtor.prototype.__mixin__ = mixins[i];
                newCtor = xtor;
            }

            return newCtor;
        }

        function _constructor ()  {
            if (this._construct) {
                return this._construct.apply(this, arguments);
            } else  if (this.init) {
                return this.init.apply(this, arguments);
            }
        }

        return function createClass(props, parent, mixins,options) {
            if (isArray(parent)) {
                options = mixins;
                mixins = parent;
                parent = null;
            }
            parent = parent || Object;

            if (isDefined(mixins) && !isArray(mixins)) {
                options = mixins;
                mixins = false;
            }

            var innerParent = parent;

            if (mixins) {
                mixins = serialMixins(innerParent,mixins);
            }

            if (mixins) {
                innerParent = mergeMixins(innerParent,mixins);
            }

            var klassName = props.klassName || "",
                ctor = new Function(
                    "return function " + klassName + "() {" +
                    "var inst = this," +
                    " ctor = arguments.callee;" +
                    "if (!(inst instanceof ctor)) {" +
                    "inst = Object.create(ctor.prototype);" +
                    "}" +
                    "return ctor._constructor.apply(inst, arguments) || inst;" + 
                    "}"
                )();


            // Populate our constructed prototype object
            ctor.prototype = Object.create(innerParent.prototype);

            // Enforce the constructor to be what we expect
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent;

            // And make this class extendable
            ctor.__proto__ = innerParent;


            if (!ctor._constructor) {
                ctor._constructor = _constructor;
            } 

            if (mixins) {
                ctor.__mixins__ = mixins;
            }

            if (!ctor.partial) {
                ctor.partial = function(props, options) {
                    return extendClass(this, props, options);
                };
            }
            if (!ctor.inherit) {
                ctor.inherit = function(props, mixins,options) {
                    return createClass(props, this, mixins,options);
                };
            }

            ctor.partial(props, options);

            return ctor;
        };
    }

    var createClass = f1();

    return skylark.attach("langx.klass",createClass);
});
define('skylark-langx-klass/main',[
	"./klass"
],function(klass){
	return klass;
});
define('skylark-langx-klass', ['skylark-langx-klass/main'], function (main) { return main; });

define('skylark-langx-emitter/Emitter',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass"
],function(skylark,types,objects,arrays,klass){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    var Emitter = klass({
        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }
                    if (e.data) {
                        if (listener.data) {
                            e.data = mixin({}, listener.data, e.data);
                        }
                    } else {
                        e.data = listener.data || null;
                    }
                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        listenTo: function(obj, event, callback, /*used internally*/ one) {
            if (!obj) {
                return this;
            }

            // Bind callbacks on obj,
            if (isString(callback)) {
                callback = this[callback];
            }

            if (one) {
                obj.one(event, callback, this);
            } else {
                obj.on(event, callback, this);
            }

            //keep track of them on listening.
            var listeningTo = this._listeningTo || (this._listeningTo = []),
                listening;

            for (var i = 0; i < listeningTo.length; i++) {
                if (listeningTo[i].obj == obj) {
                    listening = listeningTo[i];
                    break;
                }
            }
            if (!listening) {
                listeningTo.push(
                    listening = {
                        obj: obj,
                        events: {}
                    }
                );
            }
            var listeningEvents = listening.events,
                listeningEvent = listeningEvents[event] = listeningEvents[event] || [];
            if (listeningEvent.indexOf(callback) == -1) {
                listeningEvent.push(callback);
            }

            return this;
        },

        listenToOnce: function(obj, event, callback) {
            return this.listenTo(obj, event, callback, 1);
        },

        off: function(events, callback) {
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },
        unlistenTo: function(obj, event, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo) {
                return this;
            }
            for (var i = 0; i < listeningTo.length; i++) {
                var listening = listeningTo[i];

                if (obj && obj != listening.obj) {
                    continue;
                }

                var listeningEvents = listening.events;
                for (var eventName in listeningEvents) {
                    if (event && event != eventName) {
                        continue;
                    }

                    var listeningEvent = listeningEvents[eventName];

                    for (var j = 0; j < listeningEvent.length; j++) {
                        if (!callback || callback == listeningEvent[i]) {
                            listening.obj.off(eventName, listeningEvent[i], this);
                            listeningEvent[i] = null;
                        }
                    }

                    listeningEvent = listeningEvents[eventName] = compact(listeningEvent);

                    if (isEmptyObject(listeningEvent)) {
                        listeningEvents[eventName] = null;
                    }

                }

                if (isEmptyObject(listeningEvents)) {
                    listeningTo[i] = null;
                }
            }

            listeningTo = this._listeningTo = compact(listeningTo);
            if (isEmptyObject(listeningTo)) {
                this._listeningTo = null;
            }

            return this;
        },

        trigger  : function() {
            return this.emit.apply(this,arguments);
        }
    });

    Emitter.createEvent = function (type,props) {
        var e = new CustomEvent(type,props);
        return safeMixin(e, props);
    };

    return skylark.attach("langx.Emitter",Emitter);

});
define('skylark-langx-emitter/Evented',[
  "skylark-langx-ns/ns",
	"./Emitter"
],function(skylark,Emitter){
	return skylark.attach("langx.Evented",Emitter);
});
define('skylark-net-http/http',[
  "skylark-langx-ns/ns",
],function(skylark){
	return skylark.attach("net.http",{});
});
define('skylark-net-http/Xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/Deferred",
  "skylark-langx-emitter/Evented",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            xhrFields : {
                withCredentials : true
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }

        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = isFormData ? false : 'application/x-www-form-urlencoded';

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                //if (dataType) {
                //    xhr.responseType = dataType;
                //}

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(result);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(result) ? null : JSON.parse(result);
                            } else if (dataType == "blob") {
                                result = Blob([xhrObj.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.reponse;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };

                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

	return http.Xhr = Xhr;	
});
define('skylark-langx/skylark',[
    "skylark-langx-ns"
], function(ns) {
	return ns;
});

define('skylark-langx/arrays',[
	"skylark-langx-arrays"
],function(arrays){
  return arrays;
});
define('skylark-langx/klass',[
    "skylark-langx-klass"
],function(klass){
    return klass;
});
define('skylark-langx/ArrayStore',[
    "./klass"
],function(klass){
    var SimpleQueryEngine = function(query, options){
        // summary:
        //      Simple query engine that matches using filter functions, named filter
        //      functions or objects by name-value on a query object hash
        //
        // description:
        //      The SimpleQueryEngine provides a way of getting a QueryResults through
        //      the use of a simple object hash as a filter.  The hash will be used to
        //      match properties on data objects with the corresponding value given. In
        //      other words, only exact matches will be returned.
        //
        //      This function can be used as a template for more complex query engines;
        //      for example, an engine can be created that accepts an object hash that
        //      contains filtering functions, or a string that gets evaluated, etc.
        //
        //      When creating a new dojo.store, simply set the store's queryEngine
        //      field as a reference to this function.
        //
        // query: Object
        //      An object hash with fields that may match fields of items in the store.
        //      Values in the hash will be compared by normal == operator, but regular expressions
        //      or any object that provides a test() method are also supported and can be
        //      used to match strings by more complex expressions
        //      (and then the regex's or object's test() method will be used to match values).
        //
        // options: dojo/store/api/Store.QueryOptions?
        //      An object that contains optional information such as sort, start, and count.
        //
        // returns: Function
        //      A function that caches the passed query under the field "matches".  See any
        //      of the "query" methods on dojo.stores.
        //
        // example:
        //      Define a store with a reference to this engine, and set up a query method.
        //
        //  |   var myStore = function(options){
        //  |       //  ...more properties here
        //  |       this.queryEngine = SimpleQueryEngine;
        //  |       //  define our query method
        //  |       this.query = function(query, options){
        //  |           return QueryResults(this.queryEngine(query, options)(this.data));
        //  |       };
        //  |   };

        // create our matching query function
        switch(typeof query){
            default:
                throw new Error("Can not query with a " + typeof query);
            case "object": case "undefined":
                var queryObject = query;
                query = function(object){
                    for(var key in queryObject){
                        var required = queryObject[key];
                        if(required && required.test){
                            // an object can provide a test method, which makes it work with regex
                            if(!required.test(object[key], object)){
                                return false;
                            }
                        }else if(required != object[key]){
                            return false;
                        }
                    }
                    return true;
                };
                break;
            case "string":
                // named query
                if(!this[query]){
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];
                // fall through
            case "function":
                // fall through
        }
        
        function filter(arr, callback, thisObject){
            // summary:
            //      Returns a new Array with those items from arr that match the
            //      condition implemented by callback.
            // arr: Array
            //      the array to iterate over.
            // callback: Function|String
            //      a function that is invoked with three arguments (item,
            //      index, array). The return of this function is expected to
            //      be a boolean which determines whether the passed-in item
            //      will be included in the returned array.
            // thisObject: Object?
            //      may be used to scope the call to callback
            // returns: Array
            // description:
            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
            //      run over sparse arrays, this implementation passes the "holes" in the sparse array to
            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
            //      For more details, see:
            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
            // example:
            //  | // returns [2, 3, 4]
            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });

            // TODO: do we need "Ctr" here like in map()?
            var i = 0, l = arr && arr.length || 0, out = [], value;
            if(l && typeof arr == "string") arr = arr.split("");
            if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
            if(thisObject){
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback.call(thisObject, value, i, arr)){
                        out.push(value);
                    }
                }
            }else{
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback(value, i, arr)){
                        out.push(value);
                    }
                }
            }
            return out; // Array
        }

        function execute(array){
            // execute the whole query, first we filter
            var results = filter(array, query);
            // next we sort
            var sortSet = options && options.sort;
            if(sortSet){
                results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
                    for(var sort, i=0; sort = sortSet[i]; i++){
                        var aValue = a[sort.attribute];
                        var bValue = b[sort.attribute];
                        // valueOf enables proper comparison of dates
                        aValue = aValue != null ? aValue.valueOf() : aValue;
                        bValue = bValue != null ? bValue.valueOf() : bValue;
                        if (aValue != bValue){
                            // modified by lwf 2016/07/09
                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                        }
                    }
                    return 0;
                });
            }
            // now we paginate
            if(options && (options.start || options.count)){
                var total = results.length;
                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                results.total = total;
            }
            return results;
        }
        execute.matches = query;
        return execute;
    };

    var QueryResults = function(results){
        // summary:
        //      A function that wraps the results of a store query with additional
        //      methods.
        // description:
        //      QueryResults is a basic wrapper that allows for array-like iteration
        //      over any kind of returned data from a query.  While the simplest store
        //      will return a plain array of data, other stores may return deferreds or
        //      promises; this wrapper makes sure that *all* results can be treated
        //      the same.
        //
        //      Additional methods include `forEach`, `filter` and `map`.
        // results: Array|dojo/promise/Promise
        //      The result set as an array, or a promise for an array.
        // returns:
        //      An array-like object that can be used for iterating over.
        // example:
        //      Query a store and iterate over the results.
        //
        //  |   store.query({ prime: true }).forEach(function(item){
        //  |       //  do something
        //  |   });

        if(!results){
            return results;
        }

        var isPromise = !!results.then;
        // if it is a promise it may be frozen
        if(isPromise){
            results = Object.delegate(results);
        }
        function addIterativeMethod(method){
            // Always add the iterative methods so a QueryResults is
            // returned whether the environment is ES3 or ES5
            results[method] = function(){
                var args = arguments;
                var result = Deferred.when(results, function(results){
                    //Array.prototype.unshift.call(args, results);
                    return QueryResults(Array.prototype[method].apply(results, args));
                });
                // forEach should only return the result of when()
                // when we're wrapping a promise
                if(method !== "forEach" || isPromise){
                    return result;
                }
            };
        }

        addIterativeMethod("forEach");
        addIterativeMethod("filter");
        addIterativeMethod("map");
        if(results.total == null){
            results.total = Deferred.when(results, function(results){
                return results.length;
            });
        }
        return results; // Object
    };

    var ArrayStore = klass({
        "klassName": "ArrayStore",

        "queryEngine": SimpleQueryEngine,
        
        "idProperty": "id",


        get: function(id){
            // summary:
            //      Retrieves an object by its identity
            // id: Number
            //      The identity to use to lookup the object
            // returns: Object
            //      The object in the store that matches the given id.
            return this.data[this.index[id]];
        },

        getIdentity: function(object){
            return object[this.idProperty];
        },

        put: function(object, options){
            var data = this.data,
                index = this.index,
                idProperty = this.idProperty;
            var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
            if(id in index){
                // object exists
                if(options && options.overwrite === false){
                    throw new Error("Object already exists");
                }
                // replace the entry in data
                data[index[id]] = object;
            }else{
                // add the new object
                index[id] = data.push(object) - 1;
            }
            return id;
        },

        add: function(object, options){
            (options = options || {}).overwrite = false;
            // call put with overwrite being false
            return this.put(object, options);
        },

        remove: function(id){
            // summary:
            //      Deletes an object by its identity
            // id: Number
            //      The identity to use to delete the object
            // returns: Boolean
            //      Returns true if an object was removed, falsy (undefined) if no object matched the id
            var index = this.index;
            var data = this.data;
            if(id in index){
                data.splice(index[id], 1);
                // now we have to reindex
                this.setData(data);
                return true;
            }
        },
        query: function(query, options){
            // summary:
            //      Queries the store for objects.
            // query: Object
            //      The query to use for retrieving objects from the store.
            // options: dojo/store/api/Store.QueryOptions?
            //      The optional arguments to apply to the resultset.
            // returns: dojo/store/api/Store.QueryResults
            //      The results of the query, extended with iterative methods.
            //
            // example:
            //      Given the following store:
            //
            //  |   var store = new Memory({
            //  |       data: [
            //  |           {id: 1, name: "one", prime: false },
            //  |           {id: 2, name: "two", even: true, prime: true},
            //  |           {id: 3, name: "three", prime: true},
            //  |           {id: 4, name: "four", even: true, prime: false},
            //  |           {id: 5, name: "five", prime: true}
            //  |       ]
            //  |   });
            //
            //  ...find all items where "prime" is true:
            //
            //  |   var results = store.query({ prime: true });
            //
            //  ...or find all items where "even" is true:
            //
            //  |   var results = store.query({ even: true });
            return QueryResults(this.queryEngine(query, options)(this.data));
        },

        setData: function(data){
            // summary:
            //      Sets the given data as the source for this store, and indexes it
            // data: Object[]
            //      An array of objects to use as the source of data.
            if(data.items){
                // just for convenience with the data format IFRS expects
                this.idProperty = data.identifier || this.idProperty;
                data = this.data = data.items;
            }else{
                this.data = data;
            }
            this.index = {};
            for(var i = 0, l = data.length; i < l; i++){
                this.index[data[i][this.idProperty]] = i;
            }
        },

        init: function(options) {
            for(var i in options){
                this[i] = options[i];
            }
            this.setData(this.data || []);
        }

    });

	return ArrayStore;
});
define('skylark-langx-aspect/aspect',[
    "skylark-langx-ns"
],function(skylark){

  var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments){
        var previous = dispatcher[type];
        var around = type == "around";
        var signal;
        if(around){
            var advised = advice(function(){
                return previous.advice(this, arguments);
            });
            signal = {
                remove: function(){
                    if(advised){
                        advised = dispatcher = advice = null;
                    }
                },
                advice: function(target, args){
                    return advised ?
                        advised.apply(target, args) :  // called the advised function
                        previous.advice(target, args); // cancelled, skip to next one
                }
            };
        }else{
            // create the remove handler
            signal = {
                remove: function(){
                    if(signal.advice){
                        var previous = signal.previous;
                        var next = signal.next;
                        if(!next && !previous){
                            delete dispatcher[type];
                        }else{
                            if(previous){
                                previous.next = next;
                            }else{
                                dispatcher[type] = next;
                            }
                            if(next){
                                next.previous = previous;
                            }
                        }

                        // remove the advice to signal that this signal has been removed
                        dispatcher = advice = signal.advice = null;
                    }
                },
                id: nextId++,
                advice: advice,
                receiveArguments: receiveArguments
            };
        }
        if(previous && !around){
            if(type == "after"){
                // add the listener to the end of the list
                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
                while(previous.next && (previous = previous.next)){}
                previous.next = signal;
                signal.previous = previous;
            }else if(type == "before"){
                // add to beginning
                dispatcher[type] = signal;
                signal.next = previous;
                previous.previous = signal;
            }
        }else{
            // around or first one just replaces
            dispatcher[type] = signal;
        }
        return signal;
    }
    function aspect(type){
        return function(target, methodName, advice, receiveArguments){
            var existing = target[methodName], dispatcher;
            if(!existing || existing.target != target){
                // no dispatcher in place
                target[methodName] = dispatcher = function(){
                    var executionId = nextId;
                    // before advice
                    var args = arguments;
                    var before = dispatcher.before;
                    while(before){
                        args = before.advice.apply(this, args) || args;
                        before = before.next;
                    }
                    // around advice
                    if(dispatcher.around){
                        var results = dispatcher.around.advice(this, args);
                    }
                    // after advice
                    var after = dispatcher.after;
                    while(after && after.id < executionId){
                        if(after.receiveArguments){
                            var newResults = after.advice.apply(this, args);
                            // change the return value only if a new value was returned
                            results = newResults === undefined ? results : newResults;
                        }else{
                            results = after.advice.call(this, results, args);
                        }
                        after = after.next;
                    }
                    return results;
                };
                if(existing){
                    dispatcher.around = {advice: function(target, args){
                        return existing.apply(target, args);
                    }};
                }
                dispatcher.target = target;
            }
            var results = advise((dispatcher || existing), type, advice, receiveArguments);
            advice = null;
            return results;
        };
    }

    return skylark.attach("langx.aspect",{
        after: aspect("after"),
 
        around: aspect("around"),
        
        before: aspect("before")
    });
});
define('skylark-langx-aspect/main',[
	"./aspect"
],function(aspect){
	return aspect;
});
define('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });

define('skylark-langx/aspect',[
    "skylark-langx-aspect"
],function(aspect){
  return aspect;
});
define('skylark-langx/async',[
    "skylark-langx-async"
],function(async){
    return async;
});
define('skylark-langx-datetimes/datetimes',[
    "skylark-langx-ns"
],function(skylark){
     function parseMilliSeconds(str) {

        var strs = str.split(' ');
        var number = parseInt(strs[0]);

        if (isNaN(number)){
            return 0;
        }

        var min = 60000 * 60;

        switch (strs[1].trim().replace(/\./g, '')) {
            case 'minutes':
            case 'minute':
            case 'min':
            case 'mm':
            case 'm':
                return 60000 * number;
            case 'hours':
            case 'hour':
            case 'HH':
            case 'hh':
            case 'h':
            case 'H':
                return min * number;
            case 'seconds':
            case 'second':
            case 'sec':
            case 'ss':
            case 's':
                return 1000 * number;
            case 'days':
            case 'day':
            case 'DD':
            case 'dd':
            case 'd':
                return (min * 24) * number;
            case 'months':
            case 'month':
            case 'MM':
            case 'M':
                return (min * 24 * 28) * number;
            case 'weeks':
            case 'week':
            case 'W':
            case 'w':
                return (min * 24 * 7) * number;
            case 'years':
            case 'year':
            case 'yyyy':
            case 'yy':
            case 'y':
                return (min * 24 * 365) * number;
            default:
                return 0;
        }
    };
	
	return skylark.attach("langx.datetimes",{
		parseMilliSeconds
	});
});
define('skylark-langx-datetimes/main',[
	"./datetimes"
],function(datetimes){
	return datetimes;
});
define('skylark-langx-datetimes', ['skylark-langx-datetimes/main'], function (main) { return main; });

define('skylark-langx/datetimes',[
    "skylark-langx-datetimes"
],function(datetimes){
    return datetimes;
});
define('skylark-langx/Deferred',[
    "skylark-langx-async/Deferred"
],function(Deferred){
    return Deferred;
});
define('skylark-langx-emitter/main',[
	"./Emitter",
	"./Evented"
],function(Emitter){
	return Emitter;
});
define('skylark-langx-emitter', ['skylark-langx-emitter/main'], function (main) { return main; });

define('skylark-langx/Emitter',[
    "skylark-langx-emitter"
],function(Evented){
    return Evented;
});
define('skylark-langx/Evented',[
    "skylark-langx-emitter"
],function(Evented){
    return Evented;
});
define('skylark-langx/funcs',[
    "skylark-langx-funcs"
],function(funcs){
    return funcs;
});
define('skylark-langx/hoster',[
	"skylark-langx-hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx/numbers',[
	"skylark-langx-numbers"
],function(numbers){
	return numbers;
});
define('skylark-langx/objects',[
    "skylark-langx-objects"
],function(objects){
    return objects;
});
define('skylark-langx-strings/strings',[
    "skylark-langx-ns"
],function(skylark){
    // add default escape function for escaping HTML entities
    var escapeCharMap = Object.freeze({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;',
    });
    function replaceChar(c) {
        return escapeCharMap[c];
    }
    var escapeChars = /[&<>"'`=]/g;


     /*
     * Converts camel case into dashes.
     * @param {String} str
     * @return {String}
     * @exapmle marginTop -> margin-top
     */
    function dasherize(str) {
        return str.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/_/g, '-')
            .toLowerCase();
    }

    function deserializeValue(value) {
        try {
            return value ?
                value == "true" ||
                (value == "false" ? false :
                    value == "null" ? null :
                    +value + "" == value ? +value :
                    /^[\[\{]/.test(value) ? JSON.parse(value) :
                    value) : value;
        } catch (e) {
            return value;
        }
    }

    function escapeHTML(str) {
        if (str == null) {
            return '';
        }
        if (!str) {
            return String(str);
        }

        return str.toString().replace(escapeChars, replaceChar);
    }

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : ((r & 0x3) | 0x8);
            return v.toString(16);
        });
    }

    function trim(str) {
        return str == null ? "" : String.prototype.trim.call(str);
    }

    function substitute( /*String*/ template,
        /*Object|Array*/
        map,
        /*Function?*/
        transform,
        /*Object?*/
        thisObject) {
        // summary:
        //    Performs parameterized substitutions on a string. Throws an
        //    exception if any parameter is unmatched.
        // template:
        //    a string with expressions in the form `${key}` to be replaced or
        //    `${key:format}` which specifies a format function. keys are case-sensitive.
        // map:
        //    hash to search for substitutions
        // transform:
        //    a function to process all parameters before substitution takes


        thisObject = thisObject || window;
        transform = transform ?
            proxy(thisObject, transform) : function(v) {
                return v;
            };

        function getObject(key, map) {
            if (key.match(/\./)) {
                var retVal,
                    getValue = function(keys, obj) {
                        var _k = keys.pop();
                        if (_k) {
                            if (!obj[_k]) return null;
                            return getValue(keys, retVal = obj[_k]);
                        } else {
                            return retVal;
                        }
                    };
                return getValue(key.split(".").reverse(), map);
            } else {
                return map[key];
            }
        }

        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
            function(match, key, format) {
                var value = getObject(key, map);
                if (format) {
                    value = getObject(format, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            }); // String
    }

    var idCounter = 0;
    function uniqueId (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    }


    /**
     * https://github.com/cho45/micro-template.js
     * (c) cho45 http://cho45.github.com/mit-license
     */
    function template (id, data) {

        function include(name, args) {
            var stash = {};
            for (var key in template.context.stash) if (template.context.stash.hasOwnProperty(key)) {
                stash[key] = template.context.stash[key];
            }
            if (args) for (var key in args) if (args.hasOwnProperty(key)) {
                stash[key] = args[key];
            }
            var context = template.context;
            context.ret += template(name, stash);
            template.context = context;
        }

        function wrapper(name, fun) {
            var current = template.context.ret;
            template.context.ret = '';
            fun.apply(template.context);
            var content = template.context.ret;
            var orig_content = template.context.stash.content;
            template.context.stash.content = content;
            template.context.ret = current + template(name, template.context.stash);
            template.context.stash.content = orig_content;
        }

        var me = arguments.callee;
        if (!me.cache[id]) me.cache[id] = (function () {
            var name = id, string = /^[\w\-]+$/.test(id) ? me.get(id): (name = 'template(string)', id); // no warnings
            var line = 1, body = (
                "try { " +
                    (me.variable ?  "var " + me.variable + " = this.stash;" : "with (this.stash) { ") +
                        "this.ret += '"  +
                        string.
                            replace(/<%/g, '\x11').replace(/%>/g, '\x13'). // if you want other tag, just edit this line
                            replace(/'(?![^\x11\x13]+?\x13)/g, '\\x27').
                            replace(/^\s*|\s*$/g, '').
                            replace(/\n|\r\n/g, function () { return "';\nthis.line = " + (++line) + "; this.ret += '\\n" }).
                            replace(/\x11=raw(.+?)\x13/g, "' + ($1) + '").
                            replace(/\x11=(.+?)\x13/g, "' + this.escapeHTML($1) + '").
                            replace(/\x11(.+?)\x13/g, "'; $1; this.ret += '") +
                    "'; " + (me.variable ? "" : "}") + "return this.ret;" +
                "} catch (e) { throw 'TemplateError: ' + e + ' (on " + name + "' + ' line ' + this.line + ')'; } " +
                "//@ sourceURL=" + name + "\n" // source map
            ).replace(/this\.ret \+= '';/g, '');
            var func = new Function(body);
            var map  = { '&' : '&amp;', '<' : '&lt;', '>' : '&gt;', '\x22' : '&#x22;', '\x27' : '&#x27;' };
            var escapeHTML = function (string) { return (''+string).replace(/[&<>\'\"]/g, function (_) { return map[_] }) };
            return function (stash) { return func.call(me.context = { escapeHTML: escapeHTML, line: 1, ret : '', stash: stash }) };
        })();
        return data ? me.cache[id](data) : me.cache[id];
    }

    template.cache = {};
    

    template.get = function (id) {
        return document.getElementById(id).innerHTML;
    };

    function rtrim(str) {
        return str.replace(/\s+$/g, '');
    }

    // Slugify a string
    function slugify(str) {
        str = str.replace(/^\s+|\s+$/g, '');

        // Make the string lowercase
        str = str.toLowerCase();

        // Remove accents, swap ñ for n, etc
        var from = "ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;";
        var to   = "AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------";
        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }

        // Remove invalid chars
        //str = str.replace(/[^a-z0-9 -]/g, '') 
        // Collapse whitespace and replace by -
        str = str.replace(/\s+/g, '-') 
        // Collapse dashes
        .replace(/-+/g, '-'); 

        return str;
    }    

    // return boolean if string 'true' or string 'false', or if a parsable string which is a number
    // also supports JSON object and/or arrays parsing
    function toType(str) {
        var type = typeof str;
        if (type !== 'string') {
            return str;
        }
        var nb = parseFloat(str);
        if (!isNaN(nb) && isFinite(str)) {
            return nb;
        }
        if (str === 'false') {
            return false;
        }
        if (str === 'true') {
            return true;
        }

        try {
            str = JSON.parse(str);
        } catch (e) {}

        return str;
    }

	return skylark.attach("langx.strings",{
        camelCase: function(str) {
            return str.replace(/-([\da-z])/g, function(a) {
                return a.toUpperCase().replace('-', '');
            });
        },

        dasherize: dasherize,

        deserializeValue: deserializeValue,

        escapeHTML : escapeHTML,

        generateUUID : generateUUID,

        lowerFirst: function(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        },

        rtrim : rtrim,

        serializeValue: function(value) {
            return JSON.stringify(value)
        },


        substitute: substitute,

        slugify : slugify,

        template : template,

        trim: trim,

        uniqueId: uniqueId,

        upperFirst: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
	}) ; 

});
define('skylark-langx-strings/main',[
	"./strings"
],function(strings){
	return strings;
});
define('skylark-langx-strings', ['skylark-langx-strings/main'], function (main) { return main; });

define('skylark-langx/strings',[
    "skylark-langx-strings"
],function(strings){
    return strings;
});
define('skylark-langx/Stateful',[
	"./Evented",
  "./strings",
  "./objects"
],function(Evented,strings,objects){
    var isEqual = objects.isEqual,
        mixin = objects.mixin,
        result = objects.result,
        isEmptyObject = objects.isEmptyObject,
        clone = objects.clone,
        uniqueId = strings.uniqueId;

    var Stateful = Evented.inherit({
        _construct : function(attributes, options) {
            var attrs = attributes || {};
            options || (options = {});
            this.cid = uniqueId(this.cidPrefix);
            this.attributes = {};
            if (options.collection) this.collection = options.collection;
            if (options.parse) attrs = this.parse(attrs, options) || {};
            var defaults = result(this, 'defaults');
            attrs = mixin({}, defaults, attrs);
            this.set(attrs, options);
            this.changed = {};
        },

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',


        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return clone(this.attributes);
        },


        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null) return this;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options || (options = {});

          // Run validation.
          if (!this._validate(attrs, options)) return false;

          // Extract attributes and options.
          var unset      = options.unset;
          var silent     = options.silent;
          var changes    = [];
          var changing   = this._changing;
          this._changing = true;

          if (!changing) {
            this._previousAttributes = clone(this.attributes);
            this.changed = {};
          }

          var current = this.attributes;
          var changed = this.changed;
          var prev    = this._previousAttributes;

          // For each `set` attribute, update or delete the current value.
          for (var attr in attrs) {
            val = attrs[attr];
            if (!isEqual(current[attr], val)) changes.push(attr);
            if (!isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }

          // Update the `id`.
          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }

          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, mixin({}, options, {unset: true}));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, mixin({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !isEmptyObject(this.changed);
          return this.changed[attr] !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (isEqual(old[attr], val)) continue;
            changed[attr] = val;
          }
          return !isEmptyObject(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return clone(this._previousAttributes);
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, mixin({}, options, {validate: true}));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = mixin({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, mixin(options, {validationError: error}));
          return false;
        }
    });

	return Stateful;
});
define('skylark-langx-topic/topic',[
	"skylark-langx-ns",
	"skylark-langx-emitter/Evented"
],function(skylark,Evented){
	var hub = new Evented();

	return skylark.attach("langx.topic",{
	    publish: function(name, arg1,argn) {
	        var data = [].slice.call(arguments, 1);

	        return hub.trigger({
	            type : name,
	            data : data
	        });
	    },

        subscribe: function(name, listener,ctx) {
        	var handler = function(e){
                listener.apply(ctx,e.data);
            };
            hub.on(name, handler);
            return {
            	remove : function(){
            		hub.off(name,handler);
            	}
            }

        }

	});
});
define('skylark-langx-topic/main',[
	"./topic"
],function(topic){
	return topic;
});
define('skylark-langx-topic', ['skylark-langx-topic/main'], function (main) { return main; });

define('skylark-langx/topic',[
	"skylark-langx-topic"
],function(topic){
	return topic;
});
define('skylark-langx/types',[
    "skylark-langx-types"
],function(types){
    return types;
});
define('skylark-langx/langx',[
    "./skylark",
    "./arrays",
    "./ArrayStore",
    "./aspect",
    "./async",
    "./datetimes",
    "./Deferred",
    "./Emitter",
    "./Evented",
    "./funcs",
    "./hoster",
    "./klass",
    "./numbers",
    "./objects",
    "./Stateful",
    "./strings",
    "./topic",
    "./types"
], function(skylark,arrays,ArrayStore,aspect,async,datetimes,Deferred,Emitter,Evented,funcs,hoster,klass,numbers,objects,Stateful,strings,topic,types) {
    "use strict";
    var toString = {}.toString,
        concat = Array.prototype.concat,
        indexOf = Array.prototype.indexOf,
        slice = Array.prototype.slice,
        filter = Array.prototype.filter,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin,
        isFunction = types.isFunction;


    function funcArg(context, arg, idx, payload) {
        return isFunction(arg) ? arg.call(context, idx, payload) : arg;
    }

    function getQueryParams(url) {
        var url = url || window.location.href,
            segs = url.split("?"),
            params = {};

        if (segs.length > 1) {
            segs[1].split("&").forEach(function(queryParam) {
                var nv = queryParam.split('=');
                params[nv[0]] = nv[1];
            });
        }
        return params;
    }


    function toPixel(value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
    }


    var _uid = 1;

    function uid(obj) {
        return obj._uid || (obj._uid = _uid++);
    }

    function langx() {
        return langx;
    }

    mixin(langx, {
        createEvent : Emitter.createEvent,

        funcArg: funcArg,

        getQueryParams: getQueryParams,

        toPixel: toPixel,

        uid: uid,

        URL: typeof window !== "undefined" ? window.URL || window.webkitURL : null

    });


    mixin(langx, arrays,aspect,datetimes,funcs,numbers,objects,strings,types,{
        ArrayStore : ArrayStore,

        async : async,
        
        Deferred: Deferred,

        Emitter: Emitter,

        Evented: Evented,

        hoster : hoster,

        klass : klass,
       
        Stateful: Stateful,

        topic : topic
    });

    return skylark.langx = langx;
});
define('skylark-domx-browser/browser',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {
    "use strict";

    var browser = langx.hoster.browser;
 
    var checkedCssProperties = {
            "transitionproperty": "TransitionProperty",
        },
        transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        },
        transEndEventName = null;


    var css3PropPrefix = "",
        css3StylePrefix = "",
        css3EventPrefix = "",

        cssStyles = {},
        cssProps = {},

        vendorPrefix,
        vendorPrefixRE,
        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,

        document = window.document,
        testEl = document.createElement("div"),

        matchesSelector = testEl.webkitMatchesSelector ||
                          testEl.mozMatchesSelector ||
                          testEl.oMatchesSelector ||
                          testEl.matchesSelector,

        requestFullScreen = testEl.requestFullscreen || 
                            testEl.webkitRequestFullscreen || 
                            testEl.mozRequestFullScreen || 
                            testEl.msRequestFullscreen,

        exitFullScreen =  document.exitFullscreen ||
                          document.webkitCancelFullScreen ||
                          document.mozCancelFullScreen ||
                          document.msExitFullscreen,

        testStyle = testEl.style;

    for (var name in testStyle) {
        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);
        if (matched) {
            if (!vendorPrefixRE) {
                vendorPrefix = matched[1];
                vendorPrefixRE = new RegExp("^(" + vendorPrefix + ")(.*)$");

                css3StylePrefix = vendorPrefix;
                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';
                css3EventPrefix = vendorPrefix.toLowerCase();
            }

            cssStyles[langx.lowerFirst(matched[2])] = name;
            var cssPropName = langx.dasherize(matched[2]);
            cssProps[cssPropName] = css3PropPrefix + cssPropName;

            if (transEndEventNames[name]) {
              transEndEventName = transEndEventNames[name];
            }
        }
    }

    if (!transEndEventName) {
        if (testStyle["transition"] !== undefined) {
            transEndEventName = transEndEventNames["transition"];
        }
    }

    function normalizeCssEvent(name) {
        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();
    }

    function normalizeCssProperty(name) {
        return cssProps[name] || name;
    }

    function normalizeStyleProperty(name) {
        return cssStyles[name] || name;
    }

    langx.mixin(browser, {
        css3PropPrefix: css3PropPrefix,

        isIE : !!/msie/i.exec( window.navigator.userAgent ),

        normalizeStyleProperty: normalizeStyleProperty,

        normalizeCssProperty: normalizeCssProperty,

        normalizeCssEvent: normalizeCssEvent,

        matchesSelector: matchesSelector,

        requestFullScreen : requestFullScreen,

        exitFullscreen : requestFullScreen,

        location: function() {
            return window.location;
        },

        support : {

        }

    });

    if  (transEndEventName) {
        browser.support.transition = {
            end : transEndEventName
        };
    }

    testEl = null;

    return skylark.attach("domx.browser",browser);
});

define('skylark-domx-browser/main',[
	"./browser"
],function(browser){
	return browser;
});
define('skylark-domx-browser', ['skylark-domx-browser/main'], function (main) { return main; });

define('skylark-domx-noder/noder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser"
], function(skylark, langx, browser) {
    var isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g),
        fragmentRE = /^\s*<(\w+|!)[^>]*>/,
        singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        div = document.createElement("div"),
        table = document.createElement('table'),
        tableBody = document.createElement('tbody'),
        tableRow = document.createElement('tr'),
        containers = {
            'tr': tableBody,
            'tbody': table,
            'thead': table,
            'tfoot': table,
            'td': tableRow,
            'th': tableRow,
            '*': div
        },
        rootNodeRE = /^(?:body|html)$/i,
        map = Array.prototype.map,
        slice = Array.prototype.slice;

    function ensureNodes(nodes, copyByClone) {
        if (!langx.isArrayLike(nodes)) {
            nodes = [nodes];
        }
        if (copyByClone) {
            nodes = map.call(nodes, function(node) {
                return node.cloneNode(true);
            });
        }
        return langx.flatten(nodes);
    }

    function nodeName(elm, chkName) {
        var name = elm.nodeName && elm.nodeName.toLowerCase();
        if (chkName !== undefined) {
            return name === chkName.toLowerCase();
        }
        return name;
    };


    function activeElement(doc) {
        doc = doc || document;
        var el;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            el = doc.activeElement;
        } catch ( error ) {
            el = doc.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if ( !el ) {
            el = doc.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if ( !el.nodeName ) {
            el = doc.body;
        }

        return el;
    };

    function enhancePlaceContent(placing,node) {
        if (langx.isFunction(placing)) {
            return placing.apply(node,[]);
        }
        if (langx.isArrayLike(placing)) {
            var neddsFlattern;
            for (var i=0;i<placing.length;i++) {
                if (langx.isFunction(placing[i])) {
                    placing[i] = placing[i].apply(node,[]);
                    if (langx.isArrayLike(placing[i])) {
                        neddsFlattern = true;
                    }
                }
            }
            if (neddsFlattern) {
                placing = langx.flatten(placing);
            }
        }
        return placing;
    }
    function after(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone),
                refNode = refNode.nextSibling;

            for (var i = 0; i < nodes.length; i++) {
                if (refNode) {
                    parent.insertBefore(nodes[i], refNode);
                } else {
                    parent.appendChild(nodes[i]);
                }
            }
        }
        return this;
    }

    function append(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var parentNode = node,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            parentNode.appendChild(nodes[i]);
        }
        return this;
    }

    function before(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                parent.insertBefore(nodes[i], refNode);
            }
        }
        return this;
    }
    /*   
     * Get the children of the specified node, including text and comment nodes.
     * @param {HTMLElement} elm
     */
    function contents(elm) {
        if (nodeName(elm, "iframe")) {
            return elm.contentDocument;
        }
        return elm.childNodes;
    }

    /*   
     * Create a element and set attributes on it.
     * @param {HTMLElement} tag
     * @param {props} props
     * @param } parent
     */
    function createElement(tag, props, parent) {
        var node = document.createElement(tag);
        if (props) {
            for (var name in props) {
                node.setAttribute(name, props[name]);
            }
        }
        if (parent) {
            append(parent, node);
        }
        return node;
    }

    /*   
     * Create a DocumentFragment from the HTML fragment.
     * @param {String} html
     */
    function createFragment(html) {
        // A special case optimization for a single tag
        html = langx.trim(html);
        if (singleTagRE.test(html)) {
            return [createElement(RegExp.$1)];
        }

        var name = fragmentRE.test(html) && RegExp.$1
        if (!(name in containers)) {
            name = "*"
        }
        var container = containers[name];
        container.innerHTML = "" + html;
        dom = slice.call(container.childNodes);

        dom.forEach(function(node) {
            container.removeChild(node);
        })

        return dom;
    }

    /*   
     * Create a deep copy of the set of matched elements.
     * @param {HTMLElement} node
     * @param {Boolean} deep
     */
    function clone(node, deep) {
        var self = this,
            clone;

        // TODO: Add feature detection here in the future
        if (!isIE || node.nodeType !== 1 || deep) {
            return node.cloneNode(deep);
        }

        // Make a HTML5 safe shallow copy
        if (!deep) {
            clone = document.createElement(node.nodeName);

            // Copy attribs
            each(self.getAttribs(node), function(attr) {
                self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
            });

            return clone;
        }
    }

    /*   
     * Check to see if a dom node is a descendant of another dom node .
     * @param {String} node
     * @param {Node} child
     */
    function contains(node, child) {
        return isChildOf(child, node);
    }

    /*   
     * Create a new Text node.
     * @param {String} text
     * @param {Node} child
     */
    function createTextNode(text) {
        return document.createTextNode(text);
    }

    /*   
     * Get the current document object.
     */
    function doc() {
        return document;
    }

    /*   
     * Remove all child nodes of the set of matched elements from the DOM.
     * @param {Object} node
     */
    function empty(node) {
        while (node.hasChildNodes()) {
            var child = node.firstChild;
            node.removeChild(child);
        }
        return this;
    }

    var fulledEl = null;

    function fullScreen(el) {
        if (el === false) {
            browser.exitFullScreen.apply(document);
        } else if (el) {
            browser.requestFullScreen.apply(el);
            fulledEl = el;
        } else {
            return (
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
            )
        }
    }


    // Selectors
    function focusable( element, hasTabindex ) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" );
            return img.length > 0 && img.is( ":visible" );
        }

        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
            focusableIfVisible = !element.disabled;

            if ( focusableIfVisible ) {

                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $( element ).closest( "fieldset" )[ 0 ];
                if ( fieldset ) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ( "a" === nodeName ) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
    };


   var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
 
    /*   
     * Get the HTML contents of the first element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} html
     */
    function html(node, html) {
        if (html === undefined) {
            return node.innerHTML;
        } else {
            this.empty(node);
            html = html || "";
            if (langx.isString(html)) {
                html = html.replace( rxhtmlTag, "<$1></$2>" );
            }
            if (langx.isString(html) || langx.isNumber(html)) {               
                node.innerHTML = html;
            } else if (langx.isArrayLike(html)) {
                for (var i = 0; i < html.length; i++) {
                    node.appendChild(html[i]);
                }
            } else {
                node.appendChild(html);
            }

            return this;
        }
    }


    /*   
     * Check to see if a dom node is a descendant of another dom node.
     * @param {Node} node
     * @param {Node} parent
     * @param {Node} directly
     */
    function isChildOf(node, parent, directly) {
        if (directly) {
            return node.parentNode === parent;
        }
        if (document.documentElement.contains) {
            return parent.contains(node);
        }
        while (node) {
            if (parent === node) {
                return true;
            }

            node = node.parentNode;
        }

        return false;
    }

    /*   
     * Check to see if a dom node is a document.
     * @param {Node} node
     */
    function isDocument(node) {
        return node != null && node.nodeType == node.DOCUMENT_NODE
    }

    /*   
     * Check to see if a dom node is in the document
     * @param {Node} node
     */
    function isInDocument(node) {
      return (node === document.body) ? true : document.body.contains(node);
    }        

    var blockNodes = ["div", "p", "ul", "ol", "li", "blockquote", "hr", "pre", "h1", "h2", "h3", "h4", "h5", "table"];

    function isBlockNode(node) {
        if (!node || node.nodeType === 3) {
          return false;
        }
        return new RegExp("^(" + (blockNodes.join('|')) + ")$").test(node.nodeName.toLowerCase());
    }


    /*   
     * Get the owner document object for the specified element.
     * @param {Node} elm
     */
    function ownerDoc(elm) {
        if (!elm) {
            return document;
        }

        if (elm.nodeType == 9) {
            return elm;
        }

        return elm.ownerDocument;
    }

    /*   
     *
     * @param {Node} elm
     */
    function ownerWindow(elm) {
        var doc = ownerDoc(elm);
        return doc.defaultView || doc.parentWindow;
    }

    /*   
     * insert one or more nodes as the first children of the specified node.
     * @param {Node} node
     * @param {Node or ArrayLike} placing
     * @param {Boolean Optional} copyByClone
     */
    function prepend(node, placing, copyByClone) {
        var parentNode = node,
            refNode = parentNode.firstChild,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            if (refNode) {
                parentNode.insertBefore(nodes[i], refNode);
            } else {
                parentNode.appendChild(nodes[i]);
            }
        }
        return this;
    }

    /*   
     *
     * @param {Node} elm
     */
    function offsetParent(elm) {
        var parent = elm.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && document.defaultView.getComputedStyle(parent).position == "static") {
            parent = parent.offsetParent;
        }
        return parent;
    }

    /*   
     * Remove the set of matched elements from the DOM.
     * @param {Node} node
     */
    function remove(node) {
        if (node && node.parentNode) {
            try {
                node.parentNode.removeChild(node);
            } catch (e) {
                console.warn("The node is already removed", e);
            }
        }
        return this;
    }

    function removeChild(node,children) {
        if (!langx.isArrayLike(children)) {
            children = [children];
        }
        for (var i=0;i<children.length;i++) {
            node.removeChild(children[i]);
        }

        return this;
    }

    function scrollParent( elm, includeHidden ) {
        var position = document.defaultView.getComputedStyle(elm).position,
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter( function() {
                var parent = $( this );
                if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                    return false;
                }
                return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                    parent.css( "overflow-x" ) );
            } ).eq( 0 );

        return position === "fixed" || !scrollParent.length ?
            $( this[ 0 ].ownerDocument || document ) :
            scrollParent;
    };


    function reflow(elm) {
        if (el == null) {
          elm = document;
        }
        elm.offsetHeight;

        return this;      
    }

    /*   
     * Replace an old node with the specified node.
     * @param {Node} node
     * @param {Node} oldNode
     */
    function replace(node, oldNode) {
        oldNode.parentNode.replaceChild(node, oldNode);
        return this;
    }


    /*   
     * traverse the specified node and its descendants, perform the callback function on each
     * @param {Node} node
     * @param {Function} fn
     */
    function traverse(node, fn) {
        fn(node)
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            traverse(node.childNodes[i], fn);
        }
        return this;
    }

    /*   
     *
     * @param {Node} node
     */
    function reverse(node) {
        var firstChild = node.firstChild;
        for (var i = node.children.length - 1; i > 0; i--) {
            if (i > 0) {
                var child = node.children[i];
                node.insertBefore(child, firstChild);
            }
        }
    }

    /*   
     * Wrap an HTML structure around each element in the set of matched elements.
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapper(node, wrapperNode) {
        if (langx.isString(wrapperNode)) {
            wrapperNode = this.createFragment(wrapperNode).firstChild;
        }
        node.parentNode.insertBefore(wrapperNode, node);
        wrapperNode.appendChild(node);
    }

    /*   
     * Wrap an HTML structure around the content of each element in the set of matched
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapperInner(node, wrapperNode) {
        var childNodes = slice.call(node.childNodes);
        node.appendChild(wrapperNode);
        for (var i = 0; i < childNodes.length; i++) {
            wrapperNode.appendChild(childNodes[i]);
        }
        return this;
    }

    /*   
     * Remove the parents of the set of matched elements from the DOM, leaving the matched
     * @param {Node} node
     */
    function unwrap(node) {
        var child, parent = node.parentNode;
        if (parent) {
            if (this.isDoc(parent.parentNode)) return;
            parent.parentNode.insertBefore(node, parent);
        }
    }

    function noder() {
        return noder;
    }

    langx.mixin(noder, {
        active  : activeElement,

        blur : function(el) {
            el.blur();
        },

        body: function() {
            return document.body;
        },

        clone: clone,
        contents: contents,

        createElement: createElement,

        createFragment: createFragment,

        contains: contains,

        createTextNode: createTextNode,

        doc: doc,

        empty: empty,

        fullScreen: fullScreen,

        focusable: focusable,

        html: html,

        isChildOf: isChildOf,

        isDocument: isDocument,

        isInDocument: isInDocument,

        isWindow: langx.isWindow,

        nodeName : nodeName,

        offsetParent: offsetParent,

        ownerDoc: ownerDoc,

        ownerWindow: ownerWindow,

        after: after,

        before: before,

        prepend: prepend,

        append: append,

        reflow: reflow,

        remove: remove,

        removeChild : removeChild,

        replace: replace,

        traverse: traverse,

        reverse: reverse,

        wrapper: wrapper,

        wrapperInner: wrapperInner,

        unwrap: unwrap
    });

    return skylark.attach("domx.noder" , noder);
});
define('skylark-domx-noder/main',[
	"./noder"
],function(noder){
	return noder;
});
define('skylark-domx-noder', ['skylark-domx-noder/main'], function (main) { return main; });

define('skylark-domx-finder/finder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder"
], function(skylark, langx, browser, noder) {
    var local = {},
        filter = Array.prototype.filter,
        slice = Array.prototype.slice,
        nativeMatchesSelector = browser.matchesSelector;

    /*
    ---
    name: Slick.Parser
    description: Standalone CSS3 Selector parser
    provides: Slick.Parser
    ...
    */
    ;
    (function() {

        var parsed,
            separatorIndex,
            combinatorIndex,
            reversed,
            cache = {},
            reverseCache = {},
            reUnescape = /\\/g;

        var parse = function(expression, isReversed) {
            if (expression == null) return null;
            if (expression.Slick === true) return expression;
            expression = ('' + expression).replace(/^\s+|\s+$/g, '');
            reversed = !!isReversed;
            var currentCache = (reversed) ? reverseCache : cache;
            if (currentCache[expression]) return currentCache[expression];
            parsed = {
                Slick: true,
                expressions: [],
                raw: expression,
                reverse: function() {
                    return parse(this.raw, true);
                }
            };
            separatorIndex = -1;
            while (expression != (expression = expression.replace(regexp, parser)));
            parsed.length = parsed.expressions.length;
            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
        };

        var reverseCombinator = function(combinator) {
            if (combinator === '!') return ' ';
            else if (combinator === ' ') return '!';
            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
            else return '!' + combinator;
        };

        var reverse = function(expression) {
            var expressions = expression.expressions;
            for (var i = 0; i < expressions.length; i++) {
                var exp = expressions[i];
                var last = {
                    parts: [],
                    tag: '*',
                    combinator: reverseCombinator(exp[0].combinator)
                };

                for (var j = 0; j < exp.length; j++) {
                    var cexp = exp[j];
                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
                    cexp.combinator = cexp.reverseCombinator;
                    delete cexp.reverseCombinator;
                }

                exp.reverse().push(last);
            }
            return expression;
        };

        var escapeRegExp = (function() {
            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
            var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g,
                to = '\\';
            return function(string) {
                return string.replace(from, to)
            }
        }())

        var regexp = new RegExp(
            "^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
            .replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
            .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
            .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
        );

        function parser(
            rawMatch,

            separator,
            combinator,
            combinatorChildren,

            tagName,
            id,
            className,

            attributeKey,
            attributeOperator,
            attributeQuote,
            attributeValue,

            pseudoMarker,
            pseudoClass,
            pseudoQuote,
            pseudoClassQuotedValue,
            pseudoClassValue
        ) {
            if (separator || separatorIndex === -1) {
                parsed.expressions[++separatorIndex] = [];
                combinatorIndex = -1;
                if (separator) return '';
            }

            if (combinator || combinatorChildren || combinatorIndex === -1) {
                combinator = combinator || ' ';
                var currentSeparator = parsed.expressions[separatorIndex];
                if (reversed && currentSeparator[combinatorIndex])
                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
                currentSeparator[++combinatorIndex] = {
                    combinator: combinator,
                    tag: '*'
                };
            }

            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

            if (tagName) {
                currentParsed.tag = tagName.replace(reUnescape, '');

            } else if (id) {
                currentParsed.id = id.replace(reUnescape, '');

            } else if (className) {
                className = className.replace(reUnescape, '');

                if (!currentParsed.classList) currentParsed.classList = [];
                if (!currentParsed.classes) currentParsed.classes = [];
                currentParsed.classList.push(className);
                currentParsed.classes.push({
                    value: className,
                    regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
                });

            } else if (pseudoClass) {
                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

                if (!currentParsed.pseudos) currentParsed.pseudos = [];
                currentParsed.pseudos.push({
                    key: pseudoClass.replace(reUnescape, ''),
                    value: pseudoClassValue,
                    type: pseudoMarker.length == 1 ? 'class' : 'element'
                });

            } else if (attributeKey) {
                attributeKey = attributeKey.replace(reUnescape, '');
                attributeValue = (attributeValue || '').replace(reUnescape, '');

                var test, regexp;

                switch (attributeOperator) {
                    case '^=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue));
                        break;
                    case '$=':
                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');
                        break;
                    case '~=':
                        regexp = new RegExp('(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)');
                        break;
                    case '|=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');
                        break;
                    case '=':
                        test = function(value) {
                            return attributeValue == value;
                        };
                        break;
                    case '*=':
                        test = function(value) {
                            return value && value.indexOf(attributeValue) > -1;
                        };
                        break;
                    case '!=':
                        test = function(value) {
                            return attributeValue != value;
                        };
                        break;
                    default:
                        test = function(value) {
                            return !!value;
                        };
                }

                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {
                    return false;
                };

                if (!test) test = function(value) {
                    return value && regexp.test(value);
                };

                if (!currentParsed.attributes) currentParsed.attributes = [];
                currentParsed.attributes.push({
                    key: attributeKey,
                    operator: attributeOperator,
                    value: attributeValue,
                    test: test
                });

            }

            return '';
        };

        // Slick NS

        var Slick = (this.Slick || {});

        Slick.parse = function(expression) {
            return parse(expression);
        };

        Slick.escapeRegExp = escapeRegExp;

        if (!this.Slick) this.Slick = Slick;

    }).apply(local);


    var simpleClassSelectorRE = /^\.([\w-]*)$/,
        simpleIdSelectorRE = /^#([\w-]*)$/,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        slice = Array.prototype.slice;


    local.parseSelector = local.Slick.parse;


    var pseudos = local.pseudos = {
        // custom pseudos
        "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        'checked': function(elm) {
            return !!elm.checked;
        },

        'contains': function(elm, idx, nodes, text) {
            if ($(this).text().indexOf(text) > -1) return this
        },

        'disabled': function(elm) {
            return !!elm.disabled;
        },

        'enabled': function(elm) {
            return !elm.disabled;
        },

        'eq': function(elm, idx, nodes, value) {
            return (idx == value);
        },

        'even': function(elm, idx, nodes, value) {
            return (idx % 2) === 0;
        },

        'focus': function(elm) {
            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);
        },

        'focusable': function( elm ) {
            return noder.focusable(elm, elm.tabindex != null );
        },

        'first': function(elm, idx) {
            return (idx === 0);
        },

        'gt': function(elm, idx, nodes, value) {
            return (idx > value);
        },

        'has': function(elm, idx, nodes, sel) {
            return find(elm, sel);
        },

        // Element/input types
        "header": function(elem) {
            return rheader.test(elem.nodeName);
        },

        'hidden': function(elm) {
            return !local.pseudos["visible"](elm);
        },

        "input": function(elem) {
            return rinputs.test(elem.nodeName);
        },

        'last': function(elm, idx, nodes) {
            return (idx === nodes.length - 1);
        },

        'lt': function(elm, idx, nodes, value) {
            return (idx < value);
        },

        'not': function(elm, idx, nodes, sel) {
            return !matches(elm, sel);
        },

        'odd': function(elm, idx, nodes, value) {
            return (idx % 2) === 1;
        },

        /*   
         * Get the parent of each element in the current set of matched elements.
         * @param {Object} elm
         */
        'parent': function(elm) {
            return !!elm.parentNode;
        },

        'selected': function(elm) {
            return !!elm.selected;
        },

        'tabbable': function(elm) {
            var tabIndex = elm.tabindex,
                hasTabindex = tabIndex != null;
            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );
        },

        'text': function(elm) {
            return elm.type === "text";
        },

        'visible': function(elm) {
            return elm.offsetWidth && elm.offsetWidth
        }
    };

    ["first", "eq", "last"].forEach(function(item) {
        pseudos[item].isArrayFilter = true;
    });



    pseudos["nth"] = pseudos["eq"];

    function createInputPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    function createButtonPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }

    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
    }) {
        pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
    }) {
        pseudos[i] = createButtonPseudo(i);
    }


    local.divide = function(cond) {
        var nativeSelector = "",
            customPseudos = [],
            tag,
            id,
            classes,
            attributes,
            pseudos;


        if (id = cond.id) {
            nativeSelector += ("#" + id);
        }
        if (classes = cond.classes) {
            for (var i = classes.length; i--;) {
                nativeSelector += ("." + classes[i].value);
            }
        }
        if (attributes = cond.attributes) {
            for (var i = 0; i < attributes.length; i++) {
                if (attributes[i].operator) {
                    nativeSelector += ("[" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + "]");
                } else {
                    nativeSelector += ("[" + attributes[i].key + "]");
                }
            }
        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (this.pseudos[part.key]) {
                    customPseudos.push(part);
                } else {
                    if (part.value !== undefined) {
                        nativeSelector += (":" + part.key + "(" + JSON.stringify(part))
                    }
                }
            }
        }

        if (tag = cond.tag) {
            if (tag !== "*") {
                nativeSelector = tag.toUpperCase() + nativeSelector;
            }
        }

        if (!nativeSelector) {
            nativeSelector = "*";
        }

        return {
            nativeSelector: nativeSelector,
            customPseudos: customPseudos
        }

    };

    local.check = function(node, cond, idx, nodes, arrayFilte) {
        var tag,
            id,
            classes,
            attributes,
            pseudos,

            i, part, cls, pseudo;

        if (!arrayFilte) {
            if (tag = cond.tag) {
                var nodeName = node.nodeName.toUpperCase();
                if (tag == '*') {
                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
                } else {
                    if (nodeName != (tag || "").toUpperCase()) return false;
                }
            }

            if (id = cond.id) {
                if (node.getAttribute('id') != id) {
                    return false;
                }
            }


            if (classes = cond.classes) {
                for (i = classes.length; i--;) {
                    cls = node.getAttribute('class');
                    if (!(cls && classes[i].regexp.test(cls))) return false;
                }
            }

            if (attributes = cond.attributes) {
                for (i = attributes.length; i--;) {
                    part = attributes[i];
                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;
                }
            }

        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (pseudo = this.pseudos[part.key]) {
                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {
                        if (!pseudo(node, idx, nodes, part.value)) {
                            return false;
                        }
                    }
                } else {
                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    local.match = function(node, selector) {

        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            parsed = selector;
        }

        if (!parsed) {
            return true;
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            simpleExpCounter = 0,
            i,
            currentExpression;
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];
                if (this.check(node, exp)) {
                    return true;
                }
                simpleExpCounter++;
            }
        }

        if (simpleExpCounter == parsed.length) {
            return false;
        }

        var nodes = this.query(document, parsed),
            item;
        for (i = 0; item = nodes[i++];) {
            if (item === node) {
                return true;
            }
        }
        return false;
    };


    local.filterSingle = function(nodes, exp) {
        var matchs = filter.call(nodes, function(node, idx) {
            return local.check(node, exp, idx, nodes, false);
        });

        matchs = filter.call(matchs, function(node, idx) {
            return local.check(node, exp, idx, matchs, true);
        });
        return matchs;
    };

    local.filter = function(nodes, selector) {
        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            return local.filterSingle(nodes, selector);
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            i,
            currentExpression,
            ret = [];
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];

                var matchs = local.filterSingle(nodes, exp);

                ret = langx.uniq(ret.concat(matchs));
            } else {
                throw new Error("not supported selector:" + selector);
            }
        }

        return ret;

    };

    local.combine = function(elm, bit) {
        var op = bit.combinator,
            cond = bit,
            node1,
            nodes = [];

        switch (op) {
            case '>': // direct children
                nodes = children(elm, cond);
                break;
            case '+': // next sibling
                node1 = nextSibling(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '^': // first child
                node1 = firstChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '~': // next siblings
                nodes = nextSiblings(elm, cond);
                break;
            case '++': // next sibling and previous sibling
                var prev = previousSibling(elm, cond, true),
                    next = nextSibling(elm, cond, true);
                if (prev) {
                    nodes.push(prev);
                }
                if (next) {
                    nodes.push(next);
                }
                break;
            case '~~': // next siblings and previous siblings
                nodes = siblings(elm, cond);
                break;
            case '!': // all parent nodes up to document
                nodes = ancestors(elm, cond);
                break;
            case '!>': // direct parent (one level)
                node1 = parent(elm, cond);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!+': // previous sibling
                nodes = previousSibling(elm, cond, true);
                break;
            case '!^': // last child
                node1 = lastChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!~': // previous siblings
                nodes = previousSiblings(elm, cond);
                break;
            default:
                var divided = this.divide(bit);
                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));
                if (divided.customPseudos) {
                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, false)
                        });

                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, true)
                        });
                    }
                }
                break;

        }
        return nodes;
    }

    local.query = function(node, selector, single) {


        var parsed = this.Slick.parse(selector);

        var
            founds = [],
            currentExpression, currentBit,
            expressions = parsed.expressions;

        for (var i = 0;
            (currentExpression = expressions[i]); i++) {
            var currentItems = [node],
                found;
            for (var j = 0;
                (currentBit = currentExpression[j]); j++) {
                found = langx.map(currentItems, function(item, i) {
                    return local.combine(item, currentBit)
                });
                if (found) {
                    currentItems = found;
                }
            }
            if (found) {
                founds = founds.concat(found);
            }
        }

        return founds;
    }

    /*
     * Get the nearest ancestor of the specified element,optional matched by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestor(node, selector, root) {
        var rootIsSelector = root && langx.isString(root);
        while (node = node.parentNode) {
            if (matches(node, selector)) {
                return node;
            }
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
        }
        return null;
    }

    /*
     * Get the ancestors of the specitied element , optionally filtered by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestors(node, selector, root) {
        var ret = [],
            rootIsSelector = root && langx.isString(root);
        while ((node = node.parentNode) && (node.nodeType !== 9)) {
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (langx.isArrayLike(root)) {
                    if (langx.inArray(node,root)>-1) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
            ret.push(node); // TODO
        }

        if (selector) {
            ret = local.filter(ret, selector);
        }
        return ret;
    }

    /*
     * Returns a element by its ID.
     * @param {string} id
     */
    function byId(id, doc) {
        doc = doc || noder.doc();
        return doc.getElementById(id);
    }

    /*
     * Get the children of the specified element , optionally filtered by a selector.
     * @param {string} node
     * @param {String optionlly} selector
     */
    function children(node, selector) {
        var childNodes = node.childNodes,
            ret = [];
        for (var i = 0; i < childNodes.length; i++) {
            var node = childNodes[i];
            if (node.nodeType == 1) {
                ret.push(node);
            }
        }
        if (selector) {
            ret = local.filter(ret, selector);
        }
        return ret;
    }

    function closest(node, selector) {
        while (node && !(matches(node, selector))) {
            node = node.parentNode;
        }

        return node;
    }

    /*
     * Get the decendant of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendants(elm, selector) {
        // Selector
        try {
            return slice.call(elm.querySelectorAll(selector));
        } catch (matchError) {
            //console.log(matchError);
        }
        return local.query(elm, selector);
    }

    /*
     * Get the nearest decendent of the specified element,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendant(elm, selector) {
        // Selector
        try {
            return elm.querySelector(selector);
        } catch (matchError) {
            //console.log(matchError);
        }
        var nodes = local.query(elm, selector);
        if (nodes.length > 0) {
            return nodes[0];
        } else {
            return null;
        }
    }

    /*
     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function find(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        if (matches(elm, selector)) {
            return elm;
        } else {
            return descendant(elm, selector);
        }
    }

    /*
     * Get the findAll of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function findAll(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        return descendants(elm, selector);
    }

    /*
     * Get the first child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String} first
     */
    function firstChild(elm, selector, first) {
        var childNodes = elm.childNodes,
            node = childNodes[0];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (first) {
                    break;
                }
            }
            node = node.nextSibling;
        }

        return null;
    }

    /*
     * Get the last child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String } last
     */
    function lastChild(elm, selector, last) {
        var childNodes = elm.childNodes,
            node = childNodes[childNodes.length - 1];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (last) {
                    break;
                }
            }
            node = node.previousSibling;
        }

        return null;
    }

    /*
     * Check the specified element against a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function matches(elm, selector) {
        if (!selector || !elm || elm.nodeType !== 1) {
            return false
        }

        if (langx.isString(selector)) {
            try {
                return nativeMatchesSelector.call(elm, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
            } catch (matchError) {
                //console.log(matchError);
            }
            return local.match(elm, selector);
        } else if (langx.isArrayLike(selector)) {
            return langx.inArray(elm, selector) > -1;
        } else if (langx.isPlainObject(selector)) {
            return local.check(elm, selector);
        } else {
            return elm === selector;
        }

    }

    /*
     * Get the nearest next sibing of the specitied element , optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional} adjacent
     */
    function nextSibling(elm, selector, adjacent) {
        var node = elm.nextSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.nextSibling;
        }
        return null;
    }

    /*
     * Get the next siblings of the specified element , optional filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function nextSiblings(elm, selector) {
        var node = elm.nextSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    /*
     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function parent(elm, selector) {
        var node = elm.parentNode;
        if (node && (!selector || matches(node, selector))) {
            return node;
        }

        return null;
    }

    /*
     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional } adjacent
     */
    function previousSibling(elm, selector, adjacent) {
        var node = elm.previousSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.previousSibling;
        }
        return null;
    }

    /*
     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function previousSiblings(elm, selector) {
        var node = elm.previousSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.previousSibling;
        }
        return ret;
    }

    /*
     * Selects all sibling elements that follow after the “prev” element, have the same parent, and match the filtering “siblings” selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function siblings(elm, selector) {
        var node = elm.parentNode.firstChild,
            ret = [];
        while (node) {
            if (node.nodeType == 1 && node !== elm) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    var finder = function() {
        return finder;
    };

    langx.mixin(finder, {

        ancestor: ancestor,

        ancestors: ancestors,

        byId: byId,

        children: children,

        closest: closest,

        descendant: descendant,

        descendants: descendants,

        find: find,

        findAll: findAll,

        firstChild: firstChild,

        lastChild: lastChild,

        matches: matches,

        nextSibling: nextSibling,

        nextSiblings: nextSiblings,

        parent: parent,

        previousSibling,

        previousSiblings,

        pseudos: local.pseudos,

        siblings: siblings
    });

    return skylark.attach("domx.finder", finder);
});
define('skylark-domx-finder/main',[
	"./finder"
],function(finder){

	return finder;
});
define('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });

define('skylark-domx-data/data',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-finder",
    "skylark-domx-noder"
], function(skylark, langx, finder,noder) {
    var map = Array.prototype.map,
        filter = Array.prototype.filter,
        camelCase = langx.camelCase,
        deserializeValue = langx.deserializeValue,

        capitalRE = /([A-Z])/g,
        propMap = {
            'tabindex': 'tabIndex',
            'readonly': 'readOnly',
            'for': 'htmlFor',
            'class': 'className',
            'maxlength': 'maxLength',
            'cellspacing': 'cellSpacing',
            'cellpadding': 'cellPadding',
            'rowspan': 'rowSpan',
            'colspan': 'colSpan',
            'usemap': 'useMap',
            'frameborder': 'frameBorder',
            'contenteditable': 'contentEditable'
        };

    // Strip and collapse whitespace according to HTML spec
    function stripAndCollapse( value ) {
      var tokens = value.match( /[^\x20\t\r\n\f]+/g ) || [];
      return tokens.join( " " );
    }


    var valHooks = {
      option: {
        get: function( elem ) {
          var val = elem.getAttribute( "value" );
          return val != null ?  val :  stripAndCollapse(text( elem ) );
        }
      },
      select: {
        get: function( elem ) {
          var value, option, i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;

          if ( index < 0 ) {
            i = max;

          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for ( ; i < max; i++ ) {
            option = options[ i ];

            if ( option.selected &&

                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                ( !option.parentNode.disabled ||
                  !noder.nodeName( option.parentNode, "optgroup" ) ) ) {

              // Get the specific value for the option
              value = val(option);

              // We don't need an array for one selects
              if ( one ) {
                return value;
              }

              // Multi-Selects return an array
              values.push( value );
            }
          }

          return values;
        },

        set: function( elem, value ) {
          var optionSet, option,
            options = elem.options,
            values = langx.makeArray( value ),
            i = options.length;

          while ( i-- ) {
            option = options[ i ];

            /* eslint-disable no-cond-assign */

            if ( option.selected =
              langx.inArray( valHooks.option.get( option ), values ) > -1
            ) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if ( !optionSet ) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    };


    // Radios and checkboxes getter/setter
    langx.each( [ "radio", "checkbox" ], function() {
      valHooks[ this ] = {
        set: function( elem, value ) {
          if ( langx.isArray( value ) ) {
            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );
          }
        }
      };
    });



    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function setAttribute(elm, name, value) {
        if (value == null) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    function aria(elm, name, value) {
        return this.attr(elm, "aria-" + name, value);
    }

    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function attr(elm, name, value) {
        if (value === undefined) {
            if (typeof name === "object") {
                for (var attrName in name) {
                    attr(elm, attrName, name[attrName]);
                }
                return this;
            } else {
                if (elm.hasAttribute && elm.hasAttribute(name)) {
                    return elm.getAttribute(name);
                }
            }
        } else {
            elm.setAttribute(name, value);
            return this;
        }
    }


    /*
     *  Read all "data-*" attributes from a node
     * @param {Object} elm  
     */

    function _attributeData(elm) {
        var store = {}
        langx.each(elm.attributes || [], function(i, attr) {
            if (attr.name.indexOf('data-') == 0) {
                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);
            }
        })
        return store;
    }

    function _store(elm, confirm) {
        var store = elm["_$_store"];
        if (!store && confirm) {
            store = elm["_$_store"] = _attributeData(elm);
        }
        return store;
    }

    function _getData(elm, name) {
        if (name === undefined) {
            return _store(elm, true);
        } else {
            var store = _store(elm);
            if (store) {
                if (name in store) {
                    return store[name];
                }
                var camelName = camelCase(name);
                if (camelName in store) {
                    return store[camelName];
                }
            }
            var attrName = 'data-' + name.replace(capitalRE, "-$1").toLowerCase()
            return attr(elm, attrName);
        }

    }

    function _setData(elm, name, value) {
        var store = _store(elm, true);
        store[camelCase(name)] = value;
    }


    /*
     * xxx
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function data(elm, name, value) {

        if (value === undefined) {
            if (typeof name === "object") {
                for (var dataAttrName in name) {
                    _setData(elm, dataAttrName, name[dataAttrName]);
                }
                return this;
            } else {
                return _getData(elm, name);
            }
        } else {
            _setData(elm, name, value);
            return this;
        }
    } 
    /*
     * Remove from the element all items that have not yet been run. 
     * @param {Object} elm  
     */

    function cleanData(elm) {
        if (elm["_$_store"]) {
            delete elm["_$_store"];
        }
    }

    /*
     * Remove a previously-stored piece of data. 
     * @param {Object} elm  
     * @param {Array} names
     */
    function removeData(elm, names) {
        if (names) {
            if (langx.isString(names)) {
                names = names.split(/\s+/);
            }
            var store = _store(elm, true);
            names.forEach(function(name) {
                delete store[name];
            });            
        } else {
            cleanData(elm);
        }
        return this;
    }

    /*
     * xxx 
     * @param {Object} elm  
     * @param {Array} names
     */
    function pluck(nodes, property) {
        return map.call(nodes, function(elm) {
            return elm[property];
        });
    }

    /*
     * Get or set the value of an property for the specified element.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function prop(elm, name, value) {
        name = propMap[name] || name;
        if (value === undefined) {
            return elm[name];
        } else {
            elm[name] = value;
            return this;
        }
    }

    /*
     * remove Attributes  
     * @param {Object} elm  
     * @param {String} name
     */
    function removeAttr(elm, name) {
        name.split(' ').forEach(function(attr) {
            setAttribute(elm, attr);
        });
        return this;
    }


    /*
     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.
     * @param {Object} elm  
     * @param {String} name
     */
    function removeProp(elm, name) {
        name.split(' ').forEach(function(prop) {
            delete elm[prop];
        });
        return this;
    }

    /*   
     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  
     * @param {Object} elm  
     * @param {String} txt
     */
    function text(elm, txt) {
        if (txt === undefined) {
            return elm.textContent;
        } else {
            elm.textContent = txt == null ? '' : '' + txt;
            return this;
        }
    }

    /*   
     * Get the current value of the first element in the set of matched elements or set the value of every matched element.
     * @param {Object} elm  
     * @param {String} value
     */
    function val(elm, value) {
        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];
        if (value === undefined) {
/*
            if (elm.multiple) {
                // select multiple values
                var selectedOptions = filter.call(finder.find(elm, "option"), (function(option) {
                    return option.selected;
                }));
                return pluck(selectedOptions, "value");
            } else {
                if (/input|textarea/i.test(elm.tagName)) {
                  return elm.value;
                }
                return text(elm);
            }
*/

          if ( hooks &&  "get" in hooks &&  ( ret = hooks.get( elm, "value" ) ) !== undefined ) {
            return ret;
          }

          ret = elm.value;

          // Handle most common string cases
          if ( typeof ret === "string" ) {
            return ret.replace( /\r/g, "" );
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;

        } else {
/*          
            if (/input|textarea/i.test(elm.tagName)) {
              elm.value = value;
            } else {
              text(elm,value);
            }
            return this;
*/
          // Treat null/undefined as ""; convert numbers to string
          if ( value == null ) {
            value = "";

          } else if ( typeof value === "number" ) {
            value += "";

          } else if ( langx.isArray( value ) ) {
            value = langx.map( value, function( value1 ) {
              return value1 == null ? "" : value1 + "";
            } );
          }

          // If set returns undefined, fall back to normal setting
          if ( !hooks || !( "set" in hooks ) || hooks.set( elm, value, "value" ) === undefined ) {
            elm.value = value;
          }
        }      
    }


    finder.pseudos.data = function( elem, i, match,dataName ) {
        return !!data( elem, dataName || match[3]);
    };
   

    function datax() {
        return datax;
    }

    langx.mixin(datax, {
        aria: aria,

        attr: attr,

        cleanData: cleanData,

        data: data,

        pluck: pluck,

        prop: prop,

        removeAttr: removeAttr,

        removeData: removeData,

        removeProp: removeProp,

        text: text,

        val: val,

        valHooks : valHooks
    });

    return skylark.attach("domx.data", datax);
});
define('skylark-domx-query/query',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {
    var some = Array.prototype.some,
        push = Array.prototype.push,
        every = Array.prototype.every,
        concat = Array.prototype.concat,
        slice = Array.prototype.slice,
        map = Array.prototype.map,
        filter = Array.prototype.filter,
        forEach = Array.prototype.forEach,
        indexOf = Array.prototype.indexOf,
        sort = Array.prototype.sort,
        isQ;

    var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;

    var funcArg = langx.funcArg,
        isArrayLike = langx.isArrayLike,
        isString = langx.isString,
        uniq = langx.uniq,
        isFunction = langx.isFunction;

    var type = langx.type,
        isArray = langx.isArray,

        isWindow = langx.isWindow,

        isDocument = langx.isDocument,

        isObject = langx.isObject,

        isPlainObject = langx.isPlainObject,

        compact = langx.compact,

        flatten = langx.flatten,

        camelCase = langx.camelCase,

        dasherize = langx.dasherize,
        children = finder.children;

    function wrapper_node_operation(func, context, oldValueFunc) {
        return function(html) {
            var argType, nodes = langx.map(arguments, function(arg) {
                argType = type(arg)
                return argType == "function" || argType == "object" || argType == "array" || arg == null ?
                    arg : noder.createFragment(arg)
            });
            if (nodes.length < 1) {
                return this
            }
            this.each(function(idx) {
                func.apply(context, [this, nodes, idx > 0]);
            });
            return this;
        }
    }

    function wrapper_map(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            var result = langx.map(self, function(elem, idx) {
                return func.apply(context, [elem].concat(params));
            });
            return query(uniq(result));
        }
    }

    function wrapper_selector(func, context, last) {
        return function(selector) {
            var self = this,
                params = slice.call(arguments);
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) {
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem] : [elem, selector]);
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }

    function wrapper_selector_until(func, context, last) {
        return function(util, selector) {
            var self = this,
                params = slice.call(arguments);
            //if (selector === undefined) { //TODO : needs confirm?
            //    selector = util;
            //    util = undefined;
            //}
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) { // TODO
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem, util] : [elem, selector, util]);
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }


    function wrapper_every_act(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            this.each(function(idx,node) {
                func.apply(context, [this].concat(params));
            });
            return self;
        }
    }

    function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {
        return function(arg1) {
            var self = this,
                params = slice.call(arguments);
            forEach.call(self, function(elem, idx) {
                var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));
                func.apply(context, [elem, arg1].concat(params.slice(1)));
            });
            return self;
        }
    }

    function wrapper_some_chk(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            return some.call(self, function(elem) {
                return func.apply(context, [elem].concat(params));
            });
        }
    }

    function wrapper_name_value(func, context, oldValueFunc) {
        return function(name, value) {
            var self = this,
                params = slice.call(arguments);

            if (langx.isPlainObject(name) || langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem].concat(params));
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0], name]);
                }
            }

        }
    }

    function wrapper_value(func, context, oldValueFunc) {
        return function(value) {
            var self = this;

            if (langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem, newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0]]);
                }
            }

        }
    }

    var NodeList = langx.klass({
        klassName: "SkNodeList",
        init: function(selector, context) {
            var self = this,
                match, nodes, node, props;

            if (selector) {
                self.context = context = context || noder.doc();

                if (isString(selector)) {
                    // a html string or a css selector is expected
                    self.selector = selector;

                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        match = [null, selector, null];
                    } else {
                        match = rquickExpr.exec(selector);
                    }

                    if (match) {
                        if (match[1]) {
                            // if selector is html
                            nodes = noder.createFragment(selector);

                            if (langx.isPlainObject(context)) {
                                props = context;
                            }

                        } else {
                            node = finder.byId(match[2], noder.ownerDoc(context));

                            if (node) {
                                // if selector is id
                                nodes = [node];
                            }

                        }
                    } else {
                        // if selector is css selector
                        if (langx.isString(context)) {
                            context = finder.find(context);
                        }

                        nodes = finder.descendants(context, selector);
                    }
                } else {
                    if (selector !== window && isArrayLike(selector)) {
                        // a dom node array is expected
                        nodes = selector;
                    } else {
                        // a dom node is expected
                        nodes = [selector];
                    }
                    //self.add(selector, false);
                }
            }


            if (nodes) {

                push.apply(self, nodes);

                if (props) {
                    for ( var name  in props ) {
                        // Properties of context are called as methods if possible
                        if ( langx.isFunction( this[ name ] ) ) {
                            this[ name ]( props[ name ] );
                        } else {
                            this.attr( name, props[ name ] );
                        }
                    }
                }
            }

            return self;
        }
    });

    var query = (function() {
        isQ = function(object) {
            return object instanceof NodeList;
        }
        init = function(selector, context) {
            return new NodeList(selector, context);
        }

        var $ = function(selector, context) {
            if (isFunction(selector)) {
                $.ready(function() {
                    selector($);
                });
            } else if (isQ(selector)) {
                return selector;
            } else {
                if (context && isQ(context) && isString(selector)) {
                    return context.find(selector);
                }
                return init(selector, context);
            }
        };

        $.fn = NodeList.prototype;
        langx.mixin($.fn, {
            // `map` and `slice` in the jQuery API work differently
            // from their array counterparts
            length : 0,

            map: function(fn) {
                return $(uniq(langx.map(this, function(el, i) {
                    return fn.call(el, i, el)
                })));
            },

            slice: function() {
                return $(slice.apply(this, arguments))
            },

            forEach: function() {
                return forEach.apply(this,arguments);
            },

            get: function(idx) {
                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
            },

            indexOf: function() {
                return indexOf.apply(this,arguments);
            },

            sort : function() {
                return sort.apply(this,arguments);
            },

            toArray: function() {
                return slice.call(this);
            },

            size: function() {
                return this.length
            },

            //remove: wrapper_every_act(noder.remove, noder),
            remove : function(selector) {
                if (selector) {
                    return this.find(selector).remove();
                }
                this.each(function(i,node){
                    noder.remove(node);
                });
                return this;
            },

            each: function(callback) {
                langx.each(this, callback);
                return this;
            },

            filter: function(selector) {
                if (isFunction(selector)) return this.not(this.not(selector))
                return $(filter.call(this, function(element) {
                    return finder.matches(element, selector)
                }))
            },

            add: function(selector, context) {
                return $(uniq(this.toArray().concat($(selector, context).toArray())));
            },

            is: function(selector) {
                if (this.length > 0) {
                    var self = this;
                    if (langx.isString(selector)) {
                        return some.call(self,function(elem) {
                            return finder.matches(elem, selector);
                        });
                    } else if (langx.isArrayLike(selector)) {
                       return some.call(self,function(elem) {
                            return langx.inArray(elem, selector) > -1;
                        });
                    } else if (langx.isHtmlNode(selector)) {
                       return some.call(self,function(elem) {
                            return elem ==  selector;
                        });
                    }
                }
                return false;
            },
            
            not: function(selector) {
                var nodes = []
                if (isFunction(selector) && selector.call !== undefined)
                    this.each(function(idx,node) {
                        if (!selector.call(this, idx,node)) nodes.push(this)
                    })
                else {
                    var excludes = typeof selector == 'string' ? this.filter(selector) :
                        (isArrayLike(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
                    this.forEach(function(el) {
                        if (excludes.indexOf(el) < 0) nodes.push(el)
                    })
                }
                return $(nodes)
            },

            has: function(selector) {
                return this.filter(function() {
                    return isObject(selector) ?
                        noder.contains(this, selector) :
                        $(this).find(selector).size()
                })
            },

            eq: function(idx) {
                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
            },

            first: function() {
                return this.eq(0);
            },

            last: function() {
                return this.eq(-1);
            },

            find: wrapper_selector(finder.descendants, finder),

            closest: wrapper_selector(finder.closest, finder),
            /*
                        closest: function(selector, context) {
                            var node = this[0],
                                collection = false
                            if (typeof selector == 'object') collection = $(selector)
                            while (node && !(collection ? collection.indexOf(node) >= 0 : finder.matches(node, selector)))
                                node = node !== context && !isDocument(node) && node.parentNode
                            return $(node)
                        },
            */


            parents: wrapper_selector(finder.ancestors, finder),

            parentsUntil: wrapper_selector_until(finder.ancestors, finder),


            parent: wrapper_selector(finder.parent, finder),

            children: wrapper_selector(finder.children, finder),

            contents: wrapper_map(noder.contents, noder),

            empty: wrapper_every_act(noder.empty, noder),

            html: wrapper_value(noder.html, noder),

            // `pluck` is borrowed from Prototype.js
            pluck: function(property) {
                return langx.map(this, function(el) {
                    return el[property]
                })
            },

            pushStack : function(elms) {
                var ret = $(elms);
                ret.prevObject = this;
                return ret;
            },
            
            replaceWith: function(newContent) {
                return this.before(newContent).remove();
            },

            wrap: function(structure) {
                var func = isFunction(structure)
                if (this[0] && !func)
                    var dom = $(structure).get(0),
                        clone = dom.parentNode || this.length > 1

                return this.each(function(index,node) {
                    $(this).wrapAll(
                        func ? structure.call(this, index,node) :
                        clone ? dom.cloneNode(true) : dom
                    )
                })
            },

            wrapAll: function(wrappingElement) {
                if (this[0]) {
                    $(this[0]).before(wrappingElement = $(wrappingElement));
                    var children;
                    // drill down to the inmost element
                    while ((children = wrappingElement.children()).length) {
                        wrappingElement = children.first();
                    }
                    $(wrappingElement).append(this);
                }
                return this
            },

            wrapInner: function(wrappingElement) {
                var func = isFunction(wrappingElement)
                return this.each(function(index,node) {
                    var self = $(this),
                        contents = self.contents(),
                        dom = func ? wrappingElement.call(this, index,node) : wrappingElement
                    contents.length ? contents.wrapAll(dom) : self.append(dom)
                })
            },

            unwrap: function(selector) {
                if (this.parent().children().length === 0) {
                    // remove dom without text
                    this.parent(selector).not("body").each(function() {
                        $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));
                    });
                } else {
                    this.parent().each(function() {
                        $(this).replaceWith($(this).children())
                    });
                }
                return this
            },

            clone: function() {
                return this.map(function() {
                    return this.cloneNode(true)
                })
            },


            toggle: function(setting) {
                return this.each(function() {
                    var el = $(this);
                    (setting === undefined ? el.css("display") == "none" : setting) ? el.show(): el.hide()
                })
            },

            prev: function(selector) {
                return $(this.pluck('previousElementSibling')).filter(selector || '*')
            },

            prevAll: wrapper_selector(finder.previousSiblings, finder),

            next: function(selector) {
                return $(this.pluck('nextElementSibling')).filter(selector || '*')
            },

            nextAll: wrapper_selector(finder.nextSiblings, finder),

            siblings: wrapper_selector(finder.siblings, finder),

            index: function(elem) {
                if (elem) {
                    return this.indexOf($(elem)[0]);
                } else {
                    return this.parent().children().indexOf(this[0]);
                }
            }
        });

        // for now
        $.fn.detach = $.fn.remove;

        $.fn.hover = function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        };


        var traverseNode = noder.traverse;


        $.fn.after = wrapper_node_operation(noder.after, noder);

        $.fn.prepend = wrapper_node_operation(noder.prepend, noder);

        $.fn.before = wrapper_node_operation(noder.before, noder);

        $.fn.append = wrapper_node_operation(noder.append, noder);


        langx.each( {
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function( name, original ) {
            $.fn[ name ] = function( selector ) {
                var elems,
                    ret = [],
                    insert = $( selector ),
                    last = insert.length - 1,
                    i = 0;

                for ( ; i <= last; i++ ) {
                    elems = i === last ? this : this.clone( true );
                    $( insert[ i ] )[ original ]( elems );

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // .get() because push.apply(_, arraylike) throws on ancient WebKit
                    push.apply( ret, elems.get() );
                }

                return this.pushStack( ret );
            };
        } );

/*
        $.fn.insertAfter = function(html) {
            $(html).after(this);
            return this;
        };

        $.fn.insertBefore = function(html) {
            $(html).before(this);
            return this;
        };

        $.fn.appendTo = function(html) {
            $(html).append(this);
            return this;
        };

        $.fn.prependTo = function(html) {
            $(html).prepend(this);
            return this;
        };

        $.fn.replaceAll = function(selector) {
            $(selector).replaceWith(this);
            return this;
        };
*/
        return $;
    })();

    (function($) {
        $.fn.scrollParent = function( includeHidden ) {
            var position = this.css( "position" ),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter( function() {
                    var parent = $( this );
                    if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                        return false;
                    }
                    return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                        parent.css( "overflow-x" ) );
                } ).eq( 0 );

            return position === "fixed" || !scrollParent.length ?
                $( this[ 0 ].ownerDocument || document ) :
                scrollParent;
        };

    })(query);


    (function($) {
        $.fn.end = function() {
            return this.prevObject || $()
        }

        $.fn.andSelf = function() {
            return this.add(this.prevObject || $())
        }

        $.fn.addBack = function(selector) {
            if (this.prevObject) {
                if (selector) {
                    return this.add(this.prevObject.filter(selector));
                } else {
                    return this.add(this.prevObject);
                }
            } else {
                return this;
            }
        }

        'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings,prev,prevAll,next,nextAll'.split(',').forEach(function(property) {
            var fn = $.fn[property]
            $.fn[property] = function() {
                var ret = fn.apply(this, arguments)
                ret.prevObject = this
                return ret
            }
        })
    })(query);


    (function($) {
        $.fn.query = $.fn.find;

        $.fn.place = function(refNode, position) {
            // summary:
            //      places elements of this node list relative to the first element matched
            //      by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
            // queryOrNode:
            //      may be a string representing any valid CSS3 selector or a DOM node.
            //      In the selector case, only the first matching element will be used
            //      for relative positioning.
            // position:
            //      can be one of:
            //
            //      -   "last" (default)
            //      -   "first"
            //      -   "before"
            //      -   "after"
            //      -   "only"
            //      -   "replace"
            //
            //      or an offset in the childNodes
            if (langx.isString(refNode)) {
                refNode = finder.descendant(refNode);
            } else if (isQ(refNode)) {
                refNode = refNode[0];
            }
            return this.each(function(i, node) {
                switch (position) {
                    case "before":
                        noder.before(refNode, node);
                        break;
                    case "after":
                        noder.after(refNode, node);
                        break;
                    case "replace":
                        noder.replace(refNode, node);
                        break;
                    case "only":
                        noder.empty(refNode);
                        noder.append(refNode, node);
                        break;
                    case "first":
                        noder.prepend(refNode, node);
                        break;
                        // else fallthrough...
                    default: // aka: last
                        noder.append(refNode, node);
                }
            });
        };

        $.fn.addContent = function(content, position) {
            if (content.template) {
                content = langx.substitute(content.template, content);
            }
            return this.append(content);
        };



        $.fn.disableSelection = ( function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.on( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                } );
            };
        } )();

        $.fn.enableSelection = function() {
            return this.off( ".ui-disableSelection" );
        };

        $.fn.reflow = function() {
            return noder.flow(this[0]);
        };

        $.fn.isBlockNode = function() {
            return noder.isBlockNode(this[0]);
        };
       

    })(query);

    query.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = plugins.instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };


    query.wraps = {
        wrapper_node_operation,
        wrapper_map,
        wrapper_value,
        wrapper_selector,
        wrapper_some_chk,
        wrapper_selector_until,
        wrapper_every_act_firstArgFunc,
        wrapper_every_act,
        wrapper_name_value

    };

    return skylark.attach("domx.query", query);

});
define('skylark-domx-query/main',[
	"./query"
],function(query){
	return query;
});
define('skylark-domx-query', ['skylark-domx-query/main'], function (main) { return main; });

define('skylark-domx-velm/velm',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query"
], function(skylark, langx, noder, finder, $) {
    var map = Array.prototype.map,
        slice = Array.prototype.slice;
    /*
     * VisualElement is a skylark class type wrapping a visule dom node,
     * provides a number of prototype methods and supports chain calls.
     */
    var VisualElement = langx.klass({
        klassName: "VisualElement",

        "_construct": function(node) {
            if (langx.isString(node)) {
                if (node.charAt(0) === "<") {
                    //html
                    node = noder.createFragment(node)[0];
                } else {
                    // id
                    node = document.getElementById(node);
                }
            }
            this._elm = node;
        }
    });

    VisualElement.prototype.$ = VisualElement.prototype.query = function(selector) {
        return $(selector,this._elm);
    };

    VisualElement.prototype.elm = function() {
        return this._elm;
    };

    /*
     * the VisualElement object wrapping document.body
     */
    var root = new VisualElement(document.body),
        velm = function(node) {
            if (node) {
                return new VisualElement(node);
            } else {
                return root;
            }
        };
    /*
     * Extend VisualElement prototype with wrapping the specified methods.
     * @param {ArrayLike} fn
     * @param {Object} context
     */
    function _delegator(fn, context) {
        return function() {
            var self = this,
                elem = self._elm,
                ret = fn.apply(context, [elem].concat(slice.call(arguments)));

            if (ret) {
                if (ret === context) {
                    return self;
                } else {
                    if (ret instanceof HTMLElement) {
                        ret = new VisualElement(ret);
                    } else if (langx.isArrayLike(ret)) {
                        ret = map.call(ret, function(el) {
                            if (el instanceof HTMLElement) {
                                return new VisualElement(el);
                            } else {
                                return el;
                            }
                        })
                    }
                }
            }
            return ret;
        };
    }

    langx.mixin(velm, {
        batch: function(nodes, action, args) {
            nodes.forEach(function(node) {
                var elm = (node instanceof VisualElement) ? node : velm(node);
                elm[action].apply(elm, args);
            });

            return this;
        },

        root: new VisualElement(document.body),

        VisualElement: VisualElement,

        partial: function(name, fn) {
            var props = {};

            props[name] = fn;

            VisualElement.partial(props);
        },

        delegate: function(names, context) {
            var props = {};

            names.forEach(function(name) {
                props[name] = _delegator(context[name], context);
            });

            VisualElement.partial(props);
        }
    });

    // from ./finder
    velm.delegate([
        "ancestor",
        "ancestors",
        "children",
        "descendant",
        "find",
        "findAll",
        "firstChild",
        "lastChild",
        "matches",
        "nextSibling",
        "nextSiblings",
        "parent",
        "previousSibling",
        "previousSiblings",
        "siblings"
    ], finder);

    /*
     * find a dom element matched by the specified selector.
     * @param {String} selector
     */
    velm.find = function(selector) {
        if (selector === "body") {
            return this.root;
        } else {
            return this.root.descendant(selector);
        }
    };


    // from ./noder
    velm.delegate([
        "after",
        "append",
        "before",
        "clone",
        "contains",
        "contents",
        "empty",
        "html",
        "isChildOf",
        "isDocument",
        "isInDocument",
        "isWindow",
        "ownerDoc",
        "prepend",
        "remove",
        "removeChild",
        "replace",
        "reverse",
        "throb",
        "traverse",
        "wrapper",
        "wrapperInner",
        "unwrap"
    ], noder);


    return skylark.attach("domx.velm", velm);
});
define('skylark-domx-velm/main',[
	"./velm"
],function(velm){
	return velm;
});
define('skylark-domx-velm', ['skylark-domx-velm/main'], function (main) { return main; });

define('skylark-domx-data/main',[
    "./data",
    "skylark-domx-velm",
    "skylark-domx-query"    
],function(data,velm,$){
    // from ./data
    velm.delegate([
        "attr",
        "data",
        "prop",
        "removeAttr",
        "removeData",
        "text",
        "val"
    ], data);

    $.fn.text = $.wraps.wrapper_value(data.text, data, data.text);

    $.fn.attr = $.wraps.wrapper_name_value(data.attr, data, data.attr);

    $.fn.removeAttr = $.wraps.wrapper_every_act(data.removeAttr, data);

    $.fn.prop = $.wraps.wrapper_name_value(data.prop, data, data.prop);

    $.fn.removeProp = $.wraps.wrapper_every_act(data.removeProp, data);

    $.fn.data = $.wraps.wrapper_name_value(data.data, data, data.data);

    $.fn.removeData = $.wraps.wrapper_every_act(data.removeData, data);

    $.fn.val = $.wraps.wrapper_value(data.val, data, data.val);


    return data;
});
define('skylark-domx-data', ['skylark-domx-data/main'], function (main) { return main; });

define('skylark-domx-eventer/eventer',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-finder",
    "skylark-domx-noder",
    "skylark-domx-data"
], function(skylark, langx, browser, finder, noder, datax) {
    var mixin = langx.mixin,
        each = langx.each,
        slice = Array.prototype.slice,
        uid = langx.uid,
        ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,
        eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        },
        readyRE = /complete|loaded|interactive/;

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            langx.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = langx.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = langx.returnFalse;
            });
        }
        return event;
    }

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            type: segs[0],
            ns: segs.slice(1).sort().join(" ")
        };
    }

    //create a custom dom event
    var createEvent = (function() {
        var EventCtors = [
                window["CustomEvent"], // 0 default
                window["CompositionEvent"], // 1
                window["DragEvent"], // 2
                window["Event"], // 3
                window["FocusEvent"], // 4
                window["KeyboardEvent"], // 5
                window["MessageEvent"], // 6
                window["MouseEvent"], // 7
                window["MouseScrollEvent"], // 8
                window["MouseWheelEvent"], // 9
                window["MutationEvent"], // 10
                window["ProgressEvent"], // 11
                window["TextEvent"], // 12
                window["TouchEvent"], // 13
                window["UIEvent"], // 14
                window["WheelEvent"], // 15
                window["ClipboardEvent"] // 16
            ],
            NativeEvents = {
                "compositionstart": 1, // CompositionEvent
                "compositionend": 1, // CompositionEvent
                "compositionupdate": 1, // CompositionEvent

                "beforecopy": 16, // ClipboardEvent
                "beforecut": 16, // ClipboardEvent
                "beforepaste": 16, // ClipboardEvent
                "copy": 16, // ClipboardEvent
                "cut": 16, // ClipboardEvent
                "paste": 16, // ClipboardEvent

                "drag": 2, // DragEvent
                "dragend": 2, // DragEvent
                "dragenter": 2, // DragEvent
                "dragexit": 2, // DragEvent
                "dragleave": 2, // DragEvent
                "dragover": 2, // DragEvent
                "dragstart": 2, // DragEvent
                "drop": 2, // DragEvent

                "abort": 3, // Event
                "change": 3, // Event
                "error": 3, // Event
                "selectionchange": 3, // Event
                "submit": 3, // Event
                "reset": 3, // Event

                "focus": 4, // FocusEvent
                "blur": 4, // FocusEvent
                "focusin": 4, // FocusEvent
                "focusout": 4, // FocusEvent

                "keydown": 5, // KeyboardEvent
                "keypress": 5, // KeyboardEvent
                "keyup": 5, // KeyboardEvent

                "message": 6, // MessageEvent

                "click": 7, // MouseEvent
                "contextmenu": 7, // MouseEvent
                "dblclick": 7, // MouseEvent
                "mousedown": 7, // MouseEvent
                "mouseup": 7, // MouseEvent
                "mousemove": 7, // MouseEvent
                "mouseover": 7, // MouseEvent
                "mouseout": 7, // MouseEvent
                "mouseenter": 7, // MouseEvent
                "mouseleave": 7, // MouseEvent


                "textInput": 12, // TextEvent

                "touchstart": 13, // TouchEvent
                "touchmove": 13, // TouchEvent
                "touchend": 13, // TouchEvent

                "load": 14, // UIEvent
                "resize": 14, // UIEvent
                "select": 14, // UIEvent
                "scroll": 14, // UIEvent
                "unload": 14, // UIEvent,

                "wheel": 15 // WheelEvent
            };

        function getEventCtor(type) {
            var idx = NativeEvents[type];
            if (!idx) {
                idx = 0;
            }
            return EventCtors[idx];
        }

        return function(type, props) {
            //create a custom dom event

            if (langx.isString(type)) {
                props = props || {};
            } else {
                props = type || {};
                type = props.type || "";
            }
            var parsed = parse(type);
            type = parsed.type;

            props = langx.mixin({
                bubbles: true,
                cancelable: true
            }, props);

            if (parsed.ns) {
                props.namespace = parsed.ns;
            }

            var ctor = getEventCtor(type),
                e = new ctor(type, props);

            langx.safeMixin(e, props);

            return compatible(e);
        };
    })();

    function createProxy(src, props) {
        var key,
            proxy = {
                originalEvent: src
            };
        for (key in src) {
            if (key !== "keyIdentifier" && !ignoreProperties.test(key) && src[key] !== undefined) {
                proxy[key] = src[key];
            }
        }
        if (props) {
            langx.mixin(proxy, props);
        }
        return compatible(proxy, src);
    }

    var
        specialEvents = {},
        focusinSupported = "onfocusin" in window,
        focus = { focus: "focusin", blur: "focusout" },
        hover = { mouseenter: "mouseover", mouseleave: "mouseout" },
        realEvent = function(type) {
            return hover[type] || (focusinSupported && focus[type]) || type;
        },
        handlers = {},
        EventBindings = langx.klass({
            init: function(target, event) {
                this._target = target;
                this._event = event;
                this._bindings = [];
            },

            add: function(fn, options) {
                var bindings = this._bindings,
                    binding = {
                        fn: fn,
                        options: langx.mixin({}, options)
                    };

                bindings.push(binding);

                var self = this;
                if (!self._listener) {
                    self._listener = function(domEvt) {
                        var elm = this,
                            e = createProxy(domEvt),
                            args = domEvt._args,
                            bindings = self._bindings,
                            ns = e.namespace;

                        if (langx.isDefined(args)) {
                            args = [e].concat(args);
                        } else {
                            args = [e];
                        }

                        langx.each(bindings, function(idx, binding) {
                            var match = elm;
                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                                return false;
                            }
                            var fn = binding.fn,
                                options = binding.options || {},
                                selector = options.selector,
                                one = options.one,
                                data = options.data;

                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {
                                return;
                            }
                            if (selector) {
                                match = finder.closest(e.target, selector);
                                if (match && match !== elm) {
                                    langx.mixin(e, {
                                        currentTarget: match,
                                        liveFired: elm
                                    });
                                } else {
                                    return;
                                }
                            }

                            var originalEvent = self._event;
                            if (originalEvent in hover) {
                                var related = e.relatedTarget;
                                if (related && (related === match || noder.contains(match, related))) {
                                    return;
                                }
                            }

                            if (langx.isDefined(data)) {
                                e.data = data;
                            }

                            if (one) {
                                self.remove(fn, options);
                            }

                            var result = fn.apply(match, args);

                            if (result === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });;
                    };

                    var event = self._event;
                    /*
                                        if (event in hover) {
                                            var l = self._listener;
                                            self._listener = function(e) {
                                                var related = e.relatedTarget;
                                                if (!related || (related !== this && !noder.contains(this, related))) {
                                                    return l.apply(this, arguments);
                                                }
                                            }
                                        }
                    */

                    if (self._target.addEventListener) {
                        self._target.addEventListener(realEvent(event), self._listener, false);
                    } else {
                        console.warn("invalid eventer object", self._target);
                    }
                }

            },
            remove: function(fn, options) {
                options = langx.mixin({}, options);

                function matcherFor(ns) {
                    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
                }
                var matcher;
                if (options.ns) {
                    matcher = matcherFor(options.ns);
                }

                this._bindings = this._bindings.filter(function(binding) {
                    var removing = (!fn || fn === binding.fn) &&
                        (!matcher || matcher.test(binding.options.ns)) &&
                        (!options.selector || options.selector == binding.options.selector);

                    return !removing;
                });
                if (this._bindings.length == 0) {
                    if (this._target.removeEventListener) {
                        this._target.removeEventListener(realEvent(this._event), this._listener, false);
                    }
                    this._listener = null;
                }
            }
        }),
        EventsHandler = langx.klass({
            init: function(elm) {
                this._target = elm;
                this._handler = {};
            },

            // add a event listener
            // selector Optional
            register: function(event, callback, options) {
                // Seperate the event from the namespace
                var parsed = parse(event),
                    event = parsed.type,
                    specialEvent = specialEvents[event],
                    bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);

                var events = this._handler;

                // Check if there is already a handler for this event
                if (events[event] === undefined) {
                    events[event] = new EventBindings(this._target, bindingEvent || event);
                }

                // Register the new callback function
                events[event].add(callback, langx.mixin({
                    ns: parsed.ns
                }, options)); // options:{selector:xxx}
            },

            // remove a event listener
            unregister: function(event, fn, options) {
                // Check for parameter validtiy
                var events = this._handler,
                    parsed = parse(event);
                event = parsed.type;

                if (event) {
                    var listener = events[event];

                    if (listener) {
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                } else {
                    //remove all events
                    for (event in events) {
                        var listener = events[event];
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                }
            }
        }),

        findHandler = function(elm) {
            var id = uid(elm),
                handler = handlers[id];
            if (!handler) {
                handler = handlers[id] = new EventsHandler(elm);
            }
            return handler;
        };

    /*   
     * Remove an event handler for one or more events from the specified element.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {String　Optional } selector
     * @param {Function} callback
     */
    function off(elm, events, selector, callback) {
        var $this = this
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                off(elm, type, selector, fn);
            })
            return $this;
        }

        if (!langx.isString(selector) && !langx.isFunction(callback) && callback !== false) {
            callback = selector;
            selector = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        if (events) events.forEach(function(event) {

            handler.unregister(event, callback, {
                selector: selector,
            });
        });
        return this;
    }

    /*   
     * Attach an event handler function for one or more events to the selected elements.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {String　Optional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     * @param {Boolean　Optional} one
     */
    function on(elm, events, selector, data, callback, one) {

        var autoRemove, delegator;
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                on(elm, type, selector, data, fn, one);
            });
            return this;
        }

        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = undefined;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        events.forEach(function(event) {
            if (event == "ready") {
                return ready(callback);
            }
            handler.register(event, callback, {
                data: data,
                selector: selector,
                one: !!one
            });
        });
        return this;
    }

    /*   
     * Attach a handler to an event for the elements. The handler is executed at most once per 
     * @param {HTMLElement} elm  
     * @param {String} event
     * @param {String　Optional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     */
    function one(elm, events, selector, data, callback) {
        on(elm, events, selector, data, callback, 1);

        return this;
    }

    /*   
     * Prevents propagation and clobbers the default action of the passed event. The same as calling event.preventDefault() and event.stopPropagation(). 
     * @param {String} event
     */
    function stop(event) {
        if (window.document.all) {
            event.keyCode = 0;
        }
        if (event.preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
        return this;
    }
    /*   
     * Execute all handlers and behaviors attached to the matched elements for the given event  
     * @param {String} evented
     * @param {String} type
     * @param {Array or PlainObject } args
     */
    function trigger(evented, type, args) {
        var e;
        if (type instanceof Event) {
            e = type;
        } else {
            e = createEvent(type, args);
        }
        e._args = args;

        var fn = (evented.dispatchEvent || evented.trigger);
        if (fn) {
            fn.call(evented, e);
        } else {
            console.warn("The evented parameter is not a eventable object");
        }

        return this;
    }
    /*   
     * Specify a function to execute when the DOM is fully loaded.  
     * @param {Function} callback
     */
    function ready(callback) {
        // need to check if document.body exists for IE as that browser reports
        // document ready when it hasn't yet created the body elm
        if (readyRE.test(document.readyState) && document.body) {
            langx.defer(callback);
        } else {
            document.addEventListener('DOMContentLoaded', callback, false);
        }

        return this;
    }

    var keyCodeLookup = {
        "backspace": 8,
        "comma": 188,
        "delete": 46,
        "down": 40,
        "end": 35,
        "enter": 13,
        "escape": 27,
        "home": 36,
        "left": 37,
        "page_down": 34,
        "page_up": 33,
        "period": 190,
        "right": 39,
        "space": 32,
        "tab": 9,
        "up": 38
    };
    //example:
    //shortcuts(elm).add("CTRL+ALT+SHIFT+X",function(){console.log("test!")});
    function shortcuts(elm) {

        var registry = datax.data(elm, "shortcuts");
        if (!registry) {
            registry = {};
            datax.data(elm, "shortcuts", registry);
            var run = function(shortcut, event) {
                var n = event.metaKey || event.ctrlKey;
                if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {
                    if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {
                        event.preventDefault();
                        if ("keydown" == event.type) {
                            shortcut.fn(event);
                        }
                        return true;
                    }
                }
            };
            on(elm, "keyup keypress keydown", function(event) {
                if (!(/INPUT|TEXTAREA/.test(event.target.nodeName))) {
                    for (var key in registry) {
                        run(registry[key], event);
                    }
                }
            });

        }

        return {
            add: function(pattern, fn) {
                var shortcutKeys;
                if (pattern.indexOf(",") > -1) {
                    shortcutKeys = pattern.toLowerCase().split(",");
                } else {
                    shortcutKeys = pattern.toLowerCase().split(" ");
                }
                shortcutKeys.forEach(function(shortcutKey) {
                    var setting = {
                        fn: fn,
                        alt: false,
                        ctrl: false,
                        shift: false
                    };
                    shortcutKey.split("+").forEach(function(key) {
                        switch (key) {
                            case "alt":
                            case "ctrl":
                            case "shift":
                                setting[key] = true;
                                break;
                            default:
                                setting.charCode = key.charCodeAt(0);
                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);
                        }
                    });
                    var regKey = (setting.ctrl ? "ctrl" : "") + "," + (setting.alt ? "alt" : "") + "," + (setting.shift ? "shift" : "") + "," + setting.keyCode;
                    registry[regKey] = setting;
                })
            }

        };

    }

    if (browser.support.transition) {
        specialEvents.transitionEnd = {
//          handle: function (e) {
//            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
//          },
          bindType: browser.support.transition.end,
          delegateType: browser.support.transition.end
        }        
    }

    function eventer() {
        return eventer;
    }

    langx.mixin(eventer, {
        create: createEvent,

        keys: keyCodeLookup,

        off: off,

        on: on,

        one: one,

        proxy: createProxy,

        ready: ready,

        shortcuts: shortcuts,

        special: specialEvents,

        stop: stop,

        trigger: trigger

    });

    return skylark.attach("domx.eventer",eventer);
});
define('skylark-domx-eventer/main',[
    "skylark-langx/langx",
    "./eventer",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,eventer,velm,$){

    // from ./eventer
    velm.delegate([
        "off",
        "on",
        "one",
        "shortcuts",
        "trigger"
    ], eventer);

    // events
    var events = [ 'keyUp', 'keyDown', 'mouseOver', 'mouseOut', 'click', 'dblClick', 'change' ];

    events.forEach( function ( event ) {

        var method = event;

        velm.VisualElement.prototype[method ] = function ( callback ) {

            this.on( event.toLowerCase(), callback);

            return this;
        };

    });

    $.fn.on = $.wraps.wrapper_every_act(eventer.on, eventer);

    $.fn.off = $.wraps.wrapper_every_act(eventer.off, eventer);

    $.fn.trigger = $.wraps.wrapper_every_act(eventer.trigger, eventer);

    ('focusin focusout focus blur load resize scroll unload click dblclick ' +
        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
        'change select keydown keypress keyup error transitionEnd').split(' ').forEach(function(event) {
        $.fn[event] = function(data, callback) {
            return (0 in arguments) ?
                this.on(event, data, callback) :
                this.trigger(event)
        }
    });

    $.fn.one = function(event, selector, data, callback) {
        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = null;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = null;
        }

        return this.on(event, selector, data, callback, 1)
    }; 

    $.ready = eventer.ready;

    return eventer;
});
define('skylark-domx-eventer', ['skylark-domx-eventer/main'], function (main) { return main; });

define('skylark-slax-runtime/slax',[
	"skylark-langx-ns",
	"skylark-langx-objects",
	"skylark-langx-hoster",
	"skylark-langx-async",
	"skylark-net-http/Xhr",
	"skylark-domx-eventer"
],function(skylark, objects, hoster, async, Xhr, eventer){

    var _config = {


    },
    _rootUrl = "",  //The root url of slax system
    _baseUrl = "";  //the base url of slax app



    var slax = {
        prepare : function(config) {
            var p,slaxRoot,slaxApp;
            if (!config) {
                config = hoster.global.slaxConfig;
            }
            if (!config) {
                var scripts = document.getElementsByTagName("script"),
                    i = 0,
                    script, slaxDir, src, match;
                while(i < scripts.length){
                    script = scripts[i++];
                    if((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)skylark-slax-runtime([0-9A-Za-z\-]*)\.js(\W|$)/i))){
                        // sniff slaxDir and baseUrl
                        slaxDir = match[3] || "";

                        // sniff configuration on attribute in script element
                        if(src = script.getAttribute("data-slax-config") ){
                            config = eval("({ " + src + " })");
                        } else {
                            slaxRoot = script.getAttribute("data-slax-root");
                            if (slaxRoot == undefined) {
                                slaxRoot = slaxDir;
                            }
                            slaxApp = script.getAttribute("data-slax-app");
                        }
                        break;
                    }
                }
            }

            if (config) {
                objects.mixin(_config,config);
                p = async.Deferred.resolve()
            } else {
                var d = new async.Deferred(),
                    p = d.promise;
                Xhr.get(slaxRoot + "/slax-config.json").then(function(config){
                    if (slaxApp) {
                        var slaxAppPath;
                        for (var i=0; i<config.apps.length;i++) {
                            if (config.apps[i].name == slaxApp) {
                                slaxAppPath = slaxRoot + config.apps[i].dir;
                            } 
                        }
                        Xhr.get(slaxAppPath+"/spa.json").then(function(config){
                            objects.mixin(_config,config);
                            d.resolve();
                        });
                    } else {
                        objects.mixin(_config,config);
                        d.resolve();

                    }
                });

            }

            return p;
        },

        start : function() {
            var cfg = _config;

            //if (cfg.contextPath) {
            //  _cfg.baseUrl = cfg.contextPath;
            //}

             require.config(cfg.runtime);

           
            var initApp = function(spa, _cfg) {
                _cfg = _cfg || cfg;
  
                var app = spa(_cfg);

                hoster.global.go =  function(path, force) {
                    app.go(path, force);
                };

                app.prepare().then(function(){
                    app.run();
                });
            };
            if(cfg.spaModule) {
                require([cfg.spaModule], function(spa) {
                    if(spa._start) {
                        spa._start().then(function(_cfg){
                            initApp(spa, _cfg);
                        });
                    } else {
                        initApp(spa);
                    }
                });
            } else {
                initApp(skylark.spa);
            }
        }
    };

    define("slax",[],function(){
        return slax;
    });

    return skylark.attach("slax",slax);

});
define('skylark-storages-cache/cache',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("storages.cache",{});
});
define('skylark-storages-cache/cookie',[
    "skylark-langx/langx",
    "./cache"
], function(langx,cache) {
    function cookie() {
        return cookie;
    }

    langx.mixin(cookie, {
		get : function(name) {
		    if (!sKey || !this.has(name)) { return null; }
				return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(name).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"),"$1"));

		},

		has : function(name) {
			return (new RegExp("(?:^|;\\s*)" + escape(name).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
		},


		list : function() {
		    var values = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
		    for (var i = 0; i < values.length; i++) { 
		    	values[i] = unescape(values[i]); 
		    }
		    return values;
		},

		remove : function(name,path) {
		    if (!name || !this.has(name)) { 
		    	return; 
		   	}
		    document.cookie = escape(name) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (path ? "; path=" + path : "");
		},

		set: function (name, value, expires, path, domain, secure) {
		    if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) { return; }

			var type = langx.type(expires);
			if (type === 'number') {
				var date = Date.now();
				date.setTime(date.getTime() + (expire * 24 * 60 * 60 * 1000));
				expires = date;
			} else if (type === 'string') {
				expires = new Date(Date.now() + langx.parseMilliSeconds(expires));
			}

		    document.cookie = escape(name) + "=" + escape(value) + (expires? "; domain=" + expires.toGMTString()  : "") + (domain ? "; domain=" + domain : "") + (path ? "; path=" + path : "") + (secure ? "; secure" : "");
		  }	
    });


    return cache.cookie = cookie;

});


define('skylark-storages-cache/LocalFileSystem',[
    "skylark-langx/langx",
    "./cache"
], function(langx,cache) {
	var Deferred = langx.Deferred,
		requestFileSystem =  window.requestFileSystem || window.webkitRequestFileSystem,
		resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL,
     	BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.BlobBuilder;


	function errorHandler(e) {
	  var msg = '';

	  switch (e.code) {
	    case FileError.QUOTA_EXCEEDED_ERR:
	      msg = 'QUOTA_EXCEEDED_ERR';
	      break;
	    case FileError.NOT_FOUND_ERR:
	      msg = 'NOT_FOUND_ERR';
	      break;
	    case FileError.SECURITY_ERR:
	      msg = 'SECURITY_ERR';
	      break;
	    case FileError.INVALID_MODIFICATION_ERR:
	      msg = 'INVALID_MODIFICATION_ERR';
	      break;
	    case FileError.INVALID_STATE_ERR:
	      msg = 'INVALID_STATE_ERR';
	      break;
	    default:
	      msg = 'Unknown Error';
	      break;
	  };

	  return msg;
	}
	
	var LocalFileSystem = langx.Evented.inherit({
		_fs : null,
		_isPersisted : true,
		_cwd : null,

		init:	function (fs) {
			this._fs = fs;
			this._cwd = fs.root;
		},
			

		readfileAsArrayBuffer :  function (path,callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.file(function (file) {
		        var reader = new FileReader();
		        reader.onloadend = function () {
		          callback(null, this.result);
		        };
		        reader.readAsArrayBuffer(file);
		      }, errback);
		    }, errback);
		},

		readfileAsDataURL :  function (path,callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.file(function (file) {
		        var reader = new FileReader();
		        reader.onloadend = function () {
		          callback(null, this.result);
		        };
		        reader.readAsDataURL(file);
		      }, errback);
		    }, errback);
		},

		readfileAsText :  function (path,callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.file(function (file) {
		        var reader = new FileReader();
		        reader.onloadend = function () {
		          callback(null, this.result);
		        };
		        reader.readAsText(file);
		      }, errback);
		    }, errback);
		},

		writefile : function (path, contents, callback,errback) {
		    var self = this,
		    	folders = path.split('/');
		    folders = folders.slice(0, folders.length - 1);

		    this.mkdir(folders.join('/'),function(){
			    self._cwd.getFile(path, {create: true}, function (fileEntry) {
			      fileEntry.createWriter(function (fileWriter) {
			        var truncated = false;
			        fileWriter.onwriteend = function () {
			          if (!truncated) {
			            truncated = true;
			            this.truncate(this.position);
			            return;
			          }
			          callback && callback();
			        };
			        fileWriter.onerror = errback;
			        // TODO: find a way to write as binary too
			        var blob = contents;
			        if (!blob instanceof Blob) {
			        	blob = new Blob([contents], {type: 'text/plain'});
			        } 
			        fileWriter.write(blob);
			      }, errback);
			    }, errback);

		    });
		},

		rmfile : function (path, callback,errback) {
		    this._cwd.getFile(path, {}, function (fileEntry) {
		      fileEntry.remove(function () {
		        callback();
		      }, errback);
		    }, errback);
		},

		readdir : function (path, callback,errback) {
		    this._cwd.getDirectory(path, {}, function (dirEntry) {
		      var dirReader = dirEntry.createReader();
		      var entries = [];
		      readEntries();
		      function readEntries() {
		        dirReader.readEntries(function (results) {
		          if (!results.length) {
		            callback(null, entries);
		          }
		          else {
		            entries = entries.concat(
		            	Array.prototype.slice.call(results).map(
		            		function (entry) {
		              			return entry.name + (entry.isDirectory ? "/" : "");
		            		}
		            	)
		            );
		            readEntries();
		          }
		        }, errback);
		      }
		    }, errback);
		},

		mkdir : function (path, callback,errback) {
		    var folderParts = path.split('/');

		    var createDir = function(rootDir, folders) {
		      // Throw out './' or '/' and move on. Prevents: '/foo/.//bar'.
		      if (folders[0] == '.' || folders[0] == '') {
		        folders = folders.slice(1);
		      }

		      if (folders.length ==0) {
		      	callback(rootDir);
		      	return;
		      }
		      rootDir.getDirectory(folders[0], {create: true, exclusive: false},
		        function (dirEntry) {
		          if (dirEntry.isDirectory) { // TODO: check shouldn't be necessary.
		            // Recursively add the new subfolder if we have more to create and
		            // There was more than one folder to create.
		            if (folders.length && folderParts.length != 1) {
		              createDir(dirEntry, folders.slice(1));
		            } else {
		              // Return the last directory that was created.
		              if (callback) callback(dirEntry);
		            }
		          } else {
		            var e = new Error(path + ' is not a directory');
		            if (errback) {
		              errback(e);
		            } else {
		              throw e;
		            }
		          }
		        },
		        function(e) {
		            if (errback) {
		              errback(e);
		            } else {
		              throw e;
		            }
		        }
		      );
		    };

		    createDir(this._cwd, folderParts);

		},

		rmdir : function (path, callback,errback) {
		    this._cwd.getDirectory(path, {}, function (dirEntry) {
		      dirEntry.removeRecursively(function () {
		        callback();
		      }, errback);
		    }, errback);
		  },

		copy : function (src, dest, callback) {
		    // TODO: make sure works for cases where dest includes and excludes file name.
		    this._cwd.getFile(src, {}, function(fileEntry) {
		      cwd.getDirectory(dest, {}, function(dirEntry) {
		        fileEntry.copyTo(dirEntry, function () {
		          callback();
		        }, callback);
		      }, callback);
		    }, callback);
		},

		move : function(src, dest, callback) {
		    // TODO: handle more cases like file renames and moving/renaming directories
		    this._cwd.getFile(src, {}, function(fileEntry) {
		      cwd.getDirectory(dest, {}, function(dirEntry) {
		        fileEntry.moveTo(dirEntry, function () {
		          callback();
		        }, callback);
		      }, callback);
		    }, callback);
		},

		chdir : function (path, callback) {
		    this._cwd.getDirectory(path, {}, function (dirEntry) {
		      cwd = dirEntry;
		      if (fs.onchdir) {
		        fs.onchdir(cwd.fullPath);
		      }
		      callback();
		    }, callback);
		},

		importFromHost : function(files) {
		    // Duplicate each file the user selected to the app's fs.
		    var deferred = new Deferred();
		    for (var i = 0, file; file = files[i]; ++i) {
		        (function(f) {
			        cwd.getFile(file.name, {create: true, exclusive: true}, function(fileEntry) {
			          fileEntry.createWriter(function(fileWriter) {
			            fileWriter.write(f); // Note: write() can take a File or Blob object.
			          }, errorHandler);
			        }, errorHandler);
		     	})(file);
 	   	 	}
  		    return deferred.promise;
		  },

		  exportToHost : function() {

		  }
	
	});
	


    function localfs() {
        return localfs;
    }

    langx.mixin(LocalFileSystem, {
        isSupported : function() {
            return !!requestFileSystem;
        },
        request : function(size,isPersisted){
        	size = size || 1024 * 1024 * 10;
        	var typ = isPersisted ? PERSISTENT : TEMPORARY,
        		d = new Deferred();
            requestFileSystem(typ, size, function(_fs) {
                var fs = new LocalFileSystem(_fs,!!isPersisted);
                d.resolve(fs);
            }, function(e) {
            	d.reject(e);
            });

            return d.promise;
        }
    });
    
    cache.requestLocalFileSystem = LocalFileSystem.request;

	return cache.LocalFileSystem = LocalFileSystem;
});
define('skylark-storages-cache/localStorage',[
    "skylark-langx/langx",
    "./cache"
], function(langx,cache) {

    var storage  = null;

    try {
        storage = window["localStorage"];
    } catch (e){

    }

    function localStorage() {
        return localStorage;
    }

    langx.mixin(localStorage, {
        isSupported : function() {
            return !!storage;
        },

        set : function(key, val) {
            if (val === undefined) { 
                return this.remove(key) 
            }
            storage.setItem(key, langx.serializeValue(val));
            return val
        },

        get : function(key, defaultVal) {
            var val = langx.deserializeValue(storage.getItem(key))
            return (val === undefined ? defaultVal : val)
        },

        remove : function(key) { 
            storage.removeItem(key) 
        },

        clear : function() { 
            storage.clear() 
        },

        list : function() {
            var vaules = {}
            for (var i=0; i<storage.length; i++) {
                vaules[key] = storage.key(i)
            }

            return values;
        }
    });

    return  cache.localStorage = localStorage;

});


define('skylark-storages-cache/sessionStorage',[
    "skylark-langx/langx",
    "./cache"
], function(langx,cache) {

    var storage  = null;

    try {
        storage = window["sessiionStorage"];
    } catch (e){

    }

    function sessiionStorage() {
        return sessiionStorage;
    }

    langx.mixin(sessiionStorage, {
        isSupported : function() {
            return !!storage;
        },

        set : function(key, val) {
            if (val === undefined) { 
                return this.remove(key) 
            }
            storage.setItem(key, langx.serializeValue(val));
            return val
        },

        get : function(key, defaultVal) {
            var val = langx.deserializeValue(storage.getItem(key))
            return (val === undefined ? defaultVal : val)
        },

        remove : function(key) { 
            storage.removeItem(key) 
        },

        clear : function() { 
            storage.clear() 
        },

        list : function() {
            var vaules = {}
            for (var i=0; i<storage.length; i++) {
                vaules[key] = storage.key(i)
            }

            return values;
        }
    });

    return  cache.sessionStorage = sessionStorage;

});


define('skylark-storages-cache/main',[
	"./cache",
	"./cookie",
	"./LocalFileSystem",
	"./localStorage",
	"./sessionStorage"
],function(cache) {
	return cache;
});
define('skylark-storages-cache', ['skylark-storages-cache/main'], function (main) { return main; });

define('skylark-slax-runtime/cache',[
	"./slax",
	"skylark-storages-cache"
],function(slax,_cache){
	//local
	//page
	//session
	return slax.cache = {};
});
define('skylark-langx/main',[
    "./skylark",
    "./langx"
], function(skylark) {
    return skylark;
});

define('skylark-langx', ['skylark-langx/main'], function (main) { return main; });

define('skylark-widgets-shells/shells',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("widgets.shells",{});

});
define('skylark-domx-css/css',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder"
], function(skylark, langx, noder) {
    "use strict";

    var head = document.getElementsByTagName("head")[0],
        count = 0,
        sheetsByUrl = {},
        sheetsById = {},
        defaultSheetId = _createStyleSheet(),
        defaultSheet = sheetsById[defaultSheetId],
        rulesPropName = ("cssRules" in defaultSheet) ? "cssRules" : "rules",
        insertRuleFunc,
        deleteRuleFunc = defaultSheet.deleteRule || defaultSheet.removeRule;

    if (defaultSheet.insertRule) {
        var _insertRule = defaultSheet.insertRule;
        insertRuleFunc = function(selector, css, index) {
            _insertRule.call(this, selector + "{" + css + "}", index);
        };
    } else {
        insertRuleFunc = defaultSheet.addRule;
    }

    function normalizeSelector(selectorText) {
        var selector = [],
            last, len;
        last = defaultSheet[rulesPropName].length;
        insertRuleFunc.call(defaultSheet, selectorText, ';');
        len = defaultSheet[rulesPropName].length;
        for (var i = len - 1; i >= last; i--) {
            selector.push(_sheet[_rules][i].selectorText);
            deleteRuleFunc.call(defaultSheet, i);
        }
        return selector.reverse().join(', ');
    }

    /*
     * create a stylesheet element.
     * @param {Boolean} external
     * @param {Object} options
     * @param {String} [options.media = null]
     */
    function _createStyleSheet(external,options ) {
        var node,
            props = {
                type : "text/css"
            },
            id = (count++);

        options = options || {};
        if (options.media) {
            props.media = options.media;
        }

        if (external) {
            node = noder.create("link",langx.mixin(props,{
                rel  : "stylesheet",
                async : false
            }));
        } else {
            node = noder.createElement("style",props);
        }

        noder.append(head,node);
        sheetsById[id] = {
            id : id,
            node :node
        };

        return id;
    }

    function createStyleSheet(css,options) {
        if (!options) {
            options = {};
        }
        var sheetId = _createStyleSheet(false,options);
        if (css) {
            addSheetRules(sheetId,css);
        }

        return sheetId;
    }

    function loadStyleSheet(url, options,loadedCallback, errorCallback) {
        if (langx.isFunction(options)) {
            errorCallback = loadedCallback;
            loadedCallback = options;
            options = {};
        }
        var sheet = sheetsByUrl[url];
        if (!sheet) {
            var sheetId = _createStyleSheet(true,options);

            sheet = sheetsByUrl[url] = sheetsById[sheetId];
            langx.mixin(sheet,{
                state: 0, //0:unload,1:loaded,-1:loaderror
                url : url,
                deferred : new langx.Deferred()
            });

            var node = sheet.node;

            startTime = new Date().getTime();

            node.onload = function() {
                sheet.state = 1;
                sheet.deferred.resolve(sheet.id);
            },
            node.onerror = function(e) {
                sheet.state = -1;
                sheet.deferred.reject(e);
            };

            node.href = sheet.url;
        }
        if (loadedCallback || errorCallback) {
            sheet.deferred.promise.then(loadedCallback,errorCallback);
        }
        return sheet.id;
    }

    function deleteSheetRule(sheetId, rule) {
        var sheet = sheetsById[sheetId];
        if (langx.isNumber(rule)) {
            deleteRuleFunc.call(sheet, rule);
        } else {
            langx.each(sheet[rulesPropName], function(i, _rule) {
                if (rule === _rule) {
                    deleteRuleFunc.call(sheet, i);
                    return false;
                }
            });
        }
        return this;
    }

    function deleteRule(rule) {
        deleteSheetRule(defaultSheetId, rule);
        return this;
    }

    function removeStyleSheet(sheetId) {
        if (sheetId === defaultSheetId) {
            throw new Error("The default stylesheet can not be deleted");
        }
        var sheet = sheetsById[sheetId];
        delete sheetsById[sheetId];

        noder.remove(sheet.node);
        return this;
    }

    /*
     * insert a rule to the default stylesheet.
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertRule(selector, css, index) {
        return this.insertSheetRule(defaultSheetId, selector, css, index);
    }

    /*
     * Add rules to the default stylesheet.
     * @param {Object} rules
     */
    function addRules(rules) {
        return this.addRules(defaultSheetId,rules);
    }

    /*
     * insert a rule to the stylesheet specified by sheetId.
     * @param {Number} sheetId  
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertSheetRule(sheetId, selector, css, index) {
        if (!selector || !css) {
            return -1;
        }

        var sheet = sheetsById[sheetId];
        index = index || sheet[rulesPropName].length;

        return insertRuleFunc.call(sheet, selector, css, index);
    }

    /*
     * Add  rules to stylesheet.
     * @param {Number} sheetId  
     * @param {Object|String} rules
     * @return this
     * @example insertSheetRules(sheetId,{
     * 
     * });
     */
    function addSheetRules(sheetId,rules) {
        var sheet = sheetsById[sheetId],
            css;
        if (langx.isString(rules)) {
            css = rules;
        } else {
            css = toString(rules);
        }

        noder.append(sheet.node,noder.createTextNode(css));
        
        return this;
    }

    function isAtRule(str) {
        return str.startsWith("@");
    }

    function toString(json){
        var adjust = function(parentName,name,depth) {
            if (parentName) {
                if (isAtRule(parentName)) {
                    depth += 1;
                } else {
                    name =  parentName + " " + name;
                }                
            }
            return {
                name : name,
                depth : depth
            }
        };

        var strNode = function (name, values, depth) {
            var str = "",
                atFlg = isAtRule(name);


            if (isAtRule(name)) {
                // at rule
                if (langx.isString(values)) {
                    // an at rule without block
                    // ex: (1) @charset 'utf8';
                    str = css.SPACE.repeat(depth) + name.trim() + " \"" + values.trim() + " \";\n";
                } else {
                    // an at rule with block, ex :
                    //  @media 'screen' {
                    //  }
                    str += css.SPACE.repeat(depth) + name.trim() + " {\n";
                    str += strNode("",values,depth+1);
                    str += css.SPACE.repeat(depth) + " }\n";
                }
            } else {
                // a selector or a property
                if (langx.isString(values)) {
                    // a css property 
                    // ex : (1) font-color : red;
                    str = css.SPACE.repeat(depth) + name.trim() ;
                    if (atFlg) {
                        str = str +  " \"" + values.trim() + " \";\n";
                    } else {
                        str = str + ': ' + values.trim() + ";\n";
                    }

                } else {
                    // a selector rule 
                    // ex : (1) .class1 : {
                    //            font-color : red;
                    //          }
                    if (langx.isArray(values)) {
                        // array for ordering
                        for (var n =0; n<values.length; n ++) {
                           str +=  strNode(name,values[n],depth);
                        }
                    } else {
                        // plain object

                        if (name) {
                            str += css.SPACE.repeat(depth) + name.trim() + " {\n";

                            for (var n in values) {
                                var value =values[n];
                                if (langx.isString(value)) {
                                    // css property
                                    str += strNode(n,value,depth+1)
                                }
                            }

                            str += css.SPACE.repeat(depth) + "}\n";
                        }

                        for (var n in values) {
                            var value =values[n];
                            if (!langx.isString(value)) {
                                var adjusted = adjust(name,n,depth);
                                str +=  strNode(adjusted.name,value,adjusted.depth);
                            } 
                        }

                    }
                }
            }   

            return str;
        };


        return strNode("",json,0);
    }
 

    function css() {
        return css;
    }

    langx.mixin(css, {
        SPACE : "\t",

        addRules : addRules,

        addSheetRules : addSheetRules,

        createStyleSheet: createStyleSheet,

        deleteSheetRule : deleteSheetRule,

        deleteRule : deleteRule,

        insertRule : insertRule,

        insertSheetRule : insertSheetRule,

        loadStyleSheet : loadStyleSheet,

        removeStyleSheet : removeStyleSheet,

        toString : toString
    });

    return skylark.attach("domx.css", css);
});

define('skylark-domx-css/main',[
	"./css"
],function(css){
	return css;
});
define('skylark-domx-css', ['skylark-domx-css/main'], function (main) { return main; });

define('skylark-domx-scripter/scripter',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {

    var head = document.getElementsByTagName('head')[0],
        scriptsByUrl = {},
        scriptElementsById = {},
        count = 0;

    var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );

    function scripter() {
        return scripter;
    }


    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function evaluate(code,node, doc ) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if ( node ) {
            for ( i in preservedScriptAttributes ) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[ i ] || node.getAttribute && node.getAttribute( i );
                if ( val ) {
                    script.setAttribute( i, val );
                }
            }
        }
        doc.head.appendChild( script ).parentNode.removeChild( script );

        return this;
    }

    langx.mixin(scripter, {
        /*
         * Load a script from a url into the document.
         * @param {} url
         * @param {} loadedCallback
         * @param {} errorCallback
         */
        loadJavaScript: function(url, loadedCallback, errorCallback) {
            var script = scriptsByUrl[url];
            if (!script) {
                script = scriptsByUrl[url] = {
                    state: 0, //0:unload,1:loaded,-1:loaderror
                    loadedCallbacks: [],
                    errorCallbacks: []
                }
            }

            script.loadedCallbacks.push(loadedCallback);
            script.errorCallbacks.push(errorCallback);

            if (script.state === 1) {
                script.node.onload();
            } else if (script.state === -1) {
                script.node.onerror();
            } else {
                var node = script.node = document.createElement("script"),
                    id = script.id = (count++);

                node.type = "text/javascript";
                node.async = false;
                node.defer = false;
                startTime = new Date().getTime();
                head.appendChild(node);

                node.onload = function() {
                        script.state = 1;

                        var callbacks = script.loadedCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    },
                    node.onerror = function() {
                        script.state = -1;
                        var callbacks = script.errorCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    };
                node.src = url;

                scriptElementsById[id] = node;
            }
            return script.id;
        },
        /*
         * Remove the specified script from the document.
         * @param {Number} id
         */
        deleteJavaScript: function(id) {
            var node = scriptElementsById[id];
            if (node) {
                var url = node.src;
                noder.remove(node);
                delete scriptElementsById[id];
                delete scriptsByUrl[url];
            }
        },

        evaluate : evaluate,

        html : function(node,value) {

            var result = noder.html(node,value);

            if (value !== undefined) {
                var scripts = node.querySelectorAll('script');

                for (var i =0; i<scripts.length; i++) {
                    var node1 = scripts[i];
                    if (rscriptType.test( node1.type || "" ) ) {
                      evaluate(node1.textContent,node1);
                    }
                }       
                return this;         
            } else {
                return result;
            }



        }
    });

    return skylark.attach("domx.scripter", scripter);
});
define('skylark-domx-scripter/main',[
	"./scripter",
	"skylark-domx-query"
],function(scripter,$){

    $.fn.html = $.wraps.wrapper_value(scripter.html, scripter, scripter.html);

	return scripter;
});
define('skylark-domx-scripter', ['skylark-domx-scripter/main'], function (main) { return main; });

define('skylark-domx-files/files',[
    "skylark-langx/skylark"
], function(skylark) {

    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
    }


    var files = function() {
        return files;
    };

    return skylark.attach("domx.files", files);
});
define('skylark-domx-styler/styler',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark, langx) {
    var every = Array.prototype.every,
        forEach = Array.prototype.forEach,
        camelCase = langx.camelCase,
        dasherize = langx.dasherize;

    function maybeAddPx(name, value) {
        return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
    }

    var cssNumber = {
            'column-count': 1,
            'columns': 1,
            'font-weight': 1,
            'line-height': 1,
            'opacity': 1,
            'z-index': 1,
            'zoom': 1
        },
        classReCache = {

        };

    function classRE(name) {
        return name in classReCache ?
            classReCache[name] : (classReCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'));
    }

    // access className property while respecting SVGAnimatedString
    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} value
     */
    function className(node, value) {
        var klass = node.className || '',
            svg = klass && klass.baseVal !== undefined

        if (value === undefined) return svg ? klass.baseVal : klass
        svg ? (klass.baseVal = value) : (node.className = value)
    }

    function disabled(elm, value ) {
        if (arguments.length < 2) {
            return !!this.dom.disabled;
        }

        elm.disabled = value;

        return this;
    }

    var elementDisplay = {};

    function defaultDisplay(nodeName) {
        var element, display
        if (!elementDisplay[nodeName]) {
            element = document.createElement(nodeName)
            document.body.appendChild(element)
            display = getStyles(element).getPropertyValue("display")
            element.parentNode.removeChild(element)
            display == "none" && (display = "block")
            elementDisplay[nodeName] = display
        }
        return elementDisplay[nodeName]
    }
    /*
     * Display the matched elements.
     * @param {HTMLElement} elm
     */
    function show(elm) {
        styler.css(elm, "display", "");
        if (styler.css(elm, "display") == "none") {
            styler.css(elm, "display", defaultDisplay(elm.nodeName));
        }
        return this;
    }

    function isInvisible(elm) {
        return styler.css(elm, "display") == "none" || styler.css(elm, "opacity") == 0;
    }

    /*
     * Hide the matched elements.
     * @param {HTMLElement} elm
     */
    function hide(elm) {
        styler.css(elm, "display", "none");
        return this;
    }

    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function addClass(elm, name) {
        if (!name) return this
        var cls = className(elm),
            names;
        if (langx.isString(name)) {
            names = name.split(/\s+/g);
        } else {
            names = name;
        }
        names.forEach(function(klass) {
            var re = classRE(klass);
            if (!cls.match(re)) {
                cls += (cls ? " " : "") + klass;
            }
        });

        className(elm, cls);

        return this;
    }

    function getStyles( elem ) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem);
    }


    /*
     * Get the value of a computed style property for the first element in the set of matched elements or set one or more CSS properties for every matched element.
     * @param {HTMLElement} elm
     * @param {String} property
     * @param {Any} value
     */
    function css(elm, property, value) {
        if (arguments.length < 3) {
            var computedStyle,
                computedStyle = getStyles(elm)
            if (langx.isString(property)) {
                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(dasherize(property))
            } else if (langx.isArrayLike(property)) {
                var props = {}
                forEach.call(property, function(prop) {
                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(dasherize(prop)))
                })
                return props
            }
        }

        var css = '';
        if (typeof(property) == 'string') {
            if (!value && value !== 0) {
                elm.style.removeProperty(dasherize(property));
            } else {
                css = dasherize(property) + ":" + maybeAddPx(property, value)
            }
        } else {
            for (key in property) {
                if (property[key] === undefined) {
                    continue;
                }
                if (!property[key] && property[key] !== 0) {
                    elm.style.removeProperty(dasherize(key));
                } else {
                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
                }
            }
        }

        elm.style.cssText += ';' + css;
        return this;
    }

    /*
     * Determine whether any of the matched elements are assigned the given class.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function hasClass(elm, name) {
        var re = classRE(name);
        return elm.className && elm.className.match(re);
    }

    /*
     * Remove a single class, multiple classes, or all classes from each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function removeClass(elm, name) {
        if (name) {
            var cls = className(elm),
                names;

            if (langx.isString(name)) {
                names = name.split(/\s+/g);
            } else {
                names = name;
            }

            names.forEach(function(klass) {
                var re = classRE(klass);
                if (cls.match(re)) {
                    cls = cls.replace(re, " ");
                }
            });

            className(elm, cls.trim());
        } else {
            className(elm, "");
        }

        return this;
    }

    /*
     * Add or remove one or more classes from the specified element.
     * @param {HTMLElement} elm
     * @param {String} name
     * @param {} when
     */
    function toggleClass(elm, name, when) {
        var self = this;
        name.split(/\s+/g).forEach(function(klass) {
            if (when === undefined) {
                when = !self.hasClass(elm, klass);
            }
            if (when) {
                self.addClass(elm, klass);
            } else {
                self.removeClass(elm, klass)
            }
        });

        return self;
    }

    var styler = function() {
        return styler;
    };

    langx.mixin(styler, {
        autocssfix: false,
        cssHooks: {

        },

        addClass: addClass,
        className: className,
        css: css,
        disabled : disabled,        
        hasClass: hasClass,
        hide: hide,
        isInvisible: isInvisible,
        removeClass: removeClass,
        show: show,
        toggleClass: toggleClass
    });

    return skylark.attach("domx.styler", styler);
});
define('skylark-domx-styler/main',[
	"./styler",
	"skylark-domx-velm",
	"skylark-domx-query"	
],function(styler,velm,$){
	
    // from ./styler
    velm.delegate([
        "addClass",
        "className",
        "css",
        "hasClass",
        "hide",
        "isInvisible",
        "removeClass",
        "show",
        "toggleClass"
    ], styler);

    // properties

    var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',
    'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',
    'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];

    properties.forEach( function ( property ) {

        var method = property;

        velm.VisualElement.prototype[method ] = function (value) {

            this.css( property, value );

            return this;

        };

    });


    $.fn.style = $.wraps.wrapper_name_value(styler.css, styler);

    $.fn.css = $.wraps.wrapper_name_value(styler.css, styler);

    //hasClass(name)
    $.fn.hasClass = $.wraps.wrapper_some_chk(styler.hasClass, styler);

    //addClass(name)
    $.fn.addClass = $.wraps.wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className);

    //removeClass(name)
    $.fn.removeClass = $.wraps.wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className);

    //toogleClass(name,when)
    $.fn.toggleClass = $.wraps.wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className);

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };
        
	return styler;
});
define('skylark-domx-styler', ['skylark-domx-styler/main'], function (main) { return main; });

define('skylark-storages-diskfs/diskfs',[
    "skylark-langx/skylark"
], function(skylark) {

    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
    }


    var diskfs = function() {
        return diskfs;
    };

    return skylark.attach("storages.diskfs", diskfs);
});
 define('skylark-storages-diskfs/webentry',[
    "skylark-langx/arrays",
    "skylark-langx/Deferred",
    "./diskfs"
],function(arrays,Deferred, diskfs){
    var concat = Array.prototype.concat;
    var webentry = (function() {
        function one(entry, path) {
            var d = new Deferred(),
                onError = function(e) {
                    d.reject(e);
                };

            path = path || '';
            if (entry.isFile) {
                entry.file(function(file) {
                    file.relativePath = path;
                    d.resolve(file);
                }, onError);
            } else if (entry.isDirectory) {
                var dirReader = entry.createReader();
                dirReader.readEntries(function(entries) {
                    all(
                        entries,
                        path + entry.name + '/'
                    ).then(function(files) {
                        d.resolve(files);
                    }).catch(onError);
                }, onError);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                d.resolve([]);
            }
            return d.promise;
        }

        function all(entries, path) {
            return Deferred.all(
                arrays.map(entries, function(entry) {
                    return one(entry, path);
                })
            ).then(function() {
                return concat.apply([], arguments);
            });
        }

        return {
            one: one,
            all: all
        };
    })();

    return diskfs.webentry = webentry;
});
  define('skylark-domx-files/dropzone',[
    "skylark-langx/arrays",
    "skylark-langx/Deferred",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./files",
    "skylark-storages-diskfs/webentry"
],function(arrays,Deferred, styler, eventer, files, webentry){  /*
     * Make the specified element to could accept HTML5 file drag and drop.
     * @param {HTMLElement} elm
     * @param {PlainObject} params
     */
    function dropzone(elm, params) {
        params = params || {};
        var hoverClass = params.hoverClass || "dropzone",
            droppedCallback = params.dropped;

        var enterdCount = 0;
        eventer.on(elm, "dragenter", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                eventer.stop(e);
                enterdCount++;
                styler.addClass(elm, hoverClass)
            }
        });

        eventer.on(elm, "dragover", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                eventer.stop(e);
            }
        });

        eventer.on(elm, "dragleave", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                enterdCount--
                if (enterdCount == 0) {
                    styler.removeClass(elm, hoverClass);
                }
            }
        });

        eventer.on(elm, "drop", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                styler.removeClass(elm, hoverClass)
                eventer.stop(e);
                if (droppedCallback) {
                    var items = e.dataTransfer.items;
                    if (items && items.length && (items[0].webkitGetAsEntry ||
                            items[0].getAsEntry)) {
                        webentry.all(
                            arrays.map(items, function(item) {
                                if (item.webkitGetAsEntry) {
                                    return item.webkitGetAsEntry();
                                }
                                return item.getAsEntry();
                            })
                        ).then(droppedCallback);
                    } else {
                        droppedCallback(e.dataTransfer.files);
                    }
                }
            }
        });

        return this;
    }

     return files.dropzone = dropzone;
});
define('skylark-domx-files/pastezone',[
    "skylark-langx/objects",
    "skylark-domx-eventer",
    "./files"
],function(objects, eventer, files){
    function pastezone(elm, params) {
        params = params || {};
        var hoverClass = params.hoverClass || "pastezone",
            pastedCallback = params.pasted;

        eventer.on(elm, "paste", function(e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                e.originalEvent.clipboardData.items,
                files = [];
            if (items && items.length) {
                objects.each(items, function(index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        files.push(file);
                    }
                });
            }
            if (pastedCallback && files.length) {
                pastedCallback(files);
            }
        });

        return this;
    }

    return files.pastezone = pastezone;

});

define('skylark-storages-diskfs/select',[
    "./diskfs"
],function(diskfs){
    var fileInput,
        fileInputForm,
        fileSelected,
        maxFileSize = 1 / 0;

    function select(params) {
        params = params || {};
        var directory = params.directory || false,
            multiple = params.multiple || false,
            fileSelected = params.picked;
        if (!fileInput) {
            var input = fileInput = document.createElement("input");

            function selectFiles(pickedFiles) {
                for (var i = pickedFiles.length; i--;) {
                    if (pickedFiles[i].size > maxFileSize) {
                        pickedFiles.splice(i, 1);
                    }
                }
                fileSelected(pickedFiles);
            }

            input.type = "file";
            input.style.position = "fixed";
            input.style.left = 0;
            input.style.top = 0;
            input.style.opacity = .001;
            document.body.appendChild(input);

            input.onchange = function(e) {
                var entries = e.target.webkitEntries || e.target.entries;

                if (entries && entries.length) {
                    webentry.all(entries).then(function(files) {
                        selectFiles(files);
                    });
                } else {
                    selectFiles(Array.prototype.slice.call(e.target.files));
                }
                // reset to "", so selecting the same file next time still trigger the change handler
                input.value = "";
            };
        }
        fileInput.multiple = multiple;
        fileInput.webkitdirectory = directory;
        fileInput.click();
    }

    return diskfs.select = select;
});


define('skylark-domx-files/picker',[
    "skylark-langx/objects",
    "skylark-domx-eventer",
    "./files",
    "skylark-storages-diskfs/select"
],function(objects, eventer, files, select){
    /*
     * Make the specified element to pop-up the file selection dialog box when clicked , and read the contents the files selected from client file system by user.
     * @param {HTMLElement} elm
     * @param {PlainObject} params
     */
    function picker(elm, params) {
        eventer.on(elm, "click", function(e) {
            e.preventDefault();
            select(params);
        });
        return this;
    }

    return files.picker = picker;

});



define('skylark-domx-files/main',[
	"./files",
	"skylark-domx-velm",
	"skylark-domx-query",
	"./dropzone",
	"./pastezone",
	"./picker"
],function(files,velm,$){
	velm.delegate([
		"dropzone",
		"pastezone",
		"picker"
	],files);

    $.fn.pastezone = $.wraps.wrapper_every_act(files.pastezone, files);
    $.fn.dropzone = $.wraps.wrapper_every_act(files.dropzone, files);
    $.fn.picker = $.wraps.wrapper_every_act(files.picker, files);

	return files;
});
define('skylark-domx-files', ['skylark-domx-files/main'], function (main) { return main; });

define('skylark-domx-geom/geom',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, noder, styler) {
    var rootNodeRE = /^(?:body|html)$/i,
        px = langx.toPixel,
        offsetParent = noder.offsetParent,
        cachedScrollbarWidth;

    function scrollbarWidth() {
        if (cachedScrollbarWidth !== undefined) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = noder.createFragment("<div style=" +
                "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                "<div style='height:300px;width:auto;'></div></div>")[0],
            innerDiv = div.childNodes[0];

        noder.append(document.body, div);

        w1 = innerDiv.offsetWidth;

        styler.css(div, "overflow", "scroll");

        w2 = innerDiv.offsetWidth;

        if (w1 === w2) {
            w2 = div[0].clientWidth;
        }

        noder.remove(div);

        return (cachedScrollbarWidth = w1 - w2);
    }
    /*
     * Get the widths of each border of the specified element.
     * @param {HTMLElement} elm
     */
    function borderExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }        var s = getComputedStyle(elm);
        return {
            left: px(s.borderLeftWidth, elm),
            top: px(s.borderTopWidth, elm),
            right: px(s.borderRightWidth, elm),
            bottom: px(s.borderBottomWidth, elm)
        }
    }

    //viewport coordinate
    /*
     * Get or set the viewport position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingPosition(elm, coords) {
        if (coords === undefined) {
            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the viewport rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingRect(elm, coords) {
        if (coords === undefined) {
            return elm.getBoundingClientRect()
        } else {
            boundingPosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the height of the specified element client box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function clientHeight(elm, value) {
        if (value == undefined) {
            return clientSize(elm).height;
        } else {
            return clientSize(elm, {
                height: value
            });
        }
    }

    /*
     * Get or set the size of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientSize(elm, dimension) {
        if (dimension == undefined) {
            return {
                width: elm.clientWidth,
                height: elm.clientHeight
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width - pex.left - pex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height - pex.top - pex.bottom;
                }
            } else {
                var bex = borderExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width + bex.left + bex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height + bex.top + bex.bottom;
                }

            }
            styler.css(elm, props);
            return this;
        }
        return {
            width: elm.clientWidth,
            height: elm.clientHeight
        };
    }

    /*
     * Get or set the width of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientWidth(elm, value) {
        if (value == undefined) {
            return clientSize(elm).width;
        } else {
            clientSize(elm, {
                width: value
            });
            return this;
        }
    }

    /*
     * Get the rect of the specified element content box.
     * @param {HTMLElement} elm
     */
    function contentRect(elm) {
        var cs = clientSize(elm),
            pex = paddingExtents(elm);


        //// On Opera, offsetLeft includes the parent's border
        //if(has("opera")){
        //    pe.l += be.l;
        //    pe.t += be.t;
        //}
        return {
            left: pex.left,
            top: pex.top,
            width: cs.width - pex.left - pex.right,
            height: cs.height - pex.top - pex.bottom
        };
    }

    /*
     * Get the document size.
     * @param {HTMLDocument} doc
     */
    function getDocumentSize(doc) {
        var documentElement = doc.documentElement,
            body = doc.body,
            max = Math.max,
            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),
            clientWidth = max(documentElement.clientWidth, body.clientWidth),
            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),
            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),
            clientHeight = max(documentElement.clientHeight, body.clientHeight),
            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);

        return {
            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
        };
    }

    /*
     * Get the document size.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function height(elm, value) {
        if (value == undefined) {
            return size(elm).height;
        } else {
            size(elm, {
                height: value
            });
            return this;
        }
    }

    /*
     * Get the widths of each margin of the specified element.
     * @param {HTMLElement} elm
     */
    function marginExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.marginLeft),
            top: px(s.marginTop),
            right: px(s.marginRight),
            bottom: px(s.marginBottom),
        }
    }


    function marginRect(elm) {
        var obj = relativeRect(elm),
            me = marginExtents(elm);

        return {
            left: obj.left,
            top: obj.top,
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }


    function marginSize(elm) {
        var obj = size(elm),
            me = marginExtents(elm);

        return {
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }

    /*
     * Get the widths of each padding of the specified element.
     * @param {HTMLElement} elm
     */
    function paddingExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.paddingLeft),
            top: px(s.paddingTop),
            right: px(s.paddingRight),
            bottom: px(s.paddingBottom),
        }
    }

    /*
     * Get or set the document position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    //coordinate to the document
    function pagePosition(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect()
            return {
                left: obj.left + window.pageXOffset,
                top: obj.top + window.pageYOffset
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = pagePosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the document rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function pageRect(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect()
            return {
                left: obj.left + window.pageXOffset,
                top: obj.top + window.pageYOffset,
                width: Math.round(obj.width),
                height: Math.round(obj.height)
            }
        } else {
            pagePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the position of the specified element border box , relative to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    // coordinate relative to it's parent
    function relativePosition(elm, coords) {
        if (coords == undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingPosition(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left
            }
        } else {
            var props = {
                top: coords.top,
                left: coords.left
            }

            if (styler.css(elm, "position") == "static") {
                props['position'] = "relative";
            }
            styler.css(elm, props);
            return this;
        }
    }

    /*
     * Get or set the rect of the specified element border box , relatived to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function relativeRect(elm, coords) {
        if (coords === undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingRect(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left,
                width: offset.width,
                height: offset.height
            }
        } else {
            relativePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }
    /*
     * Scroll the specified element into view.
     * @param {HTMLElement} elm
     * @param {} align
     */
    function scrollIntoView(elm, align) {
        function getOffset(elm, rootElm) {
            var x, y, parent = elm;

            x = y = 0;
            while (parent && parent != rootElm && parent.nodeType) {
                x += parent.offsetLeft || 0;
                y += parent.offsetTop || 0;
                parent = parent.offsetParent;
            }

            return { x: x, y: y };
        }

        var parentElm = elm.parentNode;
        var x, y, width, height, parentWidth, parentHeight;
        var pos = getOffset(elm, parentElm);

        x = pos.x;
        y = pos.y;
        width = elm.offsetWidth;
        height = elm.offsetHeight;
        parentWidth = parentElm.clientWidth;
        parentHeight = parentElm.clientHeight;

        if (align == "end") {
            x -= parentWidth - width;
            y -= parentHeight - height;
        } else if (align == "center") {
            x -= (parentWidth / 2) - (width / 2);
            y -= (parentHeight / 2) - (height / 2);
        }

        parentElm.scrollLeft = x;
        parentElm.scrollTop = y;

        return this;
    }
    /*
     * Get or set the current horizontal position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollLeft(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        }
        var hasScrollLeft = "scrollLeft" in elm;
        if (value === undefined) {
            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset
        } else {
            if (hasScrollLeft) {
                elm.scrollLeft = value;
            } else {
                elm.scrollTo(value, elm.scrollY);
            }
            return this;
        }
    }
    /*
     * Get or the current vertical position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollTop(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        }
        var hasScrollTop = "scrollTop" in elm;

        if (value === undefined) {
            return hasScrollTop ? elm.scrollTop : elm.pageYOffset
        } else {
            if (hasScrollTop) {
                elm.scrollTop = value;
            } else {
                elm.scrollTo(elm.scrollX, value);
            }
            return this;
        }
    }
    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject}dimension
     */
    function size(elm, dimension) {
        if (dimension == undefined) {
            if (langx.isWindow(elm)) {
                return {
                    width: elm.innerWidth,
                    height: elm.innerHeight
                }

            } else if (langx.isDocument(elm)) {
                return getDocumentSize(document);
            } else {
                return {
                    width: elm.offsetWidth,
                    height: elm.offsetHeight
                }
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm),
                    bex = borderExtents(elm);

                if (props.width !== undefined && props.width !== "" && props.width !== null) {
                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;
                }

                if (props.height !== undefined && props.height !== "" && props.height !== null) {
                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;
                }
            }
            styler.css(elm, props);
            return this;
        }
    }
    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function width(elm, value) {
        if (value == undefined) {
            return size(elm).width;
        } else {
            size(elm, {
                width: value
            });
            return this;
        }
    }

    function geom() {
        return geom;
    }

    langx.mixin(geom, {
        borderExtents: borderExtents,
        //viewport coordinate
        boundingPosition: boundingPosition,

        boundingRect: boundingRect,

        clientHeight: clientHeight,

        clientSize: clientSize,

        clientWidth: clientWidth,

        contentRect: contentRect,

        getDocumentSize: getDocumentSize,

        height: height,

        marginExtents: marginExtents,

        marginRect: marginRect,

        marginSize: marginSize,

        offsetParent: offsetParent,

        paddingExtents: paddingExtents,

        //coordinate to the document
        pagePosition: pagePosition,

        pageRect: pageRect,

        // coordinate relative to it's parent
        relativePosition: relativePosition,

        relativeRect: relativeRect,

        scrollbarWidth: scrollbarWidth,

        scrollIntoView: scrollIntoView,

        scrollLeft: scrollLeft,

        scrollTop: scrollTop,

        size: size,

        width: width
    });

    ( function() {
        var max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/;

        function getOffsets( offsets, width, height ) {
            return [
                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
            ];
        }

        function parseCss( element, property ) {
            return parseInt( styler.css( element, property ), 10 ) || 0;
        }

        function getDimensions( raw ) {
            if ( raw.nodeType === 9 ) {
                return {
                    size: size(raw),
                    offset: { top: 0, left: 0 }
                };
            }
            if ( noder.isWindow( raw ) ) {
                return {
                    size: size(raw),
                    offset: { 
                        top: scrollTop(raw), 
                        left: scrollLeft(raw) 
                    }
                };
            }
            if ( raw.preventDefault ) {
                return {
                    size : {
                        width: 0,
                        height: 0
                    },
                    offset: { 
                        top: raw.pageY, 
                        left: raw.pageX 
                    }
                };
            }
            return {
                size: size(raw),
                offset: pagePosition(raw)
            };
        }

        function getScrollInfo( within ) {
            var overflowX = within.isWindow || within.isDocument ? "" :
                    styler.css(within.element,"overflow-x" ),
                overflowY = within.isWindow || within.isDocument ? "" :
                    styler.css(within.element,"overflow-y" ),
                hasOverflowX = overflowX === "scroll" ||
                    ( overflowX === "auto" && within.width < scrollWidth(within.element) ),
                hasOverflowY = overflowY === "scroll" ||
                    ( overflowY === "auto" && within.height < scrollHeight(within.element));
            return {
                width: hasOverflowY ? scrollbarWidth() : 0,
                height: hasOverflowX ? scrollbarWidth() : 0
            };
        }

        function getWithinInfo( element ) {
            var withinElement = element || window,
                isWindow = noder.isWindow( withinElement),
                isDocument = !!withinElement && withinElement.nodeType === 9,
                hasOffset = !isWindow && !isDocument,
                msize = marginSize(withinElement);
            return {
                element: withinElement,
                isWindow: isWindow,
                isDocument: isDocument,
                offset: hasOffset ? pagePosition(element) : { left: 0, top: 0 },
                scrollLeft: scrollLeft(withinElement),
                scrollTop: scrollTop(withinElement),
                width: msize.width,
                height: msize.height
            };
        }

        function posit(elm,options ) {
            // Make a copy, we don't want to modify arguments
            options = langx.extend( {}, options );

            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = options.of,
                within = getWithinInfo( options.within ),
                scrollInfo = getScrollInfo( within ),
                collision = ( options.collision || "flip" ).split( " " ),
                offsets = {};

            dimensions = getDimensions( target );
            if ( target.preventDefault ) {

                // Force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.size.width;
            targetHeight = dimensions.size.height;
            targetOffset = dimensions.offset;

            // Clone to reuse original targetOffset later
            basePosition = langx.extend( {}, targetOffset );

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            langx.each( [ "my", "at" ], function() {
                var pos = ( options[ this ] || "" ).split( " " ),
                    horizontalOffset,
                    verticalOffset;

                if ( pos.length === 1 ) {
                    pos = rhorizontal.test( pos[ 0 ] ) ?
                        pos.concat( [ "center" ] ) :
                        rvertical.test( pos[ 0 ] ) ?
                            [ "center" ].concat( pos ) :
                            [ "center", "center" ];
                }
                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

                // Calculate offsets
                horizontalOffset = roffset.exec( pos[ 0 ] );
                verticalOffset = roffset.exec( pos[ 1 ] );
                offsets[ this ] = [
                    horizontalOffset ? horizontalOffset[ 0 ] : 0,
                    verticalOffset ? verticalOffset[ 0 ] : 0
                ];

                // Reduce to just the positions without the offsets
                options[ this ] = [
                    rposition.exec( pos[ 0 ] )[ 0 ],
                    rposition.exec( pos[ 1 ] )[ 0 ]
                ];
            } );

            // Normalize collision option
            if ( collision.length === 1 ) {
                collision[ 1 ] = collision[ 0 ];
            }

            if ( options.at[ 0 ] === "right" ) {
                basePosition.left += targetWidth;
            } else if ( options.at[ 0 ] === "center" ) {
                basePosition.left += targetWidth / 2;
            }

            if ( options.at[ 1 ] === "bottom" ) {
                basePosition.top += targetHeight;
            } else if ( options.at[ 1 ] === "center" ) {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
            basePosition.left += atOffset[ 0 ];
            basePosition.top += atOffset[ 1 ];

            return ( function(elem) {
                var collisionPosition, using,
                    msize = marginSize(elem),
                    elemWidth = msize.width,
                    elemHeight = msize.height,
                    marginLeft = parseCss( elem, "marginLeft" ),
                    marginTop = parseCss( elem, "marginTop" ),
                    collisionWidth = elemWidth + marginLeft + parseCss( elem, "marginRight" ) +
                        scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss( elem, "marginBottom" ) +
                        scrollInfo.height,
                    position = langx.extend( {}, basePosition ),
                    myOffset = getOffsets( offsets.my, msize.width, msize.height);

                if ( options.my[ 0 ] === "right" ) {
                    position.left -= elemWidth;
                } else if ( options.my[ 0 ] === "center" ) {
                    position.left -= elemWidth / 2;
                }

                if ( options.my[ 1 ] === "bottom" ) {
                    position.top -= elemHeight;
                } else if ( options.my[ 1 ] === "center" ) {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[ 0 ];
                position.top += myOffset[ 1 ];

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };

                langx.each( [ "left", "top" ], function( i, dir ) {
                    if ( positions[ collision[ i ] ] ) {
                        positions[ collision[ i ] ][ dir ]( position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        } );
                    }
                } );

                if ( options.using ) {

                    // Adds feedback as second argument to using callback, if present
                    using = function( props ) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                            feedback.horizontal = "center";
                        }
                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                            feedback.vertical = "middle";
                        }
                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call( this, props, feedback );
                    };
                }

                pagePosition(elem, langx.extend( position, { using: using } ));
            })(elm);
        }

        var positions = {
            fit: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;

                    // Element is wider than within
                    if ( data.collisionWidth > outerWidth ) {

                        // Element is initially over the left side of within
                        if ( overLeft > 0 && overRight <= 0 ) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                                withinOffset;
                            position.left += overLeft - newOverRight;

                        // Element is initially over right side of within
                        } else if ( overRight > 0 && overLeft <= 0 ) {
                            position.left = withinOffset;

                        // Element is initially over both left and right sides of within
                        } else {
                            if ( overLeft > overRight ) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }

                    // Too far left -> align with left edge
                    } else if ( overLeft > 0 ) {
                        position.left += overLeft;

                    // Too far right -> align with right edge
                    } else if ( overRight > 0 ) {
                        position.left -= overRight;

                    // Adjust based on position and margin
                    } else {
                        position.left = max( position.left - collisionPosLeft, position.left );
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;

                    // Element is taller than within
                    if ( data.collisionHeight > outerHeight ) {

                        // Element is initially over the top of within
                        if ( overTop > 0 && overBottom <= 0 ) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                                withinOffset;
                            position.top += overTop - newOverBottom;

                        // Element is initially over bottom of within
                        } else if ( overBottom > 0 && overTop <= 0 ) {
                            position.top = withinOffset;

                        // Element is initially over both top and bottom of within
                        } else {
                            if ( overTop > overBottom ) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }

                    // Too far up -> align with top
                    } else if ( overTop > 0 ) {
                        position.top += overTop;

                    // Too far down -> align with bottom edge
                    } else if ( overBottom > 0 ) {
                        position.top -= overBottom;

                    // Adjust based on position and margin
                    } else {
                        position.top = max( position.top - collisionPosTop, position.top );
                    }
                }
            },
            flip: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[ 0 ] === "left" ?
                            -data.elemWidth :
                            data.my[ 0 ] === "right" ?
                                data.elemWidth :
                                0,
                        atOffset = data.at[ 0 ] === "left" ?
                            data.targetWidth :
                            data.at[ 0 ] === "right" ?
                                -data.targetWidth :
                                0,
                        offset = -2 * data.offset[ 0 ],
                        newOverRight,
                        newOverLeft;

                    if ( overLeft < 0 ) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                            outerWidth - withinOffset;
                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if ( overRight > 0 ) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                            atOffset + offset - offsetLeft;
                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[ 1 ] === "top",
                        myOffset = top ?
                            -data.elemHeight :
                            data.my[ 1 ] === "bottom" ?
                                data.elemHeight :
                                0,
                        atOffset = data.at[ 1 ] === "top" ?
                            data.targetHeight :
                            data.at[ 1 ] === "bottom" ?
                                -data.targetHeight :
                                0,
                        offset = -2 * data.offset[ 1 ],
                        newOverTop,
                        newOverBottom;
                    if ( overTop < 0 ) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                            outerHeight - withinOffset;
                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if ( overBottom > 0 ) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                            offset - offsetTop;
                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    positions.flip.left.apply( this, arguments );
                    positions.fit.left.apply( this, arguments );
                },
                top: function() {
                    positions.flip.top.apply( this, arguments );
                    positions.fit.top.apply( this, arguments );
                }
            }
        };

        geom.posit = posit;
    })();

    return skylark.attach("domx.geom", geom);
});
define('skylark-domx-geom/main',[
    "skylark-langx/langx",
    "./geom",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,geom,velm,$){
   // from ./geom
    velm.delegate([
        "borderExtents",
        "boundingPosition",
        "boundingRect",
        "clientHeight",
        "clientSize",
        "clientWidth",
        "contentRect",
        "height",
        "marginExtents",
        "offsetParent",
        "paddingExtents",
        "pagePosition",
        "pageRect",
        "relativePosition",
        "relativeRect",
        "scrollIntoView",
        "scrollLeft",
        "scrollTop",
        "size",
        "width"
    ], geom);

    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);

    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);

    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);

    $.fn.position =  function(options) {
        if (!this.length) {
            return this;
        }

        if (options) {
            if (options.of && options.of.length) {
                options = langx.clone(options);
                options.of = options.of[0];
            }
            return this.each( function() {
                geom.posit(this,options);
            });
        } else {
            var elem = this[0];

            return geom.relativePosition(elem);

        }             
    };

    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);


    $.fn.size = $.wraps.wrapper_value(geom.size, geom);

    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);

    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);

    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom.clientSize);
    
    ['width', 'height'].forEach(function(dimension) {
        var offset, Dimension = dimension.replace(/./, function(m) {
            return m[0].toUpperCase()
        });

        $.fn['outer' + Dimension] = function(margin, value) {
            if (arguments.length) {
                if (typeof margin !== 'boolean') {
                    value = margin;
                    margin = false;
                }
            } else {
                margin = false;
                value = undefined;
            }

            if (value === undefined) {
                var el = this[0];
                if (!el) {
                    return undefined;
                }
                var cb = geom.size(el);
                if (margin) {
                    var me = geom.marginExtents(el);
                    cb.width = cb.width + me.left + me.right;
                    cb.height = cb.height + me.top + me.bottom;
                }
                return dimension === "width" ? cb.width : cb.height;
            } else {
                return this.each(function(idx, el) {
                    var mb = {};
                    var me = geom.marginExtents(el);
                    if (dimension === "width") {
                        mb.width = value;
                        if (margin) {
                            mb.width = mb.width - me.left - me.right
                        }
                    } else {
                        mb.height = value;
                        if (margin) {
                            mb.height = mb.height - me.top - me.bottom;
                        }
                    }
                    geom.size(el, mb);
                })

            }
        };
    })

    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);

    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);

    return geom;
});
define('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });

define('skylark-domx-fx/fx',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer"
], function(skylark, langx, browser, noder, geom, styler, eventer) {
    var animationName,
        animationDuration,
        animationTiming,
        animationDelay,
        transitionProperty,
        transitionDuration,
        transitionTiming,
        transitionDelay,

        animationEnd = browser.normalizeCssEvent('AnimationEnd'),
        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),

        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
        transform = browser.css3PropPrefix + "transform",
        cssReset = {};


    cssReset[animationName = browser.normalizeCssProperty("animation-name")] =
        cssReset[animationDuration = browser.normalizeCssProperty("animation-duration")] =
        cssReset[animationDelay = browser.normalizeCssProperty("animation-delay")] =
        cssReset[animationTiming = browser.normalizeCssProperty("animation-timing-function")] = "";

    cssReset[transitionProperty = browser.normalizeCssProperty("transition-property")] =
        cssReset[transitionDuration = browser.normalizeCssProperty("transition-duration")] =
        cssReset[transitionDelay = browser.normalizeCssProperty("transition-delay")] =
        cssReset[transitionTiming = browser.normalizeCssProperty("transition-timing-function")] = "";



    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animate(elm, properties, duration, ease, callback, delay) {
        var key,
            cssValues = {},
            cssProperties = [],
            transforms = "",
            that = this,
            endEvent,
            wrappedCallback,
            fired = false,
            hasScrollTop = false,
            resetClipAuto = false;

        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = fx.speeds[duration];
        }
        if (duration === undefined) {
            duration = fx.speeds.normal;
        }
        duration = duration / 1000;
        if (fx.off) {
            duration = 0;
        }

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }

        if (langx.isString(properties)) {
            // keyframe animation
            cssValues[animationName] = properties;
            cssValues[animationDuration] = duration + "s";
            cssValues[animationTiming] = ease;
            endEvent = animationEnd;
        } else {
            // CSS transitions
            for (key in properties) {
                var v = properties[key];
                if (supportedTransforms.test(key)) {
                    transforms += key + "(" + v + ") ";
                } else {
                    if (key === "scrollTop") {
                        hasScrollTop = true;
                    }
                    if (key == "clip" && langx.isPlainObject(v)) {
                        cssValues[key] = "rect(" + v.top+"px,"+ v.right +"px,"+ v.bottom +"px,"+ v.left+"px)";
                        if (styler.css(elm,"clip") == "auto") {
                            var size = geom.size(elm);
                            styler.css(elm,"clip","rect("+"0px,"+ size.width +"px,"+ size.height +"px,"+"0px)");  
                            resetClipAuto = true;
                        }

                    } else {
                        cssValues[key] = v;
                    }
                    cssProperties.push(langx.dasherize(key));
                }
            }
            endEvent = transitionEnd;
        }

        if (transforms) {
            cssValues[transform] = transforms;
            cssProperties.push(transform);
        }

        if (duration > 0 && langx.isPlainObject(properties)) {
            cssValues[transitionProperty] = cssProperties.join(", ");
            cssValues[transitionDuration] = duration + "s";
            cssValues[transitionDelay] = delay + "s";
            cssValues[transitionTiming] = ease;
        }

        wrappedCallback = function(event) {
            fired = true;
            if (event) {
                if (event.target !== event.currentTarget) {
                    return // makes sure the event didn't bubble from "below"
                }
                eventer.off(event.target, endEvent, wrappedCallback)
            } else {
                eventer.off(elm, animationEnd, wrappedCallback) // triggered by setTimeout
            }
            styler.css(elm, cssReset);
            if (resetClipAuto) {
 //               styler.css(elm,"clip","auto");
            }
            callback && callback.call(this);
        };

        if (duration > 0) {
            eventer.on(elm, endEvent, wrappedCallback);
            // transitionEnd is not always firing on older Android phones
            // so make sure it gets fired
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, ((duration + delay) * 1000) + 25)();
        }

        // trigger page reflow so new elements can animate
        elm.clientLeft;

        styler.css(elm, cssValues);

        if (duration <= 0) {
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, 0)();
        }

        if (hasScrollTop) {
            scrollToTop(elm, properties["scrollTop"], duration, callback);
        }

        return this;
    }

    /*   
     * Display an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function show(elm, speed, callback) {
        styler.show(elm);
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            styler.css(elm, "opacity", 0)
            animate(elm, { opacity: 1, scale: "1,1" }, speed, callback);
        }
        return this;
    }


    /*   
     * Hide an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function hide(elm, speed, callback) {
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            animate(elm, { opacity: 0, scale: "0,0" }, speed, function() {
                styler.hide(elm);
                if (callback) {
                    callback.call(elm);
                }
            });
        } else {
            styler.hide(elm);
        }
        return this;
    }

    /*   
     * Set the vertical position of the scroll bar for an element.
     * @param {Object} elm  
     * @param {Number or String} pos
     * @param {Number or String} speed
     * @param {Function} callback
     */
    function scrollToTop(elm, pos, speed, callback) {
        var scrollFrom = parseInt(elm.scrollTop),
            i = 0,
            runEvery = 5, // run every 5ms
            freq = speed * 1000 / runEvery,
            scrollTo = parseInt(pos);

        var interval = setInterval(function() {
            i++;

            if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;

            if (i >= freq + 1) {
                clearInterval(interval);
                if (callback) langx.debounce(callback, 1000)();
            }
        }, runEvery);
    }

    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callback
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    /*   
     * Adjust the opacity of an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Number or String} opacity
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeTo(elm, speed, opacity, easing, callback) {
        animate(elm, { opacity: opacity }, speed, easing, callback);
        return this;
    }


    /*   
     * Display an element by fading them to opaque.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeIn(elm, speed, easing, callback) {
        var target = styler.css(elm, "opacity");
        if (target > 0) {
            styler.css(elm, "opacity", 0);
        } else {
            target = 1;
        }
        styler.show(elm);

        fadeTo(elm, speed, target, easing, callback);

        return this;
    }

    /*   
     * Hide an element by fading them to transparent.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeOut(elm, speed, easing, callback) {
        var _elm = elm,
            complete,
            opacity = styler.css(elm,"opacity"),
            options = {};

        if (langx.isPlainObject(speed)) {
            options.easing = speed.easing;
            options.duration = speed.duration;
            complete = speed.complete;
        } else {
            options.duration = speed;
            if (callback) {
                complete = callback;
                options.easing = easing;
            } else {
                complete = easing;
            }
        }
        options.complete = function() {
            styler.css(elm,"opacity",opacity);
            styler.hide(elm);
            if (complete) {
                complete.call(elm);
            }
        }

        fadeTo(elm, options, 0);

        return this;
    }

    /*   
     * Display or hide an element by animating its opacity.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} ceasing
     * @param {Function} callback
     */
    function fadeToggle(elm, speed, ceasing, allback) {
        if (styler.isInvisible(elm)) {
            fadeIn(elm, speed, easing, callback);
        } else {
            fadeOut(elm, speed, easing, callback);
        }
        return this;
    }

    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {

        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        // show element if it is hidden
        show(elm);

        // place it so it displays as usually but hidden
        styler.css(elm, {
            position: 'absolute',
            visibility: 'hidden'
        });

        // get naturally height, margin, padding
        var marginTop = styler.css(elm, 'margin-top');
        var marginBottom = styler.css(elm, 'margin-bottom');
        var paddingTop = styler.css(elm, 'padding-top');
        var paddingBottom = styler.css(elm, 'padding-bottom');
        var height = styler.css(elm, 'height');

        // set initial css for animation
        styler.css(elm, {
            position: position,
            visibility: 'visible',
            overflow: 'hidden',
            height: 0,
            marginTop: 0,
            marginBottom: 0,
            paddingTop: 0,
            paddingBottom: 0
        });

        // animate to gotten height, margin and padding
        animate(elm, {
            height: height,
            marginTop: marginTop,
            marginBottom: marginBottom,
            paddingTop: paddingTop,
            paddingBottom: paddingBottom
        }, {
            duration: duration,
            complete: function() {
                if (callback) {
                    callback.apply(elm);
                }
            }
        });

        return this;
    }

    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        // active the function only if the element is visible
        if (geom.height(elm) > 0) {

            // get the element position to restore it then
            var position = styler.css(elm, 'position');

            // get the element height, margin and padding to restore them then
            var height = styler.css(elm, 'height');
            var marginTop = styler.css(elm, 'margin-top');
            var marginBottom = styler.css(elm, 'margin-bottom');
            var paddingTop = styler.css(elm, 'padding-top');
            var paddingBottom = styler.css(elm, 'padding-bottom');

            // set initial css for animation
            styler.css(elm, {
                visibility: 'visible',
                overflow: 'hidden',
                height: height,
                marginTop: marginTop,
                marginBottom: marginBottom,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom
            });

            // animate element height, margin and padding to zero
            animate(elm, {
                height: 0,
                marginTop: 0,
                marginBottom: 0,
                paddingTop: 0,
                paddingBottom: 0
            }, {
                // callback : restore the element position, height, margin and padding to original values
                duration: duration,
                queue: false,
                complete: function() {
                    hide(elm);
                    styler.css(elm, {
                        visibility: 'visible',
                        overflow: 'hidden',
                        height: height,
                        marginTop: marginTop,
                        marginBottom: marginBottom,
                        paddingTop: paddingTop,
                        paddingBottom: paddingBottom
                    });
                    if (callback) {
                        callback.apply(elm);
                    }
                }
            });
        }
        return this;
    }


    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    function emulateTransitionEnd(elm,duration) {
        var called = false;
        eventer.one(elm,'transitionEnd', function () { 
            called = true;
        })
        var callback = function () { 
            if (!called) {
                eventer.trigger(elm,browser.support.transition.end) 
            }
        };
        setTimeout(callback, duration);
        
        return this;
    } 

    /*   
     *
     * @param {Node} elm
     * @param {Node} params
     */
    function overlay(elm, params) {
        var overlayDiv = noder.createElement("div", params);
        styler.css(overlayDiv, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 0x7FFFFFFF,
            opacity: 0.7
        });
        elm.appendChild(overlayDiv);
        return overlayDiv;

    }
    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};
        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            _overlay = overlay(throbber, {
                "class": 'overlay fade'
            }),
            throb = noder.createElement("div", {
                "class": "throb"
            }),
            textNode = noder.createTextNode(text || ""),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };
        if (params.style) {
            styler.css(throbber,params.style);
        }
        throb.appendChild(textNode);
        throbber.appendChild(throb);
        elm.appendChild(throbber);
        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            remove: remove,
            update: update
        };
    }

    function fx() {
        return fx;
    }

    langx.mixin(fx, {
        off: false,

        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        },

        animate,
        emulateTransitionEnd,
        fadeIn,
        fadeOut,
        fadeTo,
        fadeToggle,
        hide,
        scrollToTop,

        slideDown,
        slideToggle,
        slideUp,
        show,
        throb,
        toggle
    });

    return skylark.attach("domx.fx", fx);
});
define('skylark-domx-fx/main',[
	"./fx",
	"skylark-domx-velm",
	"skylark-domx-query"	
],function(fx,velm,$){
    // from ./fx
    velm.delegate([
        "animate",
        "emulateTransitionEnd",
        "fadeIn",
        "fadeOut",
        "fadeTo",
        "fadeToggle",
        "hide",
        "scrollToTop",
        "slideDown",
        "slideToggle",
        "slideUp",
        "show",
        "toggle"
    ], fx);

    $.fn.hide =  $.wraps.wrapper_every_act(fx.hide, fx);

    $.fn.animate = $.wraps.wrapper_every_act(fx.animate, fx);
    $.fn.emulateTransitionEnd = $.wraps.wrapper_every_act(fx.emulateTransitionEnd, fx);

    $.fn.show = $.wraps.wrapper_every_act(fx.show, fx);
    $.fn.hide = $.wraps.wrapper_every_act(fx.hide, fx);
    $.fn.toogle = $.wraps.wrapper_every_act(fx.toogle, fx);
    $.fn.fadeTo = $.wraps.wrapper_every_act(fx.fadeTo, fx);
    $.fn.fadeIn = $.wraps.wrapper_every_act(fx.fadeIn, fx);
    $.fn.fadeOut = $.wraps.wrapper_every_act(fx.fadeOut, fx);
    $.fn.fadeToggle = $.wraps.wrapper_every_act(fx.fadeToggle, fx);

    $.fn.slideDown = $.wraps.wrapper_every_act(fx.slideDown, fx);
    $.fn.slideToggle = $.wraps.wrapper_every_act(fx.slideToggle, fx);
    $.fn.slideUp = $.wraps.wrapper_every_act(fx.slideUp, fx);

	return fx;
});
define('skylark-domx-fx', ['skylark-domx-fx/main'], function (main) { return main; });

define('skylark-domx-plugins/plugins',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-query",
    "skylark-domx-velm"
], function(skylark, langx, noder, datax, eventer, finder, geom, styler, fx, $, elmx) {
    "use strict";

    var slice = Array.prototype.slice,
        concat = Array.prototype.concat,
        pluginKlasses = {},
        shortcuts = {};

    /*
     * Create or get or destory a plugin instance assocated with the element.
     */
    function instantiate(elm,pluginName,options) {
        var pair = pluginName.split(":"),
            instanceDataName = pair[1];
        pluginName = pair[0];

        if (!instanceDataName) {
            instanceDataName = pluginName;
        }

        var pluginInstance = datax.data( elm, instanceDataName );

        if (options === "instance") {
            return pluginInstance;
        } else if (options === "destroy") {
            if (!pluginInstance) {
                throw new Error ("The plugin instance is not existed");
            }
            pluginInstance.destroy();
            datax.removeData( elm, pluginName);
            pluginInstance = undefined;
        } else {
            if (!pluginInstance) {
                if (options !== undefined && typeof options !== "object") {
                    throw new Error ("The options must be a plain object");
                }
                var pluginKlass = pluginKlasses[pluginName]; 
                pluginInstance = new pluginKlass(elm,options);
                datax.data( elm, instanceDataName,pluginInstance );
            } else if (options) {
                pluginInstance.reset(options);
            }
        }

        return pluginInstance;
    }


    function shortcutter(pluginName,extfn) {
       /*
        * Create or get or destory a plugin instance assocated with the element,
        * and also you can execute the plugin method directory;
        */
        return function (elm,options) {
            var  plugin = instantiate(elm, pluginName,"instance");
            if ( options === "instance" ) {
              return plugin || null;
            }

            if (!plugin) {
                plugin = instantiate(elm, pluginName,typeof options == 'object' && options || {});
                if (typeof options != "string") {
                  return this;
                }
            } 
            if (options) {
                var args = slice.call(arguments,1); //2
                if (extfn) {
                    return extfn.apply(plugin,args);
                } else {
                    if (typeof options == 'string') {
                        var methodName = options;

                        if ( !plugin ) {
                            throw new Error( "cannot call methods on " + pluginName +
                                " prior to initialization; " +
                                "attempted to call method '" + methodName + "'" );
                        }

                        if ( !langx.isFunction( plugin[ methodName ] ) || methodName.charAt( 0 ) === "_" ) {
                            throw new Error( "no such method '" + methodName + "' for " + pluginName +
                                " plugin instance" );
                        }

                        return plugin[methodName].apply(plugin,args);
                    }                
                }                
            }

        }

    }

    /*
     * Register a plugin type
     */
    function register( pluginKlass,shortcutName,instanceDataName,extfn) {
        var pluginName = pluginKlass.prototype.pluginName;
        
        pluginKlasses[pluginName] = pluginKlass;

        if (shortcutName) {
            if (instanceDataName && langx.isFunction(instanceDataName)) {
                extfn = instanceDataName;
                instanceDataName = null;
            } 
            if (instanceDataName) {
                pluginName = pluginName + ":" + instanceDataName;
            }

            var shortcut = shortcuts[shortcutName] = shortcutter(pluginName,extfn);
                
            $.fn[shortcutName] = function(options) {
                var returnValue = this;

                if ( !this.length && options === "instance" ) {
                  returnValue = undefined;
                } else {
                  var args = slice.call(arguments);
                  this.each(function () {
                    var args2 = slice.call(args);
                    args2.unshift(this);
                    var  ret  = shortcut.apply(undefined,args2);
                    if (ret !== undefined) {
                        returnValue = ret;
                        return false;
                    }
                  });
                }

                return returnValue;
            };

            elmx.partial(shortcutName,function(options) {
                var  ret  = shortcut(this._elm,options);
                if (ret === undefined) {
                    ret = this;
                }
                return ret;
            });

        }
    }

 
    var Plugin =   langx.Evented.inherit({
        klassName: "Plugin",

        _construct : function(elm,options) {
           this._elm = elm;
           this._initOptions(options);
        },

        _initOptions : function(options) {
          var ctor = this.constructor,
              cache = ctor.cache = ctor.cache || {},
              defaults = cache.defaults;
          if (!defaults) {
            var  ctors = [];
            do {
              ctors.unshift(ctor);
              if (ctor === Plugin) {
                break;
              }
              ctor = ctor.superclass;
            } while (ctor);

            defaults = cache.defaults = {};
            for (var i=0;i<ctors.length;i++) {
              ctor = ctors[i];
              if (ctor.prototype.hasOwnProperty("options")) {
                langx.mixin(defaults,ctor.prototype.options,true);
              }
              if (ctor.hasOwnProperty("options")) {
                langx.mixin(defaults,ctor.options,true);
              }
            }
          }
          Object.defineProperty(this,"options",{
            value :langx.mixin({},defaults,options,true)
          });

          //return this.options = langx.mixin({},defaults,options);
          return this.options;
        },


        destroy: function() {
            var that = this;

            this._destroy();
            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            datax.removeData(this._elm,this.pluginName );
        },

        _destroy: langx.noop,

        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },

        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if ( arguments.length === 0 ) {

                // Don't return a reference to the internal hash
                return langx.mixin( {}, this.options );
            }

            if ( typeof key === "string" ) {

                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = langx.mixin( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }

            this._setOptions( options );

            return this;
        },

        _setOptions: function( options ) {
            var key;

            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }

            return this;
        },

        _setOption: function( key, value ) {

            this.options[ key ] = value;

            return this;
        },

        getUID : function (prefix) {
            prefix = prefix || "plugin";
            do prefix += ~~(Math.random() * 1000000)
            while (document.getElementById(prefix))
            return prefix;
        },

        elm : function() {
            return this._elm;
        }

    });

    $.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };

    elmx.partial("plugin",function(name,options) {
        var args = slice.call( arguments, 1 );
        return instantiate.apply(this,[this.domNode,name].concat(args));
    }); 


    function plugins() {
        return plugins;
    }
     
    langx.mixin(plugins, {
        instantiate,
        Plugin,
        register,
        shortcuts
    });

    return  skylark.attach("domx.plugins",plugins);
});
define('skylark-domx-plugins/main',[
	"./plugins"
],function(plugins){
	return plugins;
});
define('skylark-domx-plugins', ['skylark-domx-plugins/main'], function (main) { return main; });

define('skylark-data-collection/collections',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("data.collections",{});
});
define('skylark-data-collection/Collection',[
    "skylark-langx/Evented",
    "./collections"
], function(Evented, collections) {

    var Collection = collections.Collection = Evented.inherit({

        "klassName": "Collection",

        _clear: function() {
            throw new Error('Unimplemented API');
        },

        "clear": function() {
            //desc: "Removes all items from the Collection",
            //result: {
            //    type: Collection,
            //    desc: "this instance for chain call"
            //},
            //params: [],
            this._clear();
            this.trigger("changed:clear");
            return this;
        },

        /*
         *@method count
         *@return {Number}
         */
        count : /*Number*/function () {
            var c = 0,
                it = this.iterator();
            while(!it.hasNext()){
                c++;
            }
            return c;
        },

        "forEach": function( /*Function*/ func, /*Object?*/ thisArg) {
            //desc: "Executes a provided callback function once per collection item.",
            //result: {
            //    type: Number,
            //    desc: "the number of items"
            //},
            //params: [{
            //    name: "func",
            //    type: Function,
            //    desc: "Function to execute for each element."
            //}, {
            //    name: "thisArg",
            //    type: Object,
            //    desc: "Value to use as this when executing callback."
            //}],
            var it = this.iterator();
            while(it.hasNext()){
                var item = it.next();
                func.call(thisArg || item,item);
            }
            return this;

        },

        "iterator" : function() {
            throw new Error('Unimplemented API');
        },

        "toArray": function() {
            //desc: "Returns an array containing all of the items in this collection in proper sequence (from first to last item).",
            //result: {
            //    type: Array,
            //    desc: "an array containing all of the elements in this collection in proper sequence"
            //},
            //params: [],
            var items = [],
                it = this.iterator();
            while(!it.hasNext()){
                items.push(it.next());
            }
            return items;
        }
    });

    return Collection;
});


define('skylark-data-collection/Map',[
    "./collections",
    "./Collection"
], function( collections, Collection) {

    var Map = collections.Map = Collection.inherit({

        "klassName": "Map",

        _getInnerItems : function() {
            return this._items;
        },

        _clear : function() {
            this._items = [];
        },

        _findKeyByRegExp: function(regExp, callback) {
            var items = this._getInnerItems();
            return items.filter(function(key) {
                if (key.match(regExp)) {
                    if (callback) callback(key);
                    return true;
                } else {
                    return false;
                }
            });
        },

        "get":  function(strKey, silent) {
            //desc: "Returns the item at the specified key in the Hashtable.",
            //result: {
            //    type: Object,
            //    desc: "The item at the specified key."
            //},
            //params: [{
            //    name: "strKey",
            //    type: String,
            //    desc: "The key of the item to return."
            //}, {
            //    name: "silent",
            //    type: Boolean,
            //    desc: "the silent flag.",
            //    optional: true
            //}],
            if (typeof(strKey) != "string") {
                throw "hash key is not string!";
            }
            /*
            if (!silent && !this.contains(strKey)) {
                throw "hash key is not  existed";
            }
            */
            var items = this._getInnerItems();
            return items[strKey];
        },

        "iterator" : function() {
            var i =0;
            return {
                hasNext : function() {
                    return i < this._items.length;
                },
                next : function() {
                    var key =  this._items[i++];
                    return [this._items[key],key];
                }
            }
        },

        "set": function( /*String*/ strKey, /*Object*/ value) {
            //desc: "Replaces the item at the specified key in the Hashtable with the specified item.",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "strKey",
            //    type: String,
            //    desc: "key of the item to replace."
            //}, {
            //    name: "value",
            //    type: Object,
            //    desc: "item to be stored at the specified position."
            //}],
            if (typeof(strKey) != "string") {
                throw "hash key is not string!";
            }

            /*
            if (!this.contains(strKey)) {
                throw "hash key is not existed";
            }
            */

            var items = this._getInnerItems();
            if (items.indexOf(strKey) == -1) {
                items.push(strKey);
            }
            var oldValue = items[strKey];
            if (oldValue !== value) {
                items[strKey] = value;
                var updated = {};
                updated[strKey] = {
                    name : strKey,
                    value : value,
                    oldValue : oldValue
                };
                this.trigger("changed" ,{ //TODO: "changed:"+ strKey
                    data : updated
                });
            }
            return this;
        },


        "remove": function( /*String*/ strKey) {
            //desc: "Removes the first occurrence of a specific item from the Hashtable",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "strKey",
            //    type: String,
            //    desc: "The key for The item to remove from the Hashtable."
            //}],
            if (typeof(strKey) != "string") {
                throw "hash key is not string!";
            }
            var items = this._getInnerItems();
            var idx = items.indexOf(strKey);
            if (idx >= 0) {
                delete items[strKey];
                delete items[idx];
            }
        },

        findByRegExp: function( /*String*/ regExp, callback) {
            //desc: "find regExp items",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "regExp",
            //    type: String,
            //    desc: "The key for The item to remove from the Hashtable."
            //}, {
            //    name: "callback",
            //    type: Function,
            //    desc: "the callback method"
            //}],
            var items = [],
                self = this;
            this._findKeyByRegExp(regExp, function(key) {
                var item = self.get(key);
                if (callback) callback(item);
                items.push(item);
            });
            return items;
        },

        removeByRegExp: function( /*String*/ regExp) {
            //desc: "Removes regExp items",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "regExp",
            //    type: String,
            //    desc: "The key for The item to remove from the Hashtable."
            //}],
            var self = this;
            this._findKeyByRegExp(regExp, function(key) {
                self.remove(key);
            });
        },

        "toPlain": function() {
            //desc: "Returns a plain object containing all of the items in this Hashable.",
            //result: {
            //    type: Object,
            //    desc: "a plain object containing all of the items in this Hashtable."
            //},
            //params: [],
            var items = this._getInnerItems(); 

            for (var i = 0; i < items.length; i++) {
                var key = items[i];
                plain[key] = items[key];
            }
            return plain;
        },

        "toString": function( /*String?*/ delim) {
            //desc: "implementation of toString, follows [].toString().",
            //result: {
            //    type: String,
            //   desc: "The string."
            //},
            //params: [{
            //    name: "delim",
            //    type: String,
            //    desc: "The delim ",
            //    optional: true
            //}],
            var items = this._getInnerItems();

            return items.join((delim || ","));
        },

        "init": function( /*Object*/ data) {
            var items = this._items = [];
            for (var name in data) {
                items.push(name);
                items[name]= data[name];
            }
        }
       
    });
    return Map;
});


define('skylark-data-collection/HashMap',[
    "./collections",
	"./Map"
],function(collections,_Map) {

	var HashMap = collections.HashMap = _Map.inherit({
	});

	return HashMap;
});
define('skylark-widgets-base/base',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("widgets.base",{});
});
define('skylark-widgets-base/Widget',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-data",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-files",
  "skylark-domx-geom",
  "skylark-domx-velm",
  "skylark-domx-query",
  "skylark-domx-fx",
  "skylark-domx-plugins",
  "skylark-data-collection/HashMap",
  "./base"
],function(skylark,langx,browser,datax,eventer,noder,files,geom,elmx,$,fx, plugins,HashMap,base){

/*---------------------------------------------------------------------------------*/

  var Widget = plugins.Plugin.inherit({
    klassName: "Widget",

    _elmx : elmx,

    _construct : function(elm,options) {
        if (langx.isHtmlNode(elm)) {
          options = this._parse(elm,options);
        } else {
          options = elm;
          elm = null;
        }
        this.overrided(elm,options);

        if (!elm) {
          this._velm = this._create();
          this._elm = this._velm.elm();
        } else {
          this._velm = elmx(this._elm);
        }
        
        Object.defineProperty(this,"state",{
          value :this.options.state || new HashMap()
        });

        //this.state = this.options.state || new Map();
        this._init();

        var addonCategoryOptions = this.options.addons;
        if (addonCategoryOptions) {
          var widgetCtor = this.constructor,
              addons = widgetCtor.addons;
          for (var categoryName in addonCategoryOptions) {
              for (var i =0;i < addonCategoryOptions[categoryName].length; i++ ) {
                var addonOption = addonCategoryOptions[categoryName][i];
                if (langx.isString(addonOption)) {
                  var addonName = addonOption,
                      addonSetting = addons[categoryName][addonName],
                      addonCtor = addonSetting.ctor ? addonSetting.ctor : addonSetting;

                  this.addon(addonCtor,addonSetting.options);

                }

              }
          }
        }

        if (this._elm.parentElement) {
          // The widget is already in document
          this._startup();
        }

     },

    /**
     * Parses widget options from attached element.
     * This is a callback method called by constructor when attached element is specified.
     * @method _parse
     * @return {Object} options.
     */
    _parse : function(elm,options) {
      var optionsAttr = datax.data(elm,"options");
      if (optionsAttr) {
         //var options1 = JSON.parse("{" + optionsAttr + "}");
         var options1 = eval("({" + optionsAttr + "})");
         options = langx.mixin(options1,options); 
      }
      return options || {};
    },


    /**
     * Create html element for this widget.
     * This is a callback method called by constructor when attached element is not specified.
     * @method _create
     */
    _create : function() {
        var template = this.options.template;
        if (template) {
          return this._elmx(template);
        } else {
          throw new Error("The template is not existed in options!");
        }
    },


    /**
     * Init widget.
     * This is a callback method called by constructor.
     * @method _init
     */
    _init : function() {
      var self = this;
      if (this.widgetClass) {
        this._velm.addClass(this.widgetClass);
      }
      this.state.on("changed",function(e,args) {
        self._refresh(args.data);
      });
    },


    /**
     * Startup widget.
     * This is a callback method called when widget element is added into dom.
     * @method _post
     */
    _startup : function() {

    },


    /**
     * Refresh widget.
     * This is a callback method called when widget state is changed.
     * @method _refresh
     */
    _refresh : function(updates) {
      /*
      var _ = this._,
          model = _.model,
          dom = _.dom,
          props = {

          };
      updates = updates || {};
      for (var attrName in updates){
          var v = updates[attrName].value;
          if (v && v.toCss) {
              v.toCss(props);
              updates[attrName].processed = true;
          }

      };

      this.css(props);

      if (updates["disabled"]) {
          var v = updates["disabled"].value;
          dom.aria('disabled', v);
          self.classes.toggle('disabled', v);
      }
      */
    },                

    mapping : {
      "events" : {
  //       'mousedown .title':  'edit',
  //       'click .button':     'save',
  //       'click .open':       function(e) { ... }            
      },

      "attributs" : {

      },

      "properties" : {

      },

      "styles" : {

      }
    },

    addon : function(ctor,setting) {
      var categoryName = ctor.categoryName,
          addonName = ctor.addonName;

      this._addons = this.addons || {};
      var category = this._addons[categoryName] = this._addons[categoryName] || {};
      category[addonName] = new ctor(this,setting);
      return this;
    },

    addons : function(categoryName,settings) {
      this._addons = this.addons || {};
      var category = this._addons[categoryName] = this._addons[categoryName] || {};

      if (settings == undefined) {
        return langx.clone(category || null);
      } else {
        langx.mixin(category,settings);
      }
    },


    /**
     * Returns a html element representing the widget.
     *
     * @method render
     * @return {HtmlElement} HTML element representing the widget.
     */
    render: function() {
      return this._elm;
    },



    /**
     * Returns a parent widget  enclosing this widgets, or null if not exist.
     *
     * @method getEnclosing
     * @return {Widget} The enclosing parent widget, or null if not exist.
     */
    getEnclosing : function(selector) {
      return null;
    },

    /**
     * Returns a widget collection with all enclosed child widgets.
     *
     * @method getEnclosed
     * @return {List} Collection with all enclosed child widgets..
     */
    getEnclosed : function() {
      var self = this;
          children = new ArrayList();
      return children;
    },

    /**
     * Sets the visible state to true.
     *
     * @method show
     * @return {Widget} Current widget instance.
     */

    show : function() {
      this._velm.show();
    },

    /**
     * Sets the visible state to false.
     *
     * @method hide
     * @return {Widget} Current widget instance.
     */
    hide : function() {
      this._velm.hide();
    },

    /**
     * Focuses the current widget.
     *
     * @method focus
     * @return {Widget} Current widget instance.
     */
    focus :function() {
      try {
        this._velm.focus();
      } catch (ex) {
        // Ignore IE error
      }

      return this;
    },

    /**
     * Blurs the current widget.
     *
     * @method blur
     * @return {Widget} Current widget instance.
     */
    blur : function() {
      this._velm.blur();

      return this;
    },

    enable: function () {
      this.state.set('disabled',false);
      return this;
    },

    disable: function () {
      this.state.set('disabled',true);
      return this;
    },

    /**
     * Sets the specified aria property.
     *
     * @method aria
     * @param {String} name Name of the aria property to set.
     * @param {String} value Value of the aria property.
     * @return {Widget} Current widget instance.
     */
    aria : function(name, value) {
      const self = this, elm = self.getEl(self.ariaTarget);

      if (typeof value === 'undefined') {
        return self._aria[name];
      }

      self._aria[name] = value;

      if (self.state.get('rendered')) {
        elm.setAttribute(name === 'role' ? name : 'aria-' + name, value);
      }

      return self;
    },

    attr: function (name,value) {
        var velm = this._velm,
            ret = velm.attr(name,value);
        return ret == velm ? this : ret;
    },

    css: function (name, value) {
        var velm = this._velm,
            ret = velm.css(name, value);
        return ret == velm ? this : ret;
    },

    data: function (name, value) {
        var velm = this._velm,
            ret = velm.data(name,value);
        return ret == velm ? this : ret;
    },

    prop: function (name,value) {
        var velm = this._velm,
            ret = velm.prop(name,value);
        return ret == velm ? this : ret;
    },

    throb: function(params) {
      return fx.throb(this._elm,params);
    },

    emit : function(type,params) {
      var e = langx.Emitter.createEvent(type,{
        data : params
      });
      return langx.Emitter.prototype.emit.call(this,e,params);
    },

    /**
     *  Attach the current widget element to dom document.
     *
     * @method attach
     * @return {Widget} This Widget.
     */
    attach : function(target,position){
        var elm = target;
        if (!position || position=="child") {
            noder.append(elm,this._elm);
        } else  if (position == "before") {
            noder.before(elm,this._elm);
        } else if (position == "after") {
            noder.after(elm,this._elm);
        }
        this._startup();
    },

    /**
     *  Detach the current widget element from dom document.
     *
     * @method html
     * @return {HtmlElement} HTML element representing the widget.
     */
    detach : function() {
      this._velm.remove();
    }
  });

  Widget.inherit = function(meta) {
    var ctor = plugins.Plugin.inherit.apply(this,arguments);

    function addStatePropMethod(name) {
        ctor.prototype[name] = function(value) {
          if (value !== undefined) {
            this.state.set(name,value);
            return this;
          } else {
            return this.state.get(name);
          }
        };
    }
    if (meta.state) {
      for (var name in meta.state) {
          addStatePropMethod(name);
      }
    }

    if (meta.pluginName) {
      plugins.register(ctor,meta.pluginName);
    }
    return ctor;
  };

  Widget.register = function(ctor,widgetName) {
    var meta = ctor.prototype,
        pluginName = widgetName || meta.pluginName;

    function addStatePropMethod(name) {
        ctor.prototype[name] = function(value) {
          if (value !== undefined) {
            this.state.set(name,value);
            return this;
          } else {
            return this.state.get(name);
          }
        };
    }
    if (meta.state) {
      for (var name in meta.state) {
          addStatePropMethod(name);
      }
    }

    if (pluginName) {
      plugins.register(ctor,pluginName);
    }
    return ctor;
  };

  return base.Widget = Widget;
});

define('skylark-widgets-swt/Widget',[
  "skylark-widgets-base/Widget"
],function(Widget){
  return Widget;
});

define('skylark-nprogress/nprogress',[],function(){
  function nprogress() {
    var NProgress = {};

    NProgress.version = '0.2.0';

    var Settings = NProgress.settings = {
      minimum: 0.08,
      easing: 'ease',
      positionUsing: '',
      speed: 200,
      trickle: true,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: true,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: 'body',
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };

    /**
     * Updates configuration.
     *
     *     NProgress.configure({
     *       minimum: 0.1
     *     });
     */
    NProgress.configure = function(options) {
      var key, value;
      for (key in options) {
        value = options[key];
        if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
      }

      return this;
    };

    /**
     * Last number.
     */

    NProgress.status = null;

    /**
     * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
     *
     *     NProgress.set(0.4);
     *     NProgress.set(1.0);
     */

    NProgress.set = function(n) {
      var started = NProgress.isStarted();

      n = clamp(n, Settings.minimum, 1);
      NProgress.status = (n === 1 ? null : n);

      var progress = NProgress.render(!started),
          bar      = progress.querySelector(Settings.barSelector),
          speed    = Settings.speed,
          ease     = Settings.easing;

      progress.offsetWidth; /* Repaint */

      queue(function(next) {
        // Set positionUsing if it hasn't already been set
        if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

        // Add transition
        css(bar, barPositionCSS(n, speed, ease));

        if (n === 1) {
          // Fade out
          css(progress, { 
            transition: 'none', 
            opacity: 1 
          });
          progress.offsetWidth; /* Repaint */

          setTimeout(function() {
            css(progress, { 
              transition: 'all ' + speed + 'ms linear', 
              opacity: 0 
            });
            setTimeout(function() {
              NProgress.remove();
              next();
            }, speed);
          }, speed);
        } else {
          setTimeout(next, speed);
        }
      });

      return this;
    };

    NProgress.isStarted = function() {
      return typeof NProgress.status === 'number';
    };

    /**
     * Shows the progress bar.
     * This is the same as setting the status to 0%, except that it doesn't go backwards.
     *
     *     NProgress.start();
     *
     */
    NProgress.start = function() {
      if (!NProgress.status) NProgress.set(0);

      var work = function() {
        setTimeout(function() {
          if (!NProgress.status) return;
          NProgress.trickle();
          work();
        }, Settings.trickleSpeed);
      };

      if (Settings.trickle) work();

      return this;
    };

    /**
     * Hides the progress bar.
     * This is the *sort of* the same as setting the status to 100%, with the
     * difference being `done()` makes some placebo effect of some realistic motion.
     *
     *     NProgress.done();
     *
     * If `true` is passed, it will show the progress bar even if its hidden.
     *
     *     NProgress.done(true);
     */

    NProgress.done = function(force) {
      if (!force && !NProgress.status) return this;

      return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
    };

    /**
     * Increments by a random amount.
     */

    NProgress.inc = function(amount) {
      var n = NProgress.status;

      if (!n) {
        return NProgress.start();
      } else {
        if (typeof amount !== 'number') {
          amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
        }

        n = clamp(n + amount, 0, 0.994);
        return NProgress.set(n);
      }
    };

    NProgress.trickle = function() {
      return NProgress.inc(Math.random() * Settings.trickleRate);
    };

    /**
     * Waits for all supplied jQuery promises and
     * increases the progress as the promises resolve.
     *
     * @param $promise jQUery Promise
     */
    (function() {
      var initial = 0, current = 0;

      NProgress.promise = function($promise) {
        if (!$promise || $promise.state() === "resolved") {
          return this;
        }

        if (current === 0) {
          NProgress.start();
        }

        initial++;
        current++;

        $promise.always(function() {
          current--;
          if (current === 0) {
              initial = 0;
              NProgress.done();
          } else {
              NProgress.set((initial - current) / initial);
          }
        });

        return this;
      };

    })();

    /**
     * (Internal) renders the progress bar markup based on the `template`
     * setting.
     */

    NProgress.render = function(fromStart) {
      if (NProgress.isRendered()) return document.getElementById('nprogress');

      addClass(document.documentElement, 'nprogress-busy');
      
      var progress = document.createElement('div');
      progress.id = 'nprogress';
      progress.innerHTML = Settings.template;

      var bar      = progress.querySelector(Settings.barSelector),
          perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
          parent   = document.querySelector(Settings.parent),
          spinner;
      
      css(bar, {
        transition: 'all 0 linear',
        transform: 'translate3d(' + perc + '%,0,0)'
      });

      if (!Settings.showSpinner) {
        spinner = progress.querySelector(Settings.spinnerSelector);
        spinner && removeElement(spinner);
      }

      if (parent != document.body) {
        addClass(parent, 'nprogress-custom-parent');
      }

      parent.appendChild(progress);
      return progress;
    };

    /**
     * Removes the element. Opposite of render().
     */

    NProgress.remove = function() {
      removeClass(document.documentElement, 'nprogress-busy');
      removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
      var progress = document.getElementById('nprogress');
      progress && removeElement(progress);
    };

    /**
     * Checks if the progress bar is rendered.
     */

    NProgress.isRendered = function() {
      return !!document.getElementById('nprogress');
    };

    /**
     * Determine which positioning CSS rule to use.
     */

    NProgress.getPositioningCSS = function() {
      // Sniff on document.body.style
      var bodyStyle = document.body.style;

      // Sniff prefixes
      var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                         ('MozTransform' in bodyStyle) ? 'Moz' :
                         ('msTransform' in bodyStyle) ? 'ms' :
                         ('OTransform' in bodyStyle) ? 'O' : '';

      if (vendorPrefix + 'Perspective' in bodyStyle) {
        // Modern browsers with 3D support, e.g. Webkit, IE10
        return 'translate3d';
      } else if (vendorPrefix + 'Transform' in bodyStyle) {
        // Browsers without 3D support, e.g. IE9
        return 'translate';
      } else {
        // Browsers without translate() support, e.g. IE7-8
        return 'margin';
      }
    };

    /**
     * Helpers
     */

    function clamp(n, min, max) {
      if (n < min) return min;
      if (n > max) return max;
      return n;
    }

    /**
     * (Internal) converts a percentage (`0..1`) to a bar translateX
     * percentage (`-100%..0%`).
     */

    function toBarPerc(n) {
      return (-1 + n) * 100;
    }


    /**
     * (Internal) returns the correct CSS for changing the bar's
     * position given an n percentage, and speed and ease from Settings
     */

    function barPositionCSS(n, speed, ease) {
      var barCSS;

      if (Settings.positionUsing === 'translate3d') {
        barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
      } else if (Settings.positionUsing === 'translate') {
        barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
      } else {
        barCSS = { 'margin-left': toBarPerc(n)+'%' };
      }

      barCSS.transition = 'all '+speed+'ms '+ease;

      return barCSS;
    }

    /**
     * (Internal) Queues a function to be executed.
     */

    var queue = (function() {
      var pending = [];
      
      function next() {
        var fn = pending.shift();
        if (fn) {
          fn(next);
        }
      }

      return function(fn) {
        pending.push(fn);
        if (pending.length == 1) next();
      };
    })();

    /**
     * (Internal) Applies css properties to an element, similar to the jQuery 
     * css method.
     *
     * While this helper does assist with vendor prefixed property names, it 
     * does not perform any manipulation of values prior to setting styles.
     */

    var css = (function() {
      var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
          cssProps    = {};

      function camelCase(string) {
        return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
          return letter.toUpperCase();
        });
      }

      function getVendorProp(name) {
        var style = document.body.style;
        if (name in style) return name;

        var i = cssPrefixes.length,
            capName = name.charAt(0).toUpperCase() + name.slice(1),
            vendorName;
        while (i--) {
          vendorName = cssPrefixes[i] + capName;
          if (vendorName in style) return vendorName;
        }

        return name;
      }

      function getStyleProp(name) {
        name = camelCase(name);
        return cssProps[name] || (cssProps[name] = getVendorProp(name));
      }

      function applyCss(element, prop, value) {
        prop = getStyleProp(prop);
        element.style[prop] = value;
      }

      return function(element, properties) {
        var args = arguments,
            prop, 
            value;

        if (args.length == 2) {
          for (prop in properties) {
            value = properties[prop];
            if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
          }
        } else {
          applyCss(element, args[1], args[2]);
        }
      }
    })();

    /**
     * (Internal) Determines if an element or space separated list of class names contains a class name.
     */

    function hasClass(element, name) {
      var list = typeof element == 'string' ? element : classList(element);
      return list.indexOf(' ' + name + ' ') >= 0;
    }

    /**
     * (Internal) Adds a class to an element.
     */

    function addClass(element, name) {
      var oldList = classList(element),
          newList = oldList + name;

      if (hasClass(oldList, name)) return; 

      // Trim the opening space.
      element.className = newList.substring(1);
    }

    /**
     * (Internal) Removes a class from an element.
     */

    function removeClass(element, name) {
      var oldList = classList(element),
          newList;

      if (!hasClass(element, name)) return;

      // Replace the class name.
      newList = oldList.replace(' ' + name + ' ', ' ');

      // Trim the opening and closing spaces.
      element.className = newList.substring(1, newList.length - 1);
    }

    /**
     * (Internal) Gets a space separated list of the class names on the element. 
     * The list is wrapped with a single space on each end to facilitate finding 
     * matches within the list.
     */

    function classList(element) {
      return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
    }

    /**
     * (Internal) Removes an element from the DOM.
     */

    function removeElement(element) {
      element && element.parentNode && element.parentNode.removeChild(element);
    }

    return NProgress;
  }

  return nprogress;

});



define('skylark-nprogress/main',[
	"./nprogress"
],function(nprogress){
	return nprogress;
});
define('skylark-nprogress', ['skylark-nprogress/main'], function (main) { return main; });

define('skylark-bootbox4/bootbox',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-data",
  "skylark-domx-styler"
],function(skylark,langx,$) {

  "use strict";

  // the base DOM structure needed to create a modal
  var templates = {
    dialog:
      "<div class='bootbox modal' tabindex='-1' role='dialog'>" +
        "<div class='modal-dialog'>" +
          "<div class='modal-content'>" +
            "<div class='modal-body'><div class='bootbox-body'></div></div>" +
          "</div>" +
        "</div>" +
      "</div>",
    header:
      "<div class='modal-header'>" +
        "<h4 class='modal-title'></h4>" +
      "</div>",
    footer:
      "<div class='modal-footer'></div>",
    closeButton:
      "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",
    form:
      "<form class='bootbox-form'></form>",
    inputs: {
      text:
        "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",
      textarea:
        "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",
      email:
        "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",
      select:
        "<select class='bootbox-input bootbox-input-select form-control'></select>",
      checkbox:
        "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>",
      date:
        "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />",
      time:
        "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />",
      number:
        "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />",
      password:
        "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />"
    }
  };

  var defaults = {
    // default language
    locale: "en",
    // show backdrop or not. Default to static so user has to interact with dialog
    backdrop: "static",
    // animate the modal in/out
    animate: true,
    // additional class string applied to the top level dialog
    className: null,
    // whether or not to include a close button
    closeButton: true,
    // show the dialog immediately by default
    show: true,
    // dialog container
    container: "body"
  };

  // our public object; augmented after our private API
  var bootbox = {};

  /**
   * @private
   */
  function _t(key) {
    var locale = locales[defaults.locale];
    return locale ? locale[key] : locales.en[key];
  }

  function processCallback(e, dialog, callback) {
    e.stopPropagation();
    e.preventDefault();

    // by default we assume a callback will get rid of the dialog,
    // although it is given the opportunity to override this

    // so, if the callback can be invoked and it *explicitly returns false*
    // then we'll set a flag to keep the dialog active...
    var preserveDialog = langx.isFunction(callback) && callback.call(dialog, e) === false;

    // ... otherwise we'll bin it
    if (!preserveDialog) {
      dialog.modal("hide");
    }
  }

  function getKeyLength(obj) {
    // @TODO defer to Object.keys(x).length if available?
    var k, t = 0;
    for (k in obj) {
      t ++;
    }
    return t;
  }

  function each(collection, iterator) {
    var index = 0;
    langx.each(collection, function(key, value) {
      iterator(key, value, index++);
    });
  }

  function sanitize(options) {
    var buttons;
    var total;

    if (typeof options !== "object") {
      throw new Error("Please supply an object of options");
    }

    if (!options.message) {
      throw new Error("Please specify a message");
    }

    // make sure any supplied options take precedence over defaults
    options = langx.extend({}, defaults, options);

    if (!options.buttons) {
      options.buttons = {};
    }

    buttons = options.buttons;

    total = getKeyLength(buttons);

    each(buttons, function(key, button, index) {

      if (langx.isFunction(button)) {
        // short form, assume value is our callback. Since button
        // isn't an object it isn't a reference either so re-assign it
        button = buttons[key] = {
          callback: button
        };
      }

      // before any further checks make sure by now button is the correct type
      if (langx.type(button) !== "object") {
        throw new Error("button with key " + key + " must be an object");
      }

      if (!button.label) {
        // the lack of an explicit label means we'll assume the key is good enough
        button.label = key;
      }

      if (!button.className) {
        if (total <= 2 && index === total-1) {
          // always add a primary to the main option in a two-button dialog
          button.className = "btn-primary";
        } else {
          button.className = "btn-default";
        }
      }
    });

    return options;
  }

  /**
   * map a flexible set of arguments into a single returned object
   * if args.length is already one just return it, otherwise
   * use the properties argument to map the unnamed args to
   * object properties
   * so in the latter case:
   * mapArguments(["foo", langx.noop], ["message", "callback"])
   * -> { message: "foo", callback: langx.noop }
   */
  function mapArguments(args, properties) {
    var argn = args.length;
    var options = {};

    if (argn < 1 || argn > 2) {
      throw new Error("Invalid argument length");
    }

    if (argn === 2 || typeof args[0] === "string") {
      options[properties[0]] = args[0];
      options[properties[1]] = args[1];
    } else {
      options = args[0];
    }

    return options;
  }

  /**
   * merge a set of default dialog options with user supplied arguments
   */
  function mergeArguments(defaults, args, properties) {
    return langx.extend(
      // deep merge
      true,
      // ensure the target is an empty, unreferenced object
      {},
      // the base options object for this type of dialog (often just buttons)
      defaults,
      // args could be an object or array; if it's an array properties will
      // map it to a proper options object
      mapArguments(
        args,
        properties
      )
    );
  }

  /**
   * this entry-level method makes heavy use of composition to take a simple
   * range of inputs and return valid options suitable for passing to bootbox.dialog
   */
  function mergeDialogOptions(className, labels, properties, args) {
    //  build up a base set of dialog properties
    var baseOptions = {
      className: "bootbox-" + className,
      buttons: createLabels.apply(null, labels)
    };

    // ensure the buttons properties generated, *after* merging
    // with user args are still valid against the supplied labels
    return validateButtons(
      // merge the generated base properties with user supplied arguments
      mergeArguments(
        baseOptions,
        args,
        // if args.length > 1, properties specify how each arg maps to an object key
        properties
      ),
      labels
    );
  }

  /**
   * from a given list of arguments return a suitable object of button labels
   * all this does is normalise the given labels and translate them where possible
   * e.g. "ok", "confirm" -> { ok: "OK, cancel: "Annuleren" }
   */
  function createLabels() {
    var buttons = {};

    for (var i = 0, j = arguments.length; i < j; i++) {
      var argument = arguments[i];
      var key = argument.toLowerCase();
      var value = argument.toUpperCase();

      buttons[key] = {
        label: _t(value)
      };
    }

    return buttons;
  }

  function validateButtons(options, buttons) {
    var allowedButtons = {};
    each(buttons, function(key, value) {
      allowedButtons[value] = true;
    });

    each(options.buttons, function(key) {
      if (allowedButtons[key] === undefined) {
        throw new Error("button key " + key + " is not allowed (options are " + buttons.join("\n") + ")");
      }
    });

    return options;
  }

  bootbox.alert = function() {
    var options;

    options = mergeDialogOptions("alert", ["ok"], ["message", "callback"], arguments);

    if (options.callback && !langx.isFunction(options.callback)) {
      throw new Error("alert requires callback property to be a function when provided");
    }

    /**
     * overrides
     */
    options.buttons.ok.callback = options.onEscape = function() {
      if (langx.isFunction(options.callback)) {
        return options.callback.call(this);
      }
      return true;
    };

    return bootbox.dialog(options);
  };

  bootbox.confirm = function() {
    var options;

    options = mergeDialogOptions("confirm", ["cancel", "confirm"], ["message", "callback"], arguments);

    /**
     * overrides; undo anything the user tried to set they shouldn't have
     */
    options.buttons.cancel.callback = options.onEscape = function() {
      return options.callback.call(this, false);
    };

    options.buttons.confirm.callback = function() {
      return options.callback.call(this, true);
    };

    // confirm specific validation
    if (!langx.isFunction(options.callback)) {
      throw new Error("confirm requires a callback");
    }

    return bootbox.dialog(options);
  };

  bootbox.prompt = function() {
    var options;
    var defaults;
    var dialog;
    var form;
    var input;
    var shouldShow;
    var inputOptions;

    // we have to create our form first otherwise
    // its value is undefined when gearing up our options
    // @TODO this could be solved by allowing message to
    // be a function instead...
    form = $(templates.form);

    // prompt defaults are more complex than others in that
    // users can override more defaults
    // @TODO I don't like that prompt has to do a lot of heavy
    // lifting which mergeDialogOptions can *almost* support already
    // just because of 'value' and 'inputType' - can we refactor?
    defaults = {
      className: "bootbox-prompt",
      buttons: createLabels("cancel", "confirm"),
      value: "",
      inputType: "text"
    };

    options = validateButtons(
      mergeArguments(defaults, arguments, ["title", "callback"]),
      ["cancel", "confirm"]
    );

    // capture the user's show value; we always set this to false before
    // spawning the dialog to give us a chance to attach some handlers to
    // it, but we need to make sure we respect a preference not to show it
    shouldShow = (options.show === undefined) ? true : options.show;

    /**
     * overrides; undo anything the user tried to set they shouldn't have
     */
    options.message = form;

    options.buttons.cancel.callback = options.onEscape = function() {
      return options.callback.call(this, null);
    };

    options.buttons.confirm.callback = function() {
      var value;

      switch (options.inputType) {
        case "text":
        case "textarea":
        case "email":
        case "select":
        case "date":
        case "time":
        case "number":
        case "password":
          value = input.val();
          break;

        case "checkbox":
          var checkedItems = input.find("input:checked");

          // we assume that checkboxes are always multiple,
          // hence we default to an empty array
          value = [];

          each(checkedItems, function(_, item) {
            value.push($(item).val());
          });
          break;
      }

      return options.callback.call(this, value);
    };

    options.show = false;

    // prompt specific validation
    if (!options.title) {
      throw new Error("prompt requires a title");
    }

    if (!langx.isFunction(options.callback)) {
      throw new Error("prompt requires a callback");
    }

    if (!templates.inputs[options.inputType]) {
      throw new Error("invalid prompt type");
    }

    // create the input based on the supplied type
    input = $(templates.inputs[options.inputType]);

    switch (options.inputType) {
      case "text":
      case "textarea":
      case "email":
      case "date":
      case "time":
      case "number":
      case "password":
        input.val(options.value);
        break;

      case "select":
        var groups = {};
        inputOptions = options.inputOptions || [];

        if (!langx.isArray(inputOptions)) {
          throw new Error("Please pass an array of input options");
        }

        if (!inputOptions.length) {
          throw new Error("prompt with select requires options");
        }

        each(inputOptions, function(_, option) {

          // assume the element to attach to is the input...
          var elem = input;

          if (option.value === undefined || option.text === undefined) {
            throw new Error("given options in wrong format");
          }

          // ... but override that element if this option sits in a group

          if (option.group) {
            // initialise group if necessary
            if (!groups[option.group]) {
              groups[option.group] = $("<optgroup/>").attr("label", option.group);
            }

            elem = groups[option.group];
          }

          elem.append("<option value='" + option.value + "'>" + option.text + "</option>");
        });

        each(groups, function(_, group) {
          input.append(group);
        });

        // safe to set a select's value as per a normal input
        input.val(options.value);
        break;

      case "checkbox":
        var values   = langx.isArray(options.value) ? options.value : [options.value];
        inputOptions = options.inputOptions || [];

        if (!inputOptions.length) {
          throw new Error("prompt with checkbox requires options");
        }

        if (!inputOptions[0].value || !inputOptions[0].text) {
          throw new Error("given options in wrong format");
        }

        // checkboxes have to nest within a containing element, so
        // they break the rules a bit and we end up re-assigning
        // our 'input' element to this container instead
        input = $("<div/>");

        each(inputOptions, function(_, option) {
          var checkbox = $(templates.inputs[options.inputType]);

          checkbox.find("input").attr("value", option.value);
          checkbox.find("label").append(option.text);

          // we've ensured values is an array so we can always iterate over it
          each(values, function(_, value) {
            if (value === option.value) {
              checkbox.find("input").prop("checked", true);
            }
          });

          input.append(checkbox);
        });
        break;
    }

    // @TODO provide an attributes option instead
    // and simply map that as keys: vals
    if (options.placeholder) {
      input.attr("placeholder", options.placeholder);
    }

    if (options.pattern) {
      input.attr("pattern", options.pattern);
    }

    if (options.maxlength) {
      input.attr("maxlength", options.maxlength);
    }

    // now place it in our form
    form.append(input);

    form.on("submit", function(e) {
      e.preventDefault();
      // Fix for SammyJS (or similar JS routing library) hijacking the form post.
      e.stopPropagation();
      // @TODO can we actually click *the* button object instead?
      // e.g. buttons.confirm.click() or similar
      dialog.find(".btn-primary").click();
    });

    dialog = bootbox.dialog(options);

    // clear the existing handler focusing the submit button...
    dialog.off("shown.bs.modal");

    // ...and replace it with one focusing our input, if possible
    dialog.on("shown.bs.modal", function() {
      // need the closure here since input isn't
      // an object otherwise
      input.focus();
    });

    if (shouldShow === true) {
      dialog.modal("show");
    }

    return dialog;
  };

  bootbox.dialog = function(options) {
    options = sanitize(options);

    var dialog = $(templates.dialog);
    var innerDialog = dialog.find(".modal-dialog");
    var body = dialog.find(".modal-body");
    var buttons = options.buttons;
    var buttonStr = "";
    var callbacks = {
      onEscape: options.onEscape
    };

    if ($.fn.modal === undefined) {
      throw new Error(
        "$.fn.modal is not defined; please double check you have included " +
        "the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ " +
        "for more details."
      );
    }

    each(buttons, function(key, button) {

      // @TODO I don't like this string appending to itself; bit dirty. Needs reworking
      // can we just build up button elements instead? slower but neater. Then button
      // can just become a template too
      buttonStr += "<button data-bb-handler='" + key + "' type='button' class='btn " + button.className + "'>" + button.label + "</button>";
      callbacks[key] = button.callback;
    });

    body.find(".bootbox-body").html(options.message);

    if (options.animate === true) {
      dialog.addClass("fade");
    }

    if (options.className) {
      dialog.addClass(options.className);
    }

    if (options.size === "large") {
      innerDialog.addClass("modal-lg");
    } else if (options.size === "small") {
      innerDialog.addClass("modal-sm");
    }

    if (options.title) {
      body.before(templates.header);
    }

    if (options.closeButton) {
      var closeButton = $(templates.closeButton);

      if (options.title) {
        dialog.find(".modal-header").prepend(closeButton);
      } else {
        closeButton.css("margin-top", "-10px").prependTo(body);
      }
    }

    if (options.title) {
      dialog.find(".modal-title").html(options.title);
    }

    if (buttonStr.length) {
      body.after(templates.footer);
      dialog.find(".modal-footer").html(buttonStr);
    }


    /**
     * Bootstrap event listeners; used handle extra
     * setup & teardown required after the underlying
     * modal has performed certain actions
     */

    dialog.on("hidden.bs.modal", function(e) {
      // ensure we don't accidentally intercept hidden events triggered
      // by children of the current dialog. We shouldn't anymore now BS
      // namespaces its events; but still worth doing
      if (e.target === this) {
        dialog.remove();
      }
    });

    /*
    dialog.on("show.bs.modal", function() {
      // sadly this doesn't work; show is called *just* before
      // the backdrop is added so we'd need a setTimeout hack or
      // otherwise... leaving in as would be nice
      if (options.backdrop) {
        dialog.next(".modal-backdrop").addClass("bootbox-backdrop");
      }
    });
    */

    dialog.on("shown.bs.modal", function() {
      dialog.find(".btn-primary:first").focus();
    });

    /**
     * Bootbox event listeners; experimental and may not last
     * just an attempt to decouple some behaviours from their
     * respective triggers
     */

    if (options.backdrop !== "static") {
      // A boolean true/false according to the Bootstrap docs
      // should show a dialog the user can dismiss by clicking on
      // the background.
      // We always only ever pass static/false to the actual
      // $.modal function because with `true` we can't trap
      // this event (the .modal-backdrop swallows it)
      // However, we still want to sort of respect true
      // and invoke the escape mechanism instead
      dialog.on("click.dismiss.bs.modal", function(e) {
        // @NOTE: the target varies in >= 3.3.x releases since the modal backdrop
        // moved *inside* the outer dialog rather than *alongside* it
        if (dialog.children(".modal-backdrop").length) {
          e.currentTarget = dialog.children(".modal-backdrop").get(0);
        }

        if (e.target !== e.currentTarget) {
          return;
        }

        dialog.trigger("escape.close.bb");
      });
    }

    dialog.on("escape.close.bb", function(e) {
      if (callbacks.onEscape) {
        processCallback(e, dialog, callbacks.onEscape);
      }
    });

    /**
     * Standard jQuery event listeners; used to handle user
     * interaction with our dialog
     */

    dialog.on("click", ".modal-footer button", function(e) {
      var callbackKey = $(this).data("bb-handler");

      processCallback(e, dialog, callbacks[callbackKey]);
    });

    dialog.on("click", ".bootbox-close-button", function(e) {
      // onEscape might be falsy but that's fine; the fact is
      // if the user has managed to click the close button we
      // have to close the dialog, callback or not
      processCallback(e, dialog, callbacks.onEscape);
    });

    dialog.on("keyup", function(e) {
      if (e.which === 27) {
        dialog.trigger("escape.close.bb");
      }
    });

    // the remainder of this method simply deals with adding our
    // dialogent to the DOM, augmenting it with Bootstrap's modal
    // functionality and then giving the resulting object back
    // to our caller

    $(options.container).append(dialog);

    dialog.modal({
      backdrop: options.backdrop ? "static": false,
      keyboard: false,
      show: false
    });

    if (options.show) {
      dialog.modal("show");
    }

    // @TODO should we return the raw element here or should
    // we wrap it in an object on which we can expose some neater
    // methods, e.g. var d = bootbox.alert(); d.hide(); instead
    // of d.modal("hide");

   /*
    function BBDialog(elem) {
      this.elem = elem;
    }

    BBDialog.prototype = {
      hide: function() {
        return this.elem.modal("hide");
      },
      show: function() {
        return this.elem.modal("show");
      }
    };
    */

    return dialog;

  };

  bootbox.setDefaults = function() {
    var values = {};

    if (arguments.length === 2) {
      // allow passing of single key/value...
      values[arguments[0]] = arguments[1];
    } else {
      // ... and as an object too
      values = arguments[0];
    }

    langx.extend(defaults, values);
  };

  bootbox.hideAll = function() {
    $(".bootbox").modal("hide");

    return bootbox;
  };


  /**
   * standard locales. Please add more according to ISO 639-1 standard. Multiple language variants are
   * unlikely to be required. If this gets too large it can be split out into separate JS files.
   */
  var locales = {
    bg_BG : {
      OK      : "Ок",
      CANCEL  : "Отказ",
      CONFIRM : "Потвърждавам"
    },
    br : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Sim"
    },
    cs : {
      OK      : "OK",
      CANCEL  : "Zrušit",
      CONFIRM : "Potvrdit"
    },
    da : {
      OK      : "OK",
      CANCEL  : "Annuller",
      CONFIRM : "Accepter"
    },
    de : {
      OK      : "OK",
      CANCEL  : "Abbrechen",
      CONFIRM : "Akzeptieren"
    },
    el : {
      OK      : "Εντάξει",
      CANCEL  : "Ακύρωση",
      CONFIRM : "Επιβεβαίωση"
    },
    en : {
      OK      : "OK",
      CANCEL  : "Cancel",
      CONFIRM : "OK"
    },
    es : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Aceptar"
    },
    et : {
      OK      : "OK",
      CANCEL  : "Katkesta",
      CONFIRM : "OK"
    },
    fa : {
      OK      : "قبول",
      CANCEL  : "لغو",
      CONFIRM : "تایید"
    },
    fi : {
      OK      : "OK",
      CANCEL  : "Peruuta",
      CONFIRM : "OK"
    },
    fr : {
      OK      : "OK",
      CANCEL  : "Annuler",
      CONFIRM : "D'accord"
    },
    he : {
      OK      : "אישור",
      CANCEL  : "ביטול",
      CONFIRM : "אישור"
    },
    hu : {
      OK      : "OK",
      CANCEL  : "Mégsem",
      CONFIRM : "Megerősít"
    },
    hr : {
      OK      : "OK",
      CANCEL  : "Odustani",
      CONFIRM : "Potvrdi"
    },
    id : {
      OK      : "OK",
      CANCEL  : "Batal",
      CONFIRM : "OK"
    },
    it : {
      OK      : "OK",
      CANCEL  : "Annulla",
      CONFIRM : "Conferma"
    },
    ja : {
      OK      : "OK",
      CANCEL  : "キャンセル",
      CONFIRM : "確認"
    },
    lt : {
      OK      : "Gerai",
      CANCEL  : "Atšaukti",
      CONFIRM : "Patvirtinti"
    },
    lv : {
      OK      : "Labi",
      CANCEL  : "Atcelt",
      CONFIRM : "Apstiprināt"
    },
    nl : {
      OK      : "OK",
      CANCEL  : "Annuleren",
      CONFIRM : "Accepteren"
    },
    no : {
      OK      : "OK",
      CANCEL  : "Avbryt",
      CONFIRM : "OK"
    },
    pl : {
      OK      : "OK",
      CANCEL  : "Anuluj",
      CONFIRM : "Potwierdź"
    },
    pt : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Confirmar"
    },
    ru : {
      OK      : "OK",
      CANCEL  : "Отмена",
      CONFIRM : "Применить"
    },
    sq : {
      OK : "OK",
      CANCEL : "Anulo",
      CONFIRM : "Prano"
    },
    sv : {
      OK      : "OK",
      CANCEL  : "Avbryt",
      CONFIRM : "OK"
    },
    th : {
      OK      : "ตกลง",
      CANCEL  : "ยกเลิก",
      CONFIRM : "ยืนยัน"
    },
    tr : {
      OK      : "Tamam",
      CANCEL  : "İptal",
      CONFIRM : "Onayla"
    },
    zh_CN : {
      OK      : "OK",
      CANCEL  : "取消",
      CONFIRM : "确认"
    },
    zh_TW : {
      OK      : "OK",
      CANCEL  : "取消",
      CONFIRM : "確認"
    }
  };

  bootbox.addLocale = function(name, values) {
    langx.each(["OK", "CANCEL", "CONFIRM"], function(_, v) {
      if (!values[v]) {
        throw new Error("Please supply a translation for '" + v + "'");
      }
    });

    locales[name] = {
      OK: values.OK,
      CANCEL: values.CANCEL,
      CONFIRM: values.CONFIRM
    };

    return bootbox;
  };

  bootbox.removeLocale = function(name) {
    delete locales[name];

    return bootbox;
  };

  bootbox.setLocale = function(name) {
    return bootbox.setDefaults("locale", name);
  };

  bootbox.init = function(_$) {
    return init(_$ || $);
  };

  return skylark.attach("itg.bootbox",bootbox);

});

define('skylark-bootbox4/main',[
	"./bootbox"
],function(bootbox){
	return bootbox;
});
define('skylark-bootbox4', ['skylark-bootbox4/main'], function (main) { return main; });

define('skylark-visibility/fallback',[],function(){
    if ( document.visibilityState || document.webkitVisibilityState ) {
        return;
    }

    document.hidden = false;
    document.visibilityState = 'visible';

    var event = null
    var i = 0
    var fireEvent = function () {
        if( document.createEvent ) {
            if ( !event ) {
                event = document.createEvent('HTMLEvents');
                event.initEvent('visibilitychange', true, true);
            }
            document.dispatchEvent(event);
        } else {
            if ( typeof(Visibility) == 'object' ) {
                Visibility._change.call(Visibility, { });
            }
        }
    }

    var onFocus = function () {
        document.hidden = false;
        document.visibilityState = 'visible';
        fireEvent();
    };
    var onBlur  = function () {
        document.hidden = true;
        document.visibilityState = 'hidden';
        fireEvent();
    }

    if ( document.addEventListener ) {
        window.addEventListener('focus', onFocus, true);
        window.addEventListener('blur',  onBlur,  true);
    } else {
        document.attachEvent('onfocusin',  onFocus);
        document.attachEvent('onfocusout', onBlur);
    }
});

define('skylark-visibility/core',[
    "./fallback"
],function(){
    if (window.Visibility) {
        return window.Visibility;
    }
    var lastId = -1;

    // Visibility.js allow you to know, that your web page is in the background
    // tab and thus not visible to the user. This library is wrap under
    // Page Visibility API. It fix problems with different vendor prefixes and
    // add high-level useful functions.
    var self = {

        // Call callback only when page become to visible for user or
        // call it now if page is visible now or Page Visibility API
        // doesn’t supported.
        //
        // Return false if API isn’t supported, true if page is already visible
        // or listener ID (you can use it in `unbind` method) if page isn’t
        // visible now.
        //
        //   Visibility.onVisible(function () {
        //       startIntroAnimation();
        //   });
        onVisible: function (callback) {
            var support = self.isSupported();
            if ( !support || !self.hidden() ) {
                callback();
                return support;
            }

            var listener = self.change(function (e, state) {
                if ( !self.hidden() ) {
                    self.unbind(listener);
                    callback();
                }
            });
            return listener;
        },

        // Call callback when visibility will be changed. First argument for
        // callback will be original event object, second will be visibility
        // state name.
        //
        // Return listener ID to unbind listener by `unbind` method.
        //
        // If Page Visibility API doesn’t supported method will be return false
        // and callback never will be called.
        //
        //   Visibility.change(function(e, state) {
        //       Statistics.visibilityChange(state);
        //   });
        //
        // It is just proxy to `visibilitychange` event, but use vendor prefix.
        change: function (callback) {
            if ( !self.isSupported() ) {
                return false;
            }
            lastId += 1;
            var number = lastId;
            self._callbacks[number] = callback;
            self._listen();
            return number;
        },

        // Remove `change` listener by it ID.
        //
        //   var id = Visibility.change(function(e, state) {
        //       firstChangeCallback();
        //       Visibility.unbind(id);
        //   });
        unbind: function (id) {
            delete self._callbacks[id];
        },

        // Call `callback` in any state, expect “prerender”. If current state
        // is “prerender” it will wait until state will be changed.
        // If Page Visibility API doesn’t supported, it will call `callback`
        // immediately.
        //
        // Return false if API isn’t supported, true if page is already after
        // prerendering or listener ID (you can use it in `unbind` method)
        // if page is prerended now.
        //
        //   Visibility.afterPrerendering(function () {
        //       Statistics.countVisitor();
        //   });
        afterPrerendering: function (callback) {
            var support   = self.isSupported();
            var prerender = 'prerender';

            if ( !support || prerender != self.state() ) {
                callback();
                return support;
            }

            var listener = self.change(function (e, state) {
                if ( prerender != state ) {
                    self.unbind(listener);
                    callback();
                }
            });
            return listener;
        },

        // Return true if page now isn’t visible to user.
        //
        //   if ( !Visibility.hidden() ) {
        //       VideoPlayer.play();
        //   }
        //
        // It is just proxy to `document.hidden`, but use vendor prefix.
        hidden: function () {
            return !!(self._doc.hidden || self._doc.webkitHidden);
        },

        // Return visibility state: 'visible', 'hidden' or 'prerender'.
        //
        //   if ( 'prerender' == Visibility.state() ) {
        //       Statistics.pageIsPrerendering();
        //   }
        //
        // Don’t use `Visibility.state()` to detect, is page visible, because
        // visibility states can extend in next API versions.
        // Use more simpler and general `Visibility.hidden()` for this cases.
        //
        // It is just proxy to `document.visibilityState`, but use
        // vendor prefix.
        state: function () {
            return self._doc.visibilityState       ||
                   self._doc.webkitVisibilityState ||
                   'visible';
        },

        // Return true if browser support Page Visibility API.
        // refs: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
        //
        //   if ( Visibility.isSupported() ) {
        //       Statistics.startTrackingVisibility();
        //       Visibility.change(function(e, state)) {
        //           Statistics.trackVisibility(state);
        //       });
        //   }
        isSupported: function () {
            return self._doc.hidden !== undefined || self._doc.webkitHidden !== undefined;
        },

        // Link to document object to change it in tests.
        _doc: document || {},

        // Callbacks from `change` method, that wait visibility changes.
        _callbacks: { },

        // Listener for `visibilitychange` event.
        _change: function(event) {
            var state = self.state();

            for ( var i in self._callbacks ) {
                self._callbacks[i].call(self._doc, event, state);
            }
        },

        // Set listener for `visibilitychange` event.
        _listen: function () {
            if ( self._init ) {
                return;
            }

            var event = 'visibilitychange';
            if ( self._doc.webkitVisibilityState ) {
                event = 'webkit' + event;
            }

            var listener = function () {
                self._change.apply(self, arguments);
            };
            if ( self._doc.addEventListener ) {
                self._doc.addEventListener(event, listener);
            } else {
                self._doc.attachEvent(event, listener);
            }
            self._init = true;
        }

    };


    return window.Visibility = self;

});

define('skylark-visibility/visibility',[
    "./core"
],function(core){
    var lastTimer = -1;

    var install = function (Visibility) {

        // Run callback every `interval` milliseconds if page is visible and
        // every `hiddenInterval` milliseconds if page is hidden.
        //
        //   Visibility.every(60 * 1000, 5 * 60 * 1000, function () {
        //       checkNewMails();
        //   });
        //
        // You can skip `hiddenInterval` and callback will be called only if
        // page is visible.
        //
        //   Visibility.every(1000, function () {
        //       updateCountdown();
        //   });
        //
        // It is analog of `setInterval(callback, interval)` but use visibility
        // state.
        //
        // It return timer ID, that you can use in `Visibility.stop(id)` to stop
        // timer (`clearInterval` analog).
        // Warning: timer ID is different from interval ID from `setInterval`,
        // so don’t use it in `clearInterval`.
        //
        // On change state from hidden to visible timers will be execute.
        Visibility.every = function (interval, hiddenInterval, callback) {
            Visibility._time();

            if ( !callback ) {
                callback = hiddenInterval;
                hiddenInterval = null;
            }

            lastTimer += 1;
            var number = lastTimer;

            Visibility._timers[number] = {
                visible:  interval,
                hidden:   hiddenInterval,
                callback: callback
            };
            Visibility._run(number, false);

            if ( Visibility.isSupported() ) {
                Visibility._listen();
            }
            return number;
        };

        // Stop timer from `every` method by it ID (`every` method return it).
        //
        //   slideshow = Visibility.every(5 * 1000, function () {
        //       changeSlide();
        //   });
        //   $('.stopSlideshow').click(function () {
        //       Visibility.stop(slideshow);
        //   });
        Visibility.stop = function(id) {
            if ( !Visibility._timers[id] ) {
                return false;
            }
            Visibility._stop(id);
            delete Visibility._timers[id];
            return true;
        };

        // Callbacks and intervals added by `every` method.
        Visibility._timers = { };

        // Initialize variables on page loading.
        Visibility._time = function () {
            if ( Visibility._timed ) {
                return;
            }
            Visibility._timed     = true;
            Visibility._wasHidden = Visibility.hidden();

            Visibility.change(function () {
                Visibility._stopRun();
                Visibility._wasHidden = Visibility.hidden();
            });
        };

        // Try to run timer from every method by it’s ID. It will be use
        // `interval` or `hiddenInterval` depending on visibility state.
        // If page is hidden and `hiddenInterval` is null,
        // it will not run timer.
        //
        // Argument `runNow` say, that timers must be execute now too.
        Visibility._run = function (id, runNow) {
            var interval,
                timer = Visibility._timers[id];

            if ( Visibility.hidden() ) {
                if ( null === timer.hidden ) {
                    return;
                }
                interval = timer.hidden;
            } else {
                interval = timer.visible;
            }

            var runner = function () {
                timer.last = new Date();
                timer.callback.call(window);
            }

            if ( runNow ) {
                var now  = new Date();
                var last = now - timer.last ;

                if ( interval > last ) {
                    timer.delay = setTimeout(function () {
                        timer.id = setInterval(runner, interval);
                        runner();
                    }, interval - last);
                } else {
                    timer.id = setInterval(runner, interval);
                    runner();
                }

            } else {
              timer.id = setInterval(runner, interval);
            }
        };

        // Stop timer from `every` method by it’s ID.
        Visibility._stop = function (id) {
            var timer = Visibility._timers[id];
            clearInterval(timer.id);
            clearTimeout(timer.delay);
            delete timer.id;
            delete timer.delay;
        };

        // Listener for `visibilitychange` event.
        Visibility._stopRun = function (event) {
            var isHidden  = Visibility.hidden(),
                wasHidden = Visibility._wasHidden;

            if ( (isHidden && !wasHidden) || (!isHidden && wasHidden) ) {
                for ( var i in Visibility._timers ) {
                    Visibility._stop(i);
                    Visibility._run(i, !isHidden);
                }
            }
        };

        return Visibility;
    }


    return   install(core);
    
});

define('skylark-visibility/main',[
	"./visibility"
],function(visibility){
	return visibility;
});
define('skylark-visibility', ['skylark-visibility/main'], function (main) { return main; });

define('skylark-tinycon/tinycon',[
  "skylark-langx/skylark"
],function(skylark) {
  var Tinycon = {};
  var currentFavicon = null;
  var originalFavicon = null;
  var faviconImage = null;
  var canvas = null;
  var options = {};
  var r = window.devicePixelRatio || 1;
  var size = 16 * r;
  var defaults = {
    width: 7,
    height: 9,
    font: 10 * r + 'px arial',
    color: '#ffffff',
    background: '#F03D25',
    fallback: true,
    crossOrigin: true,
    abbreviate: true
  };

  var ua = (function () {
    var agent = navigator.userAgent.toLowerCase();
    // New function has access to 'agent' via closure
    return function (browser) {
      return agent.indexOf(browser) !== -1;
    };
  }());

  var browser = {
    ie: ua('trident'),
    chrome: ua('chrome'),
    webkit: ua('chrome') || ua('safari'),
    safari: ua('safari') && !ua('chrome'),
    mozilla: ua('mozilla') && !ua('chrome') && !ua('safari')
  };

  // private methods
  var getFaviconTag = function(){

    var links = document.getElementsByTagName('link');

    for(var i=0, len=links.length; i < len; i++) {
      if ((links[i].getAttribute('rel') || '').match(/\bicon\b/i)) {
        return links[i];
      }
    }

    return false;
  };

  var removeFaviconTag = function(){

    var links = document.getElementsByTagName('link');
    var head = document.getElementsByTagName('head')[0];

    for(var i=0, len=links.length; i < len; i++) {
      var exists = (typeof(links[i]) !== 'undefined');
      if (exists && (links[i].getAttribute('rel') || '').match(/\bicon\b/i)) {
        head.removeChild(links[i]);
      }
    }
  };

  var getCurrentFavicon = function(){

    if (!originalFavicon || !currentFavicon) {
      var tag = getFaviconTag();
      currentFavicon = tag ? tag.getAttribute('href') : '/favicon.ico';
      if (!originalFavicon) {
        originalFavicon = currentFavicon;
      }
    }

    return currentFavicon;
  };

  var getCanvas = function (){

    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
    }

    return canvas;
  };

  var setFaviconTag = function(url){
    if(url){
      removeFaviconTag();

      var link = document.createElement('link');
      link.type = 'image/x-icon';
      link.rel = 'icon';
      link.href = url;
      document.getElementsByTagName('head')[0].appendChild(link);
    }
  };

  var log = function(message){
    if (window.console) window.console.log(message);
  };

  var drawFavicon = function(label, color) {

    // fallback to updating the browser title if unsupported
    if (!getCanvas().getContext || browser.ie || browser.safari || options.fallback === 'force') {
      return updateTitle(label);
    }

    var context = getCanvas().getContext("2d");
    var color = color || '#000000';
    var src = getCurrentFavicon();

    faviconImage = document.createElement('img');
    faviconImage.onload = function() {

      // clear canvas
      context.clearRect(0, 0, size, size);

      // draw the favicon
      context.drawImage(faviconImage, 0, 0, faviconImage.width, faviconImage.height, 0, 0, size, size);

      // draw bubble over the top
      if ((label + '').length > 0) drawBubble(context, label, color);

      // refresh tag in page
      refreshFavicon();
    };

    // allow cross origin resource requests if the image is not a data:uri
    // as detailed here: https://github.com/mrdoob/three.js/issues/1305
    if (!src.match(/^data/) && options.crossOrigin) {
      faviconImage.crossOrigin = 'anonymous';
    }

    faviconImage.src = src;
  };

  var updateTitle = function(label) {

    if (options.fallback) {
      // Grab the current title that we can prefix with the label
      var originalTitle = document.title;

      // Strip out the old label if there is one
      if (originalTitle[0] === '(') {
        originalTitle = originalTitle.slice(originalTitle.indexOf(' '));
      }

      if ((label + '').length > 0) {
        document.title = '(' + label + ') ' + originalTitle;
      } else {
        document.title = originalTitle;
      }
    }
  };

  var drawBubble = function(context, label, color) {

    // automatic abbreviation for long (>2 digits) numbers
    if (typeof label == 'number' && label > 99 && options.abbreviate) {
      label = abbreviateNumber(label);
    }

    // bubble needs to be larger for double digits
    var len = (label + '').length-1;

    var width = options.width * r + (6 * r * len),
      height = options.height * r;

    var top = size - height,
            left = size - width - r,
            bottom = 16 * r,
            right = 16 * r,
            radius = 2 * r;

    // webkit seems to render fonts lighter than firefox
    context.font = (browser.webkit ? 'bold ' : '') + options.font;
    context.fillStyle = options.background;
    context.strokeStyle = options.background;
    context.lineWidth = r;

    // bubble
    context.beginPath();
        context.moveTo(left + radius, top);
    context.quadraticCurveTo(left, top, left, top + radius);
    context.lineTo(left, bottom - radius);
        context.quadraticCurveTo(left, bottom, left + radius, bottom);
        context.lineTo(right - radius, bottom);
        context.quadraticCurveTo(right, bottom, right, bottom - radius);
        context.lineTo(right, top + radius);
        context.quadraticCurveTo(right, top, right - radius, top);
        context.closePath();
        context.fill();

    // bottom shadow
    context.beginPath();
    context.strokeStyle = "rgba(0,0,0,0.3)";
    context.moveTo(left + radius / 2.0, bottom);
    context.lineTo(right - radius / 2.0, bottom);
    context.stroke();

    // label
    context.fillStyle = options.color;
    context.textAlign = "right";
    context.textBaseline = "top";

    // unfortunately webkit/mozilla are a pixel different in text positioning
    context.fillText(label, r === 2 ? 29 : 15, browser.mozilla ? 7*r : 6*r);
  };

  var refreshFavicon = function(){
    // check support
    if (!getCanvas().getContext) return;

    setFaviconTag(getCanvas().toDataURL());
  };

  var abbreviateNumber = function(label) {
    var metricPrefixes = [
      ['G', 1000000000],
      ['M',    1000000],
      ['k',       1000]
    ];

    for(var i = 0; i < metricPrefixes.length; ++i) {
      if (label >= metricPrefixes[i][1]) {
        label = round(label / metricPrefixes[i][1]) + metricPrefixes[i][0];
        break;
      }
    }

    return label;
  };

  var round = function (value, precision) {
    var number = new Number(value);
    return number.toFixed(precision);
  };

  // public methods
  Tinycon.setOptions = function(custom){
    options = {};

    // account for deprecated UK English spelling
    if (custom.colour) {
      custom.color = custom.colour;
    }

    for(var key in defaults){
      options[key] = custom.hasOwnProperty(key) ? custom[key] : defaults[key];
    }
    return this;
  };

  Tinycon.setImage = function(url){
    currentFavicon = url;
    refreshFavicon();
    return this;
  };

  Tinycon.setBubble = function(label, color) {
    label = label || '';
    drawFavicon(label, color);
    return this;
  };

  Tinycon.reset = function(){
    currentFavicon = originalFavicon;
    setFaviconTag(originalFavicon);
  };

  Tinycon.setOptions(defaults);

  return skylark.attach("itg.tinycon",Tinycon);
});

define('skylark-tinycon/main',[
	"./tinycon"
],function(tinycon){
	return tinycon;
});
define('skylark-tinycon', ['skylark-tinycon/main'], function (main) { return main; });

define('skylark-widgets-shells/Shell',[
	"skylark-langx/langx",
	"skylark-domx-css",
	"skylark-domx-scripter",
	"skylark-domx-finder",
	"skylark-domx-query",
	"skylark-widgets-swt/Widget",
	"skylark-nprogress",
	"skylark-bootbox4",
    "skylark-visibility",
  "skylark-tinycon",
	"./shells"
],function(langx, css, scripter, finder,$,Widget,nprogress,bootbox,Visibility, Tinycon,shells){
	function createAlert(params,template) {
	    params.parseTemplate('alert', params, function (alertTpl) {
	      params.translate(alertTpl, function (translatedHTML) {				
	        var alert = $('#' + params.alert_id);
					if (alert.length) {
						return updateAlert(alert, params);
					}
					alert = $(translatedHTML);
					alert.fadeIn(200);

					
					params.container.prepend(alert);
					//components.get('toaster/tray').prepend(alert);

					if (typeof params.closefn === 'function') {
						alert.find('button').on('click', function () {
							params.closefn();
							fadeOut(alert);
							return false;
						});
					}

					if (params.timeout) {
						startTimeout(alert, params.timeout);
					}

					if (typeof params.clickfn === 'function') {
						alert
							.addClass('pointer')
							.on('click', function (e) {
								if (!$(e.target).is('.close')) {
									params.clickfn();
								}
								fadeOut(alert);
							});
					}

			  });
	   });

		//Benchpress.parse('alert', params, function (alertTpl) {
		//	translator.translate(alertTpl, function (translatedHTML) {
		//		...
		//	});
		//});
	}

	function updateAlert(alert, params) {
		alert.find('strong').html(params.title);
		alert.find('p').html(params.message);
		alert.attr('class', 'alert alert-dismissable alert-' + params.type + ' clearfix');

		clearTimeout(parseInt(alert.attr('timeoutId'), 10));
		if (params.timeout) {
			startTimeout(alert, params.timeout);
		}

		alert.children().fadeOut(100);
		//translator.translate(alert.html(), function (translatedHTML) {
		params.translate(alert.html(), function (translatedHTML) {
			alert.children().fadeIn(100);
			alert.html(translatedHTML);
		});

		// Handle changes in the clickfn
		alert.off('click').removeClass('pointer');
		if (typeof params.clickfn === 'function') {
			alert
				.addClass('pointer')
				.on('click', function (e) {
					if (!$(e.target).is('.close')) {
						params.clickfn();
					}
					fadeOut(alert);
				});
		}
	}

	function fadeOut(alert) {
		alert.fadeOut(500, function () {
			$(this).remove();
		});
	}

	function startTimeout(alert, timeout) {
		var timeoutId = setTimeout(function () {
			fadeOut(alert);
		}, timeout);

		alert.attr('timeoutId', timeoutId);

		// Reset and start animation
		alert.css('transition-property', 'none');
		alert.removeClass('animate');

		setTimeout(function () {
			alert.css('transition-property', '');
			alert.css('transition', 'width ' + (timeout + 450) + 'ms linear, background-color ' + (timeout + 450) + 'ms ease-in');
			alert.addClass('animate');
		}, 50);

		// Handle mouseenter/mouseleave
		alert
			.on('mouseenter', function () {
				$(this).css('transition-duration', 0);
			});
	}




	var Shell = Widget.inherit({
		options : {
	        i18n : {
	            locale : "en",
	            translate : function(txt) {
	              return langx.Deferred.resolve(txt);
	            }
	        },
			alerts : {
				container : "",     // element,$elment or selector,
				titles : {
					success : '[[global:alert.success]]',
					error :  '[[global:alert.error]]'
				},
			},
			templator  : {
				parse  : null,    // template function
			},
			skins : {

			}
		},

		_construct : function(options) {
			this.overrided(document.body,options);

	      	this._titleObj = {
	        	active: false,
	        	interval: undefined,
	        	titles: [],
	      	};

	     	var self = this;

	     	self.isFocused = true;

	      	Visibility.change(function (event, state) {
	        	if (state === 'visible') {
	          		self.isFocused = true;
	         		self.alternatingTitle('');
	        	} else if (state === 'hidden') {
	          		self.isFocused = false;
	        	}
      		});      
		},

		progress : function() {
			return nprogress;
		},

		alert : function (params) {
			params.alert_id = 'alert_button_' + (params.alert_id ? params.alert_id : new Date().getTime());
			params.title = params.title ? params.title.trim() || '' : '';
			params.message = params.message ? params.message.trim() : '';
			params.type = params.type || 'info';


			var alert = $('#' + params.alert_id);

      		params.translate = params.translate || this.option("i18n.translate");
			if (alert.length) {
				updateAlert(alert, params);
			} else {
        		params.parseTemplate = params.parseTemplate || this.option("templator.parse");
        		params.container  = params.container || this.option("alerts.container");
				createAlert(params);
			}
		},

		removeAlert : function (id) {
			$('#alert_button_' + id).remove();
		},

		alertSuccess : function (message, timeout) {
			this.alert({
				title: this.option("alerts.titles.success"),
				message: message,
				type: 'success',
				timeout: timeout || 5000,
			});
		},

		alertError : function (message, timeout) {
			message = message.message || message;

			this.alert({
				title: this.option("alerts.titles.error"),
				message: message,
				type: 'danger',
				timeout: timeout || 10000,
			});
		},

    	alternatingTitle : function (title) {
      		if (typeof title !== 'string') {
        		return;
      		}

	      var titleObj = this._titleObj;

	      if (title.length > 0 && !app.isFocused) {
	        if (!titleObj.titles[0]) {
	          titleObj.titles[0] = window.document.title;
	        }

	        var translate = this.option("i18n.translate");
	        translate(title, function (translated) {
	            titleObj.titles[1] = translated;
	            if (titleObj.interval) {
	              clearInterval(titleObj.interval);
	            }

	            titleObj.interval = setInterval(function () {
	              var title = titleObj.titles[titleObj.titles.indexOf(window.document.title) ^ 1];
	              if (title) {
	                window.document.title = $('<div/>').html(title).text();
	              }
	            }, 2000);
	        });
	        
	      } else {
	        if (titleObj.interval) {
	          clearInterval(titleObj.interval);
	        }
	        if (titleObj.titles[0]) {
	          window.document.title = $('<div/>').html(titleObj.titles[0]).text();
	        }
	      }
	    },

	    refreshTitle : function (title) {
	        var self = this,
	            translate = this.option("i18n.translate"),
	            titleObj = this._titleObj;

	        translate(title, function (translated) {
	          titleObj.titles[0] = translated;
	          self.alternatingTitle('');
	        });
	    },


	    /*
	     * Manipulatethe favicon, in particular adding alert bubbles and changing images. 
	     */
	    tinycon : function(bubble,options) {

	    	if (langx.isUndefined(options)){
	    		if (langx.isPlainObject(bubble))	{
	    			options = bubble;
	    			bubble = undefined;
	    		}
	    	} 

	    	if (langx.isDefined(options)) {
	    		Tinycon.setOptions(options)
	    	}
	    	if (langx.isDefined(bubble)) {
	    		Tinycon.setBubble(bubble);
	    	}

	    },


		reskin : function (skinName,cssUrl,clientEl) {

			if (!clientEl) {
				clientEl = document.getElementById("skinSheet");
				if (!clientEl) {
					return;
				}
			}

			var currentSkinClassName = $('body').attr('class').split(/\s+/).filter(function (className) {
				return className.startsWith('skin-');
			});
			var currentSkin = currentSkinClassName[0].slice(5);
			currentSkin = currentSkin !== 'noskin' ? currentSkin : '';

			// Stop execution if skin didn't change
			if (skinName === currentSkin) {
				return;
			}

			var linkEl = document.createElement('link');
			linkEl.rel = 'stylesheet';
			linkEl.type = 'text/css';
			linkEl.href = cssUrl;
			linkEl.onload = function () {
				clientEl.parentNode.removeChild(clientEl);

				// Update body class with proper skin name
				$('body').removeClass(currentSkinClassName.join(' '));
				$('body').addClass('skin-' + (skinName || 'noskin'));
			};

			document.head.appendChild(linkEl);
		},


		loadStyleSheet : function(url,options,loadedCallback, errorCallback) {
			return css.loadStyleSheet(url,options,loadedCallback, errorCallback);

		},

		removeStyleSheet : function(id) {
			return css.removeStyleSheet(id);

		},

		loadScript : function(url, loadedCallback, errorCallback) {
			return scripter.loadJavaScript(url,loadedCallback,errorCallback);
		},

		removeScript : function(id) {
			return scripter.deleteJavaScript(id);
		}


	});


	return shells.Shell = Shell;

});

define('skylark-bootstrap3/bs3',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query"
],function(skylark,langx,browser,eventer,noder,geom,$){
	var ui = skylark.ui = skylark.ui || {}, 
		bs3 = ui.bs3 = {};

/*---------------------------------------------------------------------------------*/
	/*
	 * Fuel UX utilities.js
	 * https://github.com/ExactTarget/fuelux
	 *
	 * Copyright (c) 2014 ExactTarget
	 * Licensed under the BSD New license.
	 */
	var CONST = {
		BACKSPACE_KEYCODE: 8,
		COMMA_KEYCODE: 188, // `,` & `<`
		DELETE_KEYCODE: 46,
		DOWN_ARROW_KEYCODE: 40,
		ENTER_KEYCODE: 13,
		TAB_KEYCODE: 9,
		UP_ARROW_KEYCODE: 38
	};

	var isShiftHeld = function isShiftHeld (e) { return e.shiftKey === true; };

	var isKey = function isKey (keyCode) {
		return function compareKeycodes (e) {
			return e.keyCode === keyCode;
		};
	};

	var isBackspaceKey = isKey(CONST.BACKSPACE_KEYCODE);
	var isDeleteKey = isKey(CONST.DELETE_KEYCODE);
	var isTabKey = isKey(CONST.TAB_KEYCODE);
	var isUpArrow = isKey(CONST.UP_ARROW_KEYCODE);
	var isDownArrow = isKey(CONST.DOWN_ARROW_KEYCODE);

	var ENCODED_REGEX = /&[^\s]*;/;
	/*
	 * to prevent double encoding decodes content in loop until content is encoding free
	 */
	var cleanInput = function cleanInput (questionableMarkup) {
		// check for encoding and decode
		while (ENCODED_REGEX.test(questionableMarkup)) {
			questionableMarkup = $('<i>').html(questionableMarkup).text();
		}

		// string completely decoded now encode it
		return $('<i>').text(questionableMarkup).html();
	};




	langx.mixin(bs3, {
		CONST: CONST,
		cleanInput: cleanInput,
		isBackspaceKey: isBackspaceKey,
		isDeleteKey: isDeleteKey,
		isShiftHeld: isShiftHeld,
		isTabKey: isTabKey,
		isUpArrow: isUpArrow,
		isDownArrow: isDownArrow
	});

	return bs3;
});

define('skylark-bootstrap3/affix',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){


/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = bs3.Affix = plugins.Plugin.inherit({
        klassName: "Affix",

        pluginName : "bs3.affix",

        _construct : function(element,options) {
          this.options = langx.mixin({}, Affix.DEFAULTS, options)

          this.$target = $(this.options.target)
            .on('scroll.bs.affix.data-api', langx.proxy(this.checkPosition, this))
            .on('click.bs.affix.data-api',  langx.proxy(this.checkPositionWithEventLoop, this))

          this.$element     = $(element)
          this.affixed      = null;
          this.unpin        = null;
          this.pinnedOffset = null;

          this.checkPosition();
        },

        getState : function (scrollHeight, height, offsetTop, offsetBottom) {
          var scrollTop    = this.$target.scrollTop()
          var position     = this.$element.offset()
          var targetHeight = this.$target.height()

          if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

          if (this.affixed == 'bottom') {
            if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
            return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
          }

          var initializing   = this.affixed == null
          var colliderTop    = initializing ? scrollTop : position.top
          var colliderHeight = initializing ? targetHeight : height

          if (offsetTop != null && scrollTop <= offsetTop) return 'top'
          if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

          return false
        },

        getPinnedOffset : function () {
          if (this.pinnedOffset) return this.pinnedOffset
          this.$element.removeClass(Affix.RESET).addClass('affix')
          var scrollTop = this.$target.scrollTop()
          var position  = this.$element.offset()
          return (this.pinnedOffset = position.top - scrollTop)
        },

        checkPositionWithEventLoop : function () {
          setTimeout(langx.proxy(this.checkPosition, this), 1)
        },

        checkPosition : function () {
          if (!this.$element.is(':visible')) return

          var height       = this.$element.height()
          var offset       = this.options.offset
          var offsetTop    = offset.top
          var offsetBottom = offset.bottom
          var scrollHeight = Math.max($(document).height(), $(document.body).height())

          if (typeof offset != 'object')         offsetBottom = offsetTop = offset
          if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
          if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

          var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

          if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css('top', '')

            var affixType = 'affix' + (affix ? '-' + affix : '')
            var e         = eventer.create(affixType + '.bs.affix')

            this.$element.trigger(e)

            if (e.isDefaultPrevented()) return

            this.affixed = affix
            this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

            this.$element
              .removeClass(Affix.RESET)
              .addClass(affixType)
              .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
          }

          if (affix == 'bottom') {
            this.$element.offset({
              top: scrollHeight - height - offsetBottom
            })
          }
        }
  });


  Affix.VERSION  = '3.3.7'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }


  /*
  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin;
  $.fn.affix.Constructor = Affix;


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  return $.fn.affix;
  */

  plugins.register(Affix,"affix");

  return Affix;
});

define('skylark-bootstrap3/alert',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]';

  var Alert = bs3.Alert = plugins.Plugin.inherit({
    klassName: "Alert",

    pluginName : "bs3.alert",

    _construct : function(el,options) {
      $(el).on('click', dismiss, this.close)
    },

    close : function (e) {
      var $this    = $(this);
      var selector = $this.attr('data-target');

      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
      }

      var $parent = $(selector === '#' ? [] : selector);

      if (e) e.preventDefault()

      if (!$parent.length) {
        $parent = $this.closest('.alert');
      }

      $parent.trigger(e = eventer.create('close.bs.alert'));

      if (e.isDefaultPrevented()) {
        return
      }
        
      $parent.removeClass('in');

      function removeElement() {
        // detach from parent, fire event then clean up data
        $parent.detach().trigger('closed.bs.alert').remove()
      }

      if (browser.support.transition) {
        if ($parent.hasClass('fade') ) {
          $parent.one('transitionEnd', removeElement)
          .emulateTransitionEnd(Alert.TRANSITION_DURATION);
        } else {
          removeElement();
        }

      } 
    }
  });


  Alert.VERSION = '3.3.7';

  Alert.TRANSITION_DURATION = 150;


  /*
  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var wgt  = $this.data('bs.alert')

      if (!wgt) {
        $this.data('bs.alert', (wgt = new Alert(this)));
      }
      if (typeof option == 'string') {
        wgt[option].call($this);
      }
    })
  }

  var old = $.fn.alert;

  $.fn.alert             = Plugin;
  $.fn.alert.Constructor = Alert;


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  }

  return $.fn.alert;
  */

  plugins.register(Alert,"alert");

  return Alert;

});

define('skylark-bootstrap3/button',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: button.js v3.3.7
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = bs3.Button = plugins.Plugin.inherit({
    klassName: "Button",

    pluginName : "bs3.button",

    _construct : function(element,options) {
      var $el = this.$element  = $(element)
      this.options   = langx.mixin({}, Button.DEFAULTS, options)
      this.isLoading = false

      if ($el.closest('[data-toggle^="button"]')) {
        $el.on("click.bs.button.data-api",langx.proxy(function(e){
          this.toggle()

          if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
            // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
            e.preventDefault()
            // The target component still receive the focus
            var $btn = this.$element; 
            if ($btn.is('input,button')) {
              $btn.trigger('focus');
            } else {
              $btn.find('input:visible,button:visible').first().trigger('focus');
            }
          }
        },this));
      }
    },

    setState : function (state) {
      var d    = 'disabled'
      var $el  = this.$element
      var val  = $el.is('input') ? 'val' : 'html'
      var data = $el.data()

      state += 'Text'

      if (data.resetText == null) $el.data('resetText', $el[val]())

      // push to event loop to allow forms to submit
      setTimeout(langx.proxy(function () {
        $el[val](data[state] == null ? this.options[state] : data[state])

        if (state == 'loadingText') {
          this.isLoading = true
          $el.addClass(d).attr(d, d).prop(d, true)
        } else if (this.isLoading) {
          this.isLoading = false
          $el.removeClass(d).removeAttr(d).prop(d, false)
        }
      }, this), 0)
    },

    toggle : function () {
      var changed = true
      var $parent = this.$element.closest('[data-toggle="buttons"]')

      if ($parent.length) {
        var $input = this.$element.find('input')
        if ($input.prop('type') == 'radio') {
          if ($input.prop('checked')) changed = false
          $parent.find('.active').removeClass('active')
          this.$element.addClass('active')
        } else if ($input.prop('type') == 'checkbox') {
          if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
          this.$element.toggleClass('active')
        }
        $input.prop('checked', this.$element.hasClass('active'))
        if (changed) $input.trigger('change')
      } else {
        this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
        this.$element.toggleClass('active')
      }
    }

  });  

  Button.VERSION  = '3.3.7'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }



  // BUTTON PLUGIN DEFINITION
  // ========================
  /*

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var wgt    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!wgt) {
        $this.data('bs.button', (wgt = new Button(this, options)));
      }

      if (option == 'toggle') {
        wgt.toggle();
      } else if (option) {
        wgt.setState(option);
      }
    });
  }

  var old = $.fn.button;

  $.fn.button             = Plugin;
  $.fn.button.Constructor = Button;


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old;
    return this;
  }


  return $.fn.button;
  */

  plugins.register(Button,"button",function(options){
      //this -> plugin instance
      if (options == 'toggle') {
        this.toggle();
      } else if (options) {
        this.setState(options);
      }    
  });

  return Button;
});

define('skylark-bootstrap3/transition',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,bs3){

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  eventer.special.bsTransitionEnd = eventer.special.transitionEnd;
});

define('skylark-bootstrap3/carousel',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "skylark-domx-plugins",
    "./bs3",
    "./transition"
], function(langx, browser, eventer, noder, geom, $, plugins, bs3) {

    /* ========================================================================
     * Bootstrap: carousel.js v3.3.7
     * http://getbootstrap.com/javascript/#carousel
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    'use strict';

    // CAROUSEL CLASS DEFINITION
    // =========================

    var Carousel = bs3.Carousel = plugins.Plugin.inherit({
        klassName: "Carousel",

        pluginName: "bs3.carousel",

        options : {
            interval: 5000,
            pause: 'hover',
            wrap: true,
            keyboard: true,

            selectors :{
                controls : {
                 // The class for the "toggle" control:
                  toggle: '.toggle',
                  // The class for the "prev" control:
                  prev: '.prev',
                  // The class for the "next" control:
                  next: '.next',
                  // The class for the "close" control:
                  close: '.close',
                  // The class for the "play-pause" toggle control:
                  playPause: '.play-pause'
                },
                indicators : {
                    container : ".carousel-indicators"  
                },
                slides : {
                    container : "",
                    item : ".item" 
                }
            }


        },

        _construct: function(element, options) {
            options = langx.mixin({}, $(element).data(), options);
            //this.options = options
            this.overrided(element,options);

            this.$element = $(element)
            this.$indicators = this.$element.find(this.options.selectors.indicators.container); //'.carousel-indicators'
            this.paused = null
            this.sliding = null
            this.interval = null
            this.$active = null
            this.$items = null

            var self = this;
            if (!this.options.embeded) {
                this.options.keyboard && this.$element.on('keydown.bs.carousel', langx.proxy(this.keydown, this))

                this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
                    .on('mouseenter.bs3.carousel', langx.proxy(this.pause, this))
                    .on('mouseleave.bs3.carousel', langx.proxy(this.cycle, this));

                this.$element.on("click.bs3.carousel.data-api", "[data-slide],[data-slide-to]", function(e) {
                    var $this = $(this),
                        slide = $this.attr('data-slide'),
                        slideIndex = $this.attr('data-slide-to');

                    if (slide == "prev") {
                        self.prev();
                    } else if (slide == "next") {
                        self.next();
                    } else  if (slideIndex) {
                        self.to(slideIndex);
                    }
                    e.preventDefault();
                });
            }
        },

        keydown : function(e) {
            if (/input|textarea/i.test(e.target.tagName)) return
            switch (e.which) {
                case 37:
                    this.prev();
                    break
                case 39:
                    this.next();
                    break
                default:
                    return
            }

            e.preventDefault()
        },

        cycle : function(e) {
            e || (this.paused = false)

            this.interval && clearInterval(this.interval)

            this.options.interval &&
                !this.paused &&
                (this.interval = setInterval(langx.proxy(this.next, this), this.options.interval))

            return this
        },

        getItemIndex : function(item) {
            this.$items = item.parent().children(this.options.selectors.slides.item);//'.item' 
            return this.$items.index(item || this.$active)
        },

        getItemForDirection : function(direction, active) {
            var activeIndex = this.getItemIndex(active)
            var willWrap = (direction == 'prev' && activeIndex === 0) ||
                (direction == 'next' && activeIndex == (this.$items.length - 1))
            if (willWrap && !this.options.wrap) return active
            var delta = direction == 'prev' ? -1 : 1
            var itemIndex = (activeIndex + delta) % this.$items.length
            return this.$items.eq(itemIndex)
        },

        to : function(pos) {
            var that = this
            var activeIndex = this.getItemIndex(this.$active = this.$element.find(this.options.selectors.slides.item+".active"));//'.item.active'

            if (pos > (this.$items.length - 1) || pos < 0) return

            if (this.sliding) return this.$element.one('slid.bs.carousel', function() { that.to(pos) }) // yes, "slid"
            if (activeIndex == pos) return this.pause().cycle()

            return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
        },

        pause : function(e) {
            e || (this.paused = true)

            if (this.$element.find(this.options.selectors.controls.next + ","+ this.options.selectors.controls.prev).length && browser.support.transition) { //.next,.prev
                this.$element.trigger(browser.support.transition.end)
                this.cycle(true)
            }

            this.interval = clearInterval(this.interval)

            return this
        },

        next : function() {
            if (this.sliding) return
            return this.slide('next')
        },

        prev : function() {
            if (this.sliding) return
            return this.slide('prev')
        },

        slide : function(type, next) {
            var $active = this.$element.find(this.options.selectors.slides.item+".active");//'.item.active'
            var $next = next || this.getItemForDirection(type, $active)
            var isCycling = this.interval
            var direction = type == 'next' ? 'left' : 'right'
            var that = this

            if ($next.hasClass('active')) return (this.sliding = false)

            var relatedTarget = $next[0]
            var slideEvent = eventer.create('slide.bs.carousel', {
                relatedTarget: relatedTarget,
                direction: direction
            })
            this.$element.trigger(slideEvent)
            if (slideEvent.isDefaultPrevented()) return

            this.sliding = true

            isCycling && this.pause()

            if (this.$indicators.length) {
                this.$indicators.find('.active').removeClass('active')
                var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
                $nextIndicator && $nextIndicator.addClass('active')
            }

            var slidEvent = eventer.create('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
            if (browser.support.transition && this.$element.hasClass('slide')) {
                $next.addClass(type)
                $next[0].offsetWidth // force reflow
                $active.addClass(direction)
                $next.addClass(direction)
                $active
                    .one('transitionEnd', function() {
                        $next.removeClass([type, direction].join(' ')).addClass('active')
                        $active.removeClass(['active', direction].join(' '))
                        that.sliding = false
                        setTimeout(function() {
                            that.$element.trigger(slidEvent)
                        }, 0)
                    })
                    .emulateTransitionEnd()
            } else {
                $active.removeClass('active')
                $next.addClass('active')
                this.sliding = false
                this.$element.trigger(slidEvent)
            }

            isCycling && this.cycle()

            return this
        },

    });

    // var Carousel = function (element, options) {
    // }

    Carousel.VERSION = '3.3.7'

    Carousel.TRANSITION_DURATION = 600




    // CAROUSEL PLUGIN DEFINITION
    // ==========================
    /*
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var wgt = $this.data('bs.carousel')
            var options = langx.mixin({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
            var action = typeof option == 'string' ? option : options.slide

            if (!wgt) {
                $this.data('bs.carousel', (wgt = new Carousel(this, options)));
            }
            if (typeof option == 'number') {
                wgt.to(option);
            } else if (action) {
                wgt[action]()
            } else if (options.interval) {
                wgt.pause().cycle();
            }
        })
    }
    */
    plugins.register(Carousel,"carousel",function(options){
        //this -> plugin instance
        var action = typeof options == 'string' ? options : options.slide
        if (typeof options == 'number') {
            this.to(options);
        } else if (action) {
            this[action]()
        } else if (options.interval) {
            this.pause().cycle();
        }        
    });

    return Carousel;

});
define('skylark-bootstrap3/collapse',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "skylark-domx-plugins",
    "./bs3",
    "./transition"
], function(langx, browser, eventer, noder, geom, $, plugins, bs3) {


/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = bs3.Collapse = plugins.Plugin.inherit({
    klassName: "Collapse",

    pluginName : "bs3.collapse",

    _construct : function(element,options) {
      options = langx.mixin({}, Collapse.DEFAULTS, $(element).data(), options)
      this.overrided(element,options);

      this.$element      = $(element)
      this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                             '[data-toggle="collapse"][data-target="#' + element.id + '"]')
      this.transitioning = null

      if (this.options.parent) {
        this.$parent = this.getParent()
      } else {
        this.addAriaAndCollapsedClass(this.$element, this.$trigger)
      }

      if (this.options.toggle) {
        this.toggle();
      }
    },

    dimension : function () {
      var hasWidth = this.$element.hasClass('width')
      return hasWidth ? 'width' : 'height'
    },

    show : function () {
      if (this.transitioning || this.$element.hasClass('in')) return

      var activesData
      var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

      if (actives && actives.length) {
        activesData = actives.data('bs.collapse')
        if (activesData && activesData.transitioning) return
      }

      var startEvent = eventer.create('show.bs.collapse')
      this.$element.trigger(startEvent)
      if (startEvent.isDefaultPrevented()) return

      if (actives && actives.length) {
        //Plugin.call(actives, 'hide')
        actives.collapse("hide");
        activesData || actives.data('bs.collapse', null)
      }

      var dimension = this.dimension()

      this.$element
        .removeClass('collapse')
        .addClass('collapsing')[dimension](0)
        .attr('aria-expanded', true)

      this.$trigger
        .removeClass('collapsed')
        .attr('aria-expanded', true)

      this.transitioning = 1

      var complete = function () {
        this.$element
          .removeClass('collapsing')
          .addClass('collapse in')[dimension]('')
        this.transitioning = 0
        this.$element
          .trigger('shown.bs.collapse')
      }

      if (!browser.support.transition) return complete.call(this)

      var scrollSize = langx.camelCase(['scroll', dimension].join('-'))

      this.$element
        .one('transitionEnd', langx.proxy(complete, this))
        .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
    },

    hide : function () {
      if (this.transitioning || !this.$element.hasClass('in')) return

      var startEvent = eventer.create('hide.bs.collapse')
      this.$element.trigger(startEvent)
      if (startEvent.isDefaultPrevented()) return

      var dimension = this.dimension()

      this.$element[dimension](this.$element[dimension]())[0].offsetHeight

      this.$element
        .addClass('collapsing')
        .removeClass('collapse in')
        .attr('aria-expanded', false)

      this.$trigger
        .addClass('collapsed')
        .attr('aria-expanded', false)

      this.transitioning = 1

      var complete = function () {
        this.transitioning = 0
        this.$element
          .removeClass('collapsing')
          .addClass('collapse')
          .trigger('hidden.bs.collapse')
      }

      if (!browser.support.transition) return complete.call(this)

      this.$element
        [dimension](0)
        .one('transitionEnd', langx.proxy(complete, this))
        .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
    },

    toggle : function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']()
    },

    getParent : function () {
      return $(this.options.parent)
        .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
        .each(langx.proxy(function (i, element) {
          var $element = $(element)
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this))
        .end()
    },

    addAriaAndCollapsedClass : function ($element, $trigger) {
      var isOpen = $element.hasClass('in')

      $element.attr('aria-expanded', isOpen)
      $trigger
        .toggleClass('collapsed', !isOpen)
        .attr('aria-expanded', isOpen)
    }

  });

  Collapse.VERSION  = '3.3.7'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }


  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  /*
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = langx.mixin({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin;
  $.fn.collapse.Constructor = Collapse;

  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }
  */

  plugins.register(Collapse,"collapse");

  return Collapse;

});

define('skylark-bootstrap3/dropdown',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop';
  var toggle   = '[data-toggle="dropdown"]';

  var Dropdown = bs3.Dropdown = plugins.Plugin.inherit({
    klassName: "Dropdown",

    pluginName : "bs3.dropdown",

    _construct : function(element,options) {
      var $el = this.$element = $(element);
      $el.on('click.bs.dropdown', this.toggle);
      $el.on('keydown.bs.dropdown', '[data-toggle="dropdown"],.dropdown-menu',this.keydown);
    },

    toggle : function (e) {
      var $this = $(this)

      if ($this.is('.disabled, :disabled')) return

      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open')

      clearMenus()

      if (!isActive) {
        if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
          // if mobile we use a backdrop because click events don't delegate
          $(document.createElement('div'))
            .addClass('dropdown-backdrop')
            .insertAfter($(this))
            .on('click', clearMenus)
        }

        var relatedTarget = { relatedTarget: this }
        $parent.trigger(e = eventer.create('show.bs.dropdown', relatedTarget))

        if (e.isDefaultPrevented()) return

        $this
          .trigger('focus')
          .attr('aria-expanded', 'true')

        $parent
          .toggleClass('open')
          .trigger(eventer.create('shown.bs.dropdown', relatedTarget))
      }

      return false
    },

    keydown : function (e) {
      if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

      var $this = $(this)

      e.preventDefault()
      e.stopPropagation()

      if ($this.is('.disabled, :disabled')) return

      var $parent  = getParent($this)
      var isActive = $parent.hasClass('open')

      if (!isActive && e.which != 27 || isActive && e.which == 27) {
        if (e.which == 27) $parent.find(toggle).trigger('focus')
        return $this.trigger('click')
      }

      var desc = ' li:not(.disabled):visible a'
      var $items = $parent.find('.dropdown-menu' + desc)

      if (!$items.length) return

      var index = $items.index(e.target)

      if (e.which == 38 && index > 0)                 index--         // up
      if (e.which == 40 && index < $items.length - 1) index++         // down
      if (!~index)                                    index = 0

      $items.eq(index).trigger('focus')
    }

  });

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && noder.contains($parent[0], e.target)) return

      $parent.trigger(e = eventer.create('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger(eventer.create('hidden.bs.dropdown', relatedTarget))
    })
  }


  /*
  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin;
  $.fn.dropdown.Constructor = Dropdown;


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }



  return $.fn.dropdown;
  */

  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================
  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() });

  plugins.register(Dropdown,"dropdown");

  return Dropdown;

});

define('skylark-bootstrap3/modal',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = bs3.Modal = plugins.Plugin.inherit({
    klassName: "Modal",

    pluginName : "bs3.modal",

    _construct : function(element,options) {
      options = langx.mixin({}, Modal.DEFAULTS, $(element).data(), options)
      this.overrided(element,options);
      this.$container               = $(options.container || document.body)
      this.$element            = $(element)
      this.$dialog             = this.$element.find('.modal-dialog')
      if (!this.$container.is("body")) {
        this.$element.css("position","absolute");
      }
      //this.$container.append(this.$element);
      this.$backdrop           = null
      this.isShown             = null
      this.originalBodyPad     = null
      this.scrollbarWidth      = 0
      this.ignoreBackdropClick = false

      if (this.options.remote) {
        this.$element
          .find('.modal-content')
          .load(this.options.remote, langx.proxy(function () {
            this.$element.trigger('loaded.bs.modal')
          }, this))
      }
    },

    toggle : function (_relatedTarget) {
      return this.isShown ? this.hide() : this.show(_relatedTarget)
    },

    show : function (_relatedTarget) {
      var that = this
      var e    = eventer.create('show.bs.modal', { relatedTarget: _relatedTarget })

      this.$element.trigger(e)

      if (this.isShown || e.isDefaultPrevented()) return

      this.isShown = true

      this.checkScrollbar()
      this.setScrollbar()
      this.$container.addClass('modal-open')

      this.escape()
      this.resize()

      this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', langx.proxy(this.hide, this))

      this.$dialog.on('mousedown.dismiss.bs.modal', function () {
        that.$element.one('mouseup.dismiss.bs.modal', function (e) {
          if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
        })
      })

      this.backdrop(function () {
        var transition = browser.support.transition && that.$element.hasClass('fade')

        if (!noder.isChildOf(that.$element[0],that.$container[0])) {
          that.$element.appendTo(that.$container) // don't move modals dom position
        }

        that.$element
          .show()
          .scrollTop(0)

        that.adjustDialog()

        if (transition) {
          that.$element[0].offsetWidth // force reflow
        }

        that.$element.addClass('in')

        that.enforceFocus()

        var e = eventer.create('shown.bs.modal', { relatedTarget: _relatedTarget })

        transition ?
          that.$dialog // wait for modal to slide in
            .one('transitionEnd', function () {
              that.$element.trigger('focus').trigger(e)
            })
            .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
          that.$element.trigger('focus').trigger(e)
      })
    },

    hide : function (e) {
      if (e) e.preventDefault()

      e = eventer.create('hide.bs.modal')

      this.$element.trigger(e)

      if (!this.isShown || e.isDefaultPrevented()) return

      this.isShown = false

      this.escape()
      this.resize()

      $(document).off('focusin.bs.modal')

      this.$element
        .removeClass('in')
        .off('click.dismiss.bs.modal')
        .off('mouseup.dismiss.bs.modal')

      this.$dialog.off('mousedown.dismiss.bs.modal')

      browser.support.transition && this.$element.hasClass('fade') ?
        this.$element
          .one('transitionEnd', langx.proxy(this.hideModal, this))
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        this.hideModal()
    },

    enforceFocus : function () {
      $(document)
        .off('focusin.bs.modal') // guard against infinite focus loop
        .on('focusin.bs.modal', langx.proxy(function (e) {
          if (document !== e.target &&
              this.$element[0] !== e.target &&
              !this.$element.has(e.target).length) {
            this.$element.trigger('focus')
          }
        }, this))
    },

    escape : function () {
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keydown.dismiss.bs.modal', langx.proxy(function (e) {
          e.which == 27 && this.hide()
        }, this))
      } else if (!this.isShown) {
        this.$element.off('keydown.dismiss.bs.modal')
      }
    },

    resize : function () {
      if (this.isShown) {
        $(window).on('resize.bs.modal', langx.proxy(this.handleUpdate, this))
      } else {
        $(window).off('resize.bs.modal')
      }
    },

    hideModal : function () {
      var that = this
      this.$element.hide()
      this.backdrop(function () {
        that.$container.removeClass('modal-open')
        that.resetAdjustments()
        that.resetScrollbar()
        that.$element.trigger('hidden.bs.modal')
      })
    },

    removeBackdrop : function () {
      this.$backdrop && this.$backdrop.remove()
      this.$backdrop = null
    },

    backdrop : function (callback) {
      var that = this
      var animate = this.$element.hasClass('fade') ? 'fade' : ''

      if (this.isShown && this.options.backdrop) {
        var doAnimate = browser.support.transition && animate

        this.$backdrop = $(document.createElement('div'))
          .addClass('modal-backdrop ' + animate)
          .appendTo(this.$container)

        if (!this.$container.is("body")) {
          this.$backdrop.css("position","absolute");
        }


        this.$element.on('click.dismiss.bs.modal', langx.proxy(function (e) {
          if (this.ignoreBackdropClick) {
            this.ignoreBackdropClick = false
            return
          }
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus()
            : this.hide()
        }, this))

        if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

        this.$backdrop.addClass('in')

        if (!callback) return

        doAnimate ?
          this.$backdrop
            .one('transitionEnd', callback)
            .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
          callback()

      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in')

        var callbackRemove = function () {
          that.removeBackdrop()
          callback && callback()
        }
        browser.support.transition && this.$element.hasClass('fade') ?
          this.$backdrop
            .one('transitionEnd', callbackRemove)
            .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
          callbackRemove()

      } else if (callback) {
        callback()
      }
    },

    // these following methods are used to handle overflowing modals

    handleUpdate : function () {
      this.adjustDialog()
    },

    adjustDialog : function () {
      var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

      this.$element.css({
        paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
        paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
      })
    },

    resetAdjustments : function () {
      this.$element.css({
        paddingLeft: '',
        paddingRight: ''
      })
    },

    checkScrollbar : function () {
      var fullWindowWidth = window.innerWidth
      if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
        var documentElementRect = document.documentElement.getBoundingClientRect()
        fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
      }
      this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
      this.scrollbarWidth = this.measureScrollbar()
    },

    setScrollbar : function () {
      var bodyPad = parseInt((this.$container.css('padding-right') || 0), 10)
      this.originalBodyPad = document.body.style.paddingRight || ''
      if (this.bodyIsOverflowing) this.$container.css('padding-right', bodyPad + this.scrollbarWidth)
    },

    resetScrollbar : function () {
      this.$container.css('padding-right', this.originalBodyPad)
    },

    measureScrollbar : function () { // thx walsh
      var scrollDiv = document.createElement('div')
      scrollDiv.className = 'modal-scrollbar-measure'
      this.$container.append(scrollDiv)
      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
      this.$container[0].removeChild(scrollDiv)
      return scrollbarWidth
    }

  });  


  Modal.VERSION  = '3.3.7'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  /*

  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = langx.mixin({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin;
  $.fn.modal.Constructor = Modal;


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  return $.fn.modal;
  */

  plugins.register(Modal,"modal",function(options,_relatedTarget){
      //this -> plugin instance
      if (typeof options == 'string') {
        this[options](_relatedTarget);
      } else if (this.options.show) {
        this.show(_relatedTarget);
      } 
  });

  return Modal;

});

define('skylark-bootstrap3/tooltip',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = bs3.Tooltip = plugins.Plugin.inherit({
    klassName: "Tooltip",

    pluginName : "bs3.tooltip",

    _construct : function(element,options) {
      this.type       = null
      this.options    = null
      this.enabled    = null
      this.timeout    = null
      this.hoverState = null
      this.$element   = null
      this.inState    = null

      this.enabled   = true;
      this.type      = 'tooltip';
      this.$element  = $(element)
      this.options   = this.getOptions(options)
      this.$viewport = this.options.viewport && $(langx.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
      this.inState   = { click: false, hover: false, focus: false }

      if (this.$element[0] instanceof document.constructor && !this.options.selector) {
        throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
      }

      var triggers = this.options.trigger.split(' ')

      for (var i = triggers.length; i--;) {
        var trigger = triggers[i]

        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, langx.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
          var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

          this.$element.on(eventIn  + '.' + this.type, this.options.selector, langx.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, langx.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = langx.mixin({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    },

    getDefaults : function () {
      return Tooltip.DEFAULTS
    },

    getOptions : function (options) {
      options = langx.mixin({}, this.getDefaults(), this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay,
          hide: options.delay
        }
      }

      return options
    },

    getDelegateOptions : function () {
      var options  = {}
      var defaults = this.getDefaults()

      this._options && langx.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      })

      return options
    },

    enter : function (obj) {
      var self = obj instanceof this.constructor ?
        obj : $(obj.currentTarget).plugin(this.pluginName)

      if (!self) {
        //self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
        self = $(obj.currentTarget).plugin(this.pluginName, this.getDelegateOptions())
      }

      if (obj instanceof eventer.create) {
        self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
      }

      if (self.tip().hasClass('in') || self.hoverState == 'in') {
        self.hoverState = 'in'
        return
      }

      clearTimeout(self.timeout)

      self.hoverState = 'in'

      if (!self.options.delay || !self.options.delay.show) return self.show()

      self.timeout = setTimeout(function () {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    },

    isInStateTrue : function () {
      for (var key in this.inState) {
        if (this.inState[key]) return true
      }

      return false
    },

    leave : function (obj) {
      var self = obj instanceof this.constructor ?
        obj : $(obj.currentTarget).plugin(this.pluginName)

      if (!self) {
        //self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
        self = $(obj.currentTarget).plugin(this.pluginName, this.getDelegateOptions())
      }

      if (obj instanceof eventer.create) {
        self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
      }

      if (self.isInStateTrue()) return

      clearTimeout(self.timeout)

      self.hoverState = 'out'

      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.timeout = setTimeout(function () {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    },

    show : function () {
      var e = eventer.create('show.bs.' + this.type)

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)

        var inDom = noder.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
        if (e.isDefaultPrevented() || !inDom) return
        var that = this

        var $tip = this.tip()

        var tipId = this.getUID(this.type)

        this.setContent()
        $tip.attr('id', tipId)
        this.$element.attr('aria-describedby', tipId)

        if (this.options.animation) $tip.addClass('fade')

        var placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        var autoToken = /\s?auto?\s?/i
        var autoPlace = autoToken.test(placement)
        if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })
          .addClass(placement)
          .data('bs3.' + this.type, this)

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
        this.$element.trigger('inserted.bs3.' + this.type)

        var pos          = this.getPosition()
        var actualWidth  = $tip[0].offsetWidth
        var actualHeight = $tip[0].offsetHeight

        if (autoPlace) {
          var orgPlacement = placement
          var viewportDim = this.getPosition(this.$viewport)

          placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                      placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                      placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                      placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                      placement

          $tip
            .removeClass(orgPlacement)
            .addClass(placement)
        }

        var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

        this.applyPlacement(calculatedOffset, placement)

        var complete = function () {
          var prevHoverState = that.hoverState
          that.$element.trigger('shown.bs3.' + that.type)
          that.hoverState = null

          if (prevHoverState == 'out') that.leave(that)
        }

        browser.support.transition && this.$tip.hasClass('fade') ?
          $tip
            .one('transitionEnd', complete)
            .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
          complete()
      }
    },

    applyPlacement : function (offset, placement) {
      var $tip   = this.tip()
      var width  = $tip[0].offsetWidth
      var height = $tip[0].offsetHeight

      // manually read margins because getBoundingClientRect includes difference
      var marginTop = parseInt($tip.css('margin-top'), 10)
      var marginLeft = parseInt($tip.css('margin-left'), 10)

      // we must check for NaN for ie 8/9
      if (isNaN(marginTop))  marginTop  = 0
      if (isNaN(marginLeft)) marginLeft = 0

      offset.top  += marginTop
      offset.left += marginLeft

      // $.fn.offset doesn't round pixel values
      // so we use setOffset directly with our own function B-0
      //$.offset.setOffset($tip[0], langx.mixin({
       // using: function (props) {
       //   $tip.css({
       //     top: Math.round(props.top),
       //     left: Math.round(props.left)
       //   })
       /// }
      //}, offset), 0);

      geom.pagePosition($tip[0],offset);
      

      $tip.addClass('in')

      // check to see if placing tip in new offset caused the tip to resize itself
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
      }

      var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

      if (delta.left) offset.left += delta.left
      else offset.top += delta.top

      var isVertical          = /top|bottom/.test(placement)
      var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
      var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

      $tip.offset(offset)
      this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
    },

    replaceArrow : function (delta, dimension, isVertical) {
      this.arrow()
        .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
        .css(isVertical ? 'top' : 'left', '')
    },

    setContent : function () {
      var $tip  = this.tip()
      var title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    },

    hide : function (callback) {
      var that = this
      var $tip = $(this.$tip)
      var e    = eventer.create('hide.bs3.' + this.type)

      function complete() {
        if (that.hoverState != 'in') $tip.detach()
        if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
          that.$element
            .removeAttr('aria-describedby')
            .trigger('hidden.bs3.' + that.type)
        }
        callback && callback()
      }

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      browser.support.transition && $tip.hasClass('fade') ?
        $tip
          .one('transitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()

      this.hoverState = null

      return this
    },

    fixTitle : function () {
      var $e = this.$element
      if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    },

    hasContent : function () {
      return this.getTitle()
    },

    getPosition : function ($element) {
      $element   = $element || this.$element

      var el     = $element[0]
      var isBody = el.tagName == 'BODY'

      var elRect    = el.getBoundingClientRect()
      if (elRect.width == null) {
        // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
        elRect = langx.mixin({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
      }
      var isSvg = window.SVGElement && el instanceof window.SVGElement
      // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
      // See https://github.com/twbs/bootstrap/issues/20280
      var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
      var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
      var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

      return langx.mixin({}, elRect, scroll, outerDims, elOffset)
    },

    getCalculatedOffset : function (placement, pos, actualWidth, actualHeight) {
      return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
             placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
             placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
          /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

    },

    getViewportAdjustedDelta : function (placement, pos, actualWidth, actualHeight) {
      var delta = { top: 0, left: 0 }
      if (!this.$viewport) return delta

      var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
      var viewportDimensions = this.getPosition(this.$viewport)

      if (/right|left/.test(placement)) {
        var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
        var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
        if (topEdgeOffset < viewportDimensions.top) { // top overflow
          delta.top = viewportDimensions.top - topEdgeOffset
        } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
          delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
        }
      } else {
        var leftEdgeOffset  = pos.left - viewportPadding
        var rightEdgeOffset = pos.left + viewportPadding + actualWidth
        if (leftEdgeOffset < viewportDimensions.left) { // left overflow
          delta.left = viewportDimensions.left - leftEdgeOffset
        } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
          delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
        }
      }

      return delta
    },

    getTitle : function () {
      var title
      var $e = this.$element
      var o  = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    },

    getUID : function (prefix) {
      do prefix += ~~(Math.random() * 1000000)
      while (document.getElementById(prefix))
      return prefix
    },

    tip : function () {
      if (!this.$tip) {
        this.$tip = $(this.options.template)
        if (this.$tip.length != 1) {
          throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
        }
      }
      return this.$tip
    },

    arrow : function () {
      return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
    },

    enable : function () {
      this.enabled = true
    },

    disable : function () {
      this.enabled = false
    },

    toggleEnabled : function () {
      this.enabled = !this.enabled
    },

    toggle : function (e) {
      var self = this
      if (e) {
        self = $(e.currentTarget).plugin(this.pluginName)
        if (!self) {
          //self = new this.constructor(e.currentTarget, this.getDelegateOptions())
          self = $(e.currentTarget).plugin(this.pluginName, this.getDelegateOptions());
        }
      }

      if (e) {
        self.inState.click = !self.inState.click
        if (self.isInStateTrue()) self.enter(self)
        else self.leave(self)
      } else {
        self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
      }
    },

    destroy : function () {
      var that = this
      clearTimeout(this.timeout)
      this.hide(function () {
        that.$element.off('.' + that.type).removeData('bs3.' + that.type)
        if (that.$tip) {
          that.$tip.detach()
        }
        that.$tip = null
        that.$arrow = null
        that.$viewport = null
        that.$element = null
      })
    }

  }); 



  Tooltip.VERSION  = '3.3.7'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }


  /*
  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin;
  $.fn.tooltip.Constructor = Tooltip;


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old;
    return this;
  }

  return $.fn.tooltip;
  */

  plugins.register(Tooltip,"tooltip");

  return Tooltip;
});

define('skylark-bootstrap3/popover',[
  "skylark-domx-browser",
  "skylark-langx/langx",
  "skylark-domx-eventer",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3",
  "./tooltip" 
],function(browser,langx,eventer,$,plugins,bs3,Tooltip){
/* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = bs3.Popover = Tooltip.inherit({
    klassName: "Popover",

    pluginName : "bs3.popover",

    _construct : function(element,options) {
      this.overrided(element,options);
      this.type = "popover";
    },
    getDefaults : function () {
      return Popover.DEFAULTS
    },

    setContent : function () {
      var $tip    = this.tip()
      var title   = this.getTitle()
      var content = this.getContent()

      $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
      $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
        this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
      ](content)

      $tip.removeClass('fade top bottom left right in')

      // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
      // this manually by checking the contents.
      if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
    },

    hasContent : function () {
      return this.getTitle() || this.getContent()
    },

    getContent : function () {
      var $e = this.$element
      var o  = this.options

      return $e.attr('data-content')
        || (typeof o.content == 'function' ?
              o.content.call($e[0]) :
              o.content)
    },

    arrow : function () {
      return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
    }

  });  

  Popover.VERSION  = '3.3.7'

  Popover.DEFAULTS = langx.mixin({}, Tooltip.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  /*

  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover;

  $.fn.popover             = Plugin;
  $.fn.popover.Constructor = Popover;


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  };

  return $.fn.popover;
  */

  plugins.register(Popover,"popover");

  return Popover;

});

define('skylark-bootstrap3/scrollspy',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.7
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  var ScrollSpy = bs3.ScrollSpy = plugins.Plugin.inherit({
    klassName: "ScrollSpy",

    pluginName : "bs3.scrollspy",

    _construct : function(element,options) {
      this.$body          = $(document.body)
      this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
      this.options        = langx.mixin({}, ScrollSpy.DEFAULTS, options)
      this.selector       = (this.options.target || '') + ' .nav li > a'
      this.offsets        = []
      this.targets        = []
      this.activeTarget   = null
      this.scrollHeight   = 0

      this.$scrollElement.on('scroll.bs.scrollspy', langx.proxy(this.process, this))
      this.refresh()
      this.process()
    },

    getScrollHeight : function () {
      return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    },

    refresh : function () {
      var that          = this
      var offsetMethod  = 'offset'
      var offsetBase    = 0

      this.offsets      = []
      this.targets      = []
      this.scrollHeight = this.getScrollHeight()

      if (!langx.isWindow(this.$scrollElement[0])) {
        offsetMethod = 'position'
        offsetBase   = this.$scrollElement.scrollTop()
      }

      this.$body
        .find(this.selector)
        .map(function () {
          var $el   = $(this)
          var href  = $el.data('target') || $el.attr('href')
          var $href = /^#./.test(href) && $(href)

          return ($href
            && $href.length
            && $href.is(':visible')
            && [[$href[offsetMethod]().top + offsetBase, href]]) || null
        })
        .sort(function (a, b) { return a[0] - b[0] })
        .each(function () {
          that.offsets.push(this[0])
          that.targets.push(this[1])
        })
    },

    process : function () {
      var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
      var scrollHeight = this.getScrollHeight()
      var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
      var offsets      = this.offsets
      var targets      = this.targets
      var activeTarget = this.activeTarget
      var i

      if (this.scrollHeight != scrollHeight) {
        this.refresh()
      }

      if (scrollTop >= maxScroll) {
        return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
      }

      if (activeTarget && scrollTop < offsets[0]) {
        this.activeTarget = null
        return this.clear()
      }

      for (i = offsets.length; i--;) {
        activeTarget != targets[i]
          && scrollTop >= offsets[i]
          && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
          && this.activate(targets[i])
      }
    },

    activate : function (target) {
      this.activeTarget = target

      this.clear()

      var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

      var active = $(selector)
        .parents('li')
        .addClass('active')

      if (active.parent('.dropdown-menu').length) {
        active = active
          .closest('li.dropdown')
          .addClass('active')
      }

      active.trigger('activate.bs.scrollspy')
    },

    clear : function () {
      $(this.selector)
        .parentsUntil(this.options.target, '.active')
        .removeClass('active')
    }

  });

  ScrollSpy.VERSION  = '3.3.7'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  /*

  // SCROLLSPY PLUGIN DEFINITION
  // ===========================
  var old = $.fn.scrollspy;

  $.fn.scrollspy = function scrollspy(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }


  $.fn.scrollspy.Constructor = ScrollSpy;


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old;
    return this;
  }


  return $.fn.scrollspy;
  */

  plugins.register(ScrollSpy,"scrollspy");

  return ScrollSpy;

});

define('skylark-bootstrap3/tab',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

/* ========================================================================
 * Bootstrap: tab.js v3.3.7
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

  'use strict';

  // TAB CLASS DEFINITION
  // ====================


  var Tab = bs3.Tab = plugins.Plugin.inherit({
    klassName: "Tab",

    pluginName : "bs3.tab",

    _construct : function(element,options) {
      // jscs:disable requireDollarBeforejQueryAssignment
      this.element = $(element)
      this.target = options && options.target;

      // jscs:enable requireDollarBeforejQueryAssignment
      this.element.on("click.bs.tab.data-api",langx.proxy(function(e){
        e.preventDefault()
        this.show();
      },this));    
    },

    show : function () {
      var $this    = this.element
      var $ul      = $this.closest('ul:not(.dropdown-menu)')
      var selector = this.target || $this.data('target');

      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
      }

      if ($this.parent('li').hasClass('active')) return

      var $previous = $ul.find('.active:last a')
      var hideEvent = eventer.create('hide.bs.tab', {
        relatedTarget: $this[0]
      })
      var showEvent = eventer.create('show.bs.tab', {
        relatedTarget: $previous[0]
      })

      $previous.trigger(hideEvent)
      $this.trigger(showEvent)

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

      var $target = $(selector)

      this.activate($this.closest('li'), $ul)
      this.activate($target, $target.parent(), function () {
        $previous.trigger({
          type: 'hidden.bs.tab',
          relatedTarget: $this[0]
        })
        $this.trigger({
          type: 'shown.bs.tab',
          relatedTarget: $previous[0]
        })
      })
    },

    activate : function (element, container, callback) {
      var $active    = container.find('> .active')
      var transition = callback
        && browser.support.transition
        && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

      function next() {
        $active
          .removeClass('active')
          .find('> .dropdown-menu > .active')
            .removeClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', false)

        element
          .addClass('active')
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)

        if (transition) {
          element[0].offsetWidth // reflow for transition
          element.addClass('in')
        } else {
          element.removeClass('fade')
        }

        if (element.parent('.dropdown-menu').length) {
          element
            .closest('li.dropdown')
              .addClass('active')
            .end()
            .find('[data-toggle="tab"]')
              .attr('aria-expanded', true)
        }

        callback && callback()
      }

      $active.length && transition ?
        $active
          .one('transitionEnd', next)
          .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
        next()

      $active.removeClass('in')
    }


  });


  Tab.VERSION = '3.3.7'

  Tab.TRANSITION_DURATION = 150

  /*
  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this,option)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }

  return $.fn.tab;
  */

  plugins.register(Tab,"tab");

  return Tab;
});

define('skylark-bootstrap3/taginput',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-domx-plugins",
  "./bs3"
],function(langx,browser,eventer,noder,geom,$,plugins,bs3){

  "use strict";

  var defaultOptions = {
    tagClass: function(item) {
      return 'label label-info';
    },
    focusClass: 'focus',
    itemValue: function(item) {
      return item ? item.toString() : item;
    },
    itemText: function(item) {
      return this.itemValue(item);
    },
    itemTitle: function(item) {
      return null;
    },
    freeInput: true,
    addOnBlur: true,
    maxTags: undefined,
    maxChars: undefined,
    confirmKeys: [13, 44],
    delimiter: ',',
    delimiterRegex: null,
    cancelConfirmKeysOnEmpty: false,
    onTagExists: function(item, $tag) {
      $tag.hide().fadeIn();
    },
    trimValue: false,
    allowDuplicates: false,
    triggerChange: true
  };


  var TagsInput = bs3.TagsInput = plugins.Plugin.inherit({
    klassName: "TagsInput",

    pluginName : "bs3.TagsInput",

  /**
   * Constructor function
   */
    _construct : function(element, options) {
      this.objectItems = options && options.itemValue;
      options = langx.mixin({}, defaultOptions, $(element).data(), options)
      this.overrided(element,options);

      this.isInit = true;
      this.itemsArray = [];


      this.$element = $(element);
      this.$element.hide();

      this.isSelect = (element.tagName === 'SELECT');
      this.multiple = (this.isSelect && element.hasAttribute('multiple'));
      this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
      this.inputSize = Math.max(1, this.placeholderText.length);

      this.$container = $('<div class="bootstrap-tagsinput"></div>');
      this.$input = $('<input type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);

      this.$element.before(this.$container);

      this.build();
      this.isInit = false;
    },


    /**
     * Adds the given item as a new tag. Pass true to dontPushVal to prevent
     * updating the elements val()
     */
    add: function(item, dontPushVal, options) {
      var self = this;

      if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)
        return;

      // Ignore falsey values, except false
      if (item !== false && !item)
        return;

      // Trim value
      if (typeof item === "string" && self.options.trimValue) {
        item = langx.trim(item);
      }

      // Throw an error when trying to add an object while the itemValue option was not set
      if (typeof item === "object" && !self.objectItems)
        throw("Can't add objects when itemValue option is not set");

      // Ignore strings only containg whitespace
      if (item.toString().match(/^\s*$/))
        return;

      // If SELECT but not multiple, remove current tag
      if (self.isSelect && !self.multiple && self.itemsArray.length > 0)
        self.remove(self.itemsArray[0]);

      if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
        var delimiter = (self.options.delimiterRegex) ? self.options.delimiterRegex : self.options.delimiter;
        var items = item.split(delimiter);
        if (items.length > 1) {
          for (var i = 0; i < items.length; i++) {
            this.add(items[i], true);
          }

          if (!dontPushVal)
            self.pushVal(self.options.triggerChange);
          return;
        }
      }

      var itemValue = self.options.itemValue(item),
          itemText = self.options.itemText(item),
          tagClass = self.options.tagClass(item),
          itemTitle = self.options.itemTitle(item);

      // Ignore items allready added
      var existing = langx.grep(self.itemsArray, function(item) { return self.options.itemValue(item) === itemValue; } )[0];
      if (existing && !self.options.allowDuplicates) {
        // Invoke onTagExists
        if (self.options.onTagExists) {
          var $existingTag = $(".tag", self.$container).filter(function() { return $(this).data("item") === existing; });
          self.options.onTagExists(item, $existingTag);
        }
        return;
      }

      // if length greater than limit
      if (self.items().toString().length + item.length + 1 > self.options.maxInputLength)
        return;

      // raise beforeItemAdd arg
      var beforeItemAddEvent = eventer.create('beforeItemAdd', { item: item, cancel: false, options: options});
      self.$element.trigger(beforeItemAddEvent);
      if (beforeItemAddEvent.cancel)
        return;

      // register item in internal array and map
      self.itemsArray.push(item);

      // add a tag element

      var $tag = $('<span class="tag ' + htmlEncode(tagClass) + (itemTitle !== null ? ('" title="' + itemTitle) : '') + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
      $tag.data('item', item);
      self.findInputWrapper().before($tag);
      $tag.after(' ');

      // Check to see if the tag exists in its raw or uri-encoded form
      var optionExists = (
        $('option[value="' + encodeURIComponent(itemValue) + '"]', self.$element).length ||
        $('option[value="' + htmlEncode(itemValue) + '"]', self.$element).length
      );

      // add <option /> if item represents a value not present in one of the <select />'s options
      if (self.isSelect && !optionExists) {
        var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
        $option.data('item', item);
        $option.attr('value', itemValue);
        self.$element.append($option);
      }

      if (!dontPushVal)
        self.pushVal(self.options.triggerChange);

      // Add class when reached maxTags
      if (self.options.maxTags === self.itemsArray.length || self.items().toString().length === self.options.maxInputLength)
        self.$container.addClass('bootstrap-tagsinput-max');

      // If using typeahead, once the tag has been added, clear the typeahead value so it does not stick around in the input.
      if ($('.typeahead, .twitter-typeahead', self.$container).length) {
        self.$input.typeahead('val', '');
      }

      if (this.isInit) {
        self.$element.trigger(eventer.create('itemAddedOnInit', { item: item, options: options }));
      } else {
        self.$element.trigger(eventer.create('itemAdded', { item: item, options: options }));
      }
    },

    /**
     * Removes the given item. Pass true to dontPushVal to prevent updating the
     * elements val()
     */
    remove: function(item, dontPushVal, options) {
      var self = this;

      if (self.objectItems) {
        if (typeof item === "object")
          item = langx.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } );
        else
          item = langx.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } );

        item = item[item.length-1];
      }

      if (item) {
        var beforeItemRemoveEvent = eventer.create('beforeItemRemove', { item: item, cancel: false, options: options });
        self.$element.trigger(beforeItemRemoveEvent);
        if (beforeItemRemoveEvent.cancel)
          return;

        $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();
        $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();
        if(langx.inArray(item, self.itemsArray) !== -1)
          self.itemsArray.splice(langx.inArray(item, self.itemsArray), 1);
      }

      if (!dontPushVal)
        self.pushVal(self.options.triggerChange);

      // Remove class when reached maxTags
      if (self.options.maxTags > self.itemsArray.length)
        self.$container.removeClass('bootstrap-tagsinput-max');

      self.$element.trigger(eventer.create('itemRemoved',  { item: item, options: options }));
    },

    /**
     * Removes all items
     */
    removeAll: function() {
      var self = this;

      $('.tag', self.$container).remove();
      $('option', self.$element).remove();

      while(self.itemsArray.length > 0)
        self.itemsArray.pop();

      self.pushVal(self.options.triggerChange);
    },

    /**
     * Refreshes the tags so they match the text/value of their corresponding
     * item.
     */
    refresh: function() {
      var self = this;
      $('.tag', self.$container).each(function() {
        var $tag = $(this),
            item = $tag.data('item'),
            itemValue = self.options.itemValue(item),
            itemText = self.options.itemText(item),
            tagClass = self.options.tagClass(item);

          // Update tag's class and inner text
          $tag.attr('class', null);
          $tag.addClass('tag ' + htmlEncode(tagClass));
          $tag.contents().filter(function() {
            return this.nodeType == 3;
          })[0].nodeValue = htmlEncode(itemText);

          if (self.isSelect) {
            var option = $('option', self.$element).filter(function() { return $(this).data('item') === item; });
            option.attr('value', itemValue);
          }
      });
    },

    /**
     * Returns the items added as tags
     */
    items: function() {
      return this.itemsArray;
    },

    /**
     * Assembly value by retrieving the value of each item, and set it on the
     * element.
     */
    pushVal: function() {
      var self = this,
          val = langx.map(self.items(), function(item) {
            return self.options.itemValue(item).toString();
          });

      self.$element.val(val, true);

      if (self.options.triggerChange)
        self.$element.trigger('change');
    },

    /**
     * Initializes the tags input behaviour on the element
     */
    build: function(options) {
      var self = this;

      //self.options = $.extend({}, defaultOptions, options);

      // When itemValue is set, freeInput should always be false
      if (self.objectItems)
        self.options.freeInput = false;

      makeOptionItemFunction(self.options, 'itemValue');
      makeOptionItemFunction(self.options, 'itemText');
      makeOptionFunction(self.options, 'tagClass');

      // Typeahead Bootstrap version 2.3.2
      if (self.options.typeahead) {
        var typeahead = self.options.typeahead || {};

        makeOptionFunction(typeahead, 'source');

        self.$input.typeahead(langx.extend({}, typeahead, {
          source: function (query, process) {
            function processItems(items) {
              var texts = [];

              for (var i = 0; i < items.length; i++) {
                var text = self.options.itemText(items[i]);
                map[text] = items[i];
                texts.push(text);
              }
              process(texts);
            }

            this.map = {};
            var map = this.map,
                data = typeahead.source(query);

            if (langx.isFunction(data.success)) {
              // support for Angular callbacks
              data.success(processItems);
            } else if (langx.isFunction(data.then)) {
              // support for Angular promises
              data.then(processItems);
            } else {
              // support for functions and jquery promises
              langx.Deferred.when(data)
               .then(processItems);
            }
          },
          updater: function (text) {
            self.add(this.map[text]);
            return this.map[text];
          },
          matcher: function (text) {
            return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);
          },
          sorter: function (texts) {
            return texts.sort();
          },
          highlighter: function (text) {
            var regex = new RegExp( '(' + this.query + ')', 'gi' );
            return text.replace( regex, "<strong>$1</strong>" );
          }
        }));
      }

      // typeahead.js
      if (self.options.typeaheadjs) {
        // Determine if main configurations were passed or simply a dataset
        var typeaheadjs = self.options.typeaheadjs;
        if (!langx.isArray(typeaheadjs)) {
            typeaheadjs = [null, typeaheadjs];
        }

        $.fn.typeahead.apply(self.$input, typeaheadjs).on('typeahead:selected', langx.proxy(function (obj, datum, name) {
          var index = 0;
          typeaheadjs.some(function(dataset, _index) {
            if (dataset.name === name) {
              index = _index;
              return true;
            }
            return false;
          });

          // @TODO Dep: https://github.com/corejavascript/typeahead.js/issues/89
          if (typeaheadjs[index].valueKey) {
            self.add(datum[typeaheadjs[index].valueKey]);
          } else {
            self.add(datum);
          }

          self.$input.typeahead('val', '');
        }, self));
      }

      self.$container.on('click', langx.proxy(function(event) {
        if (! self.$element.attr('disabled')) {
          self.$input.removeAttr('disabled');
        }
        self.$input.focus();
      }, self));

        if (self.options.addOnBlur && self.options.freeInput) {
          self.$input.on('focusout', langx.proxy(function(event) {
              // HACK: only process on focusout when no typeahead opened, to
              //       avoid adding the typeahead text as tag
              if ($('.typeahead, .twitter-typeahead', self.$container).length === 0) {
                self.add(self.$input.val());
                self.$input.val('');
              }
          }, self));
        }

      // Toggle the 'focus' css class on the container when it has focus
      self.$container.on({
        focusin: function() {
          self.$container.addClass(self.options.focusClass);
        },
        focusout: function() {
          self.$container.removeClass(self.options.focusClass);
        },
      });

      self.$container.on('keydown', 'input', langx.proxy(function(event) {
        var $input = $(event.target),
            $inputWrapper = self.findInputWrapper();

        if (self.$element.attr('disabled')) {
          self.$input.attr('disabled', 'disabled');
          return;
        }

        switch (event.which) {
          // BACKSPACE
          case 8:
            if (doGetCaretPosition($input[0]) === 0) {
              var prev = $inputWrapper.prev();
              if (prev.length) {
                self.remove(prev.data('item'));
              }
            }
            break;

          // DELETE
          case 46:
            if (doGetCaretPosition($input[0]) === 0) {
              var next = $inputWrapper.next();
              if (next.length) {
                self.remove(next.data('item'));
              }
            }
            break;

          // LEFT ARROW
          case 37:
            // Try to move the input before the previous tag
            var $prevTag = $inputWrapper.prev();
            if ($input.val().length === 0 && $prevTag[0]) {
              $prevTag.before($inputWrapper);
              $input.focus();
            }
            break;
          // RIGHT ARROW
          case 39:
            // Try to move the input after the next tag
            var $nextTag = $inputWrapper.next();
            if ($input.val().length === 0 && $nextTag[0]) {
              $nextTag.after($inputWrapper);
              $input.focus();
            }
            break;
         default:
             // ignore
         }

        // Reset internal input's size
        var textLength = $input.val().length,
            wordSpace = Math.ceil(textLength / 5),
            size = textLength + wordSpace + 1;
        $input.attr('size', Math.max(this.inputSize, $input.val().length));
      }, self));

      self.$container.on('keypress', 'input', langx.proxy(function(event) {
         var $input = $(event.target);

         if (self.$element.attr('disabled')) {
            self.$input.attr('disabled', 'disabled');
            return;
         }

         var text = $input.val(),
         maxLengthReached = self.options.maxChars && text.length >= self.options.maxChars;
         if (self.options.freeInput && (keyCombinationInList(event, self.options.confirmKeys) || maxLengthReached)) {
            // Only attempt to add a tag if there is data in the field
            if (text.length !== 0) {
               self.add(maxLengthReached ? text.substr(0, self.options.maxChars) : text);
               $input.val('');
            }

            // If the field is empty, let the event triggered fire as usual
            if (self.options.cancelConfirmKeysOnEmpty === false) {
                event.preventDefault();
            }
         }

         // Reset internal input's size
         var textLength = $input.val().length,
            wordSpace = Math.ceil(textLength / 5),
            size = textLength + wordSpace + 1;
         $input.attr('size', Math.max(this.inputSize, $input.val().length));
      }, self));

      // Remove icon clicked
      self.$container.on('click', '[data-role=remove]', langx.proxy(function(event) {
        if (self.$element.attr('disabled')) {
          return;
        }
        self.remove($(event.target).closest('.tag').data('item'));
      }, self));

      // Only add existing value as tags when using strings as tags
      if (self.options.itemValue === defaultOptions.itemValue) {
        if (self.$element[0].tagName === 'INPUT') {
            self.add(self.$element.val());
        } else {
          $('option', self.$element).each(function() {
            self.add($(this).attr('value'), true);
          });
        }
      }
    },

    /**
     * Removes all tagsinput behaviour and unregsiter all event handlers
     */
    destroy: function() {
      var self = this;

      // Unbind events
      self.$container.off('keypress', 'input');
      self.$container.off('click', '[role=remove]');

      self.$container.remove();
      self.$element.removeData('tagsinput');
      self.$element.show();
    },

    /**
     * Sets focus on the tagsinput
     */
    focus: function() {
      this.$input.focus();
    },

    /**
     * Returns the internal input element
     */
    input: function() {
      return this.$input;
    },

    /**
     * Returns the element which is wrapped around the internal input. This
     * is normally the $container, but typeahead.js moves the $input element.
     */
    findInputWrapper: function() {
      var elt = this.$input[0],
          container = this.$container[0];
      while(elt && elt.parentNode !== container)
        elt = elt.parentNode;

      return $(elt);
    }
  });

  /**
   * Register JQuery plugin
   */
  $.fn.tagsinput = function(arg1, arg2, arg3) {
    var results = [];

    this.each(function() {
      var tagsinput = $(this).data('tagsinput');
      // Initialize a new tags input
      if (!tagsinput) {
          tagsinput = new TagsInput(this, arg1);
          $(this).data('tagsinput', tagsinput);
          results.push(tagsinput);

          if (this.tagName === 'SELECT') {
              $('option', $(this)).attr('selected', 'selected');
          }

          // Init tags from $(this).val()
          $(this).val($(this).val());
      } else if (!arg1 && !arg2) {
          // tagsinput already exists
          // no function, trying to init
          results.push(tagsinput);
      } else if(tagsinput[arg1] !== undefined) {
          // Invoke function on existing tags input
            if(tagsinput[arg1].length === 3 && arg3 !== undefined){
               var retVal = tagsinput[arg1](arg2, null, arg3);
            }else{
               var retVal = tagsinput[arg1](arg2);
            }
          if (retVal !== undefined)
              results.push(retVal);
      }
    });

    if ( typeof arg1 == 'string') {
      // Return the results from the invoked function calls
      return results.length > 1 ? results : results[0];
    } else {
      return results;
    }
  };

  $.fn.tagsinput.Constructor = TagsInput;

  /**
   * Most options support both a string or number as well as a function as
   * option value. This function makes sure that the option with the given
   * key in the given options is wrapped in a function
   */
  function makeOptionItemFunction(options, key) {
    if (typeof options[key] !== 'function') {
      var propertyName = options[key];
      options[key] = function(item) { return item[propertyName]; };
    }
  }
  function makeOptionFunction(options, key) {
    if (typeof options[key] !== 'function') {
      var value = options[key];
      options[key] = function() { return value; };
    }
  }
  /**
   * HtmlEncodes the given value
   */
  var htmlEncodeContainer = $('<div />');
  function htmlEncode(value) {
    if (value) {
      return htmlEncodeContainer.text(value).html();
    } else {
      return '';
    }
  }

  /**
   * Returns the position of the caret in the given input field
   * http://flightschool.acylt.com/devnotes/caret-position-woes/
   */
  function doGetCaretPosition(oField) {
    var iCaretPos = 0;
    if (document.selection) {
      oField.focus ();
      var oSel = document.selection.createRange();
      oSel.moveStart ('character', -oField.value.length);
      iCaretPos = oSel.text.length;
    } else if (oField.selectionStart || oField.selectionStart == '0') {
      iCaretPos = oField.selectionStart;
    }
    return (iCaretPos);
  }

  /**
    * Returns boolean indicates whether user has pressed an expected key combination.
    * @param object keyPressEvent: JavaScript event object, refer
    *     http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    * @param object lookupList: expected key combinations, as in:
    *     [13, {which: 188, shiftKey: true}]
    */
  function keyCombinationInList(keyPressEvent, lookupList) {
      var found = false;
      langx.each(lookupList, function (index, keyCombination) {
          if (typeof (keyCombination) === 'number' && keyPressEvent.which === keyCombination) {
              found = true;
              return false;
          }

          if (keyPressEvent.which === keyCombination.which) {
              var alt = !keyCombination.hasOwnProperty('altKey') || keyPressEvent.altKey === keyCombination.altKey,
                  shift = !keyCombination.hasOwnProperty('shiftKey') || keyPressEvent.shiftKey === keyCombination.shiftKey,
                  ctrl = !keyCombination.hasOwnProperty('ctrlKey') || keyPressEvent.ctrlKey === keyCombination.ctrlKey;
              if (alt && shift && ctrl) {
                  found = true;
                  return false;
              }
          }
      });

      return found;
  }

  return TagsInput;

});
define('skylark-bootstrap3/loadedInit',[
 	"skylark-langx/langx",
 	"skylark-domx-query",
	"./affix",
	"./alert",
	"./button",
	"./carousel",
	"./collapse",
	"./dropdown",
	"./modal",
	"./popover",
	"./scrollspy",
	"./tab",
	"./taginput",
	"./tooltip",
	"./transition"
],function(langx,$,Affix,Alert,Button,Carousel,Collapse,Dropdown,Modal,Popover,ScrollSpy,Tab,Tooltip){
	function getTargetFromTrigger($trigger) {
		var href
		var target = $trigger.attr('data-target')
		  || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

		return $(target);
	}

	var init = function() {
    
		$(function () {
		    // AFFIX DATA-API
		    // =================
			$('[data-spy="affix"]').each(function () {
				var $spy = $(this)
				var data = $spy.data()

				data.offset = data.offset || {};

				if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
				if (data.offsetTop    != null) data.offset.top    = data.offsetTop

				$spy.affix(data);
			});


		  	// ALERT DATA-API
		    // =================
  			//$(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

  			// BUTTON DATA-API
		    // =================
			$(document).on('click.bs3.button.data-api', '[data-toggle^="button"]', function (e) {
				var $btn = $(e.target).closest('.btn')
				$btn.button('toggle');
				if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
					// Prevent double click on radios, and the double selections (so cancellation) on checkboxes
					e.preventDefault()
					// The target component still receive the focus
					if ($btn.is('input,button')) {
						$btn.trigger('focus');
					}else {
						$btn.find('input:visible,button:visible').first().trigger('focus');
					}
				}
			}).on('focus.bs3.button.data-api blur.bs3.button.data-api', '[data-toggle^="button"]', function (e) {
				$(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
			});

		    // CAROUSEL DATA-API
		    // =================
			$('[data-ride="carousel"]').each(function () {
				$this = $(this);
				$this.carousel($this.data());
			});

            $(document).on("click.bs3.carousel.data-api", "[data-target][data-slide],[data-target][data-slide-to],[href][data-slide],[href][data-slide-to]", function(e) {
	            var href
	            var $this = $(this)
	            var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
	            if (!$target.hasClass('carousel')) return
	            var options = langx.mixin({}, $target.data(), $this.data());
	            var slideIndex = $this.attr('data-slide-to')
	            if (slideIndex) options.interval = false

	            $target.carousel(options);

	            if (slideIndex) {
	                $target.plugin('bs3.carousel').to(slideIndex);
	            }

	            e.preventDefault();

	        });
 
			// COLLAPSE DATA-API
			// =================
 		    $(document).on('click.bs3.collapse.data-api', '[data-target][data-toggle="collapse"]', function (e) {
			    var $this   = $(this)

			    if (!$this.attr('data-target')) e.preventDefault()

			    var $target = getTargetFromTrigger($this)
			    var data    = $target.plugin('bs3.collapse')
			    var option  = data ? 'toggle' : $this.data()

			    $target.collapse(option);
		    });

			    // Dropdown DATA-API
			    // =================
	       	$(document)
	        .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	        .on('click.bs.dropdown.data-api', '[data-toggle="dropdown"]', Dropdown.prototype.toggle)
	        .on('keydown.bs.dropdown.data-api', '[data-toggle="dropdown"]', Dropdown.prototype.keydown)
	        .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);


			// MODAL DATA-API
			// ==============
			$(document).on('click.bs3.modal.data-api', '[data-toggle="modal"]', function (e) {
				var $this   = $(this)
				var href    = $this.attr('href')
				var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
				var option  = $target.data('bs3.modal') ? 'toggle' : langx.mixin({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

				if ($this.is('a')) e.preventDefault()

				$target.one('show.bs3.modal', function (showEvent) {
			  		if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
			  		$target.one('hidden.bs3.modal', function () {
			    		$this.is(':visible') && $this.trigger('focus')
			  		})
				})
				$target.modal(option, this);
			});

				// SCROLLSPY DATA-API
				// ==================
			$('[data-spy="scroll"]').each(function () {
				var $spy = $(this)
				$spy.scrollspy($spy.data());
			});

			// TAB DATA-API
			// ============

			var clickHandler = function (e) {
			    e.preventDefault()
			    $(this).tab('show');
			};

			$(document)
			.on('click.bs3.tab.data-api', '[data-toggle="tab"]', clickHandler)
			.on('click.bs3.tab.data-api', '[data-toggle="pill"]', clickHandler);

		  	/**
		   	* Initialize tagsinput behaviour on inputs and selects which have
		   	* data-role=tagsinput
		   	*/

		    $("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();

  		});
	};

	return init;
});

define('skylark-bootstrap3/main',[
    "skylark-domx-query",
    "./affix",
    "./alert",
    "./button",
    "./carousel",
    "./collapse",
    "./dropdown",
    "./modal",
    "./popover",
    "./scrollspy",
    "./tab",
    "./taginput",
    "./tooltip",
    "./transition",
    "./loadedInit"
], function($) {
    return $;
});
define('skylark-bootstrap3', ['skylark-bootstrap3/main'], function (main) { return main; });

define('skylark-widgets-swt/swt',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query"
],function(skylark,langx,browser,eventer,noder,geom,$){
	var swt = {};

	var CONST = {
		BACKSPACE_KEYCODE: 8,
		COMMA_KEYCODE: 188, // `,` & `<`
		DELETE_KEYCODE: 46,
		DOWN_ARROW_KEYCODE: 40,
		ENTER_KEYCODE: 13,
		TAB_KEYCODE: 9,
		UP_ARROW_KEYCODE: 38
	};

	var isShiftHeld = function isShiftHeld (e) { return e.shiftKey === true; };

	var isKey = function isKey (keyCode) {
		return function compareKeycodes (e) {
			return e.keyCode === keyCode;
		};
	};

	var isBackspaceKey = isKey(CONST.BACKSPACE_KEYCODE);
	var isDeleteKey = isKey(CONST.DELETE_KEYCODE);
	var isTabKey = isKey(CONST.TAB_KEYCODE);
	var isUpArrow = isKey(CONST.UP_ARROW_KEYCODE);
	var isDownArrow = isKey(CONST.DOWN_ARROW_KEYCODE);

	var ENCODED_REGEX = /&[^\s]*;/;
	/*
	 * to prevent double encoding decodes content in loop until content is encoding free
	 */
	var cleanInput = function cleanInput (questionableMarkup) {
		// check for encoding and decode
		while (ENCODED_REGEX.test(questionableMarkup)) {
			questionableMarkup = $('<i>').html(questionableMarkup).text();
		}

		// string completely decoded now encode it
		return $('<i>').text(questionableMarkup).html();
	};

	langx.mixin(swt, {
		CONST: CONST,
		cleanInput: cleanInput,
		isBackspaceKey: isBackspaceKey,
		isDeleteKey: isDeleteKey,
		isShiftHeld: isShiftHeld,
		isTabKey: isTabKey,
		isUpArrow: isUpArrow,
		isDownArrow: isDownArrow
	});

	return skylark.attach("widgets.swt",swt);

});

define('skylark-widgets-swt/Panel',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-bootstrap3/collapse",
  "./swt",
  "./Widget"
],function(langx,browser,eventer,noder,geom,$,collapse,swt,Widget){

  var Panel = Widget.inherit({
    klassName : "Panel",

    pluginName : "lark.panel",

    options : {
      toggler : {
        selector : ".panel-heading [data-toggle=\"collapse\"]"
      },

      body : {
        selector : ".panel-collapse"
      }
    },

    _init : function() {
      var self = this;
      this.$toggle = this._velm.find(this.options.toggler.selector);
      this.$body = this._velm.find(this.options.body.selector);
      this.$toggle.on('click.lark',function (e) {
        var $this   = $(this);
        var collpasePlugin    = self.$body.collapse('instance');
        if (collpasePlugin) {
          collpasePlugin.toggle();
        } else {
          self.$body.collapse($this.data());
        }
      });

    },

    expand : function() {
      // expand this panel
      this.$body.collapse("show");
    },

    collapse : function() {
      // collapse this panel
      this.$body.collapse("hide");
    },

    toogle : function() {
      // toogle this panel
     this.body.collapse("toogle");
    },

    full : function() {

    },

    unfull : function() {

    },

    toogleFull : function() {

    },
    
    close: function () {
      var panel_dom = this.dom(id);
      this.minimize(id, true).promise().then(function () {
        panel_dom.fadeOut();
      });
    }


  });


  return Panel;

});
define('skylark-widgets-swt/Accordion',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "skylark-bootstrap3/collapse",
  "./swt",
  "./Widget",
  "./Panel"
],function(langx,browser,eventer,noder,geom,$,collapse,swt,Widget, Panel){

  var Accordion = Widget.inherit({
    klassName : "Accordion",

    pluginName : "lark.accordion",

    options : {
      panel: {
        selector : "> .panel",
        template : null,
      }
    },

    _init : function() {
      var panels = [];
      this._velm.$(this.options.panel.selector).forEach(function(panelEl){
        var panel = new Accordion.Panel(panelEl,{

        });
        panels.push(panel);
      });
      this._panels = panels;
    },

    _post : function() {
      // handle internal events
    },

    _refresh : function(updates) {
    },

    panels : {
      get : function() {

      }
    },


    addPanel : function() {

    },

    /**
     * Removes a accordion pane.
     *
     * @method remove
     * @return {Accordion} The current widget.
     */
    remove : function() {

    },

    /**
     * Expands a accordion pane.
     *
     * @method remove
     * @return {Accordion} The current widget.
     */
    expand : function() {
      // expand a panel

    },

    /**
     * Expands all accordion panes.
     *
     * @method expandAll
     * @return {Accordion} The current widget.
     */
    expandAll : function() {
      // expand a panel

    },

    /**
     * Collapse a accordion pane.
     *
     * @method collapse
     * @return {Accordion} The current widget.
     */
    collapse : function() {

    },

    /**
     * Collapses all accordion pane.
     *
     * @method collapseAll
     * @return {Accordion} The current widget.
     */
    collapseAll : function() {

    }
  });

  Accordion.Panel = Panel.inherit({
    klassName : "AccordionPanel",

    _init : function() {
      //this._velm.collapse();
      this.overrided();
    },

    expand : function() {
      // expand this panel
      $(this._elm).collapse("show");
    },

    collapse : function() {
      // collapse this panel
      $(this._elm).collapse("hide");
    },

    toogle : function() {
      // toogle this panel
     $(this._elm).collapse("toogle");
    },

    remove : function() {
      this.overided();
    }
  });

  return swt.Accordion = Accordion;
});

define('skylark-widgets-swt/Button',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,$,swt,Widget){

	class Button extends Widget {
		get klassName() {
      return "Button";
    } 

    get pluginName(){
      return "lark.button";
    } 

		get options () {
      return {
        btnSize : "lg",
        btnType : "default",
        leftIcon : null,
        rightIcon : null,
        topIcon : null, // TODO
        bottomIcon : null //TODO        
      }
		}

    get state() {
      return {
        "text" : String
      }
    }

    _parse (elm,options) {
      var $el = $(elm),
          options = langx.mixin({},options);

      if (!options.btnType) {
        if ($el.hasClass("btn-link")) {
          options.btnType = "link";
        } else if ($el.hasClass("btn-default")) {
          options.btnType = "default";
        } else if ($el.hasClass("btn-primary")) {
          options.btnType = "primary";
        } else if ($el.hasClass("btn-info")) {
          options.btnType = "info";
        } else if ($el.hasClass("btn-success")) {
          options.btnType = "success";
        } else if ($el.hasClass("btn-warning")) {
          options.btnType = "warning";
        } else if ($el.hasClass("btn-danger")) {
          options.btnType = "danger";
        }        
      }

      if (!options.btnSize) {
        if ($el.hasClass("btn-xs")) {
          options.btnSize = "xs";
        } else if ($el.hasClass("btn-sm")) {
          options.btnSize = "sm";
        } else if ($el.hasClass("btn-lg")) {
          options.btnSize = "lg";
        }        
      }

      if (!options.href) {
        options.href = $el.attr('href');

        options.target = $el.attr('target');
      }

      if (!options.text) {
        options.text = $el.find('.text').text();
      }

      if (!options.leftIcon) {
        var $fa_icon_left = $el.find('.fa-icon-left');
        if ($fa_icon_left.length > 0) {
          $fa_icon_left.removeClass('fa-icon-left').removeClass('fa');
          options.leftIcon = $fa_icon_left.attr('class');
          $fa_icon_left.addClass('fa-icon-left').addClass('fa');
        }
      }

      if (!options.rightIcon) {
        var $fa_icon_right = $el.find('.fa-icon-right');

        if ($fa_icon_right.length > 0) {
          $fa_icon_right.removeClass('fa-icon-right').removeClass('fa');
          options.rightIcon = $fa_icon_right.attr('class');
          $fa_icon_right.addClass('fa-icon-right').addClass('fa');
        }        
      }
    }

    _refresh (updates) {
      //this.overrided(updates);
      super._refresh(updates);

      var velm = this._velm;

      if (updates.btnType) {
          velm.removeClass('btn-link btn-default btn-primary btn-info btn-success btn-warning btn-danger').addClass("btn-" + updates.btnType.value);
      }

      if (updates.btnSize) {
        velm.removeClass('btn-xs btn-sm btn-lg').addClass("btn-" + updates.btnSize.value);
      }

      if (updates.text) {
        velm.$('.text').text(updates.text.value);
      }

      if (updates.left) {
          velm.$('.fa-icon-left').remove();
          velm.prepend('<i style="word-spacing: -1em;" class="fa fa-icon-left fa-' + updates.iconleft.value + '">&nbsp;</i>\n');
      }

      if (updates.iconright) {
          velm.$('.fa-icon-right').remove();
          if (updates.iconright.value) {
              velm.append('<i style="word-spacing: -1em;" class="fa fa-icon-right fa-' + updates.iconright.value + '">&nbsp;</i>\n');
          }
      }
    }
  };

  Widget.register(Button);
//  class Buttonx extends Button {
//
//  }

//  Widget.register(Buttonx,"lark.button");
  return swt.Button = Button;

});




define('skylark-widgets-swt/Carousel',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "./swt",
    "./Widget",
    "skylark-bootstrap3/carousel"
], function(langx, browser, eventer, noder, geom,  $, swt, Widget) {

    var Carousel =  Widget.inherit({
        klassName : "Carousel",
        pluginName : "lark.carousel",

        options : {

            items : [],

            indicatorTemplate : "",
            slideTemplate : "",

            templates : {
              container : "<div class=\"carousel slide\" data-ride=\"carousel\">" +
                          "/div",
              indicators : {
                  container : "<ol class=\"carousel-indicators\">" +
                              "</ol>",
                  item :  "<li></li>"
              },

              slides : {
                  container : "<div class=\"carousel-inner\">" +
                              "/div",
                  item :  "<div class=\"item carousel-item\">" +
                            "<img alt=\"First slide\"  src=\"{{url}}\">" +
                          "</div>"
              }
            }
        },

        _init : function() {
          this._bs_carousel = this._velm.carousel(this.options);
          var self = this;          
          this._velm.on("click.lark", "[data-slide],[data-slide-to]", function(e) {
            var $this = $(this)
            var slideIndex = $this.attr('data-slide-to');
            if (slideIndex) {
                self.to(slideIndex);
            } else {
              var slideAction = $this.attr('data-slide');
              if (slideAction == "prev") {
                self.prev();
              } else {
                self.next();
              }
            }

            e.preventDefault();

        });
        },

        to : function(pos) {
          return this._bs_carousel.to(pos);
        },

        pause : function(e) {
          this._bs_carousel.pause(e);
          return this;
        },

        cycle : function(e) {
          return this._bs_carousel.cycle(e);
        },

        next : function() {
          return this._bs_carousel.next();
        },

        prev : function() {
          return this._bs_carousel.prev();
        },

        add : function() {
            
        },

        createIndicator: function (obj) {
          var gallery = this.gallery,
            indicator = this.indicatorPrototype.cloneNode(false)
          var title = gallery.getItemTitle(obj)
          var thumbnailProperty = this.options.thumbnailProperty
          var thumbnailUrl
          var thumbnail
          if (this.options.thumbnailIndicators) {
            if (thumbnailProperty) {
              thumbnailUrl = Gallery.getItemProperty(obj, thumbnailProperty)
            }
            if (thumbnailUrl === undefined) {
              thumbnail = obj.getElementsByTagName && $(obj).find('img')[0]
              if (thumbnail) {
                thumbnailUrl = thumbnail.src
              }
            }
            if (thumbnailUrl) {
              indicator.style.backgroundImage = 'url("' + thumbnailUrl + '")'
            }
          }
          if (title) {
            indicator.title = title;
          }
          return indicator;
      },

      addIndicator: function (index) {
        if (this.indicatorContainer.length) {
          var indicator = this.createIndicator(this.list[index])
          indicator.setAttribute('data-slide-to', index)
          this.indicatorContainer[0].appendChild(indicator)
          this.indicators.push(indicator)
        }
      },

      setActiveIndicator: function (index) {
        if (this.indicators) {
          if (this.activeIndicator) {
            this.activeIndicator.removeClass(this.options.activeIndicatorClass)
          }
          this.activeIndicator = $(this.indicators[index])
          this.activeIndicator.addClass(this.options.activeIndicatorClass)
        }
      },

      initSlides: function (reload) {
        if (!reload) {
          this.indicatorContainer = this.container.find(
            this.options.indicatorContainer
          )
          if (this.indicatorContainer.length) {
            this.indicatorPrototype = document.createElement('li')
            this.indicators = this.indicatorContainer[0].children
          }
        }
        this.overrided(reload);
      },

      addSlide: function (index) {
        this.overrided(index);
        this.addIndicator(index)
      },

      resetSlides: function () {
        this.overrided();
        this.indicatorContainer.empty();
        this.indicators = [];
      },

    });

    return swt.Carousel = Carousel;

});
define('skylark-widgets-swt/_Toggler',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){

  var _Toggler = swt._Toggler = Widget.inherit({
    klassName: "_Toggler",

    toggle: function () {
      var checked = this.isChecked();

      if (checked) {
        this.uncheck();
      } else {
        this.check();
      }
    },

    check: function  () {
      this.state.set('checked',true);
      return this;
    },

    uncheck: function () {
      this.state.set('checked',false);
      return this;
    },

    /**
     * Getter function for the checked state.
     *
     * @method isChecked
     * @return {Boolean} True/false 
     */
    isChecked: function () {
      return this.state.get('checked');
    }
  });

	return _Toggler;
});

define('skylark-widgets-swt/CheckBox',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./_Toggler"
],function(langx,browser,eventer,noder,geom,$,swt,_Toggler){

  var CheckBox =  _Toggler.inherit({
    klassName: "CheckBox",

    pluginName : "lark.checkbox",

    options : {
      selectors : {
        chk : "input[type=checkbox]",
        lbl : "checkbox-label"
      },
      template : undefined,
      checked : undefined,
      label : undefined,
      value : undefined
    },

    /*
     *@override
     */
    _parse : function(elm,options) {
      options = this.overrided(elm,options);
      var $el = $(elm),
          chkSelector = options.selectors && options.selectors.chk,
          lblSelector = options.selectors && options.selectors.lbl;

      if (!chkSelector) {
        chkSelector = this.options.selectors.chk;
      }
      if (!lblSelector) {
        lblSelector = this.options.selectors.lbl;
      }

      var $chk = $el.find(chkSelector),
          $lbl = $el.find(lblSelector);

      if (options.checked == undefined) {
        options.checked = $chk.prop('checked')
      } else {
        $chk.prop('checked',options.checked);
      }

      if (options.disabled == undefined) {
        options.disabled = $chk.prop('disabled')
      } else {
        $chk.prop('disabled',options.disabled);
      }

      return options;
    },

    /*
     *@override
     */
    _create : function() {
      //TODO
    },

    /*
     *@override
     */
    _init : function() {
      var elm = this._elm;

      // cache elements
      this.$lbl = this._velm.$(this.options.selectors.lbl);
      this.$chk = this._velm.$(this.options.selectors.chk);
    },


    /*
     *@override
     */
    _startup : function() {
      // handle internal events
      var self = this;
      this.$chk.on('change', function(evt) {
        //var $chk = $(evt.target);
        var checked = self.$chk.prop('checked');
        self.state.set("checked",checked);
      });
    },

    /*
     *@override
     */
    _refresh : function(updates) {

        function setCheckedState (checked) {
          var $chk = self.$chk;
          var $lbl = self.$label;
          var $containerToggle = self.$toggleContainer;

          if (checked) {
            $chk.prop('checked', true);
            $lbl.addClass('checked');
            $containerToggle.removeClass('hide hidden');
          } else {
            $chk.prop('checked', false);
            $lbl.removeClass('checked');
            $containerToggle.addClass('hidden');
          }
        }

        function setDisabledState (disabled) {
          var $chk = self.$chk;
          var $lbl = self.$label;

          if (disabled) {
            $chk.prop('disabled', true);
            $lbl.addClass('disabled');
          } else {
            $chk.prop('disabled', false);
            $lbl.removeClass('disabled');
          }
        }

        // update visual with attribute values from control
        this.overrided(changed);
        var self  = this;

        if (updates["checked"]) {
          setCheckedState(updates["checked"].value);
        }
        if (updates["disabled"]) {
          setDisabledState(updates["disabled"].value);
        }
    }
  });

	return swt.CheckBox = CheckBox;
});

define('skylark-widgets-swt/ComboBox',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget",
  "skylark-bootstrap3/dropdown"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){



	// COMBOBOX CONSTRUCTOR AND PROTOTYPE

	var ComboBox = Widget.inherit({
		klassName: "ComboBox",

		pluginName : "lark.combobox",

		widgetClass : "lark-combobox",

		options : {

			autoResizeMenu: true,
			filterOnKeypress: false,
			showOptionsOnKeypress: false,
			filter: function filter (list, predicate, self) {
				var visible = 0;
				self.$dropMenu.find('.empty-indicator').remove();

				list.each(function (i) {
					var $li = $(this);
					var text = $(this).text().trim();

					$li.removeClass();

					if (text === predicate) {
						$li.addClass('text-success');
						visible++;
					} else if (text.substr(0, predicate.length) === predicate) {
						$li.addClass('text-info');
						visible++;
					} else {
						$li.addClass('hidden');
					}
				});

				if (visible === 0) {
					self.$dropMenu.append('<li class="empty-indicator text-muted"><em>No Matches</em></li>');
				}
			}
		},

		_init : function() {
			this.$element = $(this._elm);

			this.$dropMenu = this.$element.find('.dropdown-menu');
			this.$input = this.$element.find('input');
			this.$button = this.$element.find('.btn');
			this.$button.dropdown();
			this.$inputGroupBtn = this.$element.find('.input-group-btn');

			this.$element.on('click.lark', 'a', langx.proxy(this.itemclicked, this));
			this.$element.on('change.lark', 'input', langx.proxy(this.inputchanged, this));
			this.$element.on('shown.bs.dropdown', langx.proxy(this.menuShown, this));
			this.$input.on('keyup.lark', langx.proxy(this.keypress, this));

			// set default selection
			this.setDefaultSelection();

			// if dropdown is empty, disable it
			var items = this.$dropMenu.children('li');
			if( items.length === 0) {
				this.$button.addClass('disabled');
			}

			// filter on load in case the first thing they do is press navigational key to pop open the menu
			if (this.options.filterOnKeypress) {
				this.options.filter(this.$dropMenu.find('li'), this.$input.val(), this);
			}
		},

		_destroy: function () {
			this.$element.remove();
			// remove any external bindings
			// [none]

			// set input value attrbute in markup
			this.$element.find('input').each(function () {
				$(this).attr('value', $(this).val());
			});

			// empty elements to return to original markup
			// [none]

			return this.$element[0].outerHTML;
		},

		doSelect: function ($item) {

			if (typeof $item[0] !== 'undefined') {
				// remove selection from old item, may result in remove and
				// re-addition of class if item is the same
				this.$element.find('li.selected:first').removeClass('selected');

				// add selection to new item
				this.$selectedItem = $item;
				this.$selectedItem.addClass('selected');

				// update input
				this.$input.val(this.$selectedItem.text().trim());
			} else {
				// this is a custom input, not in the menu
				this.$selectedItem = null;
				this.$element.find('li.selected:first').removeClass('selected');
			}
		},

		clearSelection: function () {
			this.$selectedItem = null;
			this.$input.val('');
			this.$dropMenu.find('li').removeClass('selected');
		},

		menuShown: function () {
			if (this.options.autoResizeMenu) {
				this.resizeMenu();
			}
		},

		resizeMenu: function () {
			var width = this.$element.outerWidth();
			this.$dropMenu.outerWidth(width);
		},

		selectedItem: function () {
			var item = this.$selectedItem;
			var data = {};

			if (item) {
				var txt = this.$selectedItem.text().trim();
				data = langx.mixin({
					text: txt
				}, this.$selectedItem.data());
			} else {
				data = {
					text: this.$input.val().trim(),
					notFound: true
				};
			}

			return data;
		},

		selectByText: function (text) {
			var $item = $([]);
			this.$element.find('li').each(function () {
				if ((this.textContent || this.innerText || $(this).text() || '').trim().toLowerCase() === (text || '').trim().toLowerCase()) {
					$item = $(this);
					return false;
				}
			});

			this.doSelect($item);
		},

		selectByValue: function (value) {
			var selector = 'li[data-value="' + value + '"]';
			this.selectBySelector(selector);
		},

		selectByIndex: function (index) {
			// zero-based index
			var selector = 'li:eq(' + index + ')';
			this.selectBySelector(selector);
		},

		selectBySelector: function (selector) {
			var $item = this.$element.find(selector);
			this.doSelect($item);
		},

		setDefaultSelection: function () {
			var selector = 'li[data-selected=true]:first';
			var item = this.$element.find(selector);

			if (item.length > 0) {
				// select by data-attribute
				this.selectBySelector(selector);
				item.removeData('selected');
				item.removeAttr('data-selected');
			}
		},

		enable: function () {
			this.$element.removeClass('disabled');
			this.$input.removeAttr('disabled');
			this.$button.removeClass('disabled');
		},

		disable: function () {
			this.$element.addClass('disabled');
			this.$input.attr('disabled', true);
			this.$button.addClass('disabled');
		},

		itemclicked: function (e) {
			this.$selectedItem = $(e.target).parent();

			// set input text and trigger input change event marked as synthetic
			this.$input.val(this.$selectedItem.text().trim()).trigger('change', {
				synthetic: true
			});

			// pass object including text and any data-attributes
			// to onchange event
			var data = this.selectedItem();

			// trigger changed event
			this.$element.trigger('changed.lark', data);

			e.preventDefault();

			// return focus to control after selecting an option
			this.$element.find('.dropdown-toggle').focus();
		},

		keypress: function (e) {
			var ENTER = 13;
			//var TAB = 9;
			var ESC = 27;
			var LEFT = 37;
			var UP = 38;
			var RIGHT = 39;
			var DOWN = 40;

			var IS_NAVIGATIONAL = (
				e.which === UP ||
				e.which === DOWN ||
				e.which === LEFT ||
				e.which === RIGHT
			);

			if(this.options.showOptionsOnKeypress && !this.$inputGroupBtn.hasClass('open')){
				this.$button.dropdown('toggle');
				this.$input.focus();
			}

			if (e.which === ENTER) {
				e.preventDefault();

				var selected = this.$dropMenu.find('li.selected').text().trim();
				if(selected.length > 0){
					this.selectByText(selected);
				}else{
					this.selectByText(this.$input.val());
				}

				this.$inputGroupBtn.removeClass('open');
			} else if (e.which === ESC) {
				e.preventDefault();
				this.clearSelection();
				this.$inputGroupBtn.removeClass('open');
			} else if (this.options.showOptionsOnKeypress) {
				if (e.which === DOWN || e.which === UP) {
					e.preventDefault();
					var $selected = this.$dropMenu.find('li.selected');
					if ($selected.length > 0) {
						if (e.which === DOWN) {
							$selected = $selected.next(':not(.hidden)');
						} else {
							$selected = $selected.prev(':not(.hidden)');
						}
					}

					if ($selected.length === 0){
						if (e.which === DOWN) {
							$selected = this.$dropMenu.find('li:not(.hidden):first');
						} else {
							$selected = this.$dropMenu.find('li:not(.hidden):last');
						}
					}
					this.doSelect($selected);
				}
			}

			// Avoid filtering on navigation key presses
			if (this.options.filterOnKeypress && !IS_NAVIGATIONAL) {
				this.options.filter(this.$dropMenu.find('li'), this.$input.val(), this);
			}

			this.previousKeyPress = e.which;
		},

		inputchanged: function (e, extra) {
			var val = $(e.target).val();
			// skip processing for internally-generated synthetic event
			// to avoid double processing
			if (extra && extra.synthetic) {
				this.selectByText(val);
				return;
			}
			this.selectByText(val);

			// find match based on input
			// if no match, pass the input value
			var data = this.selectedItem();
			if (data.text.length === 0) {
				data = {
					text: val
				};
			}

			// trigger changed event
			this.$element.trigger('changed.lark', data);
		}

	});



	ComboBox.prototype.getValue = ComboBox.prototype.selectedItem;



	return swt.ComboBox = ComboBox;
});

define('skylark-widgets-swt/TextBox',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){

  var SyncAttrs = [
    'rows', 'spellcheck', 'maxLength', 'size', 'readonly', 'min',
    'max', 'step', 'list', 'pattern', 'placeholder', 'required', 'multiple'
  ];

	var TextBox =  swt.TextBox = Widget.inherit({
		klassName: "TextBox",

    pluginName: "lark.textbox",

    /*
     * Parse options from attached dom element.
     * @override
     */
    _parse : function() {
      var  velm = this._velm;

      // get multiline option
      this.options.multiline = velm.is("textarea");
      
      // get current state of input
      var value = $chk.prop('checked');
      var disabled = $chk.prop('disabled');
      this.state.set("value",value);
      this.state.set(("disabled",disabled));

    },

    /*
     * Create a new  dom element for this widget
     * @override
     */
    _create : function() {
      var tagName = "input",attrs = {},
          options = this.options;

      langx.each([
        'rows', 'spellcheck', 'maxLength', 'size', 'readonly', 'min',
        'max', 'step', 'list', 'pattern', 'placeholder', 'required', 'multiple'
      ], function (name) {
        attrs[name] = options[name];
      });

      if (options.multiline) {
        tagName = "textarea"
      } 
      if (options.subtype) {
        attrs.type = options.subtype;
      }
      this._elm = this._dom.noder.createElement(tagName,attrs);
    },

    /*
     * Init this widget
     * @override
     */
    _init : function() {
    },

    /*
     * Sync dom element to widget state 
     * @override
     */
    _sync : function() {
      // handle internal events
      var self = this;
      this._velm.on('change', function(evt) {
        var value = self._velm.prop('value');
        self.state.set("value",value);
      });
    },

    _refresh : function(updates) {
        var self  = this;

        if (updates["value"] !== undefined) {
          if (self._velm.value() !== e.value) {
            self._velm.value(updates.value);
          }
        }
        if (updates["disabled"] !== undefined) {
          self._velm.disable(updates["disabled"]);
        }

        // update visual with attribute values from control
        this.overrided(changed);
    },

  });

	return TextBox;
});


 define('skylark-widgets-swt/Listing',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,$,swt,Widget){

    var Listing = Widget.inherit({
        klassName : "Listing",

        pluginName : "lark.listing",

        options : {
        	multiSelect: false,
        	//multiTier : false,

          multiTier : {
            mode   : "",  // "tree" or "accordion" or "popup"
            levels : 2,
            selectors :  {
              children : "ul",  // "> .list-group"
              hasChildren : ":has(ul)"
            },
            tree : {
              classes : {
                expandIcon: 'glyphicon-plus',    // "glyphicon-chevron-down", 'glyphicon-folder-open'
                collapseIcon: 'glyphicon-minus', // "glyphicon-chevron-right", 'glyphicon-folder-close'
                children : ""                              // "list-group children"
              },
              templates : {
                treeIcon : "<i class=\"glyphicon\"></i>",
                itemGroup: ""

              },
              selectors : {
                treeIcon : " > i"
              }
            },

            accordion : {
              selectors : {
                toggler : " > a"
              }

            }
          },

        	toggle : false,
        	classes : {
          	active : "active"
        	},


        	selectors : {
          	item : "li",                   // ".list-group-item"

        	},

          item : {
            template : "<span><i class=\"glyphicon\"></i><a href=\"javascript: void(0);\"></a> </span>",
            checkable : false,
            selectors : {
              icon : " > span > i",
              text : " > span > a"
            }
          },

        	selected : 0
        },

        state : {
          selected : Object
        },

        _init : function() {
            this.overrided();
            var self = this,
                velm = this._velm,
                itemSelector = this.options.selectors.item;

            this._$items = velm.$(itemSelector);

            velm.on('click', itemSelector, function () {
                var veItem = self._elmx(this);

                if (!veItem.hasClass('disabled')) {
                  var value = veItem.data("value");
                  if (value === undefined) {
                    value = self._$items.index(this);
                  }
                  self.state.set("selected",value);
                }

                //veItem.blur();
                return false;
            });
            this.state.set("selected",this.options.selected);

            var $this = velm,
                $toggle = this.options.toggle,
                multiTierMode = this.options.multiTier.mode,
                hasChildrenSelector = this.options.multiTier.selectors.hasChildren,
                childrenSelector = this.options.multiTier.selectors.children,
                iconSelector = this.options.item.selectors.icon,
                textSelector = this.options.item.selectors.text,
                itemTemplate = this.options.item.template,                
                obj = this;


            if (multiTierMode) {
              if (multiTierMode == "tree") {
                   var treeIconTemplate = this.options.multiTier.tree.templates.treeIcon,
                       treeIconSelector = this.options.multiTier.tree.selectors.treeIcon,
                       expandIconClass = this.options.multiTier.tree.classes.expandIcon,
                       collapseIconClass = this.options.multiTier.tree.classes.collapseIcon;

                   this._$items.each(function(){
                     if($(this).is(hasChildrenSelector)) {
                        var children = $(this).find(childrenSelector);
                        $(children).remove();
                        text = $(this).text().trim();
                        $(this).html(treeIconTemplate+itemTemplate);
                        $(this).find(treeIconSelector).addClass(expandIconClass).on("click" + "." + self.pluginName, function(e) {
                            e.preventDefault();

                            $(this).toggleClass(expandIconClass).toggleClass(collapseIconClass);

                            $(this).closest("li").toggleClass("active").children("ul").collapse("toggle");

                            if ($toggle) {
                                $(this).closest("li").siblings().removeClass("active").children("ul.in").collapse("hide");
                            }
                        });

                        $(this).find(iconSelector).addClass('glyphicon-folder-open');
                        $(this).find(textSelector).text(text);
                        $(this).append(children);



                      }  else {
                        text = $(this).text().trim();
                        $(this).html(treeIconTemplate+itemTemplate);
                        $(this).find(iconSelector).addClass('glyphicon-file');
                        $(this).find(textSelector).text(text);
                    }

                   });
              } else if (multiTierMode == "accordion") {
                var togglerSelector = self.options.multiTier.accordion.selectors.toggler;

                this._$items.has(childrenSelector).find(togglerSelector).on("click" + "." + this.pluginName, function(e) {
                    e.preventDefault();

                    $(this).closest(itemSelector).toggleClass("active").children(childrenSelector).collapse("toggle");

                    if ($toggle) {
                        $(this).closest(itemSelector).siblings().removeClass("active").children(childrenSelector+".in").collapse("hide");
                    }
                });
              }


             this._$items.filter(".active").has(childrenSelector).children(childrenSelector).addClass("collapse in");
             this._$items.not(".active").has(childrenSelector).children(childrenSelector).addClass("collapse");

              
            }   
        },

        _refresh : function(updates) {
          this.overrided(updates);
          var self  = this;

          function findItem(valueOrIdx) {
            var $item;
            if (langx.isNumber(valueOrIdx)) {
              $item = self._$items.eq(valueOrIdx);
            } else {
              $item = self._$items.filter('[data-value="' + valueOrIdx + '"]');
            }
            return $item;
          } 
                 
          function selectOneItem(valueOrIdx) {
            findItem(valueOrIdx).addClass(self.options.classes.active);
          }

          function unselectOneItem(valueOrIdx) {
            findItem(valueOrIdx).removeClass(self.options.classes.active);
          }

          if (updates["selected"]) {
            if (this.options.multiSelect) {
            } else {
              unselectOneItem(updates["selected"].oldValue);
              selectOneItem(updates["selected"].value);
            }

          }
        }

  });

  return swt.Listing = Listing;

});




define('skylark-widgets-swt/Pagination',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){

    'use strict';

    var Pagination = swt.Pagination = Widget.inherit({
        klassName : "Pagination",

        pluginName : "lark.pagination",

        options : {
            tagName : "ul",
            css : "",
            selectors : {
                firstNavi : "li[aria-label='first']",
                prevNavi : "li[aria-label='prev']",
                nextNavi : "li[aria-label='next']",
                lastNavi : "li[aria-label='last']",
                numericNavi : "li:not([aria-label])",
                numericTxt  : "a"
            },
            totalPages: 7,
            maxButtonsVisible: 5,
            currentPage: 1     
        },

        state : {
            totalPages : Number,
            currentPage : Number
        },

        _parse : function(elm,options) {

        },
        
        _create : function(self) {
        },

        _init : function() {
          this.$first = this._velm.$(this.options.selectors.firstNavi);
          this.$prev = this._velm.$(this.options.selectors.prevNavi);
          this.$last = this._velm.$(this.options.selectors.lastNavi);
          this.$next = this._velm.$(this.options.selectors.nextNavi);
          this.$numeric = this._velm.$(this.options.selectors.numericNavi);

          var self = this;

          function checkCanAction(elm) {
            var $elm = $(elm);
            if ($elm.is(".disabled,.active")) {
              return false;
            } else {
              return $elm;
            }
          }

          this.$first.click(function(){
            if (!checkCanAction(this)) {
              return;
            }
            self.currentPage(1);
          });

          this.$prev.click(function(){
            if (!checkCanAction(this)) {
              return;
            }
            self.currentPage(self.currentPage()-1);
          });

          this.$last.click(function(){
            if (!checkCanAction(this)) {
              return;
            }
            self.currentPage(self.totalPages());
          });

          this.$next.click(function(){
            if (!checkCanAction(this)) {
              return;
            }
            self.currentPage(self.currentPage()+1);
          });

          this.$numeric.click(function(){
            var ret = checkCanAction(this)
            if (!ret) {
              return;
            }
            var numeric = ret.find(self.options.selectors.numericTxt).text(),
                pageNo = parseInt(numeric);
            self.currentPage(pageNo);

          });

          this.state.set("currentPage",this.options.currentPage);
          this.state.set("totalPages",this.options.totalPages);

          this.overrided();
        },

        _refresh: function (updates) {
          this.overrided(updates);
          var self = this;

          function changePageNoBtns(currentPage,totalPages) {

            // Create the numeric buttons.
            // Variable of number control in the buttons.
            var totalPageNoBtns = Math.min(totalPages, self.options.maxButtonsVisible);
            var begin = 1;
            var end = begin + totalPageNoBtns - 1;

            /*
             * Align the values in the begin and end variables if the user has the
             * possibility that select a page that doens't appear in the paginador.
             * e.g currentPage = 1, and user go to the 20 page.
             */
            while ((currentPage < begin) || (currentPage > end)) {
              if (currentPage > end) {
                 begin += totalPageNoBtns;
                 end += totalPageNoBtns;

                 if (end > totalPages) {
                   begin = begin - (end - totalPages);
                   end = totalPages;
                 }
               } else {
                 begin -= totalPageNoBtns;
                 end -= totalPageNoBtns;

                 if (begin < 0) {
                   end = end + (begin + totalPageNoBtns);
                   begin = 1;
                 }
               }
            }
           /*
            * Verify if the user clicks in the last page show by paginator.
            * If yes, the paginator advances.
            */
            if ((currentPage === end) && (totalPages != 1)) {
              begin = currentPage - 1;
              end = begin + totalPageNoBtns - 1;

              if (end >= totalPages) {
                begin = begin - (end - (totalPages));
                end = totalPages;
              }
            }

            /*
             * Verify it the user clicks in the first page show by paginator.
             * If yes, the paginator retrogress
             */
             if ((begin === currentPage) && (totalPages != 1)) {
               if (currentPage != 1) {
                 end = currentPage + 1;
                 begin = end - (totalPageNoBtns - 1);
               }
             }

             var count = self.$numeric.size(),
                 visibles = end-begin + 1,
                 i = 0;

             self.$numeric.filter(".active").removeClass("active");
             while (i<visibles) {
               var pageNo = i + begin,
                   $btn = self.$numeric.eq(i);
               $btn.find(self.options.selectors.numericTxt).text(i+begin).show();
               if (pageNo == currentPage) {
                $btn.addClass("active");
               }
               i++;
             }
             while (i<count) {
               self.$numeric.eq(i).find(self.options.selectors.numericTxt).text(i+begin).hide();
               i++;
             }


          }

          function changeLabeldBtns(currentPage,totalPages) {
            if (currentPage < 1) {
              throw('Page can\'t be less than 1');
            } else if (currentPage > totalPages) {
              throw('Page is bigger than total pages');
            }

            if (totalPages < 1) {
              throw('Total Pages can\'t be less than 1');
            }

            if (currentPage == 1 ) {
              self.$first.addClass("disabled");
              self.$prev.addClass("disabled");
            } else {
              self.$first.removeClass("disabled");
              self.$prev.removeClass("disabled");
            }

            if (currentPage == totalPages ) {
              self.$last.addClass("disabled");
              self.$next.addClass("disabled");
            } else {
              self.$last.removeClass("disabled");
              self.$next.removeClass("disabled");
            }
          }

          if (updates.currentPage || updates.totalPages) {
            var currentPage = self.currentPage(),
                totalPages = self.totalPages();

            changePageNoBtns(currentPage,totalPages);
            changeLabeldBtns(currentPage,totalPages);
          }

        }

    });

    return Pagination;
});
define('skylark-widgets-swt/Progress',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){

    'use strict';

     var Progress = swt.Progress = Widget.inherit({
     	klassName : "Progress",

     	pluginName : "lark.progress",

     	options : {
     		selectors : {
     			bar : "progress-bar"
     		},
     		min : 0,
     		max : 100
     	},

     	state : {
     		value : Number
     	},

		_init : function() {
			this._vbar = this._velm.find(this.options.selectors.bar);
			this.value(this.options.min);
		},

		_refresh : function() {
	        this.overrided(changed);
	        var self  = this;

	        if (updates["value"] !== undefined) {
	        	var value = updates["value"],
	        		min = this.options.min,
	        		max = this.options.max;

				this._vbar.css("width",(value-min)/(max-min)*100+"%");
	        }
		},

		start : function(max){
			this.value(this.options.min);
			this._velm.slideDown();
		},

		increase : function(tick){
			var value = this.value();
			this.value(value += tick*1.0);
		},

		finish : function(){
			this.value(this.options.min);
			this._velm.slideUp();
		}     	
     });

	return Progress;
	
 });
define('skylark-widgets-swt/Radio',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./_Toggler"
],function(langx,browser,eventer,noder,geom,$,swt,_Toggler){

  var Radio = swt.Radio = _Toggler.inherit({
    klassName: "Radio",

    pluginName : "lark.radio",

    _parse : function() {
      var $radio = this.$radio;

      // get current state of input
      var checked = $radio.prop('checked');
      var disabled = $radio.prop('disabled');

      this.state.set("checked",checked);
      this.state.set(("disabled",disabled));

    },

    _init : function() {
      //this.options = langx.mixin({}, $.fn.checkbox.defaults, options);
      var element = this.domNode;
      var $element = $(element);

      if (element.tagName.toLowerCase() !== 'label') {
        logError('Radio must be initialized on the `label` that wraps the `input` element. See https://github.com/ExactTarget/fuelux/blob/master/reference/markup/checkbox.html for example of proper markup. Call `.checkbox()` on the `<label>` not the `<input>`');
        return;
      }

      // cache elements
      this.$label = $element;
      this.$radio = this.$label.find('input[type="checkbox"]');
      this.$container = $element.parent('.checkbox'); // the container div

      if (!this.options.ignoreVisibilityCheck && this.$radio.css('visibility').match(/hidden|collapse/)) {
        logError('For accessibility reasons, in order for tab and space to function on checkbox, checkbox `<input />`\'s `visibility` must not be set to `hidden` or `collapse`. See https://github.com/ExactTarget/fuelux/pull/1996 for more details.');
      }

      // determine if a toggle container is specified
      var containerSelector = this.$radio.attr('data-toggle');
      this.$toggleContainer = $(containerSelector);


      // set default state
      this.setInitialState();
    },

    _sync : function() {
      // handle internal events
      var self = this;
      this.$radio.on('change', function(evt) {
        //var $radio = $(evt.target);
        var checked = self.$radio.prop('checked');
        self.state.set("checked",checked);
      });
    },

    _refresh : function(updates) {

        function setCheckedState (checked) {
          var $radio = self.$radio;
          var $lbl = self.$label;
          var $containerToggle = self.$toggleContainer;

          if (checked) {
            // reset all items in group
            this.resetGroup();

            $radio.prop('checked', true);
            $lbl.addClass('checked');
            $containerToggle.removeClass('hide hidden');
          } else {
            $radio.prop('checked', false);
            $lbl.removeClass('checked');
            $containerToggle.addClass('hidden');
          }
        }

        function setDisabledState (disabled) {
          var $radio = self.$radio;
          var $lbl = self.$label;

          if (disabled) {
            $radio.prop('disabled', true);
            $lbl.addClass('disabled');
          } else {
            $radio.prop('disabled', false);
            $lbl.removeClass('disabled');
          }
        }

        // update visual with attribute values from control
        this.overrided(changed);
        var self  = this;

        if (updates["checked"]) {
          setCheckedState(updates["checked"].value);
        }
        if (updates["disabled"]) {
          setDisabledState(updates["disabled"].value);
        }
    },

    resetGroup: function resetGroup () {
      var $radios = $('input[name="' + this.groupName + '"]');
      $radios.each(function resetRadio (index, item) {
        var $radio = $(item);
        var $lbl = $radio.parent();
        var containerSelector = $radio.attr('data-toggle');
        var $containerToggle = $(containerSelector);


        $lbl.removeClass('checked');
        $containerToggle.addClass('hidden');
      });
    }
  });

  return Radio;
});


define('skylark-widgets-swt/SearchBox',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget",
  "skylark-bootstrap3/dropdown"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){


	// SEARCH CONSTRUCTOR AND PROTOTYPE

	var SearchBox = Widget.inherit({
		klassName: "SearchBox",

		pluginName: "lark.searchbox",

		options : {
			clearOnEmpty: false,
			searchOnKeyPress: false,
			allowCancel: false
		},
	
		_init : function() {
			this.$element = $(this._elm);
			this.$repeater = this.$element.closest('.repeater');

			if (this.$element.attr('data-searchOnKeyPress') === 'true'){
				this.options.searchOnKeyPress = true;
			}

			this.$button = this.$element.find('button');
			this.$input = this.$element.find('input');
			this.$icon = this.$element.find('.glyphicon, .fuelux-icon');

			this.$button.on('click.fu.search', langx.proxy(this.buttonclicked, this));
			this.$input.on('keyup.fu.search', langx.proxy(this.keypress, this));

			if (this.$repeater.length > 0) {
				this.$repeater.on('rendered.fu.repeater', langx.proxy(this.clearPending, this));
			}

			this.activeSearch = '';
		},
		destroy: function () {
			this.$element.remove();
			// any external bindings
			// [none]
			// set input value attrbute
			this.$element.find('input').each(function () {
				$(this).attr('value', $(this).val());
			});
			// empty elements to return to original markup
			// [none]
			// returns string of markup
			return this.$element[0].outerHTML;
		},

		search: function (searchText) {
			if (this.$icon.hasClass('glyphicon')) {
				this.$icon.removeClass('glyphicon-search').addClass('glyphicon-remove');
			}
			if (this.$icon.hasClass('fuelux-icon')) {
				this.$icon.removeClass('fuelux-icon-search').addClass('fuelux-icon-remove');
			}

			this.activeSearch = searchText;
			this.$element.addClass('searched pending');
			this.$element.trigger('searched.fu.search', searchText);
		},

		clear: function () {
			if (this.$icon.hasClass('glyphicon')) {
				this.$icon.removeClass('glyphicon-remove').addClass('glyphicon-search');
			}
			if (this.$icon.hasClass('fuelux-icon')) {
				this.$icon.removeClass('fuelux-icon-remove').addClass('fuelux-icon-search');
			}

			if (this.$element.hasClass('pending')) {
				this.$element.trigger('canceled.fu.search');
			}

			this.activeSearch = '';
			this.$input.val('');
			this.$element.trigger('cleared.fu.search');
			this.$element.removeClass('searched pending');
		},

		clearPending: function () {
			this.$element.removeClass('pending');
		},

		action: function () {
			var val = this.$input.val();

			if (val && val.length > 0) {
				this.search(val);
			} else {
				this.clear();
			}
		},

		buttonclicked: function (e) {
			e.preventDefault();
			if ($(e.currentTarget).is('.disabled, :disabled')) return;

			if (this.$element.hasClass('pending') || this.$element.hasClass('searched')) {
				this.clear();
			} else {
				this.action();
			}
		},

		keypress: function (e) {
			var ENTER_KEY_CODE = 13;
			var TAB_KEY_CODE = 9;
			var ESC_KEY_CODE = 27;

			if (e.which === ENTER_KEY_CODE) {
				e.preventDefault();
				this.action();
			} else if (e.which === TAB_KEY_CODE) {
				e.preventDefault();
			} else if (e.which === ESC_KEY_CODE) {
				e.preventDefault();
				this.clear();
			} else if (this.options.searchOnKeyPress) {
				// search on other keypress
				this.action();
			}
		},

		disable: function () {
			this.$element.addClass('disabled');
			this.$input.attr('disabled', 'disabled');

			if (!this.options.allowCancel) {
				this.$button.addClass('disabled');
			}
		},

		enable: function () {
			this.$element.removeClass('disabled');
			this.$input.removeAttr('disabled');
			this.$button.removeClass('disabled');
		}
	});

	return 	swt.SearchBox = SearchBox;
});

define('skylark-widgets-swt/SelectList',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget",
  "skylark-bootstrap3/dropdown"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){


	// SELECT CONSTRUCTOR AND PROTOTYPE

	var SelectList = Widget.inherit({
		klassName: "SelectList",

		pluginName : "lark.selectlist",
	
		options : {
			emptyLabelHTML: '<li data-value=""><a href="#">No items</a></li>'

		},

		_init : function() {
			this.$element = $(this._elm);
			//this.options = langx.mixin({}, $.fn.selectlist.defaults, options);


			this.$button = this.$element.find('.btn.dropdown-toggle');
			this.$hiddenField = this.$element.find('.hidden-field');
			this.$label = this.$element.find('.selected-label');
			this.$dropdownMenu = this.$element.find('.dropdown-menu');

			this.$button.dropdown();

			this.$element.on('click.fu.selectlist', '.dropdown-menu a', langx.proxy(this.itemClicked, this));
			this.setDefaultSelection();

			if (this.options.resize === 'auto' || this.$element.attr('data-resize') === 'auto') {
				this.resize();
			}

			// if selectlist is empty or is one item, disable it
			var items = this.$dropdownMenu.children('li');
			if( items.length === 0) {
				this.disable();
				this.doSelect( $(this.options.emptyLabelHTML));
			}

			// support jumping focus to first letter in dropdown when key is pressed
			this.$element.on('shown.bs.dropdown', function () {
					var $this = $(this);
					// attach key listener when dropdown is shown
					$(document).on('keypress.fu.selectlist', function(e){

						// get the key that was pressed
						var key = String.fromCharCode(e.which);
						// look the items to find the first item with the first character match and set focus
						$this.find("li").each(function(idx,item){
							if ($(item).text().charAt(0).toLowerCase() === key) {
								$(item).children('a').focus();
								return false;
							}
						});

				});
			});

			// unbind key event when dropdown is hidden
			this.$element.on('hide.bs.dropdown', function () {
					$(document).off('keypress.fu.selectlist');
			});
		},

		destroy: function () {
			this.$element.remove();
			// any external bindings
			// [none]
			// empty elements to return to original markup
			// [none]
			// returns string of markup
			return this.$element[0].outerHTML;
		},

		doSelect: function ($item) {
			var $selectedItem;
			this.$selectedItem = $selectedItem = $item;

			this.$hiddenField.val(this.$selectedItem.attr('data-value'));
			this.$label.html($(this.$selectedItem.children()[0]).html());

			// clear and set selected item to allow declarative init state
			// unlike other controls, selectlist's value is stored internal, not in an input
			this.$element.find('li').each(function () {
				if ($selectedItem.is($(this))) {
					$(this).attr('data-selected', true);
				} else {
					$(this).removeData('selected').removeAttr('data-selected');
				}
			});
		},

		itemClicked: function (e) {
			this.$element.trigger('clicked.fu.selectlist', this.$selectedItem);

			e.preventDefault();
			// ignore if a disabled item is clicked
			if ($(e.currentTarget).parent('li').is('.disabled, :disabled')) { return; }

			// is clicked element different from currently selected element?
			if (!($(e.target).parent().is(this.$selectedItem))) {
				this.itemChanged(e);
			}

			// return focus to control after selecting an option
			this.$element.find('.dropdown-toggle').focus();
		},

		itemChanged: function (e) {
			//selectedItem needs to be <li> since the data is stored there, not in <a>
			this.doSelect($(e.target).closest('li'));

			// pass object including text and any data-attributes
			// to onchange event
			var data = this.selectedItem();
			// trigger changed event
			this.$element.trigger('changed.fu.selectlist', data);
		},

		resize: function () {
			var width = 0;
			var newWidth = 0;
			var sizer = $('<div/>').addClass('selectlist-sizer');


			if (Boolean($(document).find('html').hasClass('fuelux'))) {
				// default behavior for fuel ux setup. means fuelux was a class on the html tag
				$(document.body).append(sizer);
			} else {
				// fuelux is not a class on the html tag. So we'll look for the first one we find so the correct styles get applied to the sizer
				$('.fuelux:first').append(sizer);
			}

			sizer.append(this.$element.clone());

			this.$element.find('a').each(function () {
				sizer.find('.selected-label').text($(this).text());
				newWidth = sizer.find('.selectlist').outerWidth();
				newWidth = newWidth + sizer.find('.sr-only').outerWidth();
				if (newWidth > width) {
					width = newWidth;
				}
			});

			if (width <= 1) {
				return;
			}

			this.$button.css('width', width);
			this.$dropdownMenu.css('width', width);

			sizer.remove();
		},

		selectedItem: function () {
			var txt = this.$selectedItem.text();
			return langx.mixin({
				text: txt
			}, this.$selectedItem.data());
		},

		selectByText: function (text) {
			var $item = $([]);
			this.$element.find('li').each(function () {
				if ((this.textContent || this.innerText || $(this).text() || '').toLowerCase() === (text || '').toLowerCase()) {
					$item = $(this);
					return false;
				}
			});
			this.doSelect($item);
		},

		selectByValue: function (value) {
			var selector = 'li[data-value="' + value + '"]';
			this.selectBySelector(selector);
		},

		selectByIndex: function (index) {
			// zero-based index
			var selector = 'li:eq(' + index + ')';
			this.selectBySelector(selector);
		},

		selectBySelector: function (selector) {
			var $item = this.$element.find(selector);
			this.doSelect($item);
		},

		setDefaultSelection: function () {
			var $item = this.$element.find('li[data-selected=true]').eq(0);

			if ($item.length === 0) {
				$item = this.$element.find('li').has('a').eq(0);
			}

			this.doSelect($item);
		},

		enable: function () {
			this.$element.removeClass('disabled');
			this.$button.removeClass('disabled');
		},

		disable: function () {
			this.$element.addClass('disabled');
			this.$button.addClass('disabled');
		}

	});	


	SelectList.prototype.getValue = SelectList.prototype.selectedItem;



	return swt.SelectList = SelectList;
});

define('skylark-widgets-swt/Tabular',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./swt",
  "./Widget"
],function(langx,browser,eventer,noder,geom,$,swt,Widget){

    var Tabular = Widget.inherit({
        klassName : "Tabular",

        pluginName : "lark.tabular",

        options : {
            buttonClasses : { 
                append: null, 
                removeLast: null, 
                insert: null, 
                remove: null, 
                moveUp: null, 
                moveDown: null, 
                rowDrag: null 
            },
            sectionClasses : { 
                caption: null, 
                header: null, 
                body: null, 
                subPanel: null, 
                footer: null 
            },
            hideButtons : { 
                append: false, 
                removeLast: false, 
                insert: false, 
                remove: false, 
                moveUp: false, 
                moveDown: false 
            }

        },

        _showEmptyMessage : function (settings, skipWidthCalculation) {
            var tbWrap = this._tbWrap;

            var $emptyCell = $('<td></td>').text(settings._i18n.rowEmpty).attr('colspan', settings._finalColSpan);
            $('table.body tbody', tbWrap).append($('<tr></tr>').addClass('empty').append($emptyCell));

            /*
            if (!skipWidthCalculation && settings.maxBodyHeight > 0) {
                // Check scrolling enabled
                if (settings.autoColumnWidth) {
                    this._calculateColumnWidth();
                } else {
                    // Set the width of empty message cell to the thead width
                    $emptyCell.width($('table.head', tbWrap).width() - 4);
                }
            }
            */
        },  

        _calculateColumnWidth : function () {
            var tbWrap = this._tbWrap;

            var $tbWhole = $('table.body', tbWrap);
            var $scroller = $('div.scroller', tbWrap);
            var settings = $tbWhole.data('appendGrid');
            var tbHeadRow = $('table.head tr.columnHead', tbWrap)[0];
            var tbColGp = $('table.body colgroup', tbWrap)[0];
            // Check any rows within the grid
            if (settings._rowOrder.length > 0) {
                // Reset the table/column width
                $('td', tbHeadRow).width('auto');
                $('col', tbColGp).width('auto');
                $tbWhole.width('auto');
                $scroller.width('auto');
                // Check the total number of columns
                var tbBodyRow = $('tbody tr', $tbWhole)[0];
                var marginThreshold = -2;
                if ($.fn.modal) {
                    // If bootstrap is loaded, cell margin was reset
                    marginThreshold = 1;
                }
                var colLimit = Math.min(tbHeadRow.childNodes.length, tbBodyRow.childNodes.length);
                for (var z = 0; z < colLimit; z++) {
                    var headCellWidth = tbHeadRow.childNodes[z].clientWidth + 1;
                    var bodyCellWidth = tbBodyRow.childNodes[z].clientWidth + marginThreshold;
                    if (bodyCellWidth > headCellWidth) {
                        tbHeadRow.childNodes[z].style.width = bodyCellWidth + 'px';
                    } else {
                        tbColGp.childNodes[z].style.width = headCellWidth + 'px';
                    }
                }
            } else {
                $('table.body,table.foot', tbWrap).width($('table.head').width());
            }
            // Set the width of footer row
            $('table.foot', tbWrap).width($tbWhole.width());
            // Check the scroll panel width
            $scroller.width($tbWhole.width() + $scroller[0].offsetWidth - $scroller[0].clientWidth + 1);
        },


        _createGridButton : function (param, uiIcon) {
            // Generate the standard grid action button based on its parameter.
            var genButton = null;
            if (param) {
                if (langx.isFunction(param)) {
                    // Generate button if it is a function.
                    genButton = $(param());
                } else if (param.nodeType) {
                    // Clone the button if it is a DOM element.
                    genButton = $(param).clone();
                } else if (param.icon || param.label) {
                    // Generate jQuery UI Button if it is a plain object with `icon` or `label` property.
                    genButton = $('<button/>').attr({ type: 'button' });
                    genButton.plugin("lark.button",param);
                }
            }
            if (!genButton) {
                // Use default setting (jQuery UI Button) if button is not created.
                genButton = $('<button/>').attr({ type: 'button' });
                genButton.plugin("lark.button",{ icon: uiIcon, showLabel: false });
            }
            return genButton;
        },

        _sortSequence : function (startIndex) {
            var tbWhole = this._elm;
            var settings = $(tbWhole).data('appendGrid');
            if (!settings.hideRowNumColumn) {
                for (var z = startIndex; z < settings._rowOrder.length; z++) {
                    $('#' + settings.idPrefix + '_Row_' + settings._rowOrder[z] + ' td.first', tbWhole).text(z + 1);
                }
            }
        },

        _emptyGrid : function () {
            var tbWhole = this._elm;

            // Load settings
            var settings = $(tbWhole).data('appendGrid');
            // Remove rows
            $('tbody', tbWhole).empty();
            settings._rowOrder.length = 0;
            settings._uniqueIndex = 0;
            // Save setting
            this._saveSetting(settings);
            // Add empty row
            this._showEmptyMessage(settings);
        },        

        _gridRowDragged : function (isMoveUp, uniqueIndex, tbRowIndex) {
            var tbWhole = this._elm;

            // Get setting
            var settings = $(tbWhole).data('appendGrid');
            // Find the start sorting index
            var startIndex = -1;
            for (var z = 0; z < settings._rowOrder.length; z++) {
                if (settings._rowOrder[z] == uniqueIndex) {
                    if (isMoveUp) {
                        startIndex = tbRowIndex;
                        settings._rowOrder.splice(z, 1);
                        settings._rowOrder.splice(tbRowIndex, 0, uniqueIndex);
                    } else {
                        startIndex = z;
                        settings._rowOrder.splice(tbRowIndex + 1, 0, uniqueIndex);
                        settings._rowOrder.splice(z, 1);
                    }
                    break;
                }
            }
            // Do re-order
            this._sortSequence( startIndex);
            // Save setting
            this._saveSetting(settings);

            // Trigger event
            if (langx.isFunction(settings.afterRowDragged)) {
                settings.afterRowDragged(tbWhole, tbRowIndex, uniqueIndex);
            }
        },

       _saveSetting : function (settings) {
            var tbWhole = this._elm;

            $(tbWhole).data('appendGrid', settings);
            $('#' + settings.idPrefix + '_rowOrder', tbWhole).val(settings._rowOrder.join());
        },


        _checkGridAndGetSettings : function (noMsg) {
            // Check the jQuery grid object is initialized and return its settings

            var settings = null,
                $grid = $(this._elm);

            if ($grid.length == 1) {
                settings = $grid.data('appendGrid');
                if (!settings && !noMsg) {
                    alert(_systemMessages.notInit);
                }
            } else if (!noMsg) {
                alert(_systemMessages.getValueMultiGrid);
            }
            return settings;
        },

        _insertRow : function (numOfRowOrRowArray, rowIndex, callerUniqueIndex) {
            // Define variables
            var self = this,
                tbWhole = this._elm;
            var settings = $(tbWhole).data('appendGrid');
            var addedRows = [], parentIndex = null, uniqueIndex, ctrl, hidden = [];
            var tbHead = tbWhole.getElementsByTagName('thead')[0];
            var tbBody = tbWhole.getElementsByTagName('tbody')[0];
            var tbRow, tbSubRow = null, tbCell, reachMaxRow = false, calColWidth = false;
            var oldHeight = 0, oldScroll = 0;
            /*
            if (settings.maxBodyHeight > 0) {
                tbHead = $('#' + settings._wrapperId + ' table thead')[0];
            }
            */
            // Check number of row to be inserted
            var numOfRow = numOfRowOrRowArray, loadData = false;
            if (langx.isArray(numOfRowOrRowArray)) {
                numOfRow = numOfRowOrRowArray.length;
                loadData = true;
            }
            // Check parent row
            if (langx.isNumeric(callerUniqueIndex)) {
                for (var z = 0; z < settings._rowOrder.length; z++) {
                    if (settings._rowOrder[z] == callerUniqueIndex) {
                        rowIndex = z;
                        if (z != 0) parentIndex = z - 1;
                        break;
                    }
                }
            }
            else if (langx.isNumeric(rowIndex)) {
                if (rowIndex >= settings._rowOrder.length) {
                    rowIndex = null;
                } else {
                    parentIndex = rowIndex - 1;
                }
            }
            else if (settings._rowOrder.length != 0) {
                rowIndex = null;
                parentIndex = settings._rowOrder.length - 1;
            }
            // Store old grid height
            if (settings.maintainScroll && !langx.isNumeric(rowIndex)) {
                oldHeight = $(tbWhole).height();
                oldScroll = $(tbWhole).scrollParent().scrollTop();
            }
            // Remove empty row
            if (settings._rowOrder.length == 0) {
                $('tr.empty', tbWhole).remove();
                calColWidth = true;
            }
            // Add total number of row
            for (var z = 0; z < numOfRow; z++) {
                // Check maximum number of rows
                if (0 < settings.maxRowsAllowed && settings._rowOrder.length >= settings.maxRowsAllowed) {
                    reachMaxRow = true;
                    break;
                }
                // Update variables
                settings._uniqueIndex++;
                uniqueIndex = settings._uniqueIndex;
                hidden.length = 0;
                // Check row insert index
                if (langx.isNumeric(rowIndex)) {
                    settings._rowOrder.splice(rowIndex, 0, uniqueIndex);
                    if (settings.useSubPanel) {
                        tbBody.insertBefore(tbSubRow = document.createElement('tr'), tbBody.childNodes[rowIndex * 2]);
                        tbBody.insertBefore(tbRow = document.createElement('tr'), tbBody.childNodes[rowIndex * 2]);
                    } else {
                        tbBody.insertBefore(tbRow = document.createElement('tr'), tbBody.childNodes[rowIndex]);
                    }
                    addedRows.push(rowIndex);
                }
                else {
                    settings._rowOrder.push(uniqueIndex);
                    tbBody.appendChild(tbRow = document.createElement('tr'));
                    if (settings.useSubPanel) {
                        tbBody.appendChild(tbSubRow = document.createElement('tr'));
                    }
                    addedRows.push(settings._rowOrder.length - 1);
                }
                tbRow.id = settings.idPrefix + '_Row_' + uniqueIndex;
                if (settings._sectionClasses.body) {
                    tbRow.className = settings._sectionClasses.body;
                }
                $(tbRow).data('appendGrid', uniqueIndex);
                // Config on the sub panel row
                if (tbSubRow != null) {
                    tbSubRow.id = settings.idPrefix + '_SubRow_' + uniqueIndex;
                    $(tbSubRow).data('appendGrid', uniqueIndex);
                    if (settings._sectionClasses.subPanel) {
                        tbSubRow.className = settings._sectionClasses.subPanel;
                    }
                }
                // Add row number
                if (!settings.hideRowNumColumn) {
                    tbRow.appendChild(tbCell = document.createElement('td'));
                    $(tbCell).addClass('ui-widget-content first').text(settings._rowOrder.length);
                    if (settings.useSubPanel) tbCell.rowSpan = 2;
                }
                // Process on each columns
                for (var y = 0; y < settings.columns.length; y++) {
                    // Skip hidden
                    if (settings.columns[y].type == 'hidden') {
                        hidden.push(y);
                        continue;
                    }
                    // Check column invisble
                    var className = 'ui-widget-content';
                    if (settings.columns[y].invisible) className += ' invisible';
                    // Insert cell
                    tbRow.appendChild(tbCell = document.createElement('td'));
                    tbCell.id = settings.idPrefix + '_' + settings.columns[y].name + '_td_' + uniqueIndex;
                    tbCell.className = className;
                    if (settings.columns[y].cellCss != null) $(tbCell).css(settings.columns[y].cellCss);
                    // Prepare control id and name
                    var ctrlId = settings.idPrefix + '_' + settings.columns[y].name + '_' + uniqueIndex, ctrlName;
                    if (langx.isFunction(settings.nameFormatter)) {
                        ctrlName = settings.nameFormatter(settings.idPrefix, settings.columns[y].name, uniqueIndex);
                    } else {
                        ctrlName = ctrlId;
                    }
                    // Check control type
                    ctrl = null;
                    if (settings.columns[y].type == 'custom') {
                        if (langx.isFunction(settings.columns[y].customBuilder)) {
                            ctrl = settings.columns[y].customBuilder(tbCell, settings.idPrefix, settings.columns[y].name, uniqueIndex);
                        }
                    } else if (settings.columns[y].type == 'select' || settings.columns[y].type == 'ui-selectmenu') {
                        ctrl = document.createElement('select');
                        ctrl.id = ctrlId;
                        ctrl.name = ctrlName;
                        // Build option list
                        if (langx.isArray(settings.columns[y].ctrlOptions)) {
                            // For array type option list
                            if (settings.columns[y].ctrlOptions.length > 0) {
                                if (langx.isPlainObject(settings.columns[y].ctrlOptions[0])) {
                                    // Check to generate optGroup or not
                                    var lastGroupName = null, lastGroupElem = null;
                                    for (var x = 0; x < settings.columns[y].ctrlOptions.length; x++) {
                                        if (!isEmpty(settings.columns[y].ctrlOptions[x].group)) {
                                            if (lastGroupName != settings.columns[y].ctrlOptions[x].group) {
                                                lastGroupName = settings.columns[y].ctrlOptions[x].group;
                                                lastGroupElem = document.createElement('optgroup');
                                                lastGroupElem.label = lastGroupName;
                                                ctrl.appendChild(lastGroupElem);
                                            }
                                        } else {
                                            lastGroupElem = null;
                                        }
                                        var option = $('<option/>').val(settings.columns[y].ctrlOptions[x].value).text(settings.columns[y].ctrlOptions[x].label);
                                        if (!isEmpty(settings.columns[y].ctrlOptions[x].title)) {
                                            option.attr('title', settings.columns[y].ctrlOptions[x].title);
                                        }
                                        if (null == lastGroupElem) {
                                            option.appendTo(ctrl);
                                        }
                                        else {
                                            option.appendTo(lastGroupElem);
                                        }
                                        // ctrl.options[ctrl.options.length] = new Option(settings.columns[y].ctrlOptions[x].label, settings.columns[y].ctrlOptions[x].value);
                                    }
                                }
                                else {
                                    for (var x = 0; x < settings.columns[y].ctrlOptions.length; x++) {
                                        ctrl.options[ctrl.options.length] = new Option(settings.columns[y].ctrlOptions[x], settings.columns[y].ctrlOptions[x]);
                                    }
                                }
                            }
                        } else if (langx.isPlainObject(settings.columns[y].ctrlOptions)) {
                            // For plain object type option list
                            for (var x in settings.columns[y].ctrlOptions) {
                                ctrl.options[ctrl.options.length] = new Option(settings.columns[y].ctrlOptions[x], x);
                            }
                        } else if (typeof (settings.columns[y].ctrlOptions) == 'string') {
                            // For string type option list
                            var arrayOpt = settings.columns[y].ctrlOptions.split(';');
                            for (var x = 0; x < arrayOpt.length; x++) {
                                var eqIndex = arrayOpt[x].indexOf(':');
                                if (-1 == eqIndex) {
                                    ctrl.options[ctrl.options.length] = new Option(arrayOpt[x], arrayOpt[x]);
                                } else {
                                    ctrl.options[ctrl.options.length] = new Option(arrayOpt[x].substring(eqIndex + 1, arrayOpt[x].length), arrayOpt[x].substring(0, eqIndex));
                                }
                            }
                        } else if (langx.isFunction(settings.columns[y].ctrlOptions)) {
                            settings.columns[y].ctrlOptions(ctrl);
                        }
                        tbCell.appendChild(ctrl);
                        // Handle UI widget
                        if (settings.columns[y].type == 'ui-selectmenu') {
                            $(ctrl).selectmenu(settings.columns[y].uiOption);
                        }
                    }
                    else if (settings.columns[y].type == 'checkbox') {
                        ctrl = document.createElement('input');
                        ctrl.type = 'checkbox';
                        ctrl.id = ctrlId;
                        ctrl.name = ctrlName;
                        ctrl.value = 1;
                        tbCell.appendChild(ctrl);
                        tbCell.style.textAlign = 'center';
                    }
                    else if (settings.columns[y].type == 'textarea') {
                        ctrl = document.createElement('textarea');
                        ctrl.id = ctrlId;
                        ctrl.name = ctrlName;
                        tbCell.appendChild(ctrl);
                    }
                    else if (-1 != settings.columns[y].type.search(/^(color|date|datetime|datetime\-local|email|month|number|range|search|tel|time|url|week)$/)) {
                        ctrl = document.createElement('input');
                        try {
                            ctrl.type = settings.columns[y].type;
                        }
                        catch (err) { /* Not supported type */ }
                        ctrl.id = ctrlId;
                        ctrl.name = ctrlName;
                        tbCell.appendChild(ctrl);
                    }
                    else {
                        // Generate text input
                        ctrl = document.createElement('input');
                        ctrl.type = 'text';
                        ctrl.id = ctrlId;
                        ctrl.name = ctrlName;
                        tbCell.appendChild(ctrl);
                        // Handle UI widget
                        if (settings.columns[y].type == 'ui-datepicker') {
                            $(ctrl).datepicker(settings.columns[y].uiOption);
                        } else if (settings.columns[y].type == 'ui-spinner') {
                            $(ctrl).spinner(settings.columns[y].uiOption);
                        } else if (settings.columns[y].type == 'ui-autocomplete') {
                            $(ctrl).autocomplete(settings.columns[y].uiOption);
                        }
                    }
                    // Add extra control properties
                    if (settings.columns[y].type != 'custom') {
                        // Add control attributes as needed
                        if (settings.columns[y].ctrlAttr != null) $(ctrl).attr(settings.columns[y].ctrlAttr);
                        // Add control properties as needed
                        if (settings.columns[y].ctrlProp != null) $(ctrl).prop(settings.columns[y].ctrlProp);
                        // Add control CSS as needed
                        if (settings.columns[y].ctrlCss != null) $(ctrl).css(settings.columns[y].ctrlCss);
                        // Add control class as needed
                        if (settings.columns[y].ctrlClass != null) $(ctrl).addClass(settings.columns[y].ctrlClass);
                        // Add jQuery UI tooltip as needed
                        if (settings.columns[y].uiTooltip) $(ctrl).tooltip(settings.columns[y].uiTooltip);
                        // Add control events as needed
                        if (langx.isFunction(settings.columns[y].onClick)) {
                            $(ctrl).click({ caller: tbWhole, callback: settings.columns[y].onClick, uniqueIndex: uniqueIndex }, function (evt) {
                                evt.data.callback(evt, $(evt.data.caller).appendGrid('getRowIndex', evt.data.uniqueIndex));
                            });
                        }
                        if (langx.isFunction(settings.columns[y].onChange)) {
                            $(ctrl).change({ caller: tbWhole, callback: settings.columns[y].onChange, uniqueIndex: uniqueIndex }, function (evt) {
                                evt.data.callback(evt, $(evt.data.caller).plugin("lark.tabular").getRowIndex(evt.data.uniqueIndex));
                            });
                        }
                    }
                    if (loadData) {
                        // Load data if needed
                        setCtrlValue(settings, y, uniqueIndex, numOfRowOrRowArray[z][settings.columns[y].name]);
                    } else if (!isEmpty(settings.columns[y].value)) {
                        // Set default value
                        setCtrlValue(settings, y, uniqueIndex, settings.columns[y].value);
                    }
                }
                // Add button cell if needed
                if (!settings._hideLastColumn || settings.columns.length > settings._visibleCount) {
                    if (!settings.rowButtonsInFront) {
                        tbRow.appendChild(tbCell = document.createElement('td'));
                    } else if (!settings.hideRowNumColumn) {
                        tbRow.insertBefore(tbCell = document.createElement('td'), tbRow.childNodes[1]);
                    } else {
                        tbRow.insertBefore(tbCell = document.createElement('td'), tbRow.firstChild);
                    }
                    tbCell.className = 'ui-widget-content last';
                    tbCell.id = settings.idPrefix + '_last_td_' + uniqueIndex;
                    if (settings._hideLastColumn) tbCell.style.display = 'none';
                    // Add standard buttons
                    if (!settings.hideButtons.insert) {
                        var button = this._createGridButton(settings.customGridButtons.insert, 'ui-icon-arrowreturnthick-1-w')
                            .attr({ id: settings.idPrefix + '_Insert_' + uniqueIndex, title: settings._i18n.insert, tabindex: -1 })
                            .addClass('insert').data('appendGrid', { uniqueIndex: uniqueIndex })
                            .click(function (evt) {
                                var rowUniqueIndex = $(this).data('appendGrid').uniqueIndex;
                                $(tbWhole).plugin("lark.tabular").insertRow(1, null, rowUniqueIndex);
                                if (evt && evt.preventDefault) evt.preventDefault(settings._buttonClasses.insert);
                                return false;
                            }).appendTo(tbCell);
                        if (!isEmpty(settings._buttonClasses.insert)) button.addClass(settings._buttonClasses.insert);
                    }
                    if (!settings.hideButtons.remove) {
                        var button = this._createGridButton(settings.customGridButtons.remove, 'ui-icon-trash')
                            .attr({ id: settings.idPrefix + '_Delete_' + uniqueIndex, title: settings._i18n.remove, tabindex: -1 })
                            .addClass('remove').data('appendGrid', { uniqueIndex: uniqueIndex })
                            .click(function (evt) {
                                var rowUniqueIndex = $(this).data('appendGrid').uniqueIndex;
                                self._removeRow( null, rowUniqueIndex, false);
                                if (evt && evt.preventDefault) evt.preventDefault();
                                return false;
                            }).appendTo(tbCell);
                        if (!isEmpty(settings._buttonClasses.remove)) button.addClass(settings._buttonClasses.remove);
                    }
                    if (!settings.hideButtons.moveUp) {
                        var button = this._createGridButton(settings.customGridButtons.moveUp, 'ui-icon-arrowthick-1-n')
                            .attr({ id: settings.idPrefix + '_MoveUp_' + uniqueIndex, title: settings._i18n.moveUp, tabindex: -1 })
                            .addClass('moveUp').data('appendGrid', { uniqueIndex: uniqueIndex })
                            .click(function (evt) {
                                var rowUniqueIndex = $(this).data('appendGrid').uniqueIndex;
                                $(tbWhole).plugin("lark.tabular").moveUpRow(null, rowUniqueIndex);
                                if (evt && evt.preventDefault) evt.preventDefault();
                                return false;
                            }).appendTo(tbCell);
                        if (!isEmpty(settings._buttonClasses.moveUp)) button.addClass(settings._buttonClasses.moveUp);
                    }
                    if (!settings.hideButtons.moveDown) {
                        var button = this._createGridButton(settings.customGridButtons.moveDown, 'ui-icon-arrowthick-1-s')
                            .attr({ id: settings.idPrefix + '_MoveDown_' + uniqueIndex, title: settings._i18n.moveDown, tabindex: -1 })
                            .addClass('moveDown').data('appendGrid', { uniqueIndex: uniqueIndex })
                            .click(function (evt) {
                                var rowUniqueIndex = $(this).data('appendGrid').uniqueIndex;
                                $(tbWhole).plugin("lark.tabular").moveDownRow(null, rowUniqueIndex);
                                if (evt && evt.preventDefault) evt.preventDefault();
                                return false;
                            }).appendTo(tbCell);
                        if (!isEmpty(settings._buttonClasses.moveDown)) button.addClass(settings._buttonClasses.moveDown);
                    }
                    // Handle row dragging
                    if (settings.rowDragging) {
                        var button = $('<div/>').addClass('rowDrag ui-state-default ui-corner-all')
                            .attr('title', settings._i18n.rowDrag).append($('<div/>').addClass('ui-icon ui-icon-caret-2-n-s').append($('<span/>').addClass('ui-button-text').text('Drag')))
                            .appendTo(tbCell);
                        if (!isEmpty(settings._buttonClasses.rowDrag)) button.addClass(settings._buttonClasses.rowDrag);
                    }
                    // Add hidden
                    for (var y = 0; y < hidden.length; y++) {
                        ctrl = document.createElement('input');
                        ctrl.id = settings.idPrefix + '_' + settings.columns[hidden[y]].name + '_' + uniqueIndex;
                        if (langx.isFunction(settings.nameFormatter)) {
                            ctrl.name = settings.nameFormatter(settings.idPrefix, settings.columns[y].name, uniqueIndex);
                        } else {
                            ctrl.name = ctrl.id;
                        }
                        ctrl.type = 'hidden';

                        if (loadData) {
                            // Load data if needed
                            ctrl.value = numOfRowOrRowArray[z][settings.columns[hidden[y]].name];
                        } else if (!isEmpty(settings.columns[hidden[y]].value)) {
                            // Set default value
                            ctrl.value = settings.columns[hidden[y]].value;
                        }
                        tbCell.appendChild(ctrl);
                    }
                    // Add extra buttons
                    if (settings.customRowButtons && settings.customRowButtons.length) {
                        // Add front buttons
                        for (var y = settings.customRowButtons.length - 1; y >= 0; y--) {
                            var buttonCfg = settings.customRowButtons[y];
                            if (buttonCfg && buttonCfg.uiButton && buttonCfg.click && buttonCfg.atTheFront) {
                                $(tbCell).prepend(makeCustomRowButton(tbWhole, buttonCfg, uniqueIndex));
                            }
                        }
                        // Add end buttons
                        for (var y = 0; y < settings.customRowButtons.length; y++) {
                            var buttonCfg = settings.customRowButtons[y];
                            if (buttonCfg && buttonCfg.uiButton && buttonCfg.click && !buttonCfg.atTheFront) {
                                $(tbCell).append(makeCustomRowButton(tbWhole, buttonCfg, uniqueIndex));
                            }
                        }
                    }
                }
                // Create sub panel
                if (settings.useSubPanel) {
                    tbSubRow.appendChild(tbCell = document.createElement('td'));
                    tbCell.className = 'ui-widget-content';
                    tbCell.colSpan = settings._visibleCount + (settings._hideLastColumn ? 0 : 1);
                    if (langx.isFunction(settings.subPanelBuilder)) {
                        settings.subPanelBuilder(tbCell, uniqueIndex);
                    }
                }
            }
            // Check if re-calculate column width is required
            /*
            if (0 < settings.maxBodyHeight && settings._calculateWidth && !calColWidth) {
                var scroll = $('#' + settings._wrapperId + '>div.scroller')[0];
                if (scroll.scrollHeight > scroll.offsetHeight) {
                    calColWidth = true;
                    settings._calculateWidth = false;
                }
            }
            */
            // Save setting
            this._saveSetting(settings);
            // Calculate column width
            /*
            if (calColWidth && settings.autoColumnWidth && settings.maxBodyHeight > 0) {
                this._calculateColumnWidth();
            }
            */
            // Trigger events
            if (langx.isNumeric(rowIndex)) {
                if (langx.isFunction(settings.afterRowInserted)) {
                    settings.afterRowInserted(tbWhole, parentIndex, addedRows);
                }
            }
            else {
                if (langx.isFunction(settings.afterRowAppended)) {
                    settings.afterRowAppended(tbWhole, parentIndex, addedRows);
                }
            }
            if (reachMaxRow && langx.isFunction(settings.maxNumRowsReached)) {
                settings.maxNumRowsReached();
            }
            // Scroll the page when append row
            if (settings.maintainScroll && !langx.isNumeric(rowIndex)) {
                // Try to maintain the height so that user no need to scroll every time when row added
                var newHeight = $(tbWhole).height();
                $(tbWhole).scrollParent().scrollTop(oldScroll + newHeight - oldHeight);
            }
            // Return added rows' uniqueIndex
            return { addedRows: addedRows, parentIndex: parentIndex, rowIndex: rowIndex };
        },

        _removeRow : function (rowIndex, uniqueIndex, force) {
            var tbWhole = this._elm;

            var settings = $(tbWhole).data('appendGrid');
            var tbBody = tbWhole.getElementsByTagName('tbody')[0];
            if (langx.isNumeric(uniqueIndex)) {
                for (var z = 0; z < settings._rowOrder.length; z++) {
                    if (settings._rowOrder[z] == uniqueIndex) {
                        rowIndex = z;
                        break;
                    }
                }
            }
            if (langx.isNumeric(rowIndex)) {
                // Remove middle row
                if (force || typeof (settings.beforeRowRemove) != 'function' || settings.beforeRowRemove(tbWhole, rowIndex)) {
                    settings._rowOrder.splice(rowIndex, 1);
                    if (settings.useSubPanel) {
                        tbBody.removeChild(tbBody.childNodes[rowIndex * 2]);
                        tbBody.removeChild(tbBody.childNodes[rowIndex * 2]);
                    } else {
                        tbBody.removeChild(tbBody.childNodes[rowIndex]);
                    }
                    // Save setting
                    this._saveSetting(settings);
                    // Sort sequence
                    this._sortSequence( rowIndex);
                    // Trigger event
                    if (langx.isFunction(settings.afterRowRemoved)) {
                        settings.afterRowRemoved(tbWhole, rowIndex);
                    }
                }
            }
            else {
                // Store old window scroll value
                var oldHeight = 0, oldScroll = 0;
                if (settings.maintainScroll) {
                    oldHeight = $(tbWhole).height();
                    oldScroll = $(tbWhole).scrollParent().scrollTop();
                }
                // Remove last row
                if (force || !langx.isFunction(settings.beforeRowRemove) || settings.beforeRowRemove(tbWhole, settings._rowOrder.length - 1)) {
                    uniqueIndex = settings._rowOrder.pop();
                    tbBody.removeChild(tbBody.lastChild);
                    if (settings.useSubPanel) {
                        tbBody.removeChild(tbBody.lastChild);
                    }
                    // Save setting
                    this._saveSetting(settings);
                    // Trigger event
                    if (langx.isFunction(settings.afterRowRemoved)) {
                        settings.afterRowRemoved(tbWhole, null);
                    }
                }
                // Scroll the page when append row
                if (settings.maintainScroll) {
                    // Try to maintain the height so that user no need to scroll every time when row added
                    var newHeight = $(tbWhole).height();
                    $(tbWhole).scrollParent().scrollTop(oldScroll + newHeight - oldHeight);
                }
            }
            // Add empty row
            if (settings._rowOrder.length == 0) {
                this._showEmptyMessage(settings);
            }
        },

        _loadData : function (records, isInit) {
            var tbWhole = this._elm;
            var tbBody, tbRow, tbCell, uniqueIndex, insertResult;
            var settings = $(tbWhole).data('appendGrid');
            if (settings) {
                // Clear existing content
                tbBody = tbWhole.getElementsByTagName('tbody')[0];
                $(tbBody).empty();
                settings._rowOrder.length = 0;
                settings._uniqueIndex = 0;
                // Check any records
                if (records != null && records.length) {
                    // Add rows
                    insertResult = this._insertRow(records.length, null, null);
                    // Set data
                    for (var r = 0; r < insertResult.addedRows.length; r++) {
                        for (var c = 0; c < settings.columns.length; c++) {
                            setCtrlValue(settings, c, settings._rowOrder[r], records[r][settings.columns[c].name]);
                        }
                        if (langx.isFunction(settings.rowDataLoaded)) {
                            settings.rowDataLoaded(tbWhole, records[r], r, settings._rowOrder[r]);
                        }
                    }
                }
                // Save setting
                settings._isDataLoaded = true;
                if (isInit) settings.initData = null;
                $(tbWhole).data('appendGrid', settings);
                // Trigger data loaded event
                if (langx.isFunction(settings.dataLoaded)) {
                    settings.dataLoaded(tbWhole, records);
                }
            }
        },

        _init: function () {
            var options = this.options,
                self = this;
            // Check mandatory paramters included
            if (!langx.isArray(options.columns) || options.columns.length == 0) {
                alert(_systemMessages.noColumnInfo);
            }
            // Check target element is table or not
            var tbWhole = this._elm, tbWrap, tbHead, tbBody, tbFoot, tbColGp, tbRow, tbCell;
            if (isEmpty(tbWhole.tagName) || tbWhole.tagName != 'TABLE') {
                alert(_systemMessages.elemNotTable);
            }
            // Generate settings
            var settings = langx.extend({}, _defaultInitOptions, _defaultCallbackContainer, options);
            // Add internal settings
            langx.extend(settings, {
                // The UniqueIndex accumulate counter
                _uniqueIndex: 0,
                // The row order array
                _rowOrder: [],
                // Indicate data is loaded or not
                _isDataLoaded: false,
                // Visible column count for internal calculation
                _visibleCount: 0,
                // Total colSpan count after excluding `hideRowNumColumn` and not generating last column
                _finalColSpan: 0,
                // Indicate to hide last column or not
                _hideLastColumn: false,
                // The element ID of the `appendGrid` wrapper
                _wrapperId: null,
                // 
                _calculateWidth: true
            });
            // Labels or messages used in grid
            if (langx.isPlainObject(options.i18n))
                settings._i18n = langx.extend({}, _defaultTextResources, options.i18n);
            else
                settings._i18n = langx.extend({}, _defaultTextResources);
            // The extra class names for buttons
            if (langx.isPlainObject(options.buttonClasses))
                settings._buttonClasses = langx.extend({}, _defaultButtonClasses, options.buttonClasses);
            else
                settings._buttonClasses = langx.extend({}, _defaultButtonClasses);
            // The extra class names for sections
            if (langx.isPlainObject(options.sectionClasses))
                settings._sectionClasses = langx.extend({}, _defaultSectionClasses, options.sectionClasses);
            else
                settings._sectionClasses = langx.extend({}, _defaultSectionClasses);
            // Make sure the `hideButtons` setting defined
            if (langx.isPlainObject(options.hideButtons))
                settings.hideButtons = langx.extend({}, _defaultHideButtons, options.hideButtons);
            else
                settings.hideButtons = langx.extend({}, _defaultHideButtons);
            // Check `idPrefix` is defined
            if (isEmpty(settings.idPrefix)) {
                // Check table ID defined
                if (isEmpty(tbWhole.id) || tbWhole.id == '') {
                    // Generate an ID using current time
                    settings.idPrefix = 'ag' + new Date().getTime();
                }
                else {
                    settings.idPrefix = tbWhole.id;
                }
            }
            // Check custom grid button parameters
            if (!langx.isPlainObject(settings.customGridButtons)) {
                settings.customGridButtons = {};
            }
            // Check rowDragging and useSubPanel option
            if (settings.useSubPanel && settings.rowDragging) {
                settings.rowDragging = false;
            }
            // Create thead and tbody
            tbHead = document.createElement('thead');
            tbHead.className = 'ui-widget-header';
            tbBody = document.createElement('tbody');
            tbBody.className = 'ui-widget-content';
            tbFoot = document.createElement('tfoot');
            tbFoot.className = 'ui-widget-header';
            tbColGp = document.createElement('colgroup');
            // Prepare the table element
            settings._wrapperId = settings.idPrefix + '-wrapper';
            tbWrap = this._tbWrap = document.createElement('div');
            $(tbWrap).attr('id', settings._wrapperId).addClass('appendGrid').insertAfter(tbWhole);
            $(tbWhole).empty().addClass('ui-widget').appendTo(tbWrap);
            // Check if content scrolling is enabled
            /*
            if (settings.maxBodyHeight > 0) {
                // Seperate the thead and tfoot from source table
                $('<table></table>').addClass('ui-widget head').append(tbHead).prependTo(tbWrap);
                $(tbWhole).addClass('body').wrap($('<div></div>').addClass('scroller').css('max-height', settings.maxBodyHeight)).append(tbColGp, tbBody);
                $('<table></table>').addClass('ui-widget foot').append(tbFoot).appendTo(tbWrap);
            } else {
                // Add thead, tbody and tfoot to the same table
                $(tbWhole).addClass('head body foot').append(tbColGp, tbHead, tbBody, tbFoot);
            }
            */
            // Add thead, tbody and tfoot to the same table
            $(tbWhole).addClass('head body foot').append(tbColGp, tbHead, tbBody, tbFoot);

            // Handle header row
            var tbHeadCellRowNum, tbHeadCellRowButton;
            tbHead.appendChild(tbRow = document.createElement('tr'));
            if (settings._sectionClasses.header) {
                tbRow.className = 'columnHead ' + settings._sectionClasses.header;
            } else {
                tbRow.className = 'columnHead';
            }
            if (!settings.hideRowNumColumn) {
                tbRow.appendChild(tbHeadCellRowNum = document.createElement('td'));
                tbHeadCellRowNum.className = 'ui-widget-header first';
                // Add column group for scrolling
                tbColGp.appendChild(document.createElement('col'));
            }
            // Prepare column information and add column header
            var pendingSkipCol = 0;
            for (var z = 0; z < settings.columns.length; z++) {
                // Assign default setting
                var columnOpt = langx.extend({}, _defaultColumnOptions, settings.columns[z]);
                settings.columns[z] = columnOpt;
                // Skip hidden
                if (settings.columns[z].type != 'hidden') {
                    // Check column is invisible
                    if (!settings.columns[z].invisible) {
                        settings._visibleCount++;
                    }
                    // Check skip header colSpan
                    if (pendingSkipCol == 0) {
                        var className = 'ui-widget-header';
                        if (settings.columns[z].invisible) className += ' invisible';
                        if (settings.columns[z].resizable) className += ' resizable';
                        tbRow.appendChild(tbCell = document.createElement('td'));
                        tbCell.id = settings.idPrefix + '_' + settings.columns[z].name + '_td_head';
                        tbCell.className = className;
                        if (settings.columns[z].displayCss) $(tbCell).css(settings.columns[z].displayCss);
                        if (settings.columns[z].headerSpan > 1) {
                            $(tbCell).attr('colSpan', settings.columns[z].headerSpan);
                            pendingSkipCol = settings.columns[z].headerSpan - 1;
                        }
                        // Add tooltip
                        if (langx.isPlainObject(settings.columns[z].displayTooltip)) {
                            $(tbCell).tooltip(settings.columns[z].displayTooltip);
                        }
                        else if (!isEmpty(settings.columns[z].displayTooltip)) {
                            $(tbCell).attr('title', settings.columns[z].displayTooltip).tooltip();
                        }
                        // Check to set display text or generate by function
                        if (langx.isFunction(settings.columns[z].display)) {
                            settings.columns[z].display(tbCell);
                        } else if (!isEmpty(settings.columns[z].display)) {
                            $(tbCell).text(settings.columns[z].display);
                        }
                        // Add column group for scrolling
                        tbColGp.appendChild(document.createElement('col'));
                    } else {
                        pendingSkipCol--;
                    }
                }
            }
            // Enable columns resizable
            if ($.fn.resizable ) {
                $('td.resizable', tbHead).resizable({ handles: 'e' });
            }
            // Check to hide last column or not
            if (settings.hideButtons.insert && settings.hideButtons.remove
                    && settings.hideButtons.moveUp && settings.hideButtons.moveDown
                    && (!langx.isArray(settings.customRowButtons) || settings.customRowButtons.length == 0)) {
                settings._hideLastColumn = true;
            }
            // Calculate the `_finalColSpan` value
            settings._finalColSpan = settings._visibleCount;
            if (!settings.hideRowNumColumn) settings._finalColSpan++;
            if (!settings._hideLastColumn) settings._finalColSpan++;
            // Generate last column header if needed
            if (!settings._hideLastColumn) {
                if (settings.rowButtonsInFront) {
                    if (settings.hideRowNumColumn) {
                        // Insert a cell at the front
                        tbRow.insertBefore(tbHeadCellRowButton = document.createElement('td'), tbRow.firstChild);
                    } else {
                        // Span the first cell that across row number and row button cells
                        // tbHeadCellRowNum.colSpan = 2;
                        // tbHeadCellRowButton = tbHeadCellRowNum;

                        // Insert a cell as the second column
                        tbRow.insertBefore(tbHeadCellRowButton = document.createElement('td'), tbRow.childnodes[1]);
                    }
                } else {
                    tbRow.appendChild(tbHeadCellRowButton = document.createElement('td'));
                }
                tbHeadCellRowButton.className = 'ui-widget-header last';
                tbHeadCellRowButton.id = settings.idPrefix + '_last_td_head';
                // Add column group for scrolling
                tbColGp.appendChild(document.createElement('col'));
            }
            // Add caption when defined
            if (settings.caption) {
                tbHead.insertBefore(tbRow = document.createElement('tr'), tbHead.firstChild);
                if (settings._sectionClasses.caption) {
                    tbRow.className = settings._sectionClasses.caption;
                }
                tbRow.appendChild(tbCell = document.createElement('td'));
                tbCell.id = settings.idPrefix + '_caption_td';
                tbCell.className = 'ui-state-active caption';
                tbCell.colSpan = settings._finalColSpan;
                // Add tooltip
                if (langx.isPlainObject(settings.captionTooltip)) {
                    $(tbCell).tooltip(settings.captionTooltip);
                } else if (!isEmpty(settings.captionTooltip)) {
                    $(tbCell).attr('title', settings.captionTooltip).tooltip();
                }
                // Check to set display text or generate by function
                if (langx.isFunction(settings.caption)) {
                    settings.caption(tbCell);
                } else {
                    $(tbCell).text(settings.caption);
                }
            }
            // Handle footer row
            tbFoot.appendChild(tbRow = document.createElement('tr'));
            if (settings._sectionClasses.footer) {
                tbRow.className = settings._sectionClasses.footer;
            }
            tbRow.appendChild(tbCell = document.createElement('td'));
            tbCell.id = settings.idPrefix + '_footer_td';
            tbCell.colSpan = settings._finalColSpan;
            $('<input/>').attr({
                type: 'hidden',
                id: settings.idPrefix + '_rowOrder',
                name: settings.idPrefix + '_rowOrder'
            }).appendTo(tbCell);
            // Make row invisible if all buttons are hidden
            if (settings.hideButtons.append && settings.hideButtons.removeLast
                    && (!langx.isArray(settings.customFooterButtons) || settings.customFooterButtons.length == 0)) {
                tbRow.style.display = 'none';
            } else {
                if (!settings.hideButtons.append) {
                    var button = this._createGridButton(settings.customGridButtons.append, 'ui-icon-plusthick')
                    .attr({ title: settings._i18n.append }).addClass('append')
                    .click(function (evt) {
                        self._insertRow(1, null, null);
                        if (evt && evt.preventDefault) evt.preventDefault();
                        return false;
                    }).appendTo(tbCell);
                    if (!isEmpty(settings._buttonClasses.append)) button.addClass(settings._buttonClasses.append);
                }
                if (!settings.hideButtons.removeLast) {
                    var button = this._createGridButton(settings.customGridButtons.removeLast, 'ui-icon-closethick')
                    .attr({ title: settings._i18n.removeLast }).addClass('removeLast')
                    .click(function (evt) {
                        self._removeRow( null, this.value, false);
                        if (evt && evt.preventDefault) evt.preventDefault();
                        return false;
                    }).appendTo(tbCell);
                    if (!isEmpty(settings._buttonClasses.removeLast)) button.addClass(settings._buttonClasses.removeLast);
                }
                if (settings.customFooterButtons && settings.customFooterButtons.length) {
                    // Add front buttons
                    for (var y = settings.customFooterButtons.length - 1; y >= 0; y--) {
                        var buttonCfg = settings.customFooterButtons[y];
                        if (buttonCfg && buttonCfg.uiButton && buttonCfg.click && buttonCfg.atTheFront) {
                            $(tbCell).prepend(makeCustomBottomButton(tbWhole, buttonCfg));
                        }
                    }
                    // Add end buttons
                    for (var y = 0; y < settings.customFooterButtons.length; y++) {
                        var buttonCfg = settings.customFooterButtons[y];
                        if (buttonCfg && buttonCfg.uiButton && buttonCfg.click && !buttonCfg.atTheFront) {
                            $(tbCell).append(makeCustomBottomButton(tbWhole, buttonCfg));
                        }
                    }
                }
            }
            // Enable dragging
            if (settings.rowDragging) {
                $(tbBody).sortable({
                    axis: 'y',
                    containment: tbWhole,
                    handle: '.rowDrag',
                    helper: function (e, tr) {
                        var org = tr.children();
                        var helper = tr.clone();
                        // Fix the cell width of cloned table cell
                        helper.children().each(function (index) {
                            $(this).width(org.eq(index).width());
                            // Set the value of drop down list when drag (Issue #18)
                            var helperSelect = $('select', this);
                            if (helperSelect.length > 0) {
                                for (var y = 0; y < helperSelect.length; y++) {
                                    var orgSelect = org.eq(index).find('select');
                                    if (orgSelect.length > y) {
                                        helperSelect[y].value = orgSelect[y].value;
                                    }
                                }
                            }
                        });
                        return helper;
                    },
                    update: function (event, ui) {
                        var uniqueIndex = ui.item[0].id.substring(ui.item[0].id.lastIndexOf('_') + 1);
                        var tbRowIndex = ui.item[0].rowIndex - $('tr', tbHead).length;
                        self._gridRowDragged(ui.originalPosition.top > ui.position.top, uniqueIndex, tbRowIndex);
                    }
                });
            }
            // Save options
            $(tbWhole).data('appendGrid', settings);
            if (langx.isArray(options.initData)) {
                // Load data if initData is array
                this._loadData(options.initData, true);
            } else {
                // Add empty rows
                //$(tbWhole).appendGrid('appendRow', settings.initRows);
                this.appendRow(settings.initRows);
            }
            // Show no rows in grid
            if (settings._rowOrder.length == 0) {
                this._showEmptyMessage(settings, true);
            }

            /*
            // Calculate column width
            if (settings.maxBodyHeight > 0) {
                if (settings.autoColumnWidth) {
                    this._calculateColumnWidth();
                } else {
                    $('table.foot', tbWrap).width($(tbWhole).width());
                }
            }
            */
        },

        isReady: function () {
            // Check the appendGrid is initialized or not
            var settings = this._checkGridAndGetSettings( true);
            if (settings) {
                return true;
            }
            return false;
        },

        isDataLoaded: function () {
            // Check the grid data is loaded by `load` method or `initData` parameter or not
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                return settings._isDataLoaded;
            }
            return false;
        },

        load: function (records) {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                if (records != null && records.length > 0) {
                    this._loadData(records, false);
                } else {
                    this._emptyGrid();
                }
            }
            return this;
        },

        appendRow: function (numOfRowOrRowArray) {
            return this.insertRow(numOfRowOrRowArray);
        },

        insertRow: function (numOfRowOrRowArray, rowIndex, callerUniqueIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                if ((langx.isArray(numOfRowOrRowArray) && numOfRowOrRowArray.length > 0) || (langx.isNumeric(numOfRowOrRowArray) && numOfRowOrRowArray > 0)) {
                    // Define variables
                    var tbWhole = this[0];
                    insertResult = this._insertRow(numOfRowOrRowArray, rowIndex, callerUniqueIndex);
                    // Reorder sequence as needed
                    if (langx.isNumeric(rowIndex) || langx.isNumeric(callerUniqueIndex)) {
                        // Sort sequence
                        this._sortSequence( insertResult.rowIndex);
                        // Move focus
                        var insertUniqueIndex = settings._rowOrder[insertResult.addedRows[0]];
                        $('#' + settings.idPrefix + '_Insert_' + insertUniqueIndex, tbWhole).focus();
                    }
                }
            }
            return this;
        },
        removeRow: function (rowIndex, uniqueIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings && settings._rowOrder.length > 0) {
                this._removeRow(rowIndex, uniqueIndex, true);
            }
            return this;
        },
        emptyGrid: function () {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                this._emptyGrid();
            }
            return target;
        },
        moveUpRow: function (rowIndex, uniqueIndex) {
            var settings = this._checkGridAndGetSettings(), target = this;
            if (settings) {
                var tbWhole = target[0], trTarget, trSwap, trAdtTarget, swapSeq, oldIndex = null;
                var tbBody = tbWhole.getElementsByTagName('tbody')[0];
                if (langx.isNumeric(rowIndex) && rowIndex > 0 && rowIndex < settings._rowOrder.length) {
                    oldIndex = rowIndex;
                    uniqueIndex = settings._rowOrder[rowIndex];
                } else if (langx.isNumeric(uniqueIndex)) {
                    oldIndex = findRowIndex(uniqueIndex, settings);
                }
                if (oldIndex != null && oldIndex > 0) {
                    // Get row to swap
                    trTarget = document.getElementById(settings.idPrefix + '_Row_' + uniqueIndex, tbWhole);
                    trSwap = document.getElementById(settings.idPrefix + '_Row_' + settings._rowOrder[oldIndex - 1], tbWhole);
                    // Get the sub panel row if used
                    if (settings.useSubPanel) {
                        trAdtTarget = document.getElementById(settings.idPrefix + '_SubRow_' + uniqueIndex, tbWhole);
                    }
                    // Remove current row
                    tbBody.removeChild(trTarget);
                    if (settings.useSubPanel) {
                        tbBody.removeChild(trAdtTarget);
                    }
                    // Insert before the above row
                    tbBody.insertBefore(trTarget, trSwap);
                    if (settings.useSubPanel) {
                        tbBody.insertBefore(trAdtTarget, trSwap);
                    }
                    // Update rowOrder
                    settings._rowOrder[oldIndex] = settings._rowOrder[oldIndex - 1];
                    settings._rowOrder[oldIndex - 1] = uniqueIndex;
                    // Update row label
                    swapSeq = $('td.first', trSwap).html();
                    $('td.first', trSwap).html($('td.first', trTarget).html());
                    $('td.first', trTarget).html(swapSeq)
                    // Save setting
                    this._saveSetting(settings);
                    // Change focus
                    $('td.last button.moveUp', trTarget).removeClass('ui-state-hover').blur();
                    $('td.last button.moveUp', trSwap).focus();
                    // Trigger event
                    if (settings.afterRowSwapped) {
                        settings.afterRowSwapped(tbWhole, oldIndex, oldIndex - 1);
                    }
                }
            }
            return target;
        },
        moveDownRow: function (rowIndex, uniqueIndex) {
            var settings = this._checkGridAndGetSettings(), target = this;
            if (settings) {
                var tbWhole = target[0], trTarget, trSwap, trAdtSwap, swapSeq, oldIndex = null;
                var tbBody = tbWhole.getElementsByTagName('tbody')[0];
                if (langx.isNumeric(rowIndex) && rowIndex >= 0 && rowIndex < settings._rowOrder.length - 1) {
                    oldIndex = rowIndex;
                    uniqueIndex = settings._rowOrder[rowIndex];
                } else if (langx.isNumeric(uniqueIndex)) {
                    oldIndex = findRowIndex(uniqueIndex, settings);
                }
                if (oldIndex != null && oldIndex != settings._rowOrder.length - 1) {
                    // Get row to swap
                    trTarget = document.getElementById(settings.idPrefix + '_Row_' + uniqueIndex, tbWhole);
                    trSwap = document.getElementById(settings.idPrefix + '_Row_' + settings._rowOrder[oldIndex + 1], tbWhole);
                    // Get the sub panel row if used
                    if (settings.useSubPanel) {
                        trAdtSwap = document.getElementById(settings.idPrefix + '_SubRow_' + settings._rowOrder[oldIndex + 1], tbWhole);
                    }
                    // Remove current row
                    tbBody.removeChild(trSwap);
                    // Insert before the above row
                    tbBody.insertBefore(trSwap, trTarget);
                    if (settings.useSubPanel) {
                        tbBody.insertBefore(trAdtSwap, trTarget);
                    }
                    // Update rowOrder
                    settings._rowOrder[oldIndex] = settings._rowOrder[oldIndex + 1];
                    settings._rowOrder[oldIndex + 1] = uniqueIndex;
                    // Update row label
                    swapSeq = $('td.first', trSwap).html();
                    $('td.first', trSwap).html($('td.first', trTarget).html());
                    $('td.first', trTarget).html(swapSeq)
                    // Save setting
                    this._saveSetting(settings);
                    // Change focus
                    $('td.last button.moveDown', trTarget).removeClass('ui-state-hover').blur();
                    $('td.last button.moveDown', trSwap).focus();
                    // Trigger event
                    if (settings.afterRowSwapped) {
                        settings.afterRowSwapped(tbWhole, oldIndex, oldIndex + 1);
                    }
                }
            }
            return target;
        },
        showColumn: function (name) {
            var settings = this._checkGridAndGetSettings();
            if (settings && name) {
                // Find column index
                var colIndex = -1, tbWhole = this[0];
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name == name) {
                        colIndex = z;
                        break;
                    }
                }
                // Make sure the column exist and show the column if it is invisible only
                if (colIndex != -1 && settings.columns[colIndex].invisible) {
                    // Change caption and footer column span
                    settings._visibleCount++;
                    settings._finalColSpan++;
                    $('#' + settings.idPrefix + '_caption_td').attr('colSpan', settings._finalColSpan);
                    $('#' + settings.idPrefix + '_footer_td').attr('colSpan', settings._finalColSpan);
                    // Remove invisible class on each row
                    $('#' + settings.idPrefix + '_' + name + '_td_head').removeClass('invisible');
                    for (var z = 0; z < settings._rowOrder.length; z++) {
                        var uniqueIndex = settings._rowOrder[z];
                        $('#' + settings.idPrefix + '_' + name + '_td_' + uniqueIndex).removeClass('invisible');
                        if (settings.useSubPanel) {
                            $('#' + settings.idPrefix + '_SubRow_' + uniqueIndex).attr('colSpan', settings._visibleCount + (settings._hideLastColumn ? 0 : 1));
                        }
                    }
                    // Save changes
                    settings.columns[colIndex].invisible = false;
                    this._saveSetting(settings);
                }
            }
            return this;
        },
        hideColumn: function (name) {
            var settings = this._checkGridAndGetSettings();
            if (settings && name) {
                // Find column index
                var colIndex = -1, tbWhole = this[0];
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name == name) {
                        colIndex = z;
                        break;
                    }
                }
                // Make sure the column exist and hide the column if it is visible only
                if (colIndex != -1 && !settings.columns[colIndex].invisible) {
                    // Change caption and footer column span
                    settings._visibleCount--;
                    settings._finalColSpan--;
                    $('#' + settings.idPrefix + '_caption_td').attr('colSpan', settings._finalColSpan);
                    $('#' + settings.idPrefix + '_footer_td').attr('colSpan', settings._finalColSpan);
                    // Add invisible class on each row
                    $('#' + settings.idPrefix + '_' + name + '_td_head').addClass('invisible');
                    for (var z = 0; z < settings._rowOrder.length; z++) {
                        var uniqueIndex = settings._rowOrder[z];
                        $('#' + settings.idPrefix + '_' + name + '_td_' + uniqueIndex).addClass('invisible');
                        if (settings.useSubPanel) {
                            $('#' + settings.idPrefix + '_SubRow_' + uniqueIndex).attr('colSpan', settings._visibleCount + (settings._hideLastColumn ? 0 : 1));
                        }
                    }
                    // Save changes
                    settings.columns[colIndex].invisible = true;
                    this._saveSetting(settings);
                }
            }
            return this;
        },
        isColumnInvisible: function (name) {
            var settings = this._checkGridAndGetSettings();
            if (settings && name) {
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name == name) {
                        return settings.columns[z].invisible;
                    }
                }
            }
            return null;
        },
        getRowCount: function () {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                return settings._rowOrder.length;
            }
            return null;
        },
        getUniqueIndex: function (rowIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings && langx.isNumeric(rowIndex) && rowIndex < settings._rowOrder.length) {
                return settings._rowOrder[rowIndex];
            }
            return null;
        },
        getRowIndex: function (uniqueIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings && langx.isNumeric(uniqueIndex)) {
                for (var z = 0; z < settings._rowOrder.length; z++) {
                    if (settings._rowOrder[z] == uniqueIndex) {
                        return z;
                    }
                }
            }
            return null;
        },
        getRowValue: function (rowIndex, uniqueIndex, loopIndex) {
            var settings = this._checkGridAndGetSettings(), result = null;
            if (settings) {
                if (langx.isNumeric(rowIndex) && rowIndex >= 0 && rowIndex < settings._rowOrder.length) {
                    uniqueIndex = settings._rowOrder[rowIndex];
                }
                if (!isEmpty(uniqueIndex)) {
                    result = getRowValue(settings, uniqueIndex, loopIndex);
                }
            }
            return result;
        },
        getAllValue: function (objectMode) {
            var settings = this._checkGridAndGetSettings(), result = null;
            if (settings) {
                // Prepare result based on objectMode setting
                result = objectMode ? {} : [];
                // Process on each rows
                for (var z = 0; z < settings._rowOrder.length; z++) {
                    if (objectMode) {
                        rowValue = getRowValue(settings, settings._rowOrder[z], z);
                        langx.extend(result, rowValue)
                    } else {
                        rowValue = getRowValue(settings, settings._rowOrder[z]);
                        result.push(rowValue);
                    }
                }
                if (objectMode) {
                    result[settings.rowCountName] = settings._rowOrder.length;
                }
            }
            return result;
        },
        getCtrlValue: function (name, rowIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings && rowIndex >= 0 && rowIndex < settings._rowOrder.length) {
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name === name) {
                        return getCtrlValue(settings, z, settings._rowOrder[rowIndex]);
                    }
                }
            }
            return null;
        },
        setCtrlValue: function (name, rowIndex, value) {
            var settings = this._checkGridAndGetSettings();
            if (settings && rowIndex >= 0 && rowIndex < settings._rowOrder.length) {
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name == name) {
                        setCtrlValue(settings, z, settings._rowOrder[rowIndex], value);
                        break;
                    }
                }
            }
            return this;
        },
        getCellCtrl: function (name, rowIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings && rowIndex >= 0 && rowIndex < settings._rowOrder.length) {
                var uniqueIndex = settings._rowOrder[rowIndex];
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name === name) {
                        return getCellCtrl(settings.columns[z].type, settings.idPrefix, name, uniqueIndex);
                    }
                }
            }
            return null;
        },
        getCellCtrlByUniqueIndex: function (name, uniqueIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                for (var z = 0; z < settings.columns.length; z++) {
                    if (settings.columns[z].name === name) {
                        return getCellCtrl(settings.columns[z].type, settings.idPrefix, name, uniqueIndex);
                    }
                }
            }
            return null;
        },
        getRowOrder: function () {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                // Return a copy of `Row Order` array
                return settings._rowOrder.slice();
            }
            return null;
        },
        getColumns: function () {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                // Return a copy of the columns array
                return settings.columns.slice();
            }
            return null;
        },
        isRowEmpty: function (rowIndex) {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                return isRowEmpty(settings, rowIndex);
            }
            return null;
        },
        removeEmptyRows: function () {
            var settings = this._checkGridAndGetSettings();
            if (settings) {
                var tbWhole = this[0];
                for (var z = settings._rowOrder.length; z >= 0; z--) {
                    if (isRowEmpty(settings, z)) {
                        // Remove itself
                        this._removeRow( null, settings._rowOrder[z], true);
                    }
                }
                return this;
            }
            return null;
        }



    });
    // The default initial options.
    var _defaultInitOptions = {
        // The text as table caption, set null to disable caption generation.
        caption: null,
        // Tooltip for caption.
        captionTooltip: null,
        // The total number of empty rows generated when init the grid. This will be ignored if `initData` is assigned.
        initRows: 3,
        // The maximum number of rows allowed in this grid.
        maxRowsAllowed: 0,
        // An array of data to be filled after initialized the grid.
        initData: null,
        // Array of column options.
        columns: null,
        // Labels or messages used in grid.
        i18n: null,
        // The ID prefix of controls generated inside the grid. Table ID will be used if not defined.
        idPrefix: null,
        // Enable row dragging by using jQuery UI sortable on grid rows.
        rowDragging: false,
        // Hide the buttons at the end of rows or bottom of grid.
        hideButtons: null,
        // Hide the row number column.
        hideRowNumColumn: false,
        // Generate row buttom column in the front of input columns.
        rowButtonsInFront: false,
        // The variable name of row count used for object mode of getAllValue
        rowCountName: '_RowCount',
        // The extra class names for buttons.
        buttonClasses: null,
        // The extra class names for table sections.
        sectionClasses: null,
        // Custom the standard grid buttons.
        customGridButtons: null,
        // Adding extra button(s) at the end of rows.
        customRowButtons: null,
        // Adding extra button(s) at the bottom of grid.
        customFooterButtons: null,
        // Use the sub panel or not
        useSubPanel: false,
        // Maintain the scroll position after appended or removed last row.
        maintainScroll: false,
        // The maximum height of grid content, scroll bar will be display when the height is greater than this value.
        maxBodyHeight: 0,
        // Auto calculate the column width when scroll bar on table body is in use.
        autoColumnWidth: true
    };
    var _defaultCallbackContainer = {
        // The callback function for format the HTML name of generated controls.
        nameFormatter: null,
        // The callback function to be triggered after all data loaded to grid.
        dataLoaded: null,
        // The callback function to be triggered after data loaded to a row.
        rowDataLoaded: null,
        // The callback function to be triggered after new row appended.
        afterRowAppended: null,
        // The callback function to be triggered after new row inserted.
        afterRowInserted: null,
        // The callback function to be triggered after grid row swapped.
        afterRowSwapped: null,
        // The callback function to be triggered before grid row remove.
        beforeRowRemove: null,
        // The callback function to be triggered after grid row removed.
        afterRowRemoved: null,
        // The callback function to be triggered after grid row dragged.
        afterRowDragged: null,
        // The callback function for generating sub panel content.
        subPanelBuilder: null,
        // The callback function for getting values from sub panel. Used for `getAllValue` method.
        subPanelGetter: null,
        // The callback function to be triggered when row(s) is/are adding to grid but the maximum number of rows allowed is reached.
        maxNumRowsReached: null
    };
    // Default column options.
    var _defaultColumnOptions = {
        // Type of column control.
        type: 'text',
        // Name of column.
        name: null,
        // Default value.
        value: null,
        // Display text on the header section.
        display: null,
        // Extra CSS setting to be added to display text.
        displayCss: null,
        // Tooltip for column head.
        displayTooltip: null,
        // The `colspan` setting on the column header.
        headerSpan: 1,
        // Extra CSS setting to be added to the control container table cell.
        cellCss: null,
        // Extra attributes to be added to the control.
        ctrlAttr: null,
        // Extra properties to be added to the control.
        ctrlProp: null,
        // Extra CSS to be added to the control.
        ctrlCss: null,
        // Extra name of class to be added to the control.
        ctrlClass: null,
        // The available option for building `select` type control.
        ctrlOptions: null,
        // Options for initalize jQuery UI widget.
        uiOption: null,
        // Options for initalize jQuery UI tooltip.
        uiTooltip: null,
        // Let column resizable by using jQuery UI Resizable Interaction.
        resizable: false,
        // Show or hide column after initialized.
        invisible: false,
        // The value to compare for indentify this column value is empty.
        emptyCriteria: null,
        // Callback function to build custom type control.
        customBuilder: null,
        // Callback function to get control value.
        customGetter: null,
        // Callback function to set control value.
        customSetter: null,
        // The `OnClick` event callback of control.
        onClick: null,
        // The `OnChange` event callback of control.
        onChange: null
    };
    var _systemMessages = {
        noColumnInfo: 'Cannot initial grid without column information!',
        elemNotTable: 'Cannot initial grid on element other than TABLE!',
        notInit: '`appendGrid` does not initialized',
        getValueMultiGrid: 'Cannot get values on multiple grid',
        notSupportMethod: 'Method is not supported by `appendGrid`: '
    };
    var _defaultTextResources = {
        append: 'Append Row',
        removeLast: 'Remove Last Row',
        insert: 'Insert Row Above',
        remove: 'Remove Current Row',
        moveUp: 'Move Up',
        moveDown: 'Move Down',
        rowDrag: 'Sort Row',
        rowEmpty: 'This Grid Is Empty'
    };
    var _defaultButtonClasses = { append: null, removeLast: null, insert: null, remove: null, moveUp: null, moveDown: null, rowDrag: null };
    var _defaultSectionClasses = { caption: null, header: null, body: null, subPanel: null, footer: null };
    var _defaultHideButtons = { append: false, removeLast: false, insert: false, remove: false, moveUp: false, moveDown: false };


    function makeCustomBottomButton(tbWhole, buttonCfg) {
        var exButton = $('<button/>').attr({ type: 'button', tabindex: -1 })
        .button(buttonCfg.uiButton).click({ tbWhole: tbWhole }, buttonCfg.click);
        if (buttonCfg.btnClass) exButton.addClass(buttonCfg.btnClass);
        if (buttonCfg.btnCss) exButton.css(buttonCfg.btnCss);
        if (buttonCfg.btnAttr) exButton.attr(buttonCfg.btnAttr);
        return exButton;
    }
    function makeCustomRowButton(tbWhole, buttonCfg, uniqueIndex) {
        var exButton = $('<button/>').val(uniqueIndex).attr({ type: 'button', tabindex: -1 })
        .button(buttonCfg.uiButton).click({ tbWhole: tbWhole, uniqueIndex: uniqueIndex }, function (evt) {
            var rowData = $(evt.data.tbWhole).plugin("lark.tabular").getRowValue(null, evt.data.uniqueIndex);
            buttonCfg.click(evt, evt.data.uniqueIndex, rowData);
        });
        if (buttonCfg.btnClass) exButton.addClass(buttonCfg.btnClass);
        if (buttonCfg.btnCss) exButton.css(buttonCfg.btnCss);
        if (buttonCfg.btnAttr) exButton.attr(buttonCfg.btnAttr);
        return exButton;
    }




    function findRowIndex(uniqueIndex, settings) {
        for (var z = 0; z < settings._rowOrder.length; z++) {
            if (settings._rowOrder[z] == uniqueIndex) {
                return z;
            }
        }
        return null;
    }
    function isEmpty(value) {
        return typeof (value) == 'undefined' || value == null;
    }
    function getObjValue(obj, key) {
        if (!isEmpty(obj) && langx.isPlainObject(obj) && !isEmpty(obj[key])) {
            return obj[key];
        }
        return null;
    }
    function getRowIndex(settings, uniqueIndex) {
        var rowIndex = null;
        for (var z = 0; z < settings._rowOrder.length; z++) {
            if (settings._rowOrder[z] == uniqueIndex) {
                return z;
            }
        }
        return rowIndex;
    }
    function getRowValue(settings, uniqueIndex, loopIndex) {
        var result = {}, keyName = null, suffix = (isEmpty(loopIndex) ? '' : '_' + loopIndex);
        for (var z = 0; z < settings.columns.length; z++) {
            keyName = settings.columns[z].name + suffix;
            result[keyName] = getCtrlValue(settings, z, uniqueIndex);
        }
        // Merge control values from sub panel if getter method defined
        if (settings.useSubPanel && langx.isFunction(settings.subPanelGetter)) {
            var adtData = settings.subPanelGetter(uniqueIndex);
            if (langx.isPlainObject(adtData)) {
                if (suffix == '') {
                    // Extend to row data directly for array mode
                    langx.extend(result, adtData);
                } else {
                    // For returning values in object mode, add suffix to all keys
                    var newData = {};
                    for (var key in adtData) {
                        newData[key + suffix] = adtData[key];
                    }
                    langx.extend(result, newData);
                }
            }
        }
        return result;
    }
    function getCtrlValue(settings, colIndex, uniqueIndex) {
        var type = settings.columns[colIndex].type, columnName = settings.columns[colIndex].name;
        if (type == 'custom') {
            if (langx.isFunction(settings.columns[colIndex].customGetter)) {
                return settings.columns[colIndex].customGetter(settings.idPrefix, columnName, uniqueIndex);
            } else {
                return null;
            }
        } else {
            var ctrl = getCellCtrl(type, settings.idPrefix, columnName, uniqueIndex);
            if (ctrl == null) {
                return null;
            }
            else if (type == 'checkbox') {
                return ctrl.checked ? 1 : 0;
            } else {
                return $(ctrl).val();
            }
        }
    }
    function getCellCtrl(type, idPrefix, columnName, uniqueIndex) {
        return document.getElementById(idPrefix + '_' + columnName + '_' + uniqueIndex);
    }
    function setCtrlValue(settings, colIndex, uniqueIndex, data) {
        var type = settings.columns[colIndex].type;
        var columnName = settings.columns[colIndex].name;
        // Handle values by type
        if (type == 'custom') {
            if (langx.isFunction(settings.columns[colIndex].customSetter)) {
                settings.columns[colIndex].customSetter(settings.idPrefix, columnName, uniqueIndex, data);
            } else {
                // `customSetter` is not a function?? Skip handling...
            }
        } else {
            var element = getCellCtrl(type, settings.idPrefix, columnName, uniqueIndex);
            if (type == 'checkbox') {
                element.checked = (data != null && data != 0);
            } else if (type == 'ui-selectmenu') {
                element.value = (data == null ? '' : data);
                $(element).selectmenu('refresh');
            }
            else {
                $(element).val(data == null ? '' : data);
            }
        }
    }


    function isRowEmpty(settings, rowIndex) {
        for (var z = 0; z < settings.columns.length; z++) {
            var uniqueIndex = settings._rowOrder[rowIndex];
            var currentValue = getCtrlValue(settings, z, uniqueIndex);
            // Check the empty criteria is function
            if (langx.isFunction(settings.columns[z].emptyCriteria)) {
                if (!settings.columns[z].emptyCriteria(currentValue)) {
                    return false;
                }
            } else {
                // Find the default value
                var defaultValue = null;
                if (!isEmpty(settings.columns[z].emptyCriteria)) {
                    defaultValue = settings.columns[z].emptyCriteria;
                } else {
                    // Check default value based on its type
                    if (settings.columns[z].type == 'checkbox') {
                        defaultValue = 0;
                    } else if (settings.columns[z].type == 'select' || settings.columns[z].type == 'ui-selectmenu') {
                        var options = getCellCtrl(settings.columns[z].type, settings.idPrefix, settings.columns[z].name, uniqueIndex).options;
                        if (options.length > 0) {
                            defaultValue = options[0].value;
                        } else {
                            defaultValue = '';
                        }
                    } else {
                        defaultValue = '';
                    }
                }
                // Compare with the default value
                if (currentValue != defaultValue) {
                    return false;
                }
            }
        }
        return true;
    }


    /*
    /// <summary>
    /// Initialize append grid or calling its methods.
    /// </summary>
    $.fn.appendGrid = function (params) {
        if (_methods[params]) {
            return _methods[params].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof (params) === 'object' || !params) {
            return _methods.init.apply(this, arguments);
        } else {
            alert(_systemMessages.notSupportMethod + params);
        }
    };
    */

    return Tabular ;
});

define('skylark-widgets-swt/TabStrip',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "./swt",
    "./Widget",
    "skylark-bootstrap3/tab",
    "skylark-bootstrap3/dropdown"
], function(langx, browser, eventer, noder, geom,  $, swt, Widget) {

    var TabStrip = Widget.inherit({
        klassName : "TabStrip",
        pluginName : "lark.tabstrip",

        options : {
          selectors : {
            header : ".nav-tabs",
            tab : "[data-toggle=\"tab\"]",
            content : ".tab-content",
            tabpane : ".tab-pane"
          },

          droptabs : {
            selectors : {
              dropdown : "li.droptabs",
              dropdownMenu    : "ul.dropdown-menu",
              dropdownTabs    : "li",
              dropdownCaret   : "b.caret",
              visibleTabs     : ">li:not(.dropdown)",
            },
            auto              : true,
            pullDropdownRight : true,


          }
        },

        _init : function() {
          this.$header = this._velm.$(this.options.selectors.header); 
          this.$tabs = this.$header.find(this.options.selectors.tab);
          this.$content = this._velm.$(this.options.selectors.content);
          this.$tabpanes = this.$content.find(this.options.selectors.tabpane);

          this.$header.find('[data-toggle="dropdown"]').dropdown();

          var self = this;
          this.$tabs.each(function(idx,tabEl){
            $(tabEl).tab({
              target : self.$tabpanes[idx]
            });
          });

        },

        arrange : function () {

          var dropdownTabsSelector = this.options.droptabs.selectors.dropdownTabs,
              visibleTabsSelector = this.options.droptabs.selectors.visibleTabs;

              $container = this.$header;
          var dropdown = $container.find(this.options.droptabs.selectors.dropdown);
          var dropdownMenu = dropdown.find(this.options.droptabs.selectors.dropdownMenu);
          var dropdownLabel = $('>a', dropdown).clone();
          var dropdownCaret = $(this.options.droptabs.selectors.dropdownCaret, dropdown);

          // We only want the default label, strip the caret out
          $(this.options.droptabs.selectors.dropdownCaret, dropdownLabel).remove();

          if (this.options.droptabs.pullDropdownRight) {
            $(dropdown).addClass('pull-right');
          }

          var $dropdownTabs = function () {
            return $(dropdownTabsSelector, dropdownMenu);
          }

          var $visibleTabs = function () {
            return $(visibleTabsSelector, $container);
          }

          function getFirstHiddenElementWidth() {
            var tempElem=$dropdownTabs().first().clone().appendTo($container).css("position","fixed");
            var hiddenElementWidth = $(tempElem).outerWidth();
            $(tempElem).remove();
            return hiddenElementWidth;
          }

          function getHiddenElementWidth(elem) {
            var tempElem=$(elem).clone().appendTo($container).css("position","fixed");
            var hiddenElementWidth = $(tempElem).outerWidth();
            $(tempElem).remove();
            return hiddenElementWidth;
          }

          function getDropdownLabel() {
            var labelText = 'Dropdown';
            if ($(dropdown).hasClass('active')) {
              labelText = $('>li.active>a', dropdownMenu).html();
            } else if (dropdownLabel.html().length > 0) {
              labelText = dropdownLabel.html();
            }

            labelText = $.trim(labelText);

            if (labelText.length > 10) {
              labelText = labelText.substring(0, 10) + '...';
            }

            return labelText;
          }

          function renderDropdownLabel() {
            $('>a', dropdown).html(getDropdownLabel() + ' ' + dropdownCaret.prop('outerHTML'));
          }

          function manageActive(elem) {
            //fixes a bug where Bootstrap can't remove the 'active' class on elements after they've been hidden inside the dropdown
            $('a', $(elem)).on('show.bs.tab', function (e) {
              $(e.relatedTarget).parent().removeClass('active');
            })
            $('a', $(elem)).on('shown.bs.tab', function (e) {
              renderDropdownLabel();
            })

          }

          function checkDropdownSelection() {
            if ($($dropdownTabs()).filter('.active').length > 0) {
              $(dropdown).addClass('active');
            } else {
              $(dropdown).removeClass('active');
            }

            renderDropdownLabel();
          }


          var visibleTabsWidth = function () {
            var visibleTabsWidth = 0;
            $($visibleTabs()).each(function( index ) {
              visibleTabsWidth += parseInt($(this).outerWidth(), 10);
            });
            visibleTabsWidth = visibleTabsWidth + parseInt($(dropdown).outerWidth(), 10);
            return visibleTabsWidth;
          }

          var availableSpace = function () {
            return $container.outerWidth()-visibleTabsWidth();
          }

          if (availableSpace()<0) {//we will hide tabs here
            var x = availableSpace();
            $($visibleTabs().get().reverse()).each(function( index ){
              if (!($(this).hasClass('always-visible'))){
                  $(this).prependTo(dropdownMenu);
                  x=x+$(this).outerWidth();
              }
              if (x>=0) {return false;}
            });
          }

          if (availableSpace()>getFirstHiddenElementWidth()) { //and here we bring the tabs out
            var x = availableSpace();
            $($dropdownTabs()).each(function( index ){
              if (getHiddenElementWidth(this) < x && !($(this).hasClass('always-dropdown'))){
                $(this).appendTo($container);
                x = x-$(this).outerWidth();
              } else {return false;}
             });

            if (!this.options.droptabs.pullDropdownRight && !$(dropdown).is(':last-child')) {
              // If not pulling-right, keep the dropdown at the end of the container.
              $(dropdown).detach().insertAfter($container.find('li:last-child'));
            }
          }

          if ($dropdownTabs().length <= 0) {
            dropdown.hide();
          } else {
            dropdown.show();
          }
        },

        add : function() {
          //TODO
        },

        remove : function(){
          //TODO
        }
    });





    return swt.TabStrip = TabStrip;

});
define('skylark-widgets-swt/Toolbar',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-widgets-base/Widget"
],function(langx,$,Widget){ 



  var Toolbar = Widget.inherit({
    pluginName : "lark.toolbar",

    options : {
      toolbarFloat: true,
      toolbarHidden: false,
      toolbarFloatOffset: 0,
      template : '<div class="lark-toolbar"><ul></ul></div>',
      separator : {
        template :  '<li><span class="separator"></span></li>'
      }
    },

    _init : function() {
      var floatInitialized, initToolbarFloat, toolbarHeight;
      //this.editor = editor;

      //this.opts = langx.extend({}, this.opts, opts);
      this.opts = this.options;


      //if (!langx.isArray(this.opts.toolbar)) {
      //  this.opts.toolbar = ['bold', 'italic', 'underline', 'strikethrough', '|', 'ol', 'ul', 'blockquote', 'code', '|', 'link', 'image', '|', 'indent', 'outdent'];
      //}

      this.wrapper = $(this._elm);
      this.list = this.wrapper.find('ul');
      this.list.on('click', function(e) {
        return false;
      });
      this.wrapper.on('mousedown', (function(_this) {
        return function(e) {
          return _this.list.find('.menu-on').removeClass('.menu-on');
        };
      })(this));
      $(document).on('mousedown.toolbar', (function(_this) {
        return function(e) {
          return _this.list.find('.menu-on').removeClass('menu-on');
        };
      })(this));
      if (!this.opts.toolbarHidden && this.opts.toolbarFloat) {
        this.wrapper.css('top', this.opts.toolbarFloatOffset);
        toolbarHeight = 0;
        initToolbarFloat = (function(_this) {
          return function() {
            _this.wrapper.css('position', 'static');
            _this.wrapper.width('auto');
            _this.editor.editable.util.reflow(_this.wrapper);
            _this.wrapper.width(_this.wrapper.outerWidth());
            _this.wrapper.css('left', _this.editor.editable.util.os.mobile ? _this.wrapper.position().left : _this.wrapper.offset().left);
            _this.wrapper.css('position', '');
            toolbarHeight = _this.wrapper.outerHeight();
            _this.editor.placeholderEl.css('top', toolbarHeight);
            return true;
          };
        })(this);
        floatInitialized = null;

        /*
        $(window).on('resize.richeditor-' + this.editor.id, function(e) {
          return floatInitialized = initToolbarFloat();
        });
        $(window).on('scroll.richeditor-' + this.editor.id, (function(_this) {
          return function(e) {
            var bottomEdge, scrollTop, topEdge;
            if (!_this.wrapper.is(':visible')) {
              return;
            }
            topEdge = _this.editor.wrapper.offset().top;
            bottomEdge = topEdge + _this.editor.wrapper.outerHeight() - 80;
            scrollTop = $(document).scrollTop() + _this.opts.toolbarFloatOffset;
            if (scrollTop <= topEdge || scrollTop >= bottomEdge) {
              _this.editor.wrapper.removeClass('toolbar-floating').css('padding-top', '');
              if (_this.editor.editable.util.os.mobile) {
                return _this.wrapper.css('top', _this.opts.toolbarFloatOffset);
              }
            } else {
              floatInitialized || (floatInitialized = initToolbarFloat());
              _this.editor.wrapper.addClass('toolbar-floating').css('padding-top', toolbarHeight);
              if (_this.editor.editable.util.os.mobile) {
                return _this.wrapper.css('top', scrollTop - topEdge + _this.opts.toolbarFloatOffset);
              }
            }
          };
        })(this));
        */
      }

      /*
      this.editor.on('destroy', (function(_this) {
        return function() {
          return _this.buttons.length = 0;
        };
      })(this));
      */

      
    },

    addToolItem : function(itemWidget) {
      $(itemWidget._elm).appendTo(this.list);
      return this;
    },

    addSeparator : function() {
      $(this.options.separator.template).appendTo(this.list);
      return this;
    }

  });


  return Toolbar;

});
define('skylark-widgets-swt/main',[
    "./swt",
    "./Widget",
    "./Accordion",
    "./Button",
    "./Carousel",
    "./CheckBox",
    "./ComboBox",
    "./TextBox",
    "./Listing",
    "./Pagination",
    "./Progress",
    "./Radio",
    "./SearchBox",
    "./SelectList",
    "./Tabular",
    "./TabStrip",
    "./TextBox",
    "./Toolbar"
], function(swt) {
    return swt;
});
define('skylark-widgets-swt', ['skylark-widgets-swt/main'], function (main) { return main; });

define('skylark-widgets-shells/main',[
	"./shells",
	"./Shell",
	"skylark-bootstrap3",
	"skylark-widgets-swt",
	"skylark-visibility"
],function(shells){
	return shells;
});
define('skylark-widgets-shells', ['skylark-widgets-shells/main'], function (main) { return main; });

define('skylark-domx-forms/forms',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("domx.forms",{});
});
define('skylark-domx-forms/deserialize',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./forms"
],function(langx,$,forms){
  /**
   * Updates a key/valueArray with the given property and value. Values will always be stored as arrays.
   *
   * @param prop The property to add the value to.
   * @param value The value to add.
   * @param obj The object to update.
   * @returns {object} Updated object.
   */
  function updateKeyValueArray( prop, value, obj ) {
    var current = obj[ prop ];

    if ( current === undefined ) {
      obj[ prop ] = [ value ];
    } else {
      current.push( value );
    }

    return obj;
  }

  /**
   * Get all of the fields contained within the given elements by name.
   *
   * @param formElm The form element.
   * @param filter Custom filter to apply to the list of fields.
   * @returns {object} All of the fields contained within the given elements, keyed by name.
   */
  function getFieldsByName(formElm, filter ) {
    var elementsByName = {};

    // Extract fields from elements
    var fields = $(formElm)
      .map(function convertFormToElements() {
        return this.elements ? langx.makeArray( this.elements ) : this;
      })
      .filter( filter || ":input:not(:disabled)" )
      .get();

    langx.each( fields, function( index, field ) {
      updateKeyValueArray( field.name, field, elementsByName );
    });

    return elementsByName;
  }

  /**
   * Figure out the type of an element. Input type will be used first, falling back to nodeName.
   *
   * @param element DOM element to check type of.
   * @returns {string} The element's type.
   */
  function getElementType( element ) {
    return ( element.type || element.nodeName ).toLowerCase();
  }

  /**
   * Normalize the provided data into a key/valueArray store.
   *
   * @param data The data provided by the user to the plugin.
   * @returns {object} The data normalized into a key/valueArray store.
   */
  function normalizeData( data ) {
    var normalized = {};
    var rPlus = /\+/g;

    // Convert data from .serializeObject() notation
    if ( langx.isPlainObject( data ) ) {
      langx.extend( normalized, data );

      // Convert non-array values into an array
      langx.each( normalized, function( name, value ) {
        if ( !langx.isArray( value ) ) {
          normalized[ name ] = [ value ];
        }
      });

    // Convert data from .serializeArray() notation
    } else if ( langx.isArray( data ) ) {
      langx.each( data, function( index, field ) {
        updateKeyValueArray( field.name, field.value, normalized );
      });

    // Convert data from .serialize() notation
    } else if ( typeof data === "string" ) {
      langx.each( data.split( "&" ), function( index, field ) {
        var current = field.split( "=" );
        var name = decodeURIComponent( current[ 0 ].replace( rPlus, "%20" ) );
        var value = decodeURIComponent( current[ 1 ].replace( rPlus, "%20" ) );
        updateKeyValueArray( name, value, normalized );
      });
    }

    return normalized;
  }

  /**
   * Map of property name -> element types.
   *
   * @type {object}
   */
  var updateTypes = {
    checked: [
      "radio",
      "checkbox"
    ],
    selected: [
      "option",
      "select-one",
      "select-multiple"
    ],
    value: [
      "button",
      "color",
      "date",
      "datetime",
      "datetime-local",
      "email",
      "hidden",
      "month",
      "number",
      "password",
      "range",
      "reset",
      "search",
      "submit",
      "tel",
      "text",
      "textarea",
      "time",
      "url",
      "week"
    ]
  };

  /**
   * Get the property to update on an element being updated.
   *
   * @param element The DOM element to get the property for.
   * @returns The name of the property to update if element is supported, otherwise `undefined`.
   */
  function getPropertyToUpdate( element ) {
    var type = getElementType( element );
    var elementProperty = undefined;

    langx.each( updateTypes, function( property, types ) {
      if ( langx.inArray( type, types ) > -1 ) {
        elementProperty = property;
        return false;
      }
    });

    return elementProperty;
  }

  /**
   * Update the element based on the provided data.
   *
   * @param element The DOM element to update.
   * @param elementIndex The index of this element in the list of elements with the same name.
   * @param value The serialized element value.
   * @param valueIndex The index of the value in the list of values for elements with the same name.
   * @param callback A function to call if the value of an element was updated.
   */
  function update( element, elementIndex, value, valueIndex, callback ) {
    var property = getPropertyToUpdate( element );

    // Handle value inputs
    // If there are multiple value inputs with the same name, they will be populated by matching indexes.
    if ( property == "value" && elementIndex == valueIndex ) {
      element.value = value;
      callback.call( element, value );

    // Handle select menus, checkboxes and radio buttons
    } else if ( property == "checked" || property == "selected" ) {
      var fields = [];

      // Extract option fields from select menus
      if ( element.options ) {
        langx.each( element.options, function( index, option ) {
          fields.push( option );
        });

      } else {
        fields.push( element );
      }

      // #37: Remove selection from multiple select menus before deserialization
      if ( element.multiple && valueIndex == 0 ) {
        element.selectedIndex = -1;
      }

      langx.each( fields, function( index, field ) {
        if ( field.value == value ) {
          field[ property ] = true;
          callback.call( field, value );
        }
      });
    }
  }

  /**
   * Default plugin options.
   *
   * @type {object}
   */
  var defaultOptions = {
    change: langx.noop,
    complete: langx.noop
  };

  /**
   * The $.deserialize function.
   *
   * @param data The data to deserialize.
   * @param options Additional options.
   * @returns {jQuery} The jQuery object that was provided to the plugin.
   */
  function deserialize(formElm,data, options ) {

    // Backwards compatible with old arguments: data, callback
    if ( langx.isFunction( options ) ) {
      options = { complete: options };
    }

    options = langx.extend( defaultOptions, options || {} );
    data = normalizeData( data );

    var elementsByName = getFieldsByName( formElm, options.filter );

    langx.each( data, function( name, values ) {
      langx.each( elementsByName[ name ], function( elementIndex, element ) {
        langx.each( values, function( valueIndex, value ) {
          update( element, elementIndex, value, valueIndex, options.change );
        });
      });
    });

    options.complete.call( formElm );

    return this;
  };

  return forms.deserialize = deserialize;
});
define('skylark-domx-forms/serializeArray',[
  "skylark-langx/langx",
  "skylark-domx-data",
  "./forms"
],function(langx,datax,forms){
    function serializeArray(formElm) {
        var name, type, result = [],
            add = function(value) {
                if (value.forEach) return value.forEach(add)
                result.push({ name: name, value: value })
            }
        langx.each(formElm.elements, function(_, field) {
            type = field.type, name = field.name
            if (name && field.nodeName.toLowerCase() != 'fieldset' &&
                !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&
                ((type != 'radio' && type != 'checkbox') || field.checked))
                add(datax.val(field))
        })
        return result
    };

    return forms.serializeArray = serializeArray;
});

define('skylark-domx-forms/serializeObject',[
  "skylark-langx/langx",
  "./forms",
  "./serializeArray"
],function(langx,forms,serializeArray){

  function serializeObject(formElm){
    var obj = {};
    
    langx.each(serializeArray(formElm), function(i,o){
      var n = o.name,
        v = o.value;
        
        obj[n] = obj[n] === undefined ? v
          : langx.isArray( obj[n] ) ? obj[n].concat( v )
          : [ obj[n], v ];
    });
    
    return obj;
  }

  return forms.serializeObject = serializeObject;
});  
define('skylark-domx-forms/serialize',[
  "skylark-langx/langx",
  "./forms"
],function(langx,forms){
    function serialize(formElm) {
        var result = []
        serializeArray(formElm).forEach(function(elm) {
            result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))
        })
        return result.join('&')
    }

    return forms.serialize = serialize;
});
define('skylark-domx-forms/main',[
	"./forms",
    "skylark-domx-velm",
    "skylark-domx-query",
    "./deserialize",
    "./serializeArray",
    "./serializeObject",
    "./serialize"
],function(forms,velm,$){

    // from ./data
    velm.delegate([
        "deserialize",
        "serializeArray",
        "serializeObject",
        "serialize"
    ], forms);

    $.fn.deserialize = $.wraps.wrapper_value(forms.deserialize, forms, forms.deserialize);
    $.fn.serializeArray = $.wraps.wrapper_value(forms.serializeArray, forms, forms.serializeArray);
    $.fn.serializeObject = $.wraps.wrapper_value(forms.serializeObject, forms, forms.serializeObject);
    $.fn.serialize = $.wraps.wrapper_value(forms.serialize, forms, forms.serialize);


	return forms;
});
define('skylark-domx-forms', ['skylark-domx-forms/main'], function (main) { return main; });

define('skylark-jquery/core',[
	"skylark-langx/skylark",
	"skylark-langx/langx",
	"skylark-domx-browser",
	"skylark-domx-noder",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-finder",
	"skylark-domx-forms",
	"skylark-domx-fx",
	"skylark-domx-styler",
	"skylark-domx-query"
],function(skylark,langx,browser,noder,datax,eventer,finder,forms,fx,styler,query){
	var filter = Array.prototype.filter,
		slice = Array.prototype.slice;

    (function($){
	    $.fn.jquery = '2.2.0';

	    $.browser = browser;
	    
	    $.camelCase = langx.camelCase;

		$.cleanData = function( elems ) {
			var elem,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				datax.cleanData(elem);
			}
		};

		$.removeData = function(elm,name) {
			datax.removeData(elm,name);
		}
	
	    $.each = langx.each;

	    $.extend = langx.extend;

	    $.grep = function(elements, callback) {
	        return filter.call(elements, callback)
	    };

	    $.attr = function(elm,name) {
	    	return datax.attr(elm,name);
	    };

	    $.isArray = langx.isArray;
	    $.isEmptyObject = langx.isEmptyObject;
	    $.isFunction = langx.isFunction;
	    $.isWindow = langx.isWindow;
	    $.isPlainObject = langx.isPlainObject;
        $.isNumeric = langx.isNumber;

	    $.inArray = langx.inArray;

	    $.makeArray = langx.makeArray;
	    $.map = langx.map;  // The behavior is somewhat different from the original jquery.

	    $.noop = function() {
	    };

	    $.parseJSON = window.JSON.parse;

	    $.proxy = langx.proxy;

	    $.trim = langx.trim;
	    $.type = langx.type;

	    $.fn.extend = function(props) {
	        langx.mixin($.fn, props);
	    };


    })(query);

    (function($){
        $.Event = function Event(src, props) {
            if (langx.isString(src)) {
            	var type = src;
            	return eventer.create(type, props);
	        }
            return eventer.proxy(src, props);
        };

        $.event = {};

	    $.event.special = eventer.special;

	    $.fn.submit = function(callback) {
	        if (0 in arguments) this.bind('submit', callback)
	        else if (this.length) {
	            var event = $.Event('submit')
	            this.eq(0).trigger(event)
	            if (!event.isDefaultPrevented()) this.get(0).submit()
	        }
	        return this
	    };

	    // event
	    $.fn.triggerHandler = $.fn.trigger;

	    $.fn.delegate = function(selector, event, callback) {
	        return this.on(event, selector, callback)
	    };

	    $.fn.undelegate = function(selector, event, callback) {
	        return this.off(event, selector, callback)
	    };

	    $.fn.live = function(event, callback) {
	        $(document.body).delegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.die = function(event, callback) {
	        $(document.body).undelegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.bind = function(event, selector, data, callback) {
	        return this.on(event, selector, data, callback)
	    };

	    $.fn.unbind = function(event, callback) {
	        return this.off(event, callback)
	    };

	    $.fn.ready = function(callback) {
	        eventer.ready(callback);
	        return this;
	    };

	    $.fn.stop = function() {
	        // todo
	        return this;
	    };

	    $.fn.moveto = function(x, y) {
	        return this.animate({
	            left: x + "px",
	            top: y + "px"
	        }, 0.4);

	    };

	    $.ready = eventer.ready;

	    $.on = eventer.on;

	    $.off = eventer.off;
    })(query);

    (function($){
	    // plugin compatibility
	    $.uuid = 0;
	    $.support = browser.support;
	    $.expr = {};

	    $.expr[":"] = $.expr.pseudos = $.expr.filters = finder.pseudos;

	    $.expr.createPseudo = function(fn) {
	    	return fn;
	    };

	    $.cssHooks = styler.cssHooks;

	    $.contains = noder.contains;

	    $.css = styler.css;

	    $.data = datax.data;

	    $.fx = fx;
	    $.fx.step = {

        };

        $.speed = function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? $.extend( {}, speed ) : {
                complete: fn || !fn && easing ||
                    $.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !$.isFunction( easing ) && easing
            };

            // Go to the end state if fx are off
            if ( $.fx.off ) {
                opt.duration = 0;

            } else {
                if ( typeof opt.duration !== "number" ) {
                    if ( opt.duration in $.fx.speeds ) {
                        opt.duration = $.fx.speeds[ opt.duration ];

                    } else {
                        opt.duration = $.fx.speeds._default;
                    }
                }
            }

            // Normalize opt.queue - true/undefined/null -> "fx"
            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }

            // Queueing
            opt.old = opt.complete;

            opt.complete = function() {
                if ( $.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue ) {
                    $.dequeue( this, opt.queue );
                }
            };

            return opt;
        };

        $.easing = {};

	    $.offset = {};
	    $.offset.setOffset = function(elem, options, i) {
	        var position = $.css(elem, "position");

	        // set position first, in-case top/left are set even on static elem
	        if (position === "static") {
	            elem.style.position = "relative";
	        }

	        var curElem = $(elem),
	            curOffset = curElem.offset(),
	            curCSSTop = $.css(elem, "top"),
	            curCSSLeft = $.css(elem, "left"),
	            calculatePosition = (position === "absolute" || position === "fixed") && $.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
	            props = {},
	            curPosition = {},
	            curTop, curLeft;

	        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
	        if (calculatePosition) {
	            curPosition = curElem.position();
	            curTop = curPosition.top;
	            curLeft = curPosition.left;
	        } else {
	            curTop = parseFloat(curCSSTop) || 0;
	            curLeft = parseFloat(curCSSLeft) || 0;
	        }

	        if ($.isFunction(options)) {
	            options = options.call(elem, i, curOffset);
	        }

	        if (options.top != null) {
	            props.top = (options.top - curOffset.top) + curTop;
	        }
	        if (options.left != null) {
	            props.left = (options.left - curOffset.left) + curLeft;
	        }

	        if ("using" in options) {
	            options.using.call(elem, props);
	        } else {
	            curElem.css(props);
	        }
	    };

        $._data = function(elm,propName) {
            if (elm.hasAttribute) {
                return datax.data(elm,propName);
            } else {
                return {};
            }
        };

     	var t = $.fn.text;  
	    $.fn.text = function(v) {
	        var r = t.apply(this,arguments);
	        if (r === undefined) {
	            r = "";
	        }  
	        return r;
	    };       

	    $.fn.pos = $.fn.position;
        	    
    })(query);

    query.parseHTML = function(html) {
        return  noder.createFragment(html);
    };

    query.uniqueSort = query.unique = langx.uniq;

    query.skylark = skylark;

    return window.jQuery = window.$ = query;
});

define('skylark-jquery/ajax',[
    "skylark-langx/langx",
    "skylark-net-http/Xhr",
    "./core",
], function(langx,Xhr,$) {
    var jsonpID = 0;

     // Attach a bunch of functions for handling common AJAX events
    $.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( i, type ) {
        $.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );
   

    function appendQuery(url, query) {
        if (query == '') return url
        return (url + '&' + query).replace(/[&?]{1,2}/, '?')
    }
    
    $.ajaxJSONP = function(options) {
        var deferred = new langx.Deferred();
        var _callbackName = options.jsonpCallback,
            callbackName = ($.isFunction(_callbackName) ?
                _callbackName() : _callbackName) || ('jsonp' + (++jsonpID)),
            script = document.createElement('script'),
            originalCallback = window[callbackName],
            responseData,
            abort = function(errorType) {
                $(script).triggerHandler('error', errorType || 'abort')
            },
            xhr = { abort: abort },
            abortTimeout;

        for (var key in options.data) {
            options.url = appendQuery(options.url, key + "=" + options.data[key]);
        }
         
//        if (deferred) deferred.promise(xhr)

        $(script).on('load error', function(e, errorType) {
            clearTimeout(abortTimeout)
            $(script).off().remove()

            if (e.type == 'error' || !responseData) {
                deferred.reject(e);
            } else {
                deferred.resolve(responseData[0],200,xhr);
            }

            window[callbackName] = originalCallback
            if (responseData && $.isFunction(originalCallback))
                originalCallback(responseData[0])

            originalCallback = responseData = undefined
        })

        window[callbackName] = function() {
            responseData = arguments
        }

        script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
        document.head.appendChild(script)

        if (options.timeout > 0) abortTimeout = setTimeout(function() {
            abort('timeout')
        }, options.timeout)

        return deferred;
    }

    //$.ajaxSettings = Xhr.defaultOptions;
    //$.ajaxSettings.xhr = function() {
    //    return new window.XMLHttpRequest()
    //};

    $.ajaxSettings = {
        processData : true
    };


    $.ajax = function(url,options) {
        if (!url) {
            options = {
                url :  "./"
            };
        } else if (!options) {
            if (langx.isString(url)) {
                options = {
                    url :  url
                };
            } else {
                options = url;
            }
        } else {
            options.url = url;
        }

        options = langx.mixin({},$.ajaxSettings,options);

        if ('jsonp' == options.dataType) {
            var hasPlaceholder = /\?.+=\?/.test(options.url);

            if (!hasPlaceholder)
                options.url = appendQuery(options.url,
                    options.jsonp ? (options.jsonp + '=?') : options.jsonp === false ? '' : 'callback=?')
            return $.ajaxJSONP(options);
        }

        function ajaxSuccess(data,status,xhr) {
            $(document).trigger("ajaxSucess");
            if (options.success) {
                options.success.apply(this,arguments);
            }
            if (options.complete) {
                options.complete.apply(this,arguments);
            }
            return data;
        }

        function ajaxError() {
            $(document).trigger("ajaxError");
            if (options.error) {
                options.error.apply(this,arguments);
            }
        }

        var p = Xhr.request(options.url,options);
        p = p.then(ajaxSuccess,ajaxError);
        p.success = p.done;
        p.error = p.fail;
        p.complete = p.always;
        
        return p;
    };

    // handle optional data/success arguments
    function parseArguments(url, data, success, dataType) {
        if ($.isFunction(url)) {
            dataType = data, success = url, data = undefined,url = undefined;
        } else if ($.isFunction(data)) {
            dataType = success, success = data, data = undefined;
        } 
        if (!$.isFunction(success)) dataType = success, success = undefined
        return {
            url: url,
            data: data,
            success: success,
            dataType: dataType
        }
    }

    $.get = function( /* url, data, success, dataType */ ) {
        return $.ajax(parseArguments.apply(null, arguments))
    }

    $.post = function( /* url, data, success, dataType */ ) {
        var options = parseArguments.apply(null, arguments)
        options.type = 'POST'
        return $.ajax(options)
    }

    $.getJSON = function( /* url, data, success */ ) {
        var options = parseArguments.apply(null, arguments)
        options.dataType = 'json'
        return $.ajax(options)
    }

    var originalLoad = $.fn.load;

    $.fn.load = function(url, data, success) {
        if ("string" != typeof url && originalLoad) {
            return originalLoad.apply(this, arguments);
        }
        if (!this.length) return this
        var self = this,
            options = parseArguments(url, data, success),
            parts = options.url && options.url.split(/\s/),
            selector,
            callback = options.success
        if (parts && parts.length > 1) options.url = parts[0], selector = parts[1]

        if (options.data && typeof options.data === "object") {
            options.type = "POST";
        }
        options.success = function(response) {
            self.html(selector ?
                $('<div>').html(response.replace(rscript, "")).find(selector) : response)
            callback && callback.apply(self, arguments)
        }
        $.ajax(options)
        return this
    }

    $.param = Xhr.param;


    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    var
        prefilters = {},
        transports = {},
        rnotwhite = (/\S+/g);

    $.ajaxPrefilter = addToPrefiltersOrTransports(prefilters);
    $.ajaxTransport = addToPrefiltersOrTransports(transports);
    $.ajaxSetup = function(target, settings) {
        langx.mixin(Xhr.defaultOptions,target,settings);
    };

    $.getScript = function( url, callback ) {
        return $.get( url, undefined, callback, "script" );
    };

    return $;

});

define('skylark-jquery/callbacks',[
    "./core"
], function($) {

    //     This module is borrow from zepto.callback.js
    //     (c) 2010-2014 Thomas Fuchs
    //     Zepto.js may be freely distributed under the MIT license.

    // Create a collection of callbacks to be fired in a sequence, with configurable behaviour
    // Option flags:
    //   - once: Callbacks fired at most one time.
    //   - memory: Remember the most recent context and arguments
    //   - stopOnFalse: Cease iterating over callback list
    //   - unique: Permit adding at most one instance of the same callback
    $.Callbacks = function(options) {
        options = $.extend({}, options)

        var memory, // Last fire value (for non-forgettable lists)
            fired, // Flag to know if list was already fired
            firing, // Flag to know if list is currently firing
            firingStart, // First callback to fire (used internally by add and fireWith)
            firingLength, // End of the loop when firing
            firingIndex, // Index of currently firing callback (modified by remove if needed)
            list = [], // Actual callback list
            stack = !options.once && [], // Stack of fire calls for repeatable lists
            fire = function(data) {
                memory = options.memory && data
                fired = true
                firingIndex = firingStart || 0
                firingStart = 0
                firingLength = list.length
                firing = true
                for (; list && firingIndex < firingLength; ++firingIndex) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false
                        break
                    }
                }
                firing = false
                if (list) {
                    if (stack) stack.length && fire(stack.shift())
                    else if (memory) list.length = 0
                    else Callbacks.disable()
                }
            },

            Callbacks = {
                add: function() {
                    if (list) {
                        var start = list.length,
                            add = function(args) {
                                $.each(args, function(_, arg) {
                                    if (typeof arg === "function") {
                                        if (!options.unique || !Callbacks.has(arg)) list.push(arg)
                                    } else if (arg && arg.length && typeof arg !== 'string') add(arg)
                                })
                            }
                        add(arguments)
                        if (firing) firingLength = list.length
                        else if (memory) {
                            firingStart = start
                            fire(memory)
                        }
                    }
                    return this
                },
                remove: function() {
                    if (list) {
                        $.each(arguments, function(_, arg) {
                            var index
                            while ((index = $.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1)
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) --firingLength
                                    if (index <= firingIndex) --firingIndex
                                }
                            }
                        })
                    }
                    return this
                },
                has: function(fn) {
                    return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))
                },
                empty: function() {
                    firingLength = list.length = 0
                    return this
                },
                disable: function() {
                    list = stack = memory = undefined
                    return this
                },
                disabled: function() {
                    return !list
                },
                lock: function() {
                    stack = undefined;
                    if (!memory) Callbacks.disable()
                    return this
                },
                locked: function() {
                    return !stack
                },
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || []
                        args = [context, args.slice ? args.slice() : args]
                        if (firing) stack.push(args)
                        else fire(args)
                    }
                    return this
                },
                fire: function() {
                    return Callbacks.fireWith(this, arguments)
                },
                fired: function() {
                    return !!fired
                }
            }

        return Callbacks
    };

    return $;

});

define('skylark-jquery/deferred',[
    "./core",
    "skylark-langx/langx"
], function($,langx) {

    $.Deferred = function() {
        var d = new langx.Deferred(),
            ret = {
                promise : function() {
                    return d.promise;
                }
            };

        ["resolve","resolveWith","reject","rejectWith","notify","then","done","fail","progress"].forEach(function(name){
            ret[name] = function() {
              var ret2 =   d[name].apply(d,arguments);
              if (ret2 == d) {
                ret2 = ret;
              }
              return ret2;
            }
        });

        return ret;
    };
    
    $.when = function(){
        var p = langx.Deferred.all(langx.makeArray(arguments)),
            originThen = p.then;
        p.then = function(onResolved,onRejected) {
            var handler = function(results) {
                //results = results.map(function(result){
                //    return [result];
                //});
                return onResolved && onResolved.apply(null,results);
            };
            return originThen.call(p,handler,onRejected);
        };
        return p;
    };

    return $;

});

define('skylark-jquery/queue',[
    "skylark-langx/langx",
    "./core",
    "./callbacks"
], function(langx, $) {

 // jQuery Data object
  var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
      rmultiDash = /([A-Z])/g,
      expando = "Sky" + ( '1.0' + Math.random() ).replace( /\D/g, ""),
      optionsCache = {},
      core_rnotwhite = /\S+/g,
      core_deletedIds = [],
      core_push = core_deletedIds.push;

// Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
      object[ flag ] = true;
    });
    return object;
  }

  function isArraylike( obj ) {
    var length = obj.length,
        type = $.type( obj );

    if ( $.isWindow( obj ) ) {
      return false;
    }

    if ( obj.nodeType === 1 && length ) {
      return true;
    }

    return type === "array" || type !== "function" &&
        ( length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj );
  }

  

  function Data() {
    // Support: Android < 4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    Object.defineProperty( this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });

    this.expando = expando + Math.random();
  }

  Data.uid = 1;

  Data.accepts = function( owner ) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType ?
        owner.nodeType === 1 || owner.nodeType === 9 : true;
  };

  Data.prototype = {
    key: function( owner ) {
      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return the key for a frozen object.
      if ( !Data.accepts( owner ) ) {
        return 0;
      }

      var descriptor = {},
      // Check if the owner object already has a cache key
          unlock = owner[ this.expando ];

      // If not, create one
      if ( !unlock ) {
        unlock = Data.uid++;

        // Secure it in a non-enumerable, non-writable property
        try {
          descriptor[ this.expando ] = { value: unlock };
          Object.defineProperties( owner, descriptor );

          // Support: Android < 4
          // Fallback to a less secure definition
        } catch ( e ) {
          descriptor[ this.expando ] = unlock;
          $.extend( owner, descriptor );
        }
      }

      // Ensure the cache object
      if ( !this.cache[ unlock ] ) {
        this.cache[ unlock ] = {};
      }

      return unlock;
    },
    set: function( owner, data, value ) {
      var prop,
      // There may be an unlock assigned to this node,
      // if there is no entry for this "owner", create one inline
      // and set the unlock as though an owner entry had always existed
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      // Handle: [ owner, key, value ] args
      if ( typeof data === "string" ) {
        cache[ data ] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Fresh assignments by object are shallow copied
        if ( $.isEmptyObject( cache ) ) {
          $.extend( this.cache[ unlock ], data );
          // Otherwise, copy the properties one-by-one to the cache object
        } else {
          for ( prop in data ) {
            cache[ prop ] = data[ prop ];
          }
        }
      }
      return cache;
    },
    get: function( owner, key ) {
      // Either a valid cache is found, or will be created.
      // New caches will be created and the unlock returned,
      // allowing direct access to the newly created
      // empty data object. A valid owner object must be provided.
      var cache = this.cache[ this.key( owner ) ];

      return key === undefined ?
          cache : cache[ key ];
    },
    access: function( owner, key, value ) {
      var stored;
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if ( key === undefined ||
          ((key && typeof key === "string") && value === undefined) ) {

        stored = this.get( owner, key );

        return stored !== undefined ?
            stored : this.get( owner, $.camelCase(key) );
      }

      // [*]When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set( owner, key, value );

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function( owner, key ) {
      var i, name, camel,
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      if ( key === undefined ) {
        this.cache[ unlock ] = {};

      } else {
        // Support array or space separated string of keys
        if ( $.isArray( key ) ) {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = key.concat( key.map( $.camelCase ) );
        } else {
          camel = $.camelCase( key );
          // Try the string as a key before any manipulation
          if ( key in cache ) {
            name = [ key, camel ];
          } else {
            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            name = camel;
            name = name in cache ?
                [ name ] : ( name.match( core_rnotwhite ) || [] );
          }
        }

        i = name.length;
        while ( i-- ) {
          delete cache[ name[ i ] ];
        }
      }
    },
    hasData: function( owner ) {
      return !$.isEmptyObject(
          this.cache[ owner[ this.expando ] ] || {}
      );
    },
    discard: function( owner ) {
      if ( owner[ this.expando ] ) {
        delete this.cache[ owner[ this.expando ] ];
      }
    }
  };

  var data_priv = new Data();

  $.extend($, {
    queue: function( elem, type, data ) {
      var queue;

      if ( elem ) {
        type = ( type || "fx" ) + "queue";
        queue = data_priv.get( elem, type );

        // Speed up dequeue by getting out quickly if this is just a lookup
        if ( data ) {
          if ( !queue || $.isArray( data ) ) {
            queue = data_priv.access( elem, type, $.makeArray(data) );
          } else {
            queue.push( data );
          }
        }
        return queue || [];
      }
    },

    dequeue: function( elem, type ) {
      type = type || "fx";

      var queue = $.queue( elem, type ),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = $._queueHooks( elem, type ),
          next = function() {
            $.dequeue( elem, type );
          };

      // If the fx queue is dequeued, always remove the progress sentinel
      if ( fn === "inprogress" ) {
        fn = queue.shift();
        startLength--;
      }

      if ( fn ) {

        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if ( type === "fx" ) {
          queue.unshift( "inprogress" );
        }

        // clear up the last queue stop function
        delete hooks.stop;
        fn.call( elem, next, hooks );
      }

      if ( !startLength && hooks ) {
        hooks.empty.fire();
      }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
      var key = type + "queueHooks";
      return data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: $.Callbacks("once memory").add(function() {
          data_priv.remove( elem, [ type + "queue", key ] );
        })
      });
    },

    // array operations
    makeArray: function( arr, results ) {
      var ret = results || [];

      if ( arr != null ) {
        if ( isArraylike( Object(arr) ) ) {
          $.merge( ret,
              typeof arr === "string" ?
                  [ arr ] : arr
          );
        } else {
          core_push.call( ret, arr );
        }
      }

      return ret;
    },
    merge: function( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }
  });

  $.extend($.fn, {
    queue: function( type, data ) {
      var setter = 2;

      if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
      }

      if ( arguments.length < setter ) {
        return $.queue( this[0], type );
      }

      return data === undefined ?
          this :
          this.each(function() {
            var queue = $.queue( this, type, data );

            // ensure a hooks for this queue
            $._queueHooks( this, type );

            if ( type === "fx" && queue[0] !== "inprogress" ) {
              $.dequeue( this, type );
            }
          });
    },
    dequeue: function( type ) {
      return this.each(function() {
        $.dequeue( this, type );
      });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
      time = $.fx ? $.fx.speeds[ time ] || time : time;
      type = type || "fx";

      return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
          clearTimeout( timeout );
        };
      });
    },
    clearQueue: function( type ) {
      return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
      var tmp,
          count = 1,
          defer = $.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if ( !( --count ) ) {
              defer.resolveWith( elements, [ elements ] );
            }
          };

      if ( typeof type !== "string" ) {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while( i-- ) {
        tmp = data_priv.get( elements[ i ], type + "queueHooks" );
        if ( tmp && tmp.empty ) {
          count++;
          tmp.empty.add( resolve );
        }
      }
      resolve();
      return defer.promise( obj );
    }
  });

  return $;

});

define('skylark-jquery/JqueryPlugin',[
	"skylark-langx-types",
	"skylark-langx-objects",
	"skylark-langx-arrays",
	"skylark-langx/langx",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-plugins",
	"skylark-domx-query",
],function(types, objects, arrays, langx, datax, eventer, plugins, $){

    var pluginUuid = 0;

	var JqPlugin = plugins.Plugin.inherit({
		klassName : "JqPlugin",

        pluginEventPrefix: "",

        options: {
            // Callbacks
            create: null
        },

        destroy: function() {
            this.overrided();

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off( this.eventNamespace );

            // Clean up events and states
            this.bindings.off( this.eventNamespace );
        },

        _construct : function(element,options) {
            //this.options = langx.mixin( {}, this.options );

            element = $( element || this.defaultElement || this )[ 0 ];

            this.overrided(element,options);
            
            this.element = $( element );
            this.uuid = pluginUuid++;
            this.eventNamespace = "." + this.pluginName + this.uuid;

            this.bindings = $();
            this.classesElementLookup = {};

			this.hoverable = $();
			this.focusable = $();

            if ( element !== this ) {
                datax.data( element, this.pluginName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                } );
                this.document = $( element.style ?

                    // Element within the document
                    element.ownerDocument :

                    // Element is window or document
                    element.document || element );
                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
            }

//            this.options = langx.mixin( {},
//                this.options,
//                this._getCreateOptions(),
//                options );

            this._create();

            this._trigger( "create", null, this._getCreateEventData() );

            this._init();
        },

//        _getCreateOptions: function() {
//            return {};
//        },

        _getCreateEventData: langx.noop,

        _create: langx.noop,

        _init: langx.noop,

		_classes: function( options ) {
			var full = [];
			var that = this;

			options = objects.mixin( {
				element: this.element,
				classes: this.options.classes || {}
			}, options );


			function bindRemoveEvent() {
				options.element.each( function( _, element ) {
					var isTracked = langx.map( that.classesElementLookup, function( elements ) {
						return elements;
					} )
						.some( function(elements ) {
							return $(elements).is( element );
						} );

					if ( !isTracked ) {
						that._on( $( element ), {
							remove: "_untrackClassesElement"
						} );
					}
				} );
			}

			function processClassString( classes, checkOption ) {
				var current, i;
				for ( i = 0; i < classes.length; i++ ) {
					current = that.classesElementLookup[ classes[ i ] ] || $();
					if ( options.add ) {
						bindRemoveEvent();
						current = $( langx.uniq( current.get().concat( options.element.get() ) ) );
					} else {
						current = $( current.not( options.element ).get() );
					}
					that.classesElementLookup[ classes[ i ] ] = current;
					full.push( classes[ i ] );
					if ( checkOption && options.classes[ classes[ i ] ] ) {
						full.push( options.classes[ classes[ i ] ] );
					}
				}
			}

			if ( options.keys ) {
				processClassString( options.keys.match( /\S+/g ) || [], true );
			}
			if ( options.extra ) {
				processClassString( options.extra.match( /\S+/g ) || [] );
			}

			return full.join( " " );
		},

		_untrackClassesElement: function( event ) {
			var that = this;
			langx.each( that.classesElementLookup, function( key, value ) {
				if ( arrays.inArray( event.target, value ) !== -1 ) {
					that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
				}
			} );

			this._off( $( event.target ) );
		},

		_removeClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, false );
		},

		_addClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, true );
		},

		_toggleClass: function( element, keys, extra, add ) {
			add = ( typeof add === "boolean" ) ? add : extra;
			var shift = ( typeof element === "string" || element === null ),
				options = {
					extra: shift ? keys : extra,
					keys: shift ? element : keys,
					element: shift ? this.element : element,
					add: add
				};
			options.element.toggleClass( this._classes( options ), add );
			return this;
		},

		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement;
			var instance = this;

			// No suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// No element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}

			objects.each( handlers, function( event, handler ) {
				function handlerProxy() {

					// Allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}

				// Copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match( /^([\w:-]*)\s*(.*)$/ );
				var eventName = match[ 1 ] + instance.eventNamespace;
				var selector = match[ 2 ];

				if ( selector ) {
					delegateElement.on( eventName, selector, handlerProxy );
				} else {
					element.on( eventName, handlerProxy );
				}
			} );
		},

		_off: function( element, eventName ) {
			eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.off( eventName );

			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},

		_trigger: function( type, event, data ) {
			var prop, orig;
			var callback = this.options[ type ];

			data = data || {};
			event = eventer.proxy( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();

			// The original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];

			// Copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}

			this.element.trigger( event, data );
			return !( types.isFunction( callback ) &&
				callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}

	});

	return JqPlugin;
});
/*!
 * jQuery UI Widget @VERSION
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

define( 'skylark-jquery/widget',[ 
	"skylark-langx/langx",
	"skylark-domx-plugins",
	"./core",
	"./JqueryPlugin"
],  function(langx,splugins, $,JqPlugin ) {

	var widgetUuid = 0;
	var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
	var widgetSlice = Array.prototype.slice;

	$.cleanData = ( function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}
			}
			orig( elems );
		};
	} )( $.cleanData );
	
	$.widget = function( name, base, prototype ) {
		var existingConstructor, constructor, basePrototype;

		// ProxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		var proxiedPrototype = {};

		var namespace = name.split( "." )[ 0 ];
		name = name.split( "." )[ 1 ];
		var fullName = namespace + "-" + name;

		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}

		if ( $.isArray( prototype ) ) {
			prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
		}

		// Create selector for plugin
		$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};

		$[ namespace ] = $[ namespace ] || {};

		existingConstructor = $[ namespace ][ name ];

		var basePrototype = base.prototype,
			newPrototype = {};

		for (var key in prototype) {
			var value = prototype[key];

			if ( $.isPlainObject( value ) ) {
				newPrototype[ key ] = $.isPlainObject( basePrototype[ key ] ) ?
					$.widget.extend( {}, basePrototype[ key ], value ) :

					// Don't extend strings, arrays, etc. with objects
					$.widget.extend( {}, value );
			} else {
				newPrototype[key] = value;
			}
		}

		var _proto = $.widget.extend({

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( base.prototype.widgetEventPrefix || name ) : name
		}, {
			options : base.prototype.options
		},newPrototype, {
			name : fullName,
			namespace: namespace,
			widgetName: name,
			pluginName : "jqueryui." + (namespace ? namespace + "." : "") + name,
			widgetFullName: fullName
		} );

		constructor = $[ namespace ][ name ] = base.inherit(_proto);
		/*

		constructor = $[ namespace ][ name ] = function( options, element ) {

			// Allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}

			// Allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		*/
		// Extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,

			// Copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: _proto,

			// Track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		} );

		/*
		basePrototype = new base();

		// We need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = ( function() {
				function _super() {
					return base.prototype[ prop ].apply( this, arguments );
				}

				function _superApply( args ) {
					return base.prototype[ prop ].apply( this, args );
				}

				return function() {
					var __super = this._super;
					var __superApply = this._superApply;
					var returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			} )();
		} );
		constructor.prototype = $.widget.extend( basePrototype, {

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		} );
		*/
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;

				// Redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
					child._proto );
			} );

			// Remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			if (base._childConstructors) {
				base._childConstructors.push( constructor );
			}
		}

		//$.widget.bridge( name, constructor );

		splugins.register(constructor,name,fullName);

		return constructor;
	};

	$.widget.extend = function( target ) {
		var input = widgetSlice.call( arguments, 1 );
		var inputIndex = 0;
		var inputLength = input.length;
		var key;
		var value;

		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {

					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :

							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );

					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};


	$.Widget = 	 JqPlugin.inherit({
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",

		options: {
			classes: {},
			disabled: false,

			// Callbacks
			create: null
		},

	     _initOptions : function(options) {
	     	options = langx.mixin(this._createOptions(),options);

			this.overrided(options);
		},

		_createOptions : function() {
			return {};
		},

		_super : function() {
			if (this.overrided) {
				return this.overrided.apply(this,arguments);
			}
		},

		_superApply : function ( args ) {
			if (this.overrided) {
				return this.overrided.apply(this,args);
			}
		},


		widget: function() {
			return this.element;
		},


		_setOption: function( key, value ) {
			if ( key === "classes" ) {
				this._setOptionClasses( value );
			}

			this.options[ key ] = value;

			if ( key === "disabled" ) {
				this._setOptionDisabled( value );
			}

			return this;
		},

		_setOptionClasses: function( value ) {
			var classKey, elements, currentElements;

			for ( classKey in value ) {
				currentElements = this.classesElementLookup[ classKey ];
				if ( value[ classKey ] === this.options.classes[ classKey ] ||
						!currentElements ||
						!currentElements.length ) {
					continue;
				}

				// We are doing this to create a new jQuery object because the _removeClass() call
				// on the next line is going to destroy the reference to the current elements being
				// tracked. We need to save a copy of this collection so that we can add the new classes
				// below.
				elements = $( currentElements.get() );
				this._removeClass( currentElements, classKey );

				// We don't use _addClass() here, because that uses this.options.classes
				// for generating the string of classes. We want to use the value passed in from
				// _setOption(), this is the new value of the classes option which was passed to
				// _setOption(). We pass this value directly to _classes().
				elements.addClass( this._classes( {
					element: elements,
					keys: classKey,
					classes: value,
					add: true
				} ));
			}
		},

		_setOptionDisabled: function( value ) {
			this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this._removeClass( this.hoverable, null, "ui-state-hover" );
				this._removeClass( this.focusable, null, "ui-state-focus" );
			}
		},

		enable: function() {
			return this._setOptions( { disabled: false } );
		},

		disable: function() {
			return this._setOptions( { disabled: true } );
		},


		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},

		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
				},
				mouseleave: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
				}
			} );
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
				},
				focusout: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
				}
			} );
		}

	});

	$.Widget._childConstructors = [];

	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}

			var hasOptions;
			var effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;

			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}

			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;

			if ( options.delay ) {
				element.delay( options.delay );
			}

			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue( function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				} );
			}
		};
	} );

	return $.widget;

});

define('skylark-jquery/main',[
    "./core",
    "./ajax",
    "./callbacks",
    "./deferred",
    "./queue",
    "./JqueryPlugin",
    "./widget"
], function($) {
    return $;
});

define('skylark-jquery', ['skylark-jquery/main'], function (main) { return main; });

define('skylark-ajaxfy-routers/routers',[
	"skylark-langx/skylark",
	"skylark-langx/langx"	
],function(skylark,langx){

	return skylark.attach("ajaxfy.routers",{
        createEvent : function (type,props) {
            var e = new CustomEvent(type,props);
            return langx.safeMixin(e, props);
        }

	});	
});

define('skylark-ajaxfy-routers/Route',[
	"skylark-langx/langx",
	"./routers"
],function(langx,routers){
    var createEvent = routers.createEvent;
    
    var Route = langx.Evented.inherit({
        klassName: "Route",
        init: function(name, setting) {
            setting = langx.mixin({}, setting);
            var pathto = setting.pathto || "",
                pattern = pathto,
                paramNames = pattern.match(/\:([a-zA-Z0-9_]+)/g);
            if (paramNames !== null) {
                paramNames = paramNames.map(function(paramName) {
                    return paramName.substring(1);
                });
                pattern = pattern.replace(/\:([a-zA-Z0-9_]+)/g, '(.*?)');
            } else {
                paramNames = [];
            }
            if (pattern === "*") {
                pattern = "(.*)";
            } else {
                pattern = pattern.replace("/", "\\/");
            }

            this._setting = setting;
            this.name = name;
            this.pathto = pathto;
            this.paramNames = paramNames;
            this.params = pattern;
            this.regex = new RegExp("^" + pattern + "$", "");

            var self = this;
            ["entering", "entered", "exiting", "exited"].forEach(function(eventName) {
                if (langx.isFunction(setting[eventName])) {
                    self.on(eventName, setting[eventName]);
                }
            });
        },

        enter: function(ctx,query) {
            if (query) {
                var r = this._entering(ctx),
                    self = this;

                return langx.Deferred.when(r).then(function(){
                    var e = createEvent("entering", {
                        route: self,
                        result: true
                    });

                    self.trigger(e);

                    return e.result;
                });
            } else {
                this._entered(ctx);

                this.trigger(createEvent("entered", langx.safeMixin({
                    route: this
                }, ctx)));
                return this;
            }
        },

        exit: function(ctx, query) {
            if (query) {
                var ok = this._exiting(ctx);
                if (!ok) {
                    return false;
                }

                var e = createEvent("exiting", {
                    route: this,
                    result: true
                });

                this.trigger(e);

                return e.result;
            } else {
                this._exited(ctx);
                this.trigger(createEvent("exited", langx.safeMixin({
                    route: this
                }, ctx)));

                return this;
            }
        },

        match: function(path) {
            var names = this.paramNames,
                x = path.indexOf('?'),
                path = ~x ? path.slice(0, x) : decodeURIComponent(path),
                m = this.regex.exec(path);

            if (!m) {
                return false
            };

            var params = {};
            for (var i = 1, len = m.length; i < len; ++i) {
                var name = names[i - 1],
                    val = decodeURIComponent(m[i]);
                params[name] = val;
            }

            return params;
        },

        path: function(params) {
            var path = this.pathto;
            if (params) {
                path = path.replace(/:([a-zA-Z0-9_]+)/g, function(match, paramName) {
                    return params[paramName];
                });
            }
            return path;
        },

        _entering: function(ctx) {
            return true;
        },
        _entered: function(ctx) {
            return true;
        },
        _exiting: function(ctx) {
            return true;
        },
        _exited: function(ctx) {
            return true;
        },
    });

	return routers.Route = Route;	
});
define('skylark-ajaxfy-routers/Router',[
    "skylark-langx/langx",
    "./routers",
    "./Route"
],function(langx,routers,Route){
    var createEvent = routers.createEvent;

    function Router() {
        var _curCtx,
            _prevCtx,
            _baseUrl,
            _homePath,
            _routes = {},
            _cache = {},
            _hub = new langx.Evented();

        var router = this;


        function current() {
            return _curCtx;
        }

        // refresh the current route
        function dispatch(ctx) {

            if (_curCtx) {
                var ret = _curCtx.route.exit({
                    path: _curCtx.path,
                    params: _curCtx.params
                }, true);
                if (!ret) {
                    return;
                }
            }

            _prevCtx = _curCtx;
            _curCtx = ctx;
            if (!_curCtx.route) {
                var m = map(_curCtx.path);
                _curCtx.route = m.route;
                _curCtx.params = m.params;
            }

            var r = _curCtx.route.enter({
                force: _curCtx.force,
                path: _curCtx.path,
                params: _curCtx.params
            },true);

            langx.Deferred.when(r).then(function() {
                _hub.trigger(createEvent("routing", {
                    current: _curCtx,
                    previous: _prevCtx
                }));

                _curCtx.route.enter({
                    path: _curCtx.path,
                    params: _curCtx.params
                },false);

                if (_prevCtx) {
                    _prevCtx.route.exit({
                        path: _prevCtx.path,
                        params: _prevCtx.params
                    }, false);
                }

                _hub.trigger(createEvent("routed", {
                    current: _curCtx,
                    previous: _prevCtx
                }));
            });
        }

        function go(path, force) {
            if (!force && _curCtx && _curCtx.path == path) {
                return false;
            }
            var ctx = map(path);
            if (ctx) {
                ctx.path = path;

                if (router.useHistoryApi) {
                    var state = {
                        force: force,
                        path: path
                    }

                    window.history.pushState(state, document.title, (_baseUrl + path).replace("//", "/"));
                    window.dispatchEvent(createEvent("popstate", {
                        state: state
                    }));
                } else if (router.useHashbang) {
                    var newHash = "#!" + path;
                    if (window.location.hash !== newHash) {
                        window.location.hash = newHash;
                    } else {
                        dispatch(ctx);
                    };
                } else {
                    dispatch(ctx);
                }
            }
            return true;
        }

        function map(path, noCache) {
            var finded = false;
            if (!noCache) {
                finded = _cache[path];
                if (finded) {
                    return finded;
                }
            }
            langx.each(_routes, function(name, route) {
                var ret = route.match(path);
                if (ret) {
                    finded = {
                        route: route,
                        params: ret
                    }
                    return false;
                }
                return true;
            });
            if (finded && !noCache) {
                _cache[path] = finded;
            }
            return finded;
        }

        function path(routeName, params) {
            var route = _routes[routeName],
                path;
            if (route) {
                path = route.path(params);
            }
            return path;
        }

        function previous() {
            return _prevCtx;
        }

        function baseUrl(path) {
            if (langx.isDefined(path)) {
                _baseUrl = path;
                return this;
            } else {
                return _baseUrl;
            }
        }

        function hub(){
            return _hub;
        }

        function homePath(path) {
            if (langx.isDefined(path)) {
                _homePath = path;
                return this;
            } else {
                return _homePath;
            }
        }

        function route(name, setting) {
            if (langx.isDefined(setting)) {
                var settings = {};
                settings[name] = setting;
                routes(settings);
                return this;
            } else {
                return _routes[name];
            }
        }

        function routes(settings) {
            if (!langx.isDefined(settings)) {
                return langx.mixin({}, _routes);
            } else {
                for (var name in settings) {
                    _routes[name] = new router.Route(name, settings[name]);
                }
            }
        }

        //starts routing urls
        function start() {
            if (router.useHashbang == null && router.useHistoryApi == null) {
                if (window.location.host  && window.history.pushState) {
                    //web access
                    router.useHistoryApi = true;
                } else {
                    // local access
                    router.useHashbang = true;
                }
            }

            var initPath = "";

            if (router.useHistoryApi) {
                initPath = window.location.pathname;
                if (_baseUrl === undefined) {
                    _baseUrl = initPath.replace(/\/$/, "");
                }
                initPath = initPath.replace(_baseUrl, "") || _homePath || "/";
            } else if (router.useHashbang) {
                initPath = window.location.hash.replace("#!", "") || _homePath || "/";
            } else {
                initPath = "/";
            }

            if (!initPath.startsWith("/")) {
                initPath = "/" + initPath;
            }
            /*
            eventer.on(document.body, "click", "a[href]", function(e) {
                var elm = e.currentTarget,
                    url = elm.getAttribute("href");

                if (url == "#") {
                    return;
                }
                if (url && langx.isSameOrigin(elm.href)) {
                    if (url.indexOf(_baseUrl) === 0) {
                        url = url.substr(_baseUrl.length);
                        eventer.stop(e);
                        url = url.replace('#!', '');
                        go(url);
                    }
                }
            });
            */
            if (router.useHistoryApi) {
                window.addEventListener("popstate", function(e) {
                    if(e.state) dispatch(e.state);
                    e.preventDefault();
                });
            } else if (router.useHashbang) {
                window.addEventListener("hashchange", function(e) {
                    dispatch({
                        path: window.location.hash.replace(/^#!/, "")
                    });
                    e.preventDefault();
                });
            }

            go(initPath);
        }

        langx.mixin(router, {
            "Route": Route,

            // Current path being processed
            "current": current,

            // Changes the current path
            "go": go,

            "map": map,

            "hub": hub,

            "off": function() {
                _hub.off.apply(_hub, arguments);
            },

            "on": function() {
                _hub.on.apply(_hub, arguments);
            },

            "one": function() {
                _hub.one.apply(_hub, arguments);
            },

            // Returns the path of the named route
            "path": path,

            "previous": previous,

            "baseUrl": baseUrl,

            "homePath": homePath,

            "route": route,

            "routes": routes,

            //starts routing urls
            "start": start,

            "trigger": function(e) {
                _hub.trigger(e);
                return this;
            },

            "useHistoryApi": null,
            "useHashbang": null
        });

    }

    return routers.Router = Router;
});

define('skylark-ajaxfy-routers/main',[
    "./routers",
    "./Router",
    "./Route"
], function(routers) {
    return routers;
});

define('skylark-ajaxfy-routers', ['skylark-ajaxfy-routers/main'], function (main) { return main; });

define('skylark-ajaxfy-spa/spa',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-ajaxfy-routers"
], function(skylark, langx, routers) {
    var Deferred = langx.Deferred;

    function createEvent(type, props) {
        var e = new CustomEvent(type, props);
        return langx.safeMixin(e, props);
    }

    var router = new routers.Router();

    var Route = router.Route = router.Route.inherit({
        klassName: "SpaRoute",

        init: function(name, setting) {
            this.overrided(name, setting);
            this.content = setting.content;
            this.forceRefresh = setting.forceRefresh;
            this.data = setting.data;
            //this.lazy = !!setting.lazy;
            var self = this;
            ["preparing", "rendering", "rendered"].forEach(function(eventName) {
                if (langx.isFunction(setting[eventName])) {
                    self.on(eventName, setting[eventName]);
                }
            });
        },

        _entering: function(ctx) {
            if (this.forceRefresh || ctx.force || !this._prepared) {
                return this.prepare();
            }
            return this;
        },

        getConfigData: function(key) {
            return key ? this.data[key] : this.data;
        },

        getNamedValue: function() {
            return window.location.pathname.match(this.regex);
        },

        prepare: function() {
            var d = new Deferred(),
                setting = this._setting,
                controllerSetting = setting.controller,
                controller = this.controller,

                self = this,
                content = setting.content,
                contentPath = setting.contentPath;

            require([controllerSetting.type], function(type) {
                controller = self.controller = new type(controllerSetting);
                d.resolve();
            });

            return d.then(function() {
                var e = createEvent("preparing", {
                    route: self,
                    result: true
                });
                self.trigger(e);
                return Deferred.when(e.result).then(function() {
                    self._prepared = true;
                });
            });
        },

        render: function(ctx) {
            var e = createEvent("rendering", {
                route: this,
                context: ctx,
                content: this.content
            });
            this.trigger(e);
            return e.content;
        },

        trigger: function(e) {
            var controller = this.controller;
            if (controller) {
                return controller.perform(e);
            } else {
                return this.overrided(e);
            }
        }
    });


    var RouteController = langx.Evented.inherit({
        klassName: "SpaRouteController",

        init: function(route, setting) {
            setting = setting || {};
            this.content = setting.content;
            this.data = setting.data;
        },

        getConfigData: function(key) {
            return key ? this.data[key] : this.data;
        },

        perform: function(e) {
            var eventName = e.type;
            if (this[eventName]) {
                return this[eventName].call(this, e);
            }

        }
    });

    var Page = langx.Evented.inherit({
        klassName: "SpaPage",

        init: function(params) {
            params = langx.mixin({
                "routeViewer": "body"
            }, params);

            this._params = params;
            this._rvc = document.querySelector(params.routeViewer);
            this._router = router;

            router.on("routed", langx.proxy(this, "refresh"));
        },

        prepare: function() {

        },

        //Refreshes the route
        refresh: function() {
            var curCtx = router.current(),
                prevCtx = router.previous();
            var content = curCtx.route.render(curCtx);
            if (content===undefined || content===null) {
                return;
            }
            if (langx.isString(content)) {
                this._rvc.innerHTML = content;
            } else {
                this._rvc.innerHTML = "";
                this._rvc.appendChild(content);
            }
            curCtx.route.trigger(createEvent("rendered", {
                route: curCtx.route,
                content: content
            }));
        }
    });

    var Plugin = langx.Evented.inherit({
        klassName: "SpaPlugin",

        init: function(name, setting) {
            this.name = name;

            if (langx.isString(setting.hookers)) {
                setting.hookers = setting.hookers.split(" ");
            }
            this._setting = setting;
        },

        isHooked: function(eventName) {
            var hookers = this._setting.hookers || [];
            return hookers.indexOf(eventName) > -1;
        },

        prepare: function() {
            var d = new Deferred(),
                setting = this._setting,
                controllerSetting = setting.controller,
                controller = this.controller,
                self = this;
            require([controllerSetting.type], function(type) {
                controller = self.controller = new type(controllerSetting);
                router.on(setting.hookers, {
                    plugin: self
                }, langx.proxy(controller.perform, controller));
                d.resolve();
            });
            return d.then(function() {
                var e = createEvent("preparing", {
                    plugin: self,
                    result: true
                });
                self.trigger(e);
                return Deferred.when(e.result).then(function() {
                    self._prepared = true;
                });
            });
        },

        trigger: function(e) {
            var controller = this.controller;
            if (controller) {
                return controller.perform(e);
            } else {
                return this.overrided(e);
            }
        }
    });

    var PluginController = langx.Evented.inherit({
        klassName: "SpaPluginController",

        init: function(plugin) {
            this.plugin = plugin;
        },

        perform: function(e) {
            var eventName = e.type;
            if (this[eventName]) {
                return this[eventName].call(this, e);
            }

        }
    });

    var Application = langx.Evented.inherit({
        klassName: "SpaApplication",

        init: function(config) {
            if (app) {
                return app;
            }
            var plugins = this._plugins = {};

            config = this._config = langx.mixin({
                plugins: {}
            }, config, true);

            langx.each(config.plugins, function(pluginName, setting) {
                plugins[pluginName] = new Plugin(pluginName, setting);
            });

            router.routes(config.routes);

            this._router = router;

            this._page = new spa.Page(config.page);

            document.title = config.title;
            var baseUrl = config.baseUrl;
            if (baseUrl === undefined) {
                baseUrl = config.baseUrl = (new langx.URL(document.baseURI)).pathname;
            }
            router.baseUrl(baseUrl);

            if (config.homePath) {
                router.homePath(config.homePath);
            }

            app = this;
        },

        baseUrl : function() {
            return router.baseUrl();
        },

        getConfig: function(key) {
            return key ? this._config[key] : this._config;
        },

        go: function(path, force) {
            router.go(path, force);
            return this;
        },

        page: function() {
            return this._page;
        },

        prepare: function() {
            if (this._prepared) {
                return Deferred.resolve();
            }
            var self = this;

            var promises0 = langx.map(this._plugins, function(plugin, name) {
                if (plugin.isHooked("starting")) {
                    return plugin.prepare();
                }
            });

            return Deferred.all(promises0).then(function() {
                router.trigger(createEvent("starting", {
                    spa: self
                }));
                var promises1 = langx.map(router.routes(), function(route, name) {
                        if (route.lazy === false) {
                            return route.prepare();
                        }
                    }),
                    promises2 = langx.map(self._plugins, function(plugin, name) {
                        if (!plugin.isHooked("starting")) {
                            return plugin.prepare();
                        }
                    });


                return Deferred.all(promises1.concat(promises2)).then(function() {
                    self._prepared = true;
                });
            });
        },

        run: function() {
            this._router.start();
            router.trigger(createEvent("started", {
                spa: this
            }));
        }
    });

    var app;
    var spa = function(config) {
        if (!app) {
            window[config.name || "app"] = app = new spa.Application(config);
        }

        return app;
    }

    langx.mixin(spa, {
        "Application": Application,

        "Page": Page,

        "Plugin": Plugin,
        "PluginController": PluginController,

        "Route": Route,

        "router" : router,
        
        "RouteController": RouteController

    });

    return skylark.attach("ajaxfy.spa",spa);
});

define('skylark-ajaxfy-spa/main',[
    "skylark-langx/skylark",
    "./spa"
], function(skylark) {
    return skylark;
});

define('skylark-ajaxfy-spa', ['skylark-ajaxfy-spa/main'], function (main) { return main; });

define('skylark-data-entities/entities',[
    "skylark-langx/langx"
], function(langx) {
    function entities() {
        return entities;
    }

    langx.mixin(entities, {
        // set a `X-Http-Method-Override` header.
        emulateHTTP : false,

        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... this will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        emulateJSON : false,

        backends : {
            
        }
    });


    return entities;
});

define('skylark-data-entities/Entity',[
	"skylark-langx/langx",
	"./entities"
],function(langx,entities){
   // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

 
  var Entity = langx.Stateful.inherit({
    sync: function() {
      return entities.sync.apply(this, arguments);
    },

    // Get the HTML-escaped value of an attribute.
    //escape: function(attr) {
    //  return _.escape(this.get(attr));
    //},

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return langx.isMatch(this.attributes,attrs);
    },

    // Fetch the entity from the server, merging the response with the entity's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = langx.mixin({parse: true}, options);
      var entity = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;
        if (!entity.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, entity, resp, options);
        entity.trigger('sync', entity, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of entity attributes, and sync the entity to the server.
    // If the server returns an attributes hash that differs, the entity's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = langx.mixin({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the entity will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var entity = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        entity.attributes = attributes;
        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;
        if (wait) serverAttrs = langx.mixin({}, attrs, serverAttrs);
        if (serverAttrs && !entity.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, entity, resp, options);
        entity.trigger('sync', entity, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = langx.mixin({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this entity on the server if it was already persisted.
    // Optimistically removes the entity from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? langx.clone(options) : {};
      var entity = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        entity.stopListening();
        entity.trigger('destroy', entity, entity.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, entity, resp, options);
        if (!entity.isNew()) entity.trigger('sync', entity, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        langx.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the entity's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        langx.result(this, 'urlRoot') ||
        langx.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the entity. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    }
  });

  return entities.Entity = Entity;

});
define('skylark-data-entities/Collection',[
	"skylark-langx/langx",
	"./entities",
	"./Entity"
],function(langx,entities,Entity){
  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };


	var Collection  = langx.Evented.inherit({
		"_construct" : function(entities, options) {
			options || (options = {});
			if (options.entity) this.entity = options.entity;
			if (options.comparator !== void 0) this.comparator = options.comparator;
			this._reset();
			if (entities) this.reset(entities, langx.mixin({silent: true}, options));
		}
	}); 

	// Default options for `Collection#set`.
	var setOptions = {add: true, remove: true, merge: true};
	var addOptions = {add: true, remove: false};

	// Splices `insert` into `array` at index `at`.
	var splice = function(array, insert, at) {
		at = Math.min(Math.max(at, 0), array.length);
		var tail = Array(array.length - at);
		var length = insert.length;
		var i;
		for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
		for (i = 0; i < length; i++) array[i + at] = insert[i];
		for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	};

  // Define the Collection's inheritable methods.
	Collection.partial({

		// The default entity for a collection is just a **Entity**.
		// This should be overridden in most cases.
		entity: Entity,

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// The JSON representation of a Collection is an array of the
		// entities' attributes.
		toJSON: function(options) {
		  return this.map(function(entity) { return entity.toJSON(options); });
		},

		// Proxy `entities.sync` by default.
		sync: function() {
		  return entities.sync.apply(this, arguments);
		},

		// Add a entity, or list of entities to the set. `entities` may be Backbone
		// Entitys or raw JavaScript objects to be converted to Entitys, or any
		// combination of the two.
		add: function(entities, options) {
		  return this.set(entities, langx.mixin({merge: false}, options, addOptions));
		},

		// Remove a entity, or a list of entities from the set.
		remove: function(entities, options) {
		  options = langx.mixin({}, options);
		  var singular = !langx.isArray(entities);
		  entities = singular ? [entities] : entities.slice();
		  var removed = this._removeEntitys(entities, options);
		  if (!options.silent && removed.length) {
		    options.changes = {added: [], merged: [], removed: removed};
		    this.trigger('update', this, options);
		  }
		  return singular ? removed[0] : removed;
		},

		// Update a collection by `set`-ing a new list of entities, adding new ones,
		// removing entities that are no longer present, and merging entities that
		// already exist in the collection, as necessary. Similar to **Entity#set**,
		// the core operation for updating the data contained by the collection.
		set: function(entities, options) {
		  if (entities == null) return;

		  options = langx.mixin({}, setOptions, options);
		  if (options.parse && !this._isEntity(entities)) {
		    entities = this.parse(entities, options) || [];
		  }

		  var singular = !langx.isArray(entities);
		  entities = singular ? [entities] : entities.slice();

		  var at = options.at;
		  if (at != null) at = +at;
		  if (at > this.length) at = this.length;
		  if (at < 0) at += this.length + 1;

		  var set = [];
		  var toAdd = [];
		  var toMerge = [];
		  var toRemove = [];
		  var modelMap = {};

		  var add = options.add;
		  var merge = options.merge;
		  var remove = options.remove;

		  var sort = false;
		  var sortable = this.comparator && at == null && options.sort !== false;
		  var sortAttr = langx.isString(this.comparator) ? this.comparator : null;

		  // Turn bare objects into entity references, and prevent invalid entities
		  // from being added.
		  var entity, i;
		  for (i = 0; i < entities.length; i++) {
		    entity = entities[i];

		    // If a duplicate is found, prevent it from being added and
		    // optionally merge it into the existing entity.
		    var existing = this.get(entity);
		    if (existing) {
		      if (merge && entity !== existing) {
		        var attrs = this._isEntity(entity) ? entity.attributes : entity;
		        if (options.parse) attrs = existing.parse(attrs, options);
		        existing.set(attrs, options);
		        toMerge.push(existing);
		        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
		      }
		      if (!modelMap[existing.cid]) {
		        modelMap[existing.cid] = true;
		        set.push(existing);
		      }
		      entities[i] = existing;

		    // If this is a new, valid entity, push it to the `toAdd` list.
		    } else if (add) {
		      entity = entities[i] = this._prepareEntity(entity, options);
		      if (entity) {
		        toAdd.push(entity);
		        this._addReference(entity, options);
		        modelMap[entity.cid] = true;
		        set.push(entity);
		      }
		    }
		  }

		  // Remove stale entities.
		  if (remove) {
		    for (i = 0; i < this.length; i++) {
		      entity = this.entities[i];
		      if (!modelMap[entity.cid]) toRemove.push(entity);
		    }
		    if (toRemove.length) this._removeEntitys(toRemove, options);
		  }

		  // See if sorting is needed, update `length` and splice in new entities.
		  var orderChanged = false;
		  var replace = !sortable && add && remove;
		  if (set.length && replace) {
		    orderChanged = this.length !== set.length || this.entities.some(function(m, index) {
		      return m !== set[index];
		    });
		    this.entities.length = 0;
		    splice(this.entities, set, 0);
		    this.length = this.entities.length;
		  } else if (toAdd.length) {
		    if (sortable) sort = true;
		    splice(this.entities, toAdd, at == null ? this.length : at);
		    this.length = this.entities.length;
		  }

		  // Silently sort the collection if appropriate.
		  if (sort) this.sort({silent: true});

		  // Unless silenced, it's time to fire all appropriate add/sort/update events.
		  if (!options.silent) {
		    for (i = 0; i < toAdd.length; i++) {
		      if (at != null) options.index = at + i;
		      entity = toAdd[i];
		      entity.trigger('add', entity, this, options);
		    }
		    if (sort || orderChanged) this.trigger('sort', this, options);
		    if (toAdd.length || toRemove.length || toMerge.length) {
		      options.changes = {
		        added: toAdd,
		        removed: toRemove,
		        merged: toMerge
		      };
		      this.trigger('update', this, options);
		    }
		  }

		  // Return the added (or merged) entity (or entities).
		  return singular ? entities[0] : entities;
		},

		// When you have more items than you want to add or remove individually,
		// you can reset the entire set with a new list of entities, without firing
		// any granular `add` or `remove` events. Fires `reset` when finished.
		// Useful for bulk operations and optimizations.
		reset: function(entities, options) {
		  options = options ? langx.clone(options) : {};
		  for (var i = 0; i < this.entities.length; i++) {
		    this._removeReference(this.entities[i], options);
		  }
		  options.previousEntitys = this.entities;
		  this._reset();
		  entities = this.add(entities, langx.mixin({silent: true}, options));
		  if (!options.silent) this.trigger('reset', this, options);
		  return entities;
		},

		// Add a entity to the end of the collection.
		push: function(entity, options) {
		  return this.add(entity, langx.mixin({at: this.length}, options));
		},

		// Remove a entity from the end of the collection.
		pop: function(options) {
		  var entity = this.at(this.length - 1);
		  return this.remove(entity, options);
		},

		// Add a entity to the beginning of the collection.
		unshift: function(entity, options) {
		  return this.add(entity, langx.mixin({at: 0}, options));
		},

		// Remove a entity from the beginning of the collection.
		shift: function(options) {
		  var entity = this.at(0);
		  return this.remove(entity, options);
		},

		// Slice out a sub-array of entities from the collection.
		slice: function() {
		  return slice.apply(this.entities, arguments);
		},

		// Get a entity from the set by id, cid, entity object with id or cid
		// properties, or an attributes object that is transformed through entityId.
		get: function(obj) {
		  if (obj == null) return void 0;
		  return this._byId[obj] ||
		    this._byId[this.entityId(obj.attributes || obj)] ||
		    obj.cid && this._byId[obj.cid];
		},

		// Returns `true` if the entity is in the collection.
		has: function(obj) {
		  return this.get(obj) != null;
		},

		// Get the entity at the given index.
		at: function(index) {
		  if (index < 0) index += this.length;
		  return this.entities[index];
		},

		// Return entities with matching attributes. Useful for simple cases of
		// `filter`.
		where: function(attrs, first) {
		  return this[first ? 'find' : 'filter'](attrs);
		},

		// Return the first entity with matching attributes. Useful for simple cases
		// of `find`.
		findWhere: function(attrs) {
		  return this.where(attrs, true);
		},

		// Force the collection to re-sort itself. You don't need to call this under
		// normal circumstances, as the set will maintain sort order as each item
		// is added.
		sort: function(options) {
		  var comparator = this.comparator;
		  if (!comparator) throw new Error('Cannot sort a set without a comparator');
		  options || (options = {});

		  var length = comparator.length;
		  if (langx.isFunction(comparator)) comparator = langx.proxy(comparator, this);

		  // Run sort based on type of `comparator`.
		  if (length === 1 || langx.isString(comparator)) {
		    this.entities = this.sortBy(comparator);
		  } else {
		    this.entities.sort(comparator);
		  }
		  if (!options.silent) this.trigger('sort', this, options);
		  return this;
		},

		// Pluck an attribute from each entity in the collection.
		pluck: function(attr) {
		  return this.map(attr + '');
		},

		// Fetch the default set of entities for this collection, resetting the
		// collection when they arrive. If `reset: true` is passed, the response
		// data will be passed through the `reset` method instead of `set`.
		fetch: function(options) {
		  options = langx.mixin({parse: true}, options);
		  var success = options.success;
		  var collection = this;
		  options.success = function(resp) {
		    var method = options.reset ? 'reset' : 'set';
		    collection[method](resp, options);
		    if (success) success.call(options.context, collection, resp, options);
		    collection.trigger('sync', collection, resp, options);
		  };
		  wrapError(this, options);
		  return this.sync('read', this, options);
		},

		// Create a new instance of a entity in this collection. Add the entity to the
		// collection immediately, unless `wait: true` is passed, in which case we
		// wait for the server to agree.
		create: function(entity, options) {
		  options = options ? langx.clone(options) : {};
		  var wait = options.wait;
		  entity = this._prepareEntity(entity, options);
		  if (!entity) return false;
		  if (!wait) this.add(entity, options);
		  var collection = this;
		  var success = options.success;
		  options.success = function(m, resp, callbackOpts) {
		    if (wait) collection.add(m, callbackOpts);
		    if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
		  };
		  entity.save(null, options);
		  return entity;
		},

		// **parse** converts a response into a list of entities to be added to the
		// collection. The default implementation is just to pass it through.
		parse: function(resp, options) {
		  return resp;
		},

		// Create a new collection with an identical list of entities as this one.
		clone: function() {
		  return new this.constructor(this.entities, {
		    entity: this.entity,
		    comparator: this.comparator
		  });
		},

		// Define how to uniquely identify entities in the collection.
		entityId: function(attrs) {
		  return attrs[this.entity.prototype.idAttribute || 'id'];
		},

		// Private method to reset all internal state. Called when the collection
		// is first initialized or reset.
		_reset: function() {
		  this.length = 0;
		  this.entities = [];
		  this._byId  = {};
		},

		// Prepare a hash of attributes (or other entity) to be added to this
		// collection.
		_prepareEntity: function(attrs, options) {
		  if (this._isEntity(attrs)) {
		    if (!attrs.collection) attrs.collection = this;
		    return attrs;
		  }
		  options = options ? langx.clone(options) : {};
		  options.collection = this;
		  var entity = new this.entity(attrs, options);
		  if (!entity.validationError) return entity;
		  this.trigger('invalid', this, entity.validationError, options);
		  return false;
		},

		// Internal method called by both remove and set.
		_removeEntitys: function(entities, options) {
		  var removed = [];
		  for (var i = 0; i < entities.length; i++) {
		    var entity = this.get(entities[i]);
		    if (!entity) continue;

		    var index = this.indexOf(entity);
		    this.entities.splice(index, 1);
		    this.length--;

		    // Remove references before triggering 'remove' event to prevent an
		    // infinite loop. #3693
		    delete this._byId[entity.cid];
		    var id = this.entityId(entity.attributes);
		    if (id != null) delete this._byId[id];

		    if (!options.silent) {
		      options.index = index;
		      entity.trigger('remove', entity, this, options);
		    }

		    removed.push(entity);
		    this._removeReference(entity, options);
		  }
		  return removed;
		},

		// Method for checking whether an object should be considered a entity for
		// the purposes of adding to the collection.
		_isEntity: function(entity) {
		  return entity instanceof Entity;
		},

		// Internal method to create a entity's ties to a collection.
		_addReference: function(entity, options) {
		  this._byId[entity.cid] = entity;
		  var id = this.entityId(entity.attributes);
		  if (id != null) this._byId[id] = entity;
		  entity.on('all', this._onEntityEvent, this);
		},

		// Internal method to sever a entity's ties to a collection.
		_removeReference: function(entity, options) {
		  delete this._byId[entity.cid];
		  var id = this.entityId(entity.attributes);
		  if (id != null) delete this._byId[id];
		  if (this === entity.collection) delete entity.collection;
		  entity.off('all', this._onEntityEvent, this);
		},

		// Internal method called every time a entity in the set fires an event.
		// Sets need to update their indexes when entities change ids. All other
		// events simply proxy through. "add" and "remove" events that originate
		// in other collections are ignored.
		_onEntityEvent: function(event, entity, collection, options) {
		  if (entity) {
		    if ((event === 'add' || event === 'remove') && collection !== this) return;
		    if (event === 'destroy') this.remove(entity, options);
		    if (event === 'change') {
		      var prevId = this.entityId(entity.previousAttributes());
		      var id = this.entityId(entity.attributes);
		      if (prevId !== id) {
		        if (prevId != null) delete this._byId[prevId];
		        if (id != null) this._byId[id] = entity;
		      }
		    }
		  }
		  this.trigger.apply(this, arguments);
		}

  	});

	return entities.Collection = Collection;
});
define('skylark-data-entities/backends/registry',[
	
],function(){
	var providers = {

	};

	function add(name,setting) {
		providers[name] = setting;
	}

	function remove(name) {
		delete provides[name];
	}

	function get(name) {
		return providers[name];
	}

	return {
		add : add,
		remove: remove,
		get : get
	}
});
define('skylark-data-entities/sync',[
	"skylark-langx/langx",
	"./entities",
  	"./backends/registry"
],function(langx,entities,registry){

	// Override 'Backbone.sync' to default to localSync,
	// the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'
	function sync(method, model, options) {
		if (!options.backend) {
			throw new Error("The backend is not specified")
		}
		var setting = registry.get(options.backend);
		if (!setting) {
			throw new Error("The backend is not defined:" + options.backend);
		}
		var syncMethod = setting.sync;
		if (!syncMethod) {
			throw new Error("The backend sync method is not defined:" + options.backend);
		}

		var options2 = langx.mixin({},setting.options,options);
	  	return syncMethod.apply(this, [method, model, options2]);
	};

  
   return entities.sync = sync;

});
define('skylark-data-entities/backends/ajaxSync',[
	"skylark-langx/langx",
	"../entities"
],function(langx,entities){
// Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  };
  

  var sync = function(method, entity, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    langx.defaults(options || (options = {}), {
      emulateHTTP: entities.emulateHTTP,
      emulateJSON: entities.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = langx.result(entity, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && entity && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || entity.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {entity: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = langx.Xhr.request(langx.mixin(params, options));
    entity.trigger('request', entity, xhr, options);
    return xhr;
  };

 
  
  return entities.backends.ajaxSync = sync;

});
define('skylark-data-entities/backends/localSync',[
  "skylark-langx/langx",
  "../entities"
],function(langx,entities){

  // A simple module to replace `Backbone.sync` with *localStorage*-based
  // persistence. Models are given GUIDS, and saved into a JSON object. Simple
  // as that.

  // Hold reference to Underscore.js and Backbone.js in the closure in order
  // to make things work even if they are removed from the global namespace

  // Generate four random hex digits.
  function S4() {
     return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
  };

  // Generate a pseudo-GUID by concatenating random hexadecimal.
  function guid() {
     return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
  };

  // Our Store is represented by a single JS object in *localStorage*. Create it
  // with a meaningful name, like the name you'd give a table.
  // window.Store is deprecated, use Backbone.LocalStorage instead
  var LocalStorage = langx.klass({
    _construct : function(name) {
      this.name = name;
      var store = this.localStorage().getItem(this.name);
      this.records = (store && store.split(",")) || [];
    },

    // Save the current state of the **Store** to *localStorage*.
    save: function() {
      this.localStorage().setItem(this.name, this.records.join(","));
    },

    // Add a model, giving it a (hopefully)-unique GUID, if it doesn't already
    // have an id of it's own.
    create: function(model) {
      if (!model.id) {
        model.id = guid();
        model.set(model.idAttribute, model.id);
      }
      this.localStorage().setItem(this.name+"-"+model.id, JSON.stringify(model));
      this.records.push(model.id.toString());
      this.save();
      return this.find(model);
    },

    // Update a model by replacing its copy in `this.data`.
    update: function(model) {
      this.localStorage().setItem(this.name+"-"+model.id, JSON.stringify(model));
      if (!_.include(this.records, model.id.toString()))
        this.records.push(model.id.toString()); this.save();
      return this.find(model);
    },

    // Retrieve a model from `this.data` by id.
    find: function(model) {
      return this.jsonData(this.localStorage().getItem(this.name+"-"+model.id));
    },

    // Return the array of all entities currently in storage.
    findAll: function() {
      return _(this.records).chain()
        .map(function(id){
          return this.jsonData(this.localStorage().getItem(this.name+"-"+id));
        }, this)
        .compact()
        .value();
    },

    // Delete a model from `this.data`, returning it.
    destroy: function(model) {
      if (model.isNew())
        return false
      this.localStorage().removeItem(this.name+"-"+model.id);
      this.records = _.reject(this.records, function(id){
        return id === model.id.toString();
      });
      this.save();
      return model;
    },

    localStorage: function() {
      return localStorage;
    },

    // fix for "illegal access" error on Android when JSON.parse is passed null
    jsonData: function (data) {
        return data && JSON.parse(data);
    }

  });

  // localSync delegate to the model or collection's
  // *localStorage* property, which should be an instance of `Store`.
  function sync(method, model, options) {
    var store = model.localStorage || model.collection.localStorage;

    var resp, errorMessage, syncDfd = langx.Deferred(); //If $ is having Deferred - use it.

    try {

      switch (method) {
        case "read":
          resp = model.id != undefined ? store.find(model) : store.findAll();
          break;
        case "create":
          resp = store.create(model);
          break;
        case "update":
          resp = store.update(model);
          break;
        case "delete":
          resp = store.destroy(model);
          break;
      }

    } catch(error) {
      if (error.code === DOMException.QUOTA_EXCEEDED_ERR && window.localStorage.length === 0)
        errorMessage = "Private browsing is unsupported";
      else
        errorMessage = error.message;
    }

    if (resp) {
      model.trigger("sync", model, resp, options);
      if (options && options.success)
        options.success(resp);
      if (syncDfd)
        syncDfd.resolve(resp);

    } else {
      errorMessage = errorMessage ? errorMessage
                                  : "Record Not Found";

      if (options && options.error)
        options.error(errorMessage);
      if (syncDfd)
        syncDfd.reject(errorMessage);
    }

    // add compatibility with $.ajax
    // always execute callback for success and error
    if (options && options.complete) options.complete(resp);

    return syncDfd && syncDfd.promise();
  };

  entities.backends.LocalStorage = sync.LocalStorage = LocalStorage;
  
  return entities.backends.localSync = sync;

});
define('skylark-data-entities/main',[
	"./entities",
	"./Collection",
	"./Entity",
	"./sync",
	"./backends/ajaxSync",
	"./backends/localSync",
	"./backends/registry"
],function(entities){
	return entities;
});
define('skylark-data-entities', ['skylark-data-entities/main'], function (main) { return main; });

define('skylark-data-streams/streams',[
    "skylark-langx/skylark"
], function(skylark) {

    return skylark.attach("data.streams",{});
});

define('skylark-data-streams/Stream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams"
], function(skylark, langx,streams) {

   	var Stream = langx.Evented.inherit({
        klassName: "Stream",
        init: function(arrayBuffer, start, length, dict) {
	        this.bytes = new Uint8Array(arrayBuffer);
	        this.start = start || 0;
	        this.pos = this.start;
	        this.end = (start + length) || this.bytes.length;
	        this.dict = dict;
        },


        length : {
        	get : function() {
            	return this.end - this.start;
        	}
        },

        getByte: function () {
            if (this.pos >= this.end)
                return null;
            return this.bytes[this.pos++];
        },
        // returns subarray of original buffer
        // should only be read
        getBytes: function (length) {
            var bytes = this.bytes;
            var pos = this.pos;
            var strEnd = this.end;

            if (!length)
                return bytes.subarray(pos, strEnd);

            var end = pos + length;
            if (end > strEnd)
                end = strEnd;

            this.pos = end;
            return bytes.subarray(pos, end);
        },

        lookChar: function () {
            if (this.pos >= this.end)
                return null;
            return String.fromCharCode(this.bytes[this.pos]);
        },
        getChar: function () {
            if (this.pos >= this.end)
                return null;
            return String.fromCharCode(this.bytes[this.pos++]);
        },
        skip: function (n) {
            if (!n)
                n = 1;
            this.pos += n;
        },
        reset: function () {
            this.pos = this.start;
        },
        moveStart: function () {
            this.start = this.pos;
        },
        makeSubStream: function (start, length, dict) {
            return new Stream(this.bytes.buffer, start, length, dict);
        },
        isStream: true
    });
    
    return streams.Stream = Stream;
	
});

define('skylark-data-streams/DecodeStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./Stream"
], function(skylark, langx, streams, Stream) {

    var DecodeStream = Stream.inherit({
        klassName : "DecodeStream",

        init : function() {
            this.pos = 0;
            this.bufferLength = 0;
            this.eof = false;
            this.buffer = null;     
        },

        ensureBuffer: function(requested) {
            var buffer = this.buffer;
            var current = buffer ? buffer.byteLength : 0;
            if (requested < current)
                return buffer;
            var size = 512;
            while (size < requested)
                size <<= 1;
            var buffer2 = new Uint8Array(size);
            for (var i = 0; i < current; ++i)
                buffer2[i] = buffer[i];
            return (this.buffer = buffer2);
        },
        getByte: function () {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return this.buffer[this.pos++];
        },
        getBytes: function(length) {
            var end, pos = this.pos;

            if (length) {
                this.ensureBuffer(pos + length);
                end = pos + length;

                while (!this.eof && this.bufferLength < end)
                    this.readBlock();

                var bufEnd = this.bufferLength;
                if (end > bufEnd)
                    end = bufEnd;
            } else {
                while (!this.eof)
                    this.readBlock();

                end = this.bufferLength;

                // checking if bufferLength is still 0 then
                // the buffer has to be initialized
                if (!end)
                    this.buffer = new Uint8Array(0);
            }

            this.pos = end;
            return this.buffer.subarray(pos, end);
        },
        lookChar: function() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return String.fromCharCode(this.buffer[this.pos]);
        },
        getChar: function () {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return String.fromCharCode(this.buffer[this.pos++]);
        },
        makeSubStream: function (start, length, dict) {
            var end = start + length;
            while (this.bufferLength <= end && !this.eof)
                this.readBlock();
            return new Stream(this.buffer, start, length, dict);
        },
        skip: function (n) {
            if (!n)
                n = 1;
            this.pos += n;
        },
        reset: function () {
            this.pos = 0;
        }

    });

    return streams.DecodeStream = DecodeStream;

});

define('skylark-data-streams/Ascii85Stream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var Ascii85Stream = DecodeStream.inherit({
        klassName : "Ascii85Stream",

        init : function(str) {
            this.str = str;
            this.dict = str.dict;
            this.input = new Uint8Array(5);

            DecodeStream.prototype.init.call(this);          
        },

        readBlock : function() {
            var tildaCode = '~'.charCodeAt(0);
            var zCode = 'z'.charCodeAt(0);
            var str = this.str;

            var c = str.getByte();
            while (Lexer.isSpace(String.fromCharCode(c)))
                c = str.getByte();

            if (!c || c === tildaCode) {
                this.eof = true;
                return;
            }

            var bufferLength = this.bufferLength,
                buffer;

            // special code for z
            if (c == zCode) {
                buffer = this.ensureBuffer(bufferLength + 4);
                for (var i = 0; i < 4; ++i)
                    buffer[bufferLength + i] = 0;
                this.bufferLength += 4;
            } else {
                var input = this.input;
                input[0] = c;
                for (var i = 1; i < 5; ++i) {
                    c = str.getByte();
                    while (Lexer.isSpace(String.fromCharCode(c)))
                        c = str.getByte();

                    input[i] = c;

                    if (!c || c == tildaCode)
                        break;
                }
                buffer = this.ensureBuffer(bufferLength + i - 1);
                this.bufferLength += i - 1;

                // partial ending;
                if (i < 5) {
                    for (; i < 5; ++i)
                        input[i] = 0x21 + 84;
                    this.eof = true;
                }
                var t = 0;
                for (var i = 0; i < 5; ++i)
                    t = t * 85 + (input[i] - 0x21);

                for (var i = 3; i >= 0; --i) {
                    buffer[bufferLength + i] = t & 0xFF;
                    t >>= 8;
                }
            }

        }

    });

    return streams.Ascii85Stream = Ascii85Stream;

});

define('skylark-data-streams/AsciiHexStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {
    var hexvalueMap = {
        9: -1, // \t
        32: -1, // space
        48: 0,
        49: 1,
        50: 2,
        51: 3,
        52: 4,
        53: 5,
        54: 6,
        55: 7,
        56: 8,
        57: 9,
        65: 10,
        66: 11,
        67: 12,
        68: 13,
        69: 14,
        70: 15,
        97: 10,
        98: 11,
        99: 12,
        100: 13,
        101: 14,
        102: 15
    };

    var AsciiHexStream = DecodeStream.inherit({
        klassName : "AsciiHexStream",

        init : function(str) {
            this.str = str;
            this.dict = str.dict;

            DecodeStream.prototype.init.call(this);          
        },

        readBlock : function() {
            var gtCode = '>'.charCodeAt(0),
                bytes = this.str.getBytes(),
                c, n,
                decodeLength, buffer, bufferLength, i, length;

            decodeLength = (bytes.length + 1) >> 1;
            buffer = this.ensureBuffer(this.bufferLength + decodeLength);
            bufferLength = this.bufferLength;

            for (i = 0, length = bytes.length; i < length; i++) {
                c = hexvalueMap[bytes[i]];
                while (c == -1 && (i + 1) < length) {
                    c = hexvalueMap[bytes[++i]];
                }

                if ((i + 1) < length && (bytes[i + 1] !== gtCode)) {
                    n = hexvalueMap[bytes[++i]];
                    buffer[bufferLength++] = c * 16 + n;
                } else {
                    // EOD marker at an odd number, behave as if a 0 followed the last
                    // digit.
                    if (bytes[i] !== gtCode) {
                        buffer[bufferLength++] = c * 16;
                    }
                }
            }

            this.bufferLength = bufferLength;
            this.eof = true;        
       }

    });

    return streams.AsciiHexStream = AsciiHexStream;
});

define('skylark-data-streams/ChunkedStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./Stream"
], function(skylark, langx,streams,Stream) {


    var ChunkedStream = Stream.inherit({
        klassName : "ChunkedStream",

        "numChunks": 0,
        "numChunksLoaded": 0,

        init : function(str) {
            var length = str.length;
            var bytes = new Uint8Array(length);
            for (var n = 0; n < length; ++n)
                bytes[n] = str.charCodeAt(n);
            DecodeStream.prototype.init.call(bytes);          
            this.dict = stream.dict;
        },

        "numChunks": function() {

        },


        getMissingChunks: function ChunkedStream_getMissingChunks() {
            var chunks = [];
            for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    chunks.push(chunk);
                }
            }
            return chunks;
        },

        getBaseStreams: function ChunkedStream_getBaseStreams() {
            return [this];
        },

        allChunksLoaded: function ChunkedStream_allChunksLoaded() {
            var _ = this._;
            return _.numChunksLoaded === _.numChunks;
        },

        onReceiveData: function(begin, chunk) {
            var end = begin + chunk.byteLength;

            assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);
            // Using this.length is inaccurate here since this.start can be moved
            // See ChunkedStream.moveStart()
            var length = this.bytes.length;
            assert(end % this.chunkSize === 0 || end === length,
                'Bad end offset: ' + end);

            this.bytes.set(new Uint8Array(chunk), begin);
            var chunkSize = this.chunkSize;
            var beginChunk = Math.floor(begin / chunkSize);
            var endChunk = Math.floor((end - 1) / chunkSize) + 1;

            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    this.loadedChunks[chunk] = true;
                    ++this.numChunksLoaded;
                }
            }
        },

        onReceiveInitialData: function(data) {
            this.bytes.set(data);
            this.initialDataLength = data.length;
            var endChunk = this.end === data.length ?
                this.numChunks : Math.floor(data.length / this.chunkSize);
            for (var i = 0; i < endChunk; i++) {
                this.loadedChunks[i] = true;
                ++this.numChunksLoaded;
            }
        },

        ensureRange: function ChunkedStream_ensureRange(begin, end) {
            if (begin >= end) {
                return;
            }

            if (end <= this.initialDataLength) {
                return;
            }

            var chunkSize = this.chunkSize;
            var beginChunk = Math.floor(begin / chunkSize);
            var endChunk = Math.floor((end - 1) / chunkSize) + 1;
            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    throw new MissingDataException(begin, end);
                }
            }
        },

        nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
            for (var chunk = beginChunk, n = this.numChunks; chunk < n; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    return chunk;
                }
            }
            // Wrap around to beginning
            for (var chunk = 0; chunk < beginChunk; ++chunk) {
                if (!(chunk in this.loadedChunks)) {
                    return chunk;
                }
            }
            return null;
        },

        hasChunk: function ChunkedStream_hasChunk(chunk) {
            return chunk in this._.loadedChunks;
        },

        getByte: function ChunkedStream_getByte() {
            var pos = this.pos;
            if (pos >= this.end) {
                return -1;
            }
            this.ensureRange(pos, pos + 1);
            return this.bytes[this.pos++];
        },

        // returns subarray of original buffer
        // should only be read
        getBytes: function ChunkedStream_getBytes(length) {
            var bytes = this.bytes;
            var pos = this.pos;
            var strEnd = this.end;

            if (!length) {
                this.ensureRange(pos, strEnd);
                return bytes.subarray(pos, strEnd);
            }

            var end = pos + length;
            if (end > strEnd)
                end = strEnd;
            this.ensureRange(pos, end);

            this.pos = end;
            return bytes.subarray(pos, end);
        },

        peekBytes: function ChunkedStream_peekBytes(length) {
            var bytes = this.getBytes(length);
            this.pos -= bytes.length;
            return bytes;
        },

        getByteRange: function ChunkedStream_getBytes(begin, end) {
            this.ensureRange(begin, end);
            return this.bytes.subarray(begin, end);
        },

        skip: function ChunkedStream_skip(n) {
            if (!n)
                n = 1;
            this.pos += n;
        },

        reset: function ChunkedStream_reset() {
            this.pos = this.start;
        },

        moveStart: function ChunkedStream_moveStart() {
            this.start = this.pos;
        },

        makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
            function ChunkedStreamSubstream() {}
            ChunkedStreamSubstream.prototype = Object.create(this);
            ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                var chunkSize = this.chunkSize;
                var beginChunk = Math.floor(this.start / chunkSize);
                var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                var missingChunks = [];
                for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!(chunk in this.loadedChunks)) {
                        missingChunks.push(chunk);
                    }
                }
                return missingChunks;
            };
            var subStream = new ChunkedStreamSubstream();
            subStream.pos = subStream.start = start;
            subStream.end = start + length || this.end;
            subStream.dict = dict;
            return subStream;
        }
    });

    return streams.ChunkedStream = ChunkedStream;

});


define('skylark-data-streams/DecryptStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var chunkSize = 512;

    var DecryptStream = DecodeStream.inherit({
        klassName : "DecryptStream",

        init : function(str, decrypt) {
            this.str = str;
            this.dict = str.dict;
            this.decrypt = decrypt;
            DecodeStream.prototype.init.call(this);          
        },

        readBlock : function() {
            var chunk = this.str.getBytes(chunkSize);
            if (!chunk || chunk.length == 0) {
                this.eof = true;
                return;
            }
            var decrypt = this.decrypt;
            chunk = decrypt(chunk);

            var bufferLength = this.bufferLength;
            var i, n = chunk.length;
            var buffer = this.ensureBuffer(bufferLength + n);
            for (i = 0; i < n; i++)
                buffer[bufferLength++] = chunk[i];
            this.bufferLength = bufferLength;
        }
    });

    return streams.DecryptStream = DecryptStream;
});


define('skylark-data-streams/FakeStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var FakeStream = DecodeStream.inherit({
        klassName : "FakeStream",

        init : function(stream) {
            this.dict = stream.dict;
            Stream.prototype.init.call(this);          
        },

        readBlock : function() {
            var bufferLength = this.bufferLength;
            bufferLength += 1024;
            var buffer = this.ensureBuffer(bufferLength);
            this.bufferLength = bufferLength;
        },

        getBytes : function (length) {
            var end, pos = this.pos;

            if (length) {
                this.ensureBuffer(pos + length);
                end = pos + length;

                while (!this.eof && this.bufferLength < end)
                    this.readBlock();

                var bufEnd = this.bufferLength;
                if (end > bufEnd)
                    end = bufEnd;
            } else {
                this.eof = true;
                end = this.bufferLength;
            }

            this.pos = end;
            return this.buffer.subarray(pos, end);
        }

    });

    return streams.FakeStream = FakeStream;
});


define('skylark-data-streams/FlateStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var codeLenCodeMap = new Uint32Array([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
    ]);

    var lengthDecode = new Uint32Array([
        0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
        0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
        0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
        0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
    ]);

    var distDecode = new Uint32Array([
        0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
        0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
        0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
        0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
    ]);

    var fixedLitCodeTab = [new Uint32Array([
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
        0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
        0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
        0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
        0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
        0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
        0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
        0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
        0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
        0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
        0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
        0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
        0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
        0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
        0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
        0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
        0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
        0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
        0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
        0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
        0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
        0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
        0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
        0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
        0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
        0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
        0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
        0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
        0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
        0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
        0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
        0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
        0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
        0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
        0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
        0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
        0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
        0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
        0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
        0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
        0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
        0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
        0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
        0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
        0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
        0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
        0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
        0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
        0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
    ]), 9];

    var fixedDistCodeTab = [new Uint32Array([
        0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
        0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
        0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
        0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
    ]), 5];


    var FlateStream = DecodeStream.inherit({
        klassName : "FlateStream",

        init : function(stream) {
            var bytes = stream.getBytes();
            var bytesPos = 0;

            this.dict = stream.dict;
            var cmf = bytes[bytesPos++];
            var flg = bytes[bytesPos++];
            if (cmf == -1 || flg == -1)
                error('Invalid header in flate stream: ' + cmf + ', ' + flg);
            if ((cmf & 0x0f) != 0x08)
                error('Unknown compression method in flate stream: ' + cmf + ', ' + flg);
            if ((((cmf << 8) + flg) % 31) != 0)
                error('Bad FCHECK in flate stream: ' + cmf + ', ' + flg);
            if (flg & 0x20)
                error('FDICT bit set in flate stream: ' + cmf + ', ' + flg);

            this.bytes = bytes;
            this.bytesPos = bytesPos;

            this.codeSize = 0;
            this.codeBuf = 0;
            DecodeStream.prototype.init.call(this);          
        },

        getBits : function(bits) {
            var codeSize = this.codeSize;
            var codeBuf = this.codeBuf;
            var bytes = this.bytes;
            var bytesPos = this.bytesPos;

            var b;
            while (codeSize < bits) {
                if (typeof(b = bytes[bytesPos++]) == 'undefined')
                    error('Bad encoding in flate stream');
                codeBuf |= b << codeSize;
                codeSize += 8;
            }
            b = codeBuf & ((1 << bits) - 1);
            this.codeBuf = codeBuf >> bits;
            this.codeSize = codeSize -= bits;
            this.bytesPos = bytesPos;
            return b;
        },

        getCode : function(table) {
            var codes = table[0];
            var maxLen = table[1];
            var codeSize = this.codeSize;
            var codeBuf = this.codeBuf;
            var bytes = this.bytes;
            var bytesPos = this.bytesPos;

            while (codeSize < maxLen) {
                var b;
                if (typeof(b = bytes[bytesPos++]) == 'undefined')
                    error('Bad encoding in flate stream');
                codeBuf |= (b << codeSize);
                codeSize += 8;
            }
            var code = codes[codeBuf & ((1 << maxLen) - 1)];
            var codeLen = code >> 16;
            var codeVal = code & 0xffff;
            if (codeSize == 0 || codeSize < codeLen || codeLen == 0)
                error('Bad encoding in flate stream');
            this.codeBuf = (codeBuf >> codeLen);
            this.codeSize = (codeSize - codeLen);
            this.bytesPos = bytesPos;
            return codeVal;
        },

        generateHuffmanTable : function(lengths) {
                var n = lengths.length;

                // find max code length
                var maxLen = 0;
                for (var i = 0; i < n; ++i) {
                    if (lengths[i] > maxLen)
                        maxLen = lengths[i];
                }

                // build the table
                var size = 1 << maxLen;
                var codes = new Uint32Array(size);
                for (var len = 1, code = 0, skip = 2; len <= maxLen;
                    ++len, code <<= 1, skip <<= 1) {
                    for (var val = 0; val < n; ++val) {
                        if (lengths[val] == len) {
                            // bit-reverse the code
                            var code2 = 0;
                            var t = code;
                            for (var i = 0; i < len; ++i) {
                                code2 = (code2 << 1) | (t & 1);
                                t >>= 1;
                            }

                            // fill the table entries
                            for (var i = code2; i < size; i += skip)
                                codes[i] = (len << 16) | val;

                            ++code;
                        }
                    }
                }

                return [codes, maxLen];
        },

        readBlock : function() {
            // read block header
            var hdr = this.getBits(3);
            if (hdr & 1)
                this.eof = true;
            hdr >>= 1;

            if (hdr == 0) { // uncompressed block
                var bytes = this.bytes;
                var bytesPos = this.bytesPos;
                var b;

                if (typeof(b = bytes[bytesPos++]) == 'undefined')
                    error('Bad block header in flate stream');
                var blockLen = b;
                if (typeof(b = bytes[bytesPos++]) == 'undefined')
                    error('Bad block header in flate stream');
                blockLen |= (b << 8);
                if (typeof(b = bytes[bytesPos++]) == 'undefined')
                    error('Bad block header in flate stream');
                var check = b;
                if (typeof(b = bytes[bytesPos++]) == 'undefined')
                    error('Bad block header in flate stream');
                check |= (b << 8);
                if (check != (~blockLen & 0xffff))
                    error('Bad uncompressed block length in flate stream');

                this.codeBuf = 0;
                this.codeSize = 0;

                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + blockLen);
                var end = bufferLength + blockLen;
                this.bufferLength = end;
                for (var n = bufferLength; n < end; ++n) {
                    if (typeof(b = bytes[bytesPos++]) == 'undefined') {
                        this.eof = true;
                        break;
                    }
                    buffer[n] = b;
                }
                this.bytesPos = bytesPos;
                return;
            }

            var litCodeTable;
            var distCodeTable;
            if (hdr == 1) { // compressed block, fixed codes
                litCodeTable = fixedLitCodeTab;
                distCodeTable = fixedDistCodeTab;
            } else if (hdr == 2) { // compressed block, dynamic codes
                var numLitCodes = this.getBits(5) + 257;
                var numDistCodes = this.getBits(5) + 1;
                var numCodeLenCodes = this.getBits(4) + 4;

                // build the code lengths code table
                var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);

                for (var i = 0; i < numCodeLenCodes; ++i)
                    codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);

                // build the literal and distance code tables
                var len = 0;
                var i = 0;
                var codes = numLitCodes + numDistCodes;
                var codeLengths = new Uint8Array(codes);
                while (i < codes) {
                    var code = this.getCode(codeLenCodeTab);
                    if (code == 16) {
                        var bitsLength = 2,
                            bitsOffset = 3,
                            what = len;
                    } else if (code == 17) {
                        var bitsLength = 3,
                            bitsOffset = 3,
                            what = (len = 0);
                    } else if (code == 18) {
                        var bitsLength = 7,
                            bitsOffset = 11,
                            what = (len = 0);
                    } else {
                        codeLengths[i++] = len = code;
                        continue;
                    }

                    var repeatLength = this.getBits(bitsLength) + bitsOffset;
                    while (repeatLength-- > 0)
                        codeLengths[i++] = what;
                }

                litCodeTable =
                    this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                distCodeTable =
                    this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
            } else {
                error('Unknown block type in flate stream');
            }

            var buffer = this.buffer;
            var limit = buffer ? buffer.length : 0;
            var pos = this.bufferLength;
            while (true) {
                var code1 = this.getCode(litCodeTable);
                if (code1 < 256) {
                    if (pos + 1 >= limit) {
                        buffer = this.ensureBuffer(pos + 1);
                        limit = buffer.length;
                    }
                    buffer[pos++] = code1;
                    continue;
                }
                if (code1 == 256) {
                    this.bufferLength = pos;
                    return;
                }
                code1 -= 257;
                code1 = lengthDecode[code1];
                var code2 = code1 >> 16;
                if (code2 > 0)
                    code2 = this.getBits(code2);
                var len = (code1 & 0xffff) + code2;
                code1 = this.getCode(distCodeTable);
                code1 = distDecode[code1];
                code2 = code1 >> 16;
                if (code2 > 0)
                    code2 = this.getBits(code2);
                var dist = (code1 & 0xffff) + code2;
                if (pos + len >= limit) {
                    buffer = this.ensureBuffer(pos + len);
                    limit = buffer.length;
                }
                for (var k = 0; k < len; ++k, ++pos)
                    buffer[pos] = buffer[pos - dist];
            }
        }
    });


    return streams.FlateStream = FlateStream;
});

define('skylark-data-streams/LZWStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var LZWStream = DecodeStream.inherit({
        klassName : "LZWStream",

        init : function(str, earlyChange) {
            this.str = str;
            this.dict = str.dict;
            this.cachedData = 0;
            this.bitsCached = 0;

            var maxLzwDictionarySize = 4096;
            var lzwState = {
                earlyChange: earlyChange,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                currentSequence: new Uint8Array(maxLzwDictionarySize),
                currentSequenceLength: 0
            };
            for (var i = 0; i < 256; ++i) {
                lzwState.dictionaryValues[i] = i;
                lzwState.dictionaryLengths[i] = 1;
            }
            this.lzwState = lzwState;
            DecodeStream.prototype.init.call(this);          
        },

        readBits : function(n) {
            var bitsCached = this.bitsCached;
            var cachedData = this.cachedData;
            while (bitsCached < n) {
                var c = this.str.getByte();
                if (c == null) {
                    this.eof = true;
                    return null;
                }
                cachedData = (cachedData << 8) | c;
                bitsCached += 8;
            }
            this.bitsCached = (bitsCached -= n);
            this.cachedData = cachedData;
            this.lastCode = null;
            return (cachedData >>> bitsCached) & ((1 << n) - 1);
        },

        readBlock : function() {
            var blockSize = 512;
            var estimatedDecodedSize = blockSize * 2,
                decodedSizeDelta = blockSize;
            var i, j, q;

            var lzwState = this.lzwState;
            if (!lzwState)
                return; // eof was found

            var earlyChange = lzwState.earlyChange;
            var nextCode = lzwState.nextCode;
            var dictionaryValues = lzwState.dictionaryValues;
            var dictionaryLengths = lzwState.dictionaryLengths;
            var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
            var codeLength = lzwState.codeLength;
            var prevCode = lzwState.prevCode;
            var currentSequence = lzwState.currentSequence;
            var currentSequenceLength = lzwState.currentSequenceLength;

            var decodedLength = 0;
            var currentBufferLength = this.bufferLength;
            var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);

            for (i = 0; i < blockSize; i++) {
                var code = this.readBits(codeLength);
                var hasPrev = currentSequenceLength > 0;
                if (code < 256) {
                    currentSequence[0] = code;
                    currentSequenceLength = 1;
                } else if (code >= 258) {
                    if (code < nextCode) {
                        currentSequenceLength = dictionaryLengths[code];
                        for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                            currentSequence[j] = dictionaryValues[q];
                            q = dictionaryPrevCodes[q];
                        }
                    } else {
                        currentSequence[currentSequenceLength++] = currentSequence[0];
                    }
                } else if (code == 256) {
                    codeLength = 9;
                    nextCode = 258;
                    currentSequenceLength = 0;
                    continue;
                } else {
                    this.eof = true;
                    delete this.lzwState;
                    break;
                }

                if (hasPrev) {
                    dictionaryPrevCodes[nextCode] = prevCode;
                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                    dictionaryValues[nextCode] = currentSequence[0];
                    nextCode++;
                    codeLength = (nextCode + earlyChange) & (nextCode + earlyChange - 1) ?
                        codeLength : Math.min(Math.log(nextCode + earlyChange) /
                            0.6931471805599453 + 1, 12) | 0;
                }
                prevCode = code;

                decodedLength += currentSequenceLength;
                if (estimatedDecodedSize < decodedLength) {
                    do {
                        estimatedDecodedSize += decodedSizeDelta;
                    } while (estimatedDecodedSize < decodedLength);
                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                }
                for (j = 0; j < currentSequenceLength; j++)
                    buffer[currentBufferLength++] = currentSequence[j];
            }
            lzwState.nextCode = nextCode;
            lzwState.codeLength = codeLength;
            lzwState.prevCode = prevCode;
            lzwState.currentSequenceLength = currentSequenceLength;

            this.bufferLength = currentBufferLength;
        }
    });

    return streams.LZWStream = LZWStream;
});


define('skylark-data-streams/PredictorStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var PredictorStream = DecodeStream.inherit({
        klassName : "PredictorStream",

        init : function(stream, params) {
            var predictor = this.predictor = params.get('Predictor') || 1;

            if (predictor <= 1)
                return stream; // no prediction
            if (predictor !== 2 && (predictor < 10 || predictor > 15))
                error('Unsupported predictor: ' + predictor);

            if (predictor === 2)
                this.readBlock = this.readBlockTiff;
            else
                this.readBlock = this.readBlockPng;

            this.stream = stream;
            this.dict = stream.dict;

            var colors = this.colors = params.get('Colors') || 1;
            var bits = this.bits = params.get('BitsPerComponent') || 8;
            var columns = this.columns = params.get('Columns') || 1;

            this.pixBytes = (colors * bits + 7) >> 3;
            this.rowBytes = (columns * colors * bits + 7) >> 3;
            DecodeStream.prototype.init.call(this);          
        },

        readBlockTiff : function () {
                var rowBytes = this.rowBytes;

                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);

                var bits = this.bits;
                var colors = this.colors;

                var rawBytes = this.stream.getBytes(rowBytes);

                var inbuf = 0,
                    outbuf = 0;
                var inbits = 0,
                    outbits = 0;
                var pos = bufferLength;

                if (bits === 1) {
                    for (var i = 0; i < rowBytes; ++i) {
                        var c = rawBytes[i];
                        inbuf = (inbuf << 8) | c;
                        // bitwise addition is exclusive or
                        // first shift inbuf and then add
                        buffer[pos++] = (c ^ (inbuf >> colors)) & 0xFF;
                        // truncate inbuf (assumes colors < 16)
                        inbuf &= 0xFFFF;
                    }
                } else if (bits === 8) {
                    for (var i = 0; i < colors; ++i)
                        buffer[pos++] = rawBytes[i];
                    for (; i < rowBytes; ++i) {
                        buffer[pos] = buffer[pos - colors] + rawBytes[i];
                        pos++;
                    }
                } else {
                    var compArray = new Uint8Array(colors + 1);
                    var bitMask = (1 << bits) - 1;
                    var j = 0,
                        k = bufferLength;
                    var columns = this.columns;
                    for (var i = 0; i < columns; ++i) {
                        for (var kk = 0; kk < colors; ++kk) {
                            if (inbits < bits) {
                                inbuf = (inbuf << 8) | (rawBytes[j++] & 0xFF);
                                inbits += 8;
                            }
                            compArray[kk] = (compArray[kk] +
                                (inbuf >> (inbits - bits))) & bitMask;
                            inbits -= bits;
                            outbuf = (outbuf << bits) | compArray[kk];
                            outbits += bits;
                            if (outbits >= 8) {
                                buffer[k++] = (outbuf >> (outbits - 8)) & 0xFF;
                                outbits -= 8;
                            }
                        }
                    }
                    if (outbits > 0) {
                        buffer[k++] = (outbuf << (8 - outbits)) +
                            (inbuf & ((1 << (8 - outbits)) - 1));
                    }
                }
                this.bufferLength += rowBytes;
        },

        readBlockPng : function() {

                var rowBytes = this.rowBytes;
                var pixBytes = this.pixBytes;

                var predictor = this.stream.getByte();
                var rawBytes = this.stream.getBytes(rowBytes);

                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);

                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                if (prevRow.length == 0)
                    prevRow = new Uint8Array(rowBytes);

                var j = bufferLength;
                switch (predictor) {
                    case 0:
                        for (var i = 0; i < rowBytes; ++i)
                            buffer[j++] = rawBytes[i];
                        break;
                    case 1:
                        for (var i = 0; i < pixBytes; ++i)
                            buffer[j++] = rawBytes[i];
                        for (; i < rowBytes; ++i) {
                            buffer[j] = (buffer[j - pixBytes] + rawBytes[i]) & 0xFF;
                            j++;
                        }
                        break;
                    case 2:
                        for (var i = 0; i < rowBytes; ++i)
                            buffer[j++] = (prevRow[i] + rawBytes[i]) & 0xFF;
                        break;
                    case 3:
                        for (var i = 0; i < pixBytes; ++i)
                            buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                        for (; i < rowBytes; ++i) {
                            buffer[j] = (((prevRow[i] + buffer[j - pixBytes]) >> 1) +
                                rawBytes[i]) & 0xFF;
                            j++;
                        }
                        break;
                    case 4:
                        // we need to save the up left pixels values. the simplest way
                        // is to create a new buffer
                        for (var i = 0; i < pixBytes; ++i) {
                            var up = prevRow[i];
                            var c = rawBytes[i];
                            buffer[j++] = up + c;
                        }
                        for (; i < rowBytes; ++i) {
                            var up = prevRow[i];
                            var upLeft = prevRow[i - pixBytes];
                            var left = buffer[j - pixBytes];
                            var p = left + up - upLeft;

                            var pa = p - left;
                            if (pa < 0)
                                pa = -pa;
                            var pb = p - up;
                            if (pb < 0)
                                pb = -pb;
                            var pc = p - upLeft;
                            if (pc < 0)
                                pc = -pc;

                            var c = rawBytes[i];
                            if (pa <= pb && pa <= pc)
                                buffer[j++] = left + c;
                            else if (pb <= pc)
                                buffer[j++] = up + c;
                            else
                                buffer[j++] = upLeft + c;
                        }
                        break;
                    default:
                        error('Unsupported predictor: ' + predictor);
                }
                this.bufferLength += rowBytes;
        }
    });

    return streams.PredictorStream = PredictorStream;
});


define('skylark-data-streams/StreamsSequenceStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./DecodeStream"
], function(skylark, langx, streams, DecodeStream) {

    var StreamsSequenceStream = DecodeStream.inherit({
        klassName : "StreamsSequenceStream",

        init : function(streams) {
            this.dict = stream.dict;
            DecodeStream.prototype.init.call(this);          
        },

        readBlock : function() {
            var streams = this.streams;
            if (streams.length == 0) {
                this.eof = true;
                return;
            }
            var stream = streams.shift();
            var chunk = stream.getBytes();
            var bufferLength = this.bufferLength;
            var newLength = bufferLength + chunk.length;
            var buffer = this.ensureBuffer(newLength);
            buffer.set(chunk, bufferLength);
            this.bufferLength = newLength;
        }
    });

    return streams.StreamsSequenceStream = StreamsSequenceStream;
});

define('skylark-data-streams/StringStream',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./streams",
    "./Stream"
], function(skylark, langx, streams, Stream) {

    var StringStream = Stream.inherit({
        klassName : "StringStream",

        init : function(str) {
            var length = str.length;
            var bytes = new Uint8Array(length);
            for (var n = 0; n < length; ++n)
                bytes[n] = str.charCodeAt(n);
            DecodeStream.prototype.init.call(this);          
        }
    });


    return streams.StringStream = StringStream;

});

define('skylark-data-streams/main',[
    "./streams",
    "./Ascii85Stream",
    "./AsciiHexStream",
    "./ChunkedStream",
    "./DecodeStream",
    "./DecryptStream",
    "./FakeStream",
    "./FlateStream",
    "./LZWStream",
    "./PredictorStream",
    "./Stream",
    "./StreamsSequenceStream",
    "./StringStream"
], function(streams) {

	return streams;
});
define('skylark-data-streams', ['skylark-data-streams/main'], function (main) { return main; });

define('skylark-data-zip/_stuk/jszip',[], function() {
/*!

JSZip v3.1.3 - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

     function init(cache, registry, preloads) {
        function getModule(moduleId, u) {
            if (!registry[moduleId]) {
                if (!cache[moduleId]) {
                    var a = typeof require=="function"&&require;
                    if (!u && a) return a(moduleId, !0);
                    if (i) return i(moduleId, !0);
                    var f = new Error("Cannot find module '" + moduleId + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var module = registry[moduleId] = {
                    exports: {}
                };
                cache[moduleId][0].call(module.exports, function require(modulePath) {
                    var depId = cache[moduleId][1][modulePath];
                    return getModule(depId ? depId : modulePath)
                }, module, module.exports, init, cache, registry, preloads)
            }
            return registry[moduleId].exports;
        }
        var i = typeof require=="function"&&require;
        for (var j = 0; j < preloads.length; j++) {
            getModule(preloads[j]);
        }
        return getModule;
    }

    var cache = {
        1: [function(require, module, exports) {
            'use strict';
            var utils = require('./utils');
            var support = require('./support');
            // private property
            var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


            // public method for encoding
            exports.encode = function(input) {
                var output = [];
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0,
                    len = input.length,
                    remainingBytes = len;

                var isArray = utils.getTypeOf(input) !== "string";
                while (i < input.length) {
                    remainingBytes = len - i;

                    if (!isArray) {
                        chr1 = input.charCodeAt(i++);
                        chr2 = i < len ? input.charCodeAt(i++) : 0;
                        chr3 = i < len ? input.charCodeAt(i++) : 0;
                    } else {
                        chr1 = input[i++];
                        chr2 = i < len ? input[i++] : 0;
                        chr3 = i < len ? input[i++] : 0;
                    }

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
                    enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

                    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

                }

                return output.join("");
            };

            // public method for decoding
            exports.decode = function(input) {
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0,
                    resultIndex = 0;

                var dataUrlPrefix = "data:";

                if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
                    // This is a common error: people give a data url
                    // (data:image/png;base64,iVBOR...) with a {base64: true} and
                    // wonders why things don't work.
                    // We can detect that the string input looks like a data url but we
                    // *can't* be sure it is one: removing everything up to the comma would
                    // be too dangerous.
                    throw new Error("Invalid base64 input, it looks like a data url.");
                }

                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

                var totalLength = input.length * 3 / 4;
                if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
                    totalLength--;
                }
                if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
                    totalLength--;
                }
                if (totalLength % 1 !== 0) {
                    // totalLength is not an integer, the length does not match a valid
                    // base64 content. That can happen if:
                    // - the input is not a base64 content
                    // - the input is *almost* a base64 content, with a extra chars at the
                    //   beginning or at the end
                    // - the input uses a base64 variant (base64url for example)
                    throw new Error("Invalid base64 input, bad content length.");
                }
                var output;
                if (support.uint8array) {
                    output = new Uint8Array(totalLength | 0);
                } else {
                    output = new Array(totalLength | 0);
                }

                while (i < input.length) {

                    enc1 = _keyStr.indexOf(input.charAt(i++));
                    enc2 = _keyStr.indexOf(input.charAt(i++));
                    enc3 = _keyStr.indexOf(input.charAt(i++));
                    enc4 = _keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output[resultIndex++] = chr1;

                    if (enc3 !== 64) {
                        output[resultIndex++] = chr2;
                    }
                    if (enc4 !== 64) {
                        output[resultIndex++] = chr3;
                    }

                }

                return output;
            };

        }, {
            "./support": 30,
            "./utils": 32
        }],
        2: [function(require, module, exports) {
            'use strict';

            var external = require("./external");
            var DataWorker = require('./stream/DataWorker');
            var DataLengthProbe = require('./stream/DataLengthProbe');
            var Crc32Probe = require('./stream/Crc32Probe');
            var DataLengthProbe = require('./stream/DataLengthProbe');

            /**
             * Represent a compressed object, with everything needed to decompress it.
             * @constructor
             * @param {number} compressedSize the size of the data compressed.
             * @param {number} uncompressedSize the size of the data after decompression.
             * @param {number} crc32 the crc32 of the decompressed file.
             * @param {object} compression the type of compression, see lib/compressions.js.
             * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
             */
            function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
                this.compressedSize = compressedSize;
                this.uncompressedSize = uncompressedSize;
                this.crc32 = crc32;
                this.compression = compression;
                this.compressedContent = data;
            }

            CompressedObject.prototype = {
                /**
                 * Create a worker to get the uncompressed content.
                 * @return {GenericWorker} the worker.
                 */
                getContentWorker: function() {
                    var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
                        .pipe(this.compression.uncompressWorker())
                        .pipe(new DataLengthProbe("data_length"));

                    var that = this;
                    worker.on("end", function() {
                        if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                            throw new Error("Bug : uncompressed data size mismatch");
                        }
                    });
                    return worker;
                },
                /**
                 * Create a worker to get the compressed content.
                 * @return {GenericWorker} the worker.
                 */
                getCompressedWorker: function() {
                    return new DataWorker(external.Promise.resolve(this.compressedContent))
                        .withStreamInfo("compressedSize", this.compressedSize)
                        .withStreamInfo("uncompressedSize", this.uncompressedSize)
                        .withStreamInfo("crc32", this.crc32)
                        .withStreamInfo("compression", this.compression);
                }
            };

            /**
             * Chain the given worker with other workers to compress the content with the
             * given compresion.
             * @param {GenericWorker} uncompressedWorker the worker to pipe.
             * @param {Object} compression the compression object.
             * @param {Object} compressionOptions the options to use when compressing.
             * @return {GenericWorker} the new worker compressing the content.
             */
            CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
                return uncompressedWorker
                    .pipe(new Crc32Probe())
                    .pipe(new DataLengthProbe("uncompressedSize"))
                    .pipe(compression.compressWorker(compressionOptions))
                    .pipe(new DataLengthProbe("compressedSize"))
                    .withStreamInfo("compression", compression);
            };

            module.exports = CompressedObject;
        }, {
            "./external": 6,
            "./stream/Crc32Probe": 25,
            "./stream/DataLengthProbe": 26,
            "./stream/DataWorker": 27
        }],
        3: [function(require, module, exports) {
            'use strict';

            var GenericWorker = require("./stream/GenericWorker");

            exports.STORE = {
                magic: "\x00\x00",
                compressWorker: function(compressionOptions) {
                    return new GenericWorker("STORE compression");
                },
                uncompressWorker: function() {
                    return new GenericWorker("STORE decompression");
                }
            };
            exports.DEFLATE = require('./flate');

        }, {
            "./flate": 7,
            "./stream/GenericWorker": 28
        }],
        4: [function(require, module, exports) {
            'use strict';

            var utils = require('./utils');

            /**
             * The following functions come from pako, from pako/lib/zlib/crc32.js
             * released under the MIT license, see pako https://github.com/nodeca/pako/
             */

            // Use ordinary array, since untyped makes no boost here
            function makeTable() {
                var c, table = [];

                for (var n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++) {
                        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                    }
                    table[n] = c;
                }

                return table;
            }

            // Create table on load. Just 255 signed longs. Not a problem.
            var crcTable = makeTable();


            function crc32(crc, buf, len, pos) {
                var t = crcTable,
                    end = pos + len;

                crc = crc ^ (-1);

                for (var i = pos; i < end; i++) {
                    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
                }

                return (crc ^ (-1)); // >>> 0;
            }

            // That's all for the pako functions.

            /**
             * Compute the crc32 of a string.
             * This is almost the same as the function crc32, but for strings. Using the
             * same function for the two use cases leads to horrible performances.
             * @param {Number} crc the starting value of the crc.
             * @param {String} str the string to use.
             * @param {Number} len the length of the string.
             * @param {Number} pos the starting position for the crc32 computation.
             * @return {Number} the computed crc32.
             */
            function crc32str(crc, str, len, pos) {
                var t = crcTable,
                    end = pos + len;

                crc = crc ^ (-1);

                for (var i = pos; i < end; i++) {
                    crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
                }

                return (crc ^ (-1)); // >>> 0;
            }

            module.exports = function crc32wrapper(input, crc) {
                if (typeof input === "undefined" || !input.length) {
                    return 0;
                }

                var isArray = utils.getTypeOf(input) !== "string";

                if (isArray) {
                    return crc32(crc | 0, input, input.length, 0);
                } else {
                    return crc32str(crc | 0, input, input.length, 0);
                }
            };

        }, {
            "./utils": 32
        }],
        5: [function(require, module, exports) {
            'use strict';
            exports.base64 = false;
            exports.binary = false;
            exports.dir = false;
            exports.createFolders = true;
            exports.date = null;
            exports.compression = null;
            exports.compressionOptions = null;
            exports.comment = null;
            exports.unixPermissions = null;
            exports.dosPermissions = null;

        }, {}],
        6: [function(require, module, exports) {
            /* global Promise */
            'use strict';

            // load the global object first:
            // - it should be better integrated in the system (unhandledRejection in node)
            // - the environment may have a custom Promise implementation (see zone.js)
            var ES6Promise = null;
            if (typeof Promise !== "undefined") {
                ES6Promise = Promise;
            } else {
                ES6Promise = require("lie");
            }

            /**
             * Let the user use/change some implementations.
             */
            module.exports = {
                Promise: ES6Promise
            };

        }, {
            "lie": 58
        }],
        7: [function(require, module, exports) {
            'use strict';
            var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

            var pako = require("pako");
            var utils = require("./utils");
            var GenericWorker = require("./stream/GenericWorker");

            var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

            exports.magic = "\x08\x00";

            /**
             * Create a worker that uses pako to inflate/deflate.
             * @constructor
             * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
             * @param {Object} options the options to use when (de)compressing.
             */
            function FlateWorker(action, options) {
                GenericWorker.call(this, "FlateWorker/" + action);

                this._pako = null;
                this._pakoAction = action;
                this._pakoOptions = options;
                // the `meta` object from the last chunk received
                // this allow this worker to pass around metadata
                this.meta = {};
            }

            utils.inherits(FlateWorker, GenericWorker);

            /**
             * @see GenericWorker.processChunk
             */
            FlateWorker.prototype.processChunk = function(chunk) {
                this.meta = chunk.meta;
                if (this._pako === null) {
                    this._createPako();
                }
                this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
            };

            /**
             * @see GenericWorker.flush
             */
            FlateWorker.prototype.flush = function() {
                GenericWorker.prototype.flush.call(this);
                if (this._pako === null) {
                    this._createPako();
                }
                this._pako.push([], true);
            };
            /**
             * @see GenericWorker.cleanUp
             */
            FlateWorker.prototype.cleanUp = function() {
                GenericWorker.prototype.cleanUp.call(this);
                this._pako = null;
            };

            /**
             * Create the _pako object.
             * TODO: lazy-loading this object isn't the best solution but it's the
             * quickest. The best solution is to lazy-load the worker list. See also the
             * issue #446.
             */
            FlateWorker.prototype._createPako = function() {
                this._pako = new pako[this._pakoAction]({
                    raw: true,
                    level: this._pakoOptions.level || -1 // default compression
                });
                var self = this;
                this._pako.onData = function(data) {
                    self.push({
                        data: data,
                        meta: self.meta
                    });
                };
            };

            exports.compressWorker = function(compressionOptions) {
                return new FlateWorker("Deflate", compressionOptions);
            };
            exports.uncompressWorker = function() {
                return new FlateWorker("Inflate", {});
            };

        }, {
            "./stream/GenericWorker": 28,
            "./utils": 32,
            "pako": 59
        }],
        8: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var GenericWorker = require('../stream/GenericWorker');
            var utf8 = require('../utf8');
            var crc32 = require('../crc32');
            var signature = require('../signature');

            /**
             * Transform an integer into a string in hexadecimal.
             * @private
             * @param {number} dec the number to convert.
             * @param {number} bytes the number of bytes to generate.
             * @returns {string} the result.
             */
            var decToHex = function(dec, bytes) {
                var hex = "",
                    i;
                for (i = 0; i < bytes; i++) {
                    hex += String.fromCharCode(dec & 0xff);
                    dec = dec >>> 8;
                }
                return hex;
            };

            /**
             * Generate the UNIX part of the external file attributes.
             * @param {Object} unixPermissions the unix permissions or null.
             * @param {Boolean} isDir true if the entry is a directory, false otherwise.
             * @return {Number} a 32 bit integer.
             *
             * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
             *
             * TTTTsstrwxrwxrwx0000000000ADVSHR
             * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
             *     ^^^_________________________ setuid, setgid, sticky
             *        ^^^^^^^^^________________ permissions
             *                 ^^^^^^^^^^______ not used ?
             *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
             */
            var generateUnixExternalFileAttr = function(unixPermissions, isDir) {

                var result = unixPermissions;
                if (!unixPermissions) {
                    // I can't use octal values in strict mode, hence the hexa.
                    //  040775 => 0x41fd
                    // 0100664 => 0x81b4
                    result = isDir ? 0x41fd : 0x81b4;
                }
                return (result & 0xFFFF) << 16;
            };

            /**
             * Generate the DOS part of the external file attributes.
             * @param {Object} dosPermissions the dos permissions or null.
             * @param {Boolean} isDir true if the entry is a directory, false otherwise.
             * @return {Number} a 32 bit integer.
             *
             * Bit 0     Read-Only
             * Bit 1     Hidden
             * Bit 2     System
             * Bit 3     Volume Label
             * Bit 4     Directory
             * Bit 5     Archive
             */
            var generateDosExternalFileAttr = function(dosPermissions, isDir) {

                // the dir flag is already set for compatibility
                return (dosPermissions || 0) & 0x3F;
            };

            /**
             * Generate the various parts used in the construction of the final zip file.
             * @param {Object} streamInfo the hash with informations about the compressed file.
             * @param {Boolean} streamedContent is the content streamed ?
             * @param {Boolean} streamingEnded is the stream finished ?
             * @param {number} offset the current offset from the start of the zip file.
             * @param {String} platform let's pretend we are this platform (change platform dependents fields)
             * @param {Function} encodeFileName the function to encode the file name / comment.
             * @return {Object} the zip parts.
             */
            var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
                var file = streamInfo['file'],
                    compression = streamInfo['compression'],
                    useCustomEncoding = encodeFileName !== utf8.utf8encode,
                    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
                    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
                    comment = file.comment,
                    encodedComment = utils.transformTo("string", encodeFileName(comment)),
                    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
                    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
                    useUTF8ForComment = utfEncodedComment.length !== comment.length,
                    dosTime,
                    dosDate,
                    extraFields = "",
                    unicodePathExtraField = "",
                    unicodeCommentExtraField = "",
                    dir = file.dir,
                    date = file.date;


                var dataInfo = {
                    crc32: 0,
                    compressedSize: 0,
                    uncompressedSize: 0
                };

                // if the content is streamed, the sizes/crc32 are only available AFTER
                // the end of the stream.
                if (!streamedContent || streamingEnded) {
                    dataInfo.crc32 = streamInfo['crc32'];
                    dataInfo.compressedSize = streamInfo['compressedSize'];
                    dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
                }

                var bitflag = 0;
                if (streamedContent) {
                    // Bit 3: the sizes/crc32 are set to zero in the local header.
                    // The correct values are put in the data descriptor immediately
                    // following the compressed data.
                    bitflag |= 0x0008;
                }
                if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
                    // Bit 11: Language encoding flag (EFS).
                    bitflag |= 0x0800;
                }


                var extFileAttr = 0;
                var versionMadeBy = 0;
                if (dir) {
                    // dos or unix, we set the dos dir flag
                    extFileAttr |= 0x00010;
                }
                if (platform === "UNIX") {
                    versionMadeBy = 0x031E; // UNIX, version 3.0
                    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
                } else { // DOS or other, fallback to DOS
                    versionMadeBy = 0x0014; // DOS, version 2.0
                    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
                }

                // date
                // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
                // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
                // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

                dosTime = date.getUTCHours();
                dosTime = dosTime << 6;
                dosTime = dosTime | date.getUTCMinutes();
                dosTime = dosTime << 5;
                dosTime = dosTime | date.getUTCSeconds() / 2;

                dosDate = date.getUTCFullYear() - 1980;
                dosDate = dosDate << 4;
                dosDate = dosDate | (date.getUTCMonth() + 1);
                dosDate = dosDate << 5;
                dosDate = dosDate | date.getUTCDate();

                if (useUTF8ForFileName) {
                    // set the unicode path extra field. unzip needs at least one extra
                    // field to correctly handle unicode path, so using the path is as good
                    // as any other information. This could improve the situation with
                    // other archive managers too.
                    // This field is usually used without the utf8 flag, with a non
                    // unicode path in the header (winrar, winzip). This helps (a bit)
                    // with the messy Windows' default compressed folders feature but
                    // breaks on p7zip which doesn't seek the unicode path extra field.
                    // So for now, UTF-8 everywhere !
                    unicodePathExtraField =
                        // Version
                        decToHex(1, 1) +
                        // NameCRC32
                        decToHex(crc32(encodedFileName), 4) +
                        // UnicodeName
                        utfEncodedFileName;

                    extraFields +=
                        // Info-ZIP Unicode Path Extra Field
                        "\x75\x70" +
                        // size
                        decToHex(unicodePathExtraField.length, 2) +
                        // content
                        unicodePathExtraField;
                }

                if (useUTF8ForComment) {

                    unicodeCommentExtraField =
                        // Version
                        decToHex(1, 1) +
                        // CommentCRC32
                        decToHex(crc32(encodedComment), 4) +
                        // UnicodeName
                        utfEncodedComment;

                    extraFields +=
                        // Info-ZIP Unicode Path Extra Field
                        "\x75\x63" +
                        // size
                        decToHex(unicodeCommentExtraField.length, 2) +
                        // content
                        unicodeCommentExtraField;
                }

                var header = "";

                // version needed to extract
                header += "\x0A\x00";
                // general purpose bit flag
                header += decToHex(bitflag, 2);
                // compression method
                header += compression.magic;
                // last mod file time
                header += decToHex(dosTime, 2);
                // last mod file date
                header += decToHex(dosDate, 2);
                // crc-32
                header += decToHex(dataInfo.crc32, 4);
                // compressed size
                header += decToHex(dataInfo.compressedSize, 4);
                // uncompressed size
                header += decToHex(dataInfo.uncompressedSize, 4);
                // file name length
                header += decToHex(encodedFileName.length, 2);
                // extra field length
                header += decToHex(extraFields.length, 2);


                var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

                var dirRecord = signature.CENTRAL_FILE_HEADER +
                    // version made by (00: DOS)
                    decToHex(versionMadeBy, 2) +
                    // file header (common to file and central directory)
                    header +
                    // file comment length
                    decToHex(encodedComment.length, 2) +
                    // disk number start
                    "\x00\x00" +
                    // internal file attributes TODO
                    "\x00\x00" +
                    // external file attributes
                    decToHex(extFileAttr, 4) +
                    // relative offset of local header
                    decToHex(offset, 4) +
                    // file name
                    encodedFileName +
                    // extra field
                    extraFields +
                    // file comment
                    encodedComment;

                return {
                    fileRecord: fileRecord,
                    dirRecord: dirRecord
                };
            };

            /**
             * Generate the EOCD record.
             * @param {Number} entriesCount the number of entries in the zip file.
             * @param {Number} centralDirLength the length (in bytes) of the central dir.
             * @param {Number} localDirLength the length (in bytes) of the local dir.
             * @param {String} comment the zip file comment as a binary string.
             * @param {Function} encodeFileName the function to encode the comment.
             * @return {String} the EOCD record.
             */
            var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
                var dirEnd = "";
                var encodedComment = utils.transformTo("string", encodeFileName(comment));

                // end of central dir signature
                dirEnd = signature.CENTRAL_DIRECTORY_END +
                    // number of this disk
                    "\x00\x00" +
                    // number of the disk with the start of the central directory
                    "\x00\x00" +
                    // total number of entries in the central directory on this disk
                    decToHex(entriesCount, 2) +
                    // total number of entries in the central directory
                    decToHex(entriesCount, 2) +
                    // size of the central directory   4 bytes
                    decToHex(centralDirLength, 4) +
                    // offset of start of central directory with respect to the starting disk number
                    decToHex(localDirLength, 4) +
                    // .ZIP file comment length
                    decToHex(encodedComment.length, 2) +
                    // .ZIP file comment
                    encodedComment;

                return dirEnd;
            };

            /**
             * Generate data descriptors for a file entry.
             * @param {Object} streamInfo the hash generated by a worker, containing informations
             * on the file entry.
             * @return {String} the data descriptors.
             */
            var generateDataDescriptors = function(streamInfo) {
                var descriptor = "";
                descriptor = signature.DATA_DESCRIPTOR +
                    // crc-32                          4 bytes
                    decToHex(streamInfo['crc32'], 4) +
                    // compressed size                 4 bytes
                    decToHex(streamInfo['compressedSize'], 4) +
                    // uncompressed size               4 bytes
                    decToHex(streamInfo['uncompressedSize'], 4);

                return descriptor;
            };


            /**
             * A worker to concatenate other workers to create a zip file.
             * @param {Boolean} streamFiles `true` to stream the content of the files,
             * `false` to accumulate it.
             * @param {String} comment the comment to use.
             * @param {String} platform the platform to use, "UNIX" or "DOS".
             * @param {Function} encodeFileName the function to encode file names and comments.
             */
            function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
                GenericWorker.call(this, "ZipFileWorker");
                // The number of bytes written so far. This doesn't count accumulated chunks.
                this.bytesWritten = 0;
                // The comment of the zip file
                this.zipComment = comment;
                // The platform "generating" the zip file.
                this.zipPlatform = platform;
                // the function to encode file names and comments.
                this.encodeFileName = encodeFileName;
                // Should we stream the content of the files ?
                this.streamFiles = streamFiles;
                // If `streamFiles` is false, we will need to accumulate the content of the
                // files to calculate sizes / crc32 (and write them *before* the content).
                // This boolean indicates if we are accumulating chunks (it will change a lot
                // during the lifetime of this worker).
                this.accumulate = false;
                // The buffer receiving chunks when accumulating content.
                this.contentBuffer = [];
                // The list of generated directory records.
                this.dirRecords = [];
                // The offset (in bytes) from the beginning of the zip file for the current source.
                this.currentSourceOffset = 0;
                // The total number of entries in this zip file.
                this.entriesCount = 0;
                // the name of the file currently being added, null when handling the end of the zip file.
                // Used for the emited metadata.
                this.currentFile = null;



                this._sources = [];
            }
            utils.inherits(ZipFileWorker, GenericWorker);

            /**
             * @see GenericWorker.push
             */
            ZipFileWorker.prototype.push = function(chunk) {

                var currentFilePercent = chunk.meta.percent || 0;
                var entriesCount = this.entriesCount;
                var remainingFiles = this._sources.length;

                if (this.accumulate) {
                    this.contentBuffer.push(chunk);
                } else {
                    this.bytesWritten += chunk.data.length;

                    GenericWorker.prototype.push.call(this, {
                        data: chunk.data,
                        meta: {
                            currentFile: this.currentFile,
                            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
                        }
                    });
                }
            };

            /**
             * The worker started a new source (an other worker).
             * @param {Object} streamInfo the streamInfo object from the new source.
             */
            ZipFileWorker.prototype.openedSource = function(streamInfo) {
                this.currentSourceOffset = this.bytesWritten;
                this.currentFile = streamInfo['file'].name;

                var streamedContent = this.streamFiles && !streamInfo['file'].dir;

                // don't stream folders (because they don't have any content)
                if (streamedContent) {
                    var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    this.push({
                        data: record.fileRecord,
                        meta: {
                            percent: 0
                        }
                    });
                } else {
                    // we need to wait for the whole file before pushing anything
                    this.accumulate = true;
                }
            };

            /**
             * The worker finished a source (an other worker).
             * @param {Object} streamInfo the streamInfo object from the finished source.
             */
            ZipFileWorker.prototype.closedSource = function(streamInfo) {
                this.accumulate = false;
                var streamedContent = this.streamFiles && !streamInfo['file'].dir;
                var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

                this.dirRecords.push(record.dirRecord);
                if (streamedContent) {
                    // after the streamed file, we put data descriptors
                    this.push({
                        data: generateDataDescriptors(streamInfo),
                        meta: {
                            percent: 100
                        }
                    });
                } else {
                    // the content wasn't streamed, we need to push everything now
                    // first the file record, then the content
                    this.push({
                        data: record.fileRecord,
                        meta: {
                            percent: 0
                        }
                    });
                    while (this.contentBuffer.length) {
                        this.push(this.contentBuffer.shift());
                    }
                }
                this.currentFile = null;
            };

            /**
             * @see GenericWorker.flush
             */
            ZipFileWorker.prototype.flush = function() {

                var localDirLength = this.bytesWritten;
                for (var i = 0; i < this.dirRecords.length; i++) {
                    this.push({
                        data: this.dirRecords[i],
                        meta: {
                            percent: 100
                        }
                    });
                }
                var centralDirLength = this.bytesWritten - localDirLength;

                var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

                this.push({
                    data: dirEnd,
                    meta: {
                        percent: 100
                    }
                });
            };

            /**
             * Prepare the next source to be read.
             */
            ZipFileWorker.prototype.prepareNextSource = function() {
                this.previous = this._sources.shift();
                this.openedSource(this.previous.streamInfo);
                if (this.isPaused) {
                    this.previous.pause();
                } else {
                    this.previous.resume();
                }
            };

            /**
             * @see GenericWorker.registerPrevious
             */
            ZipFileWorker.prototype.registerPrevious = function(previous) {
                this._sources.push(previous);
                var self = this;

                previous.on('data', function(chunk) {
                    self.processChunk(chunk);
                });
                previous.on('end', function() {
                    self.closedSource(self.previous.streamInfo);
                    if (self._sources.length) {
                        self.prepareNextSource();
                    } else {
                        self.end();
                    }
                });
                previous.on('error', function(e) {
                    self.error(e);
                });
                return this;
            };

            /**
             * @see GenericWorker.resume
             */
            ZipFileWorker.prototype.resume = function() {
                if (!GenericWorker.prototype.resume.call(this)) {
                    return false;
                }

                if (!this.previous && this._sources.length) {
                    this.prepareNextSource();
                    return true;
                }
                if (!this.previous && !this._sources.length && !this.generatedError) {
                    this.end();
                    return true;
                }
            };

            /**
             * @see GenericWorker.error
             */
            ZipFileWorker.prototype.error = function(e) {
                var sources = this._sources;
                if (!GenericWorker.prototype.error.call(this, e)) {
                    return false;
                }
                for (var i = 0; i < sources.length; i++) {
                    try {
                        sources[i].error(e);
                    } catch (e) {
                        // the `error` exploded, nothing to do
                    }
                }
                return true;
            };

            /**
             * @see GenericWorker.lock
             */
            ZipFileWorker.prototype.lock = function() {
                GenericWorker.prototype.lock.call(this);
                var sources = this._sources;
                for (var i = 0; i < sources.length; i++) {
                    sources[i].lock();
                }
            };

            module.exports = ZipFileWorker;

        }, {
            "../crc32": 4,
            "../signature": 23,
            "../stream/GenericWorker": 28,
            "../utf8": 31,
            "../utils": 32
        }],
        9: [function(require, module, exports) {
            'use strict';

            var compressions = require('../compressions');
            var ZipFileWorker = require('./ZipFileWorker');

            /**
             * Find the compression to use.
             * @param {String} fileCompression the compression defined at the file level, if any.
             * @param {String} zipCompression the compression defined at the load() level.
             * @return {Object} the compression object to use.
             */
            var getCompression = function(fileCompression, zipCompression) {

                var compressionName = fileCompression || zipCompression;
                var compression = compressions[compressionName];
                if (!compression) {
                    throw new Error(compressionName + " is not a valid compression method !");
                }
                return compression;
            };

            /**
             * Create a worker to generate a zip file.
             * @param {JSZip} zip the JSZip instance at the right root level.
             * @param {Object} options to generate the zip file.
             * @param {String} comment the comment to use.
             */
            exports.generateWorker = function(zip, options, comment) {

                var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
                var entriesCount = 0;
                try {

                    zip.forEach(function(relativePath, file) {
                        entriesCount++;
                        var compression = getCompression(file.options.compression, options.compression);
                        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
                        var dir = file.dir,
                            date = file.date;

                        file._compressWorker(compression, compressionOptions)
                            .withStreamInfo("file", {
                                name: relativePath,
                                dir: dir,
                                date: date,
                                comment: file.comment || "",
                                unixPermissions: file.unixPermissions,
                                dosPermissions: file.dosPermissions
                            })
                            .pipe(zipFileWorker);
                    });
                    zipFileWorker.entriesCount = entriesCount;
                } catch (e) {
                    zipFileWorker.error(e);
                }

                return zipFileWorker;
            };

        }, {
            "../compressions": 3,
            "./ZipFileWorker": 8
        }],
        10: [function(require, module, exports) {
            'use strict';

            /**
             * Representation a of zip file in js
             * @constructor
             */
            function JSZip() {
                // if this constructor is used without `new`, it adds `new` before itself:
                if (!(this instanceof JSZip)) {
                    return new JSZip();
                }

                if (arguments.length) {
                    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                }

                // object containing the files :
                // {
                //   "folder/" : {...},
                //   "folder/data.txt" : {...}
                // }
                this.files = {};

                this.comment = null;

                // Where we are in the hierarchy
                this.root = "";
                this.clone = function() {
                    var newObj = new JSZip();
                    for (var i in this) {
                        if (typeof this[i] !== "function") {
                            newObj[i] = this[i];
                        }
                    }
                    return newObj;
                };
            }
            JSZip.prototype = require('./object');
            JSZip.prototype.loadAsync = require('./load');
            JSZip.support = require('./support');
            JSZip.defaults = require('./defaults');

            // TODO find a better way to handle this version,
            // a require('package.json').version doesn't work with webpack, see #327
            JSZip.version = "3.1.3";

            JSZip.loadAsync = function(content, options) {
                return new JSZip().loadAsync(content, options);
            };

            JSZip.external = require("./external");
            module.exports = JSZip;

        }, {
            "./defaults": 5,
            "./external": 6,
            "./load": 11,
            "./object": 15,
            "./support": 30
        }],
        11: [function(require, module, exports) {
            'use strict';
            var utils = require('./utils');
            var external = require("./external");
            var utf8 = require('./utf8');
            var utils = require('./utils');
            var ZipEntries = require('./zipEntries');
            var Crc32Probe = require('./stream/Crc32Probe');
            var nodejsUtils = require("./nodejsUtils");

            /**
             * Check the CRC32 of an entry.
             * @param {ZipEntry} zipEntry the zip entry to check.
             * @return {Promise} the result.
             */
            function checkEntryCRC32(zipEntry) {
                return new external.Promise(function(resolve, reject) {
                    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
                    worker.on("error", function(e) {
                            reject(e);
                        })
                        .on("end", function() {
                            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                                reject(new Error("Corrupted zip : CRC32 mismatch"));
                            } else {
                                resolve();
                            }
                        })
                        .resume();
                });
            }

            module.exports = function(data, options) {
                var zip = this;
                options = utils.extend(options || {}, {
                    base64: false,
                    checkCRC32: false,
                    optimizedBinaryString: false,
                    createFolders: false,
                    decodeFileName: utf8.utf8decode
                });

                if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
                    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
                }

                return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
                    .then(function(data) {
                        var zipEntries = new ZipEntries(options);
                        zipEntries.load(data);
                        return zipEntries;
                    }).then(function checkCRC32(zipEntries) {
                        var promises = [external.Promise.resolve(zipEntries)];
                        var files = zipEntries.files;
                        if (options.checkCRC32) {
                            for (var i = 0; i < files.length; i++) {
                                promises.push(checkEntryCRC32(files[i]));
                            }
                        }
                        return external.Promise.all(promises);
                    }).then(function addFiles(results) {
                        var zipEntries = results.shift();
                        var files = zipEntries.files;
                        for (var i = 0; i < files.length; i++) {
                            var input = files[i];
                            zip.file(input.fileNameStr, input.decompressed, {
                                binary: true,
                                optimizedBinaryString: true,
                                date: input.date,
                                dir: input.dir,
                                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                                unixPermissions: input.unixPermissions,
                                dosPermissions: input.dosPermissions,
                                createFolders: options.createFolders
                            });
                        }
                        if (zipEntries.zipComment.length) {
                            zip.comment = zipEntries.zipComment;
                        }

                        return zip;
                    });
            };

        }, {
            "./external": 6,
            "./nodejsUtils": 14,
            "./stream/Crc32Probe": 25,
            "./utf8": 31,
            "./utils": 32,
            "./zipEntries": 33
        }],
        12: [function(require, module, exports) {
            "use strict";

            var utils = require('../utils');
            var GenericWorker = require('../stream/GenericWorker');

            /**
             * A worker that use a nodejs stream as source.
             * @constructor
             * @param {String} filename the name of the file entry for this stream.
             * @param {Readable} stream the nodejs stream.
             */
            function NodejsStreamInputAdapter(filename, stream) {
                GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
                this._upstreamEnded = false;
                this._bindStream(stream);
            }

            utils.inherits(NodejsStreamInputAdapter, GenericWorker);

            /**
             * Prepare the stream and bind the callbacks on it.
             * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
             * @param {Stream} stream the nodejs stream to use.
             */
            NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
                var self = this;
                this._stream = stream;
                stream.pause();
                stream
                    .on("data", function(chunk) {
                        self.push({
                            data: chunk,
                            meta: {
                                percent: 0
                            }
                        });
                    })
                    .on("error", function(e) {
                        if (self.isPaused) {
                            this.generatedError = e;
                        } else {
                            self.error(e);
                        }
                    })
                    .on("end", function() {
                        if (self.isPaused) {
                            self._upstreamEnded = true;
                        } else {
                            self.end();
                        }
                    });
            };
            NodejsStreamInputAdapter.prototype.pause = function() {
                if (!GenericWorker.prototype.pause.call(this)) {
                    return false;
                }
                this._stream.pause();
                return true;
            };
            NodejsStreamInputAdapter.prototype.resume = function() {
                if (!GenericWorker.prototype.resume.call(this)) {
                    return false;
                }

                if (this._upstreamEnded) {
                    this.end();
                } else {
                    this._stream.resume();
                }

                return true;
            };

            module.exports = NodejsStreamInputAdapter;

        }, {
            "../stream/GenericWorker": 28,
            "../utils": 32
        }],
        13: [function(require, module, exports) {
            'use strict';

            var Readable = require('readable-stream').Readable;

            var utils = require('../utils');
            utils.inherits(NodejsStreamOutputAdapter, Readable);

            /**
             * A nodejs stream using a worker as source.
             * @see the SourceWrapper in http://nodejs.org/api/stream.html
             * @constructor
             * @param {StreamHelper} helper the helper wrapping the worker
             * @param {Object} options the nodejs stream options
             * @param {Function} updateCb the update callback.
             */
            function NodejsStreamOutputAdapter(helper, options, updateCb) {
                Readable.call(this, options);
                this._helper = helper;

                var self = this;
                helper.on("data", function(data, meta) {
                        if (!self.push(data)) {
                            self._helper.pause();
                        }
                        if (updateCb) {
                            updateCb(meta);
                        }
                    })
                    .on("error", function(e) {
                        self.emit('error', e);
                    })
                    .on("end", function() {
                        self.push(null);
                    });
            }


            NodejsStreamOutputAdapter.prototype._read = function() {
                this._helper.resume();
            };

            module.exports = NodejsStreamOutputAdapter;

        }, {
            "../utils": 32,
            "readable-stream": 16
        }],
        14: [function(require, module, exports) {
            'use strict';

            module.exports = {
                /**
                 * True if this is running in Nodejs, will be undefined in a browser.
                 * In a browser, browserify won't include this file and the whole module
                 * will be resolved an empty object.
                 */
                isNode: typeof Buffer !== "undefined",
                /**
                 * Create a new nodejs Buffer.
                 * @param {Object} data the data to pass to the constructor.
                 * @param {String} encoding the encoding to use.
                 * @return {Buffer} a new Buffer.
                 */
                newBuffer: function(data, encoding) {
                    return new Buffer(data, encoding);
                },
                /**
                 * Find out if an object is a Buffer.
                 * @param {Object} b the object to test.
                 * @return {Boolean} true if the object is a Buffer, false otherwise.
                 */
                isBuffer: function(b) {
                    return Buffer.isBuffer(b);
                },

                isStream: function(obj) {
                    return obj &&
                        typeof obj.on === "function" &&
                        typeof obj.pause === "function" &&
                        typeof obj.resume === "function";
                }
            };

        }, {}],
        15: [function(require, module, exports) {
            'use strict';
            var utf8 = require('./utf8');
            var utils = require('./utils');
            var GenericWorker = require('./stream/GenericWorker');
            var StreamHelper = require('./stream/StreamHelper');
            var defaults = require('./defaults');
            var CompressedObject = require('./compressedObject');
            var ZipObject = require('./zipObject');
            var generate = require("./generate");
            var nodejsUtils = require("./nodejsUtils");
            var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


            /**
             * Add a file in the current folder.
             * @private
             * @param {string} name the name of the file
             * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
             * @param {Object} originalOptions the options of the file
             * @return {Object} the new file.
             */
            var fileAdd = function(name, data, originalOptions) {
                // be sure sub folders exist
                var dataType = utils.getTypeOf(data),
                    parent;


                /*
                 * Correct options.
                 */

                var o = utils.extend(originalOptions || {}, defaults);
                o.date = o.date || new Date();
                if (o.compression !== null) {
                    o.compression = o.compression.toUpperCase();
                }

                if (typeof o.unixPermissions === "string") {
                    o.unixPermissions = parseInt(o.unixPermissions, 8);
                }

                // UNX_IFDIR  0040000 see zipinfo.c
                if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
                    o.dir = true;
                }
                // Bit 4    Directory
                if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
                    o.dir = true;
                }

                if (o.dir) {
                    name = forceTrailingSlash(name);
                }
                if (o.createFolders && (parent = parentFolder(name))) {
                    folderAdd.call(this, parent, true);
                }

                var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
                if (!originalOptions || typeof originalOptions.binary === "undefined") {
                    o.binary = !isUnicodeString;
                }


                var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

                if (isCompressedEmpty || o.dir || !data || data.length === 0) {
                    o.base64 = false;
                    o.binary = true;
                    data = "";
                    o.compression = "STORE";
                    dataType = "string";
                }

                /*
                 * Convert content to fit.
                 */

                var zipObjectContent = null;
                if (data instanceof CompressedObject || data instanceof GenericWorker) {
                    zipObjectContent = data;
                } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
                    zipObjectContent = new NodejsStreamInputAdapter(name, data);
                } else {
                    zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
                }

                var object = new ZipObject(name, zipObjectContent, o);
                this.files[name] = object;
                /*
                TODO: we can't throw an exception because we have async promises
                (we can have a promise of a Date() for example) but returning a
                promise is useless because file(name, data) returns the JSZip
                object for chaining. Should we break that to allow the user
                to catch the error ?

                return external.Promise.resolve(zipObjectContent)
                .then(function () {
                    return object;
                });
                */
            };

            /**
             * Find the parent folder of the path.
             * @private
             * @param {string} path the path to use
             * @return {string} the parent folder, or ""
             */
            var parentFolder = function(path) {
                if (path.slice(-1) === '/') {
                    path = path.substring(0, path.length - 1);
                }
                var lastSlash = path.lastIndexOf('/');
                return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
            };

            /**
             * Returns the path with a slash at the end.
             * @private
             * @param {String} path the path to check.
             * @return {String} the path with a trailing slash.
             */
            var forceTrailingSlash = function(path) {
                // Check the name ends with a /
                if (path.slice(-1) !== "/") {
                    path += "/"; // IE doesn't like substr(-1)
                }
                return path;
            };

            /**
             * Add a (sub) folder in the current folder.
             * @private
             * @param {string} name the folder's name
             * @param {boolean=} [createFolders] If true, automatically create sub
             *  folders. Defaults to false.
             * @return {Object} the new folder.
             */
            var folderAdd = function(name, createFolders) {
                createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

                name = forceTrailingSlash(name);

                // Does this folder already exist?
                if (!this.files[name]) {
                    fileAdd.call(this, name, null, {
                        dir: true,
                        createFolders: createFolders
                    });
                }
                return this.files[name];
            };

            /**
             * Cross-window, cross-Node-context regular expression detection
             * @param  {Object}  object Anything
             * @return {Boolean}        true if the object is a regular expression,
             * false otherwise
             */
            function isRegExp(object) {
                return Object.prototype.toString.call(object) === "[object RegExp]";
            }

            // return the actual prototype of JSZip
            var out = {
                /**
                 * @see loadAsync
                 */
                load: function() {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                },


                /**
                 * Call a callback function for each entry at this folder level.
                 * @param {Function} cb the callback function:
                 * function (relativePath, file) {...}
                 * It takes 2 arguments : the relative path and the file.
                 */
                forEach: function(cb) {
                    var filename, relativePath, file;
                    for (filename in this.files) {
                        if (!this.files.hasOwnProperty(filename)) {
                            continue;
                        }
                        file = this.files[filename];
                        relativePath = filename.slice(this.root.length, filename.length);
                        if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                            cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
                        }
                    }
                },

                /**
                 * Filter nested files/folders with the specified function.
                 * @param {Function} search the predicate to use :
                 * function (relativePath, file) {...}
                 * It takes 2 arguments : the relative path and the file.
                 * @return {Array} An array of matching elements.
                 */
                filter: function(search) {
                    var result = [];
                    this.forEach(function(relativePath, entry) {
                        if (search(relativePath, entry)) { // the file matches the function
                            result.push(entry);
                        }

                    });
                    return result;
                },

                /**
                 * Add a file to the zip file, or search a file.
                 * @param   {string|RegExp} name The name of the file to add (if data is defined),
                 * the name of the file to find (if no data) or a regex to match files.
                 * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
                 * @param   {Object} o     File options
                 * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
                 * a file (when searching by string) or an array of files (when searching by regex).
                 */
                file: function(name, data, o) {
                    if (arguments.length === 1) {
                        if (isRegExp(name)) {
                            var regexp = name;
                            return this.filter(function(relativePath, file) {
                                return !file.dir && regexp.test(relativePath);
                            });
                        } else { // text
                            var obj = this.files[this.root + name];
                            if (obj && !obj.dir) {
                                return obj;
                            } else {
                                return null;
                            }
                        }
                    } else { // more than one argument : we have data !
                        name = this.root + name;
                        fileAdd.call(this, name, data, o);
                    }
                    return this;
                },

                /**
                 * Add a directory to the zip file, or search.
                 * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
                 * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
                 */
                folder: function(arg) {
                    if (!arg) {
                        return this;
                    }

                    if (isRegExp(arg)) {
                        return this.filter(function(relativePath, file) {
                            return file.dir && arg.test(relativePath);
                        });
                    }

                    // else, name is a new folder
                    var name = this.root + arg;
                    var newFolder = folderAdd.call(this, name);

                    // Allow chaining by returning a new object with this folder as the root
                    var ret = this.clone();
                    ret.root = newFolder.name;
                    return ret;
                },

                /**
                 * Delete a file, or a directory and all sub-files, from the zip
                 * @param {string} name the name of the file to delete
                 * @return {JSZip} this JSZip object
                 */
                remove: function(name) {
                    name = this.root + name;
                    var file = this.files[name];
                    if (!file) {
                        // Look for any folders
                        if (name.slice(-1) !== "/") {
                            name += "/";
                        }
                        file = this.files[name];
                    }

                    if (file && !file.dir) {
                        // file
                        delete this.files[name];
                    } else {
                        // maybe a folder, delete recursively
                        var kids = this.filter(function(relativePath, file) {
                            return file.name.slice(0, name.length) === name;
                        });
                        for (var i = 0; i < kids.length; i++) {
                            delete this.files[kids[i].name];
                        }
                    }

                    return this;
                },

                /**
                 * Generate the complete zip file
                 * @param {Object} options the options to generate the zip file :
                 * - compression, "STORE" by default.
                 * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
                 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
                 */
                generate: function(options) {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                },

                /**
                 * Generate the complete zip file as an internal stream.
                 * @param {Object} options the options to generate the zip file :
                 * - compression, "STORE" by default.
                 * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
                 * @return {StreamHelper} the streamed zip file.
                 */
                generateInternalStream: function(options) {
                    var worker, opts = {};
                    try {
                        opts = utils.extend(options || {}, {
                            streamFiles: false,
                            compression: "STORE",
                            compressionOptions: null,
                            type: "",
                            platform: "DOS",
                            comment: null,
                            mimeType: 'application/zip',
                            encodeFileName: utf8.utf8encode
                        });

                        opts.type = opts.type.toLowerCase();
                        opts.compression = opts.compression.toUpperCase();

                        // "binarystring" is prefered but the internals use "string".
                        if (opts.type === "binarystring") {
                            opts.type = "string";
                        }

                        if (!opts.type) {
                            throw new Error("No output type specified.");
                        }

                        utils.checkSupport(opts.type);

                        // accept nodejs `process.platform`
                        if (
                            opts.platform === 'darwin' ||
                            opts.platform === 'freebsd' ||
                            opts.platform === 'linux' ||
                            opts.platform === 'sunos'
                        ) {
                            opts.platform = "UNIX";
                        }
                        if (opts.platform === 'win32') {
                            opts.platform = "DOS";
                        }

                        var comment = opts.comment || this.comment || "";
                        worker = generate.generateWorker(this, opts, comment);
                    } catch (e) {
                        worker = new GenericWorker("error");
                        worker.error(e);
                    }
                    return new StreamHelper(worker, opts.type || "string", opts.mimeType);
                },
                /**
                 * Generate the complete zip file asynchronously.
                 * @see generateInternalStream
                 */
                generateAsync: function(options, onUpdate) {
                    return this.generateInternalStream(options).accumulate(onUpdate);
                },
                /**
                 * Generate the complete zip file asynchronously.
                 * @see generateInternalStream
                 */
                generateNodeStream: function(options, onUpdate) {
                    options = options || {};
                    if (!options.type) {
                        options.type = "nodebuffer";
                    }
                    return this.generateInternalStream(options).toNodejsStream(onUpdate);
                }
            };
            module.exports = out;

        }, {
            "./compressedObject": 2,
            "./defaults": 5,
            "./generate": 9,
            "./nodejs/NodejsStreamInputAdapter": 12,
            "./nodejsUtils": 14,
            "./stream/GenericWorker": 28,
            "./stream/StreamHelper": 29,
            "./utf8": 31,
            "./utils": 32,
            "./zipObject": 35
        }],
        16: [function(require, module, exports) {
            /*
             * This file is used by module bundlers (browserify/webpack/etc) when
             * including a stream implementation. We use "readable-stream" to get a
             * consistent behavior between nodejs versions but bundlers often have a shim
             * for "stream". Using this shim greatly improve the compatibility and greatly
             * reduce the final size of the bundle (only one stream implementation, not
             * two).
             */
            module.exports = require("stream");

        }, {
            "stream": undefined
        }],
        17: [function(require, module, exports) {
            'use strict';
            var DataReader = require('./DataReader');
            var utils = require('../utils');

            function ArrayReader(data) {
                DataReader.call(this, data);
                for (var i = 0; i < this.data.length; i++) {
                    data[i] = data[i] & 0xFF;
                }
            }
            utils.inherits(ArrayReader, DataReader);
            /**
             * @see DataReader.byteAt
             */
            ArrayReader.prototype.byteAt = function(i) {
                return this.data[this.zero + i];
            };
            /**
             * @see DataReader.lastIndexOfSignature
             */
            ArrayReader.prototype.lastIndexOfSignature = function(sig) {
                var sig0 = sig.charCodeAt(0),
                    sig1 = sig.charCodeAt(1),
                    sig2 = sig.charCodeAt(2),
                    sig3 = sig.charCodeAt(3);
                for (var i = this.length - 4; i >= 0; --i) {
                    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
                        return i - this.zero;
                    }
                }

                return -1;
            };
            /**
             * @see DataReader.readAndCheckSignature
             */
            ArrayReader.prototype.readAndCheckSignature = function(sig) {
                var sig0 = sig.charCodeAt(0),
                    sig1 = sig.charCodeAt(1),
                    sig2 = sig.charCodeAt(2),
                    sig3 = sig.charCodeAt(3),
                    data = this.readData(4);
                return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
            };
            /**
             * @see DataReader.readData
             */
            ArrayReader.prototype.readData = function(size) {
                this.checkOffset(size);
                if (size === 0) {
                    return [];
                }
                var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
                this.index += size;
                return result;
            };
            module.exports = ArrayReader;

        }, {
            "../utils": 32,
            "./DataReader": 18
        }],
        18: [function(require, module, exports) {
            'use strict';
            var utils = require('../utils');

            function DataReader(data) {
                this.data = data; // type : see implementation
                this.length = data.length;
                this.index = 0;
                this.zero = 0;
            }
            DataReader.prototype = {
                /**
                 * Check that the offset will not go too far.
                 * @param {string} offset the additional offset to check.
                 * @throws {Error} an Error if the offset is out of bounds.
                 */
                checkOffset: function(offset) {
                    this.checkIndex(this.index + offset);
                },
                /**
                 * Check that the specifed index will not be too far.
                 * @param {string} newIndex the index to check.
                 * @throws {Error} an Error if the index is out of bounds.
                 */
                checkIndex: function(newIndex) {
                    if (this.length < this.zero + newIndex || newIndex < 0) {
                        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
                    }
                },
                /**
                 * Change the index.
                 * @param {number} newIndex The new index.
                 * @throws {Error} if the new index is out of the data.
                 */
                setIndex: function(newIndex) {
                    this.checkIndex(newIndex);
                    this.index = newIndex;
                },
                /**
                 * Skip the next n bytes.
                 * @param {number} n the number of bytes to skip.
                 * @throws {Error} if the new index is out of the data.
                 */
                skip: function(n) {
                    this.setIndex(this.index + n);
                },
                /**
                 * Get the byte at the specified index.
                 * @param {number} i the index to use.
                 * @return {number} a byte.
                 */
                byteAt: function(i) {
                    // see implementations
                },
                /**
                 * Get the next number with a given byte size.
                 * @param {number} size the number of bytes to read.
                 * @return {number} the corresponding number.
                 */
                readInt: function(size) {
                    var result = 0,
                        i;
                    this.checkOffset(size);
                    for (i = this.index + size - 1; i >= this.index; i--) {
                        result = (result << 8) + this.byteAt(i);
                    }
                    this.index += size;
                    return result;
                },
                /**
                 * Get the next string with a given byte size.
                 * @param {number} size the number of bytes to read.
                 * @return {string} the corresponding string.
                 */
                readString: function(size) {
                    return utils.transformTo("string", this.readData(size));
                },
                /**
                 * Get raw data without conversion, <size> bytes.
                 * @param {number} size the number of bytes to read.
                 * @return {Object} the raw data, implementation specific.
                 */
                readData: function(size) {
                    // see implementations
                },
                /**
                 * Find the last occurence of a zip signature (4 bytes).
                 * @param {string} sig the signature to find.
                 * @return {number} the index of the last occurence, -1 if not found.
                 */
                lastIndexOfSignature: function(sig) {
                    // see implementations
                },
                /**
                 * Read the signature (4 bytes) at the current position and compare it with sig.
                 * @param {string} sig the expected signature
                 * @return {boolean} true if the signature matches, false otherwise.
                 */
                readAndCheckSignature: function(sig) {
                    // see implementations
                },
                /**
                 * Get the next date.
                 * @return {Date} the date.
                 */
                readDate: function() {
                    var dostime = this.readInt(4);
                    return new Date(Date.UTC(
                        ((dostime >> 25) & 0x7f) + 1980, // year
                        ((dostime >> 21) & 0x0f) - 1, // month
                        (dostime >> 16) & 0x1f, // day
                        (dostime >> 11) & 0x1f, // hour
                        (dostime >> 5) & 0x3f, // minute
                        (dostime & 0x1f) << 1)); // second
                }
            };
            module.exports = DataReader;

        }, {
            "../utils": 32
        }],
        19: [function(require, module, exports) {
            'use strict';
            var Uint8ArrayReader = require('./Uint8ArrayReader');
            var utils = require('../utils');

            function NodeBufferReader(data) {
                Uint8ArrayReader.call(this, data);
            }
            utils.inherits(NodeBufferReader, Uint8ArrayReader);

            /**
             * @see DataReader.readData
             */
            NodeBufferReader.prototype.readData = function(size) {
                this.checkOffset(size);
                var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
                this.index += size;
                return result;
            };
            module.exports = NodeBufferReader;

        }, {
            "../utils": 32,
            "./Uint8ArrayReader": 21
        }],
        20: [function(require, module, exports) {
            'use strict';
            var DataReader = require('./DataReader');
            var utils = require('../utils');

            function StringReader(data) {
                DataReader.call(this, data);
            }
            utils.inherits(StringReader, DataReader);
            /**
             * @see DataReader.byteAt
             */
            StringReader.prototype.byteAt = function(i) {
                return this.data.charCodeAt(this.zero + i);
            };
            /**
             * @see DataReader.lastIndexOfSignature
             */
            StringReader.prototype.lastIndexOfSignature = function(sig) {
                return this.data.lastIndexOf(sig) - this.zero;
            };
            /**
             * @see DataReader.readAndCheckSignature
             */
            StringReader.prototype.readAndCheckSignature = function(sig) {
                var data = this.readData(4);
                return sig === data;
            };
            /**
             * @see DataReader.readData
             */
            StringReader.prototype.readData = function(size) {
                this.checkOffset(size);
                // this will work because the constructor applied the "& 0xff" mask.
                var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
                this.index += size;
                return result;
            };
            module.exports = StringReader;

        }, {
            "../utils": 32,
            "./DataReader": 18
        }],
        21: [function(require, module, exports) {
            'use strict';
            var ArrayReader = require('./ArrayReader');
            var utils = require('../utils');

            function Uint8ArrayReader(data) {
                ArrayReader.call(this, data);
            }
            utils.inherits(Uint8ArrayReader, ArrayReader);
            /**
             * @see DataReader.readData
             */
            Uint8ArrayReader.prototype.readData = function(size) {
                this.checkOffset(size);
                if (size === 0) {
                    // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
                    return new Uint8Array(0);
                }
                var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
                this.index += size;
                return result;
            };
            module.exports = Uint8ArrayReader;

        }, {
            "../utils": 32,
            "./ArrayReader": 17
        }],
        22: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var support = require('../support');
            var ArrayReader = require('./ArrayReader');
            var StringReader = require('./StringReader');
            var NodeBufferReader = require('./NodeBufferReader');
            var Uint8ArrayReader = require('./Uint8ArrayReader');

            /**
             * Create a reader adapted to the data.
             * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
             * @return {DataReader} the data reader.
             */
            module.exports = function(data) {
                var type = utils.getTypeOf(data);
                utils.checkSupport(type);
                if (type === "string" && !support.uint8array) {
                    return new StringReader(data);
                }
                if (type === "nodebuffer") {
                    return new NodeBufferReader(data);
                }
                if (support.uint8array) {
                    return new Uint8ArrayReader(utils.transformTo("uint8array", data));
                }
                return new ArrayReader(utils.transformTo("array", data));
            };

        }, {
            "../support": 30,
            "../utils": 32,
            "./ArrayReader": 17,
            "./NodeBufferReader": 19,
            "./StringReader": 20,
            "./Uint8ArrayReader": 21
        }],
        23: [function(require, module, exports) {
            'use strict';
            exports.LOCAL_FILE_HEADER = "PK\x03\x04";
            exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
            exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
            exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
            exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
            exports.DATA_DESCRIPTOR = "PK\x07\x08";

        }, {}],
        24: [function(require, module, exports) {
            'use strict';

            var GenericWorker = require('./GenericWorker');
            var utils = require('../utils');

            /**
             * A worker which convert chunks to a specified type.
             * @constructor
             * @param {String} destType the destination type.
             */
            function ConvertWorker(destType) {
                GenericWorker.call(this, "ConvertWorker to " + destType);
                this.destType = destType;
            }
            utils.inherits(ConvertWorker, GenericWorker);

            /**
             * @see GenericWorker.processChunk
             */
            ConvertWorker.prototype.processChunk = function(chunk) {
                this.push({
                    data: utils.transformTo(this.destType, chunk.data),
                    meta: chunk.meta
                });
            };
            module.exports = ConvertWorker;

        }, {
            "../utils": 32,
            "./GenericWorker": 28
        }],
        25: [function(require, module, exports) {
            'use strict';

            var GenericWorker = require('./GenericWorker');
            var crc32 = require('../crc32');
            var utils = require('../utils');

            /**
             * A worker which calculate the crc32 of the data flowing through.
             * @constructor
             */
            function Crc32Probe() {
                GenericWorker.call(this, "Crc32Probe");
                this.withStreamInfo("crc32", 0);
            }
            utils.inherits(Crc32Probe, GenericWorker);

            /**
             * @see GenericWorker.processChunk
             */
            Crc32Probe.prototype.processChunk = function(chunk) {
                this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
                this.push(chunk);
            };
            module.exports = Crc32Probe;

        }, {
            "../crc32": 4,
            "../utils": 32,
            "./GenericWorker": 28
        }],
        26: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var GenericWorker = require('./GenericWorker');

            /**
             * A worker which calculate the total length of the data flowing through.
             * @constructor
             * @param {String} propName the name used to expose the length
             */
            function DataLengthProbe(propName) {
                GenericWorker.call(this, "DataLengthProbe for " + propName);
                this.propName = propName;
                this.withStreamInfo(propName, 0);
            }
            utils.inherits(DataLengthProbe, GenericWorker);

            /**
             * @see GenericWorker.processChunk
             */
            DataLengthProbe.prototype.processChunk = function(chunk) {
                if (chunk) {
                    var length = this.streamInfo[this.propName] || 0;
                    this.streamInfo[this.propName] = length + chunk.data.length;
                }
                GenericWorker.prototype.processChunk.call(this, chunk);
            };
            module.exports = DataLengthProbe;


        }, {
            "../utils": 32,
            "./GenericWorker": 28
        }],
        27: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var GenericWorker = require('./GenericWorker');

            // the size of the generated chunks
            // TODO expose this as a public variable
            var DEFAULT_BLOCK_SIZE = 16 * 1024;

            /**
             * A worker that reads a content and emits chunks.
             * @constructor
             * @param {Promise} dataP the promise of the data to split
             */
            function DataWorker(dataP) {
                GenericWorker.call(this, "DataWorker");
                var self = this;
                this.dataIsReady = false;
                this.index = 0;
                this.max = 0;
                this.data = null;
                this.type = "";

                this._tickScheduled = false;

                dataP.then(function(data) {
                    self.dataIsReady = true;
                    self.data = data;
                    self.max = data && data.length || 0;
                    self.type = utils.getTypeOf(data);
                    if (!self.isPaused) {
                        self._tickAndRepeat();
                    }
                }, function(e) {
                    self.error(e);
                });
            }

            utils.inherits(DataWorker, GenericWorker);

            /**
             * @see GenericWorker.cleanUp
             */
            DataWorker.prototype.cleanUp = function() {
                GenericWorker.prototype.cleanUp.call(this);
                this.data = null;
            };

            /**
             * @see GenericWorker.resume
             */
            DataWorker.prototype.resume = function() {
                if (!GenericWorker.prototype.resume.call(this)) {
                    return false;
                }

                if (!this._tickScheduled && this.dataIsReady) {
                    this._tickScheduled = true;
                    utils.delay(this._tickAndRepeat, [], this);
                }
                return true;
            };

            /**
             * Trigger a tick a schedule an other call to this function.
             */
            DataWorker.prototype._tickAndRepeat = function() {
                this._tickScheduled = false;
                if (this.isPaused || this.isFinished) {
                    return;
                }
                this._tick();
                if (!this.isFinished) {
                    utils.delay(this._tickAndRepeat, [], this);
                    this._tickScheduled = true;
                }
            };

            /**
             * Read and push a chunk.
             */
            DataWorker.prototype._tick = function() {

                if (this.isPaused || this.isFinished) {
                    return false;
                }

                var size = DEFAULT_BLOCK_SIZE;
                var data = null,
                    nextIndex = Math.min(this.max, this.index + size);
                if (this.index >= this.max) {
                    // EOF
                    return this.end();
                } else {
                    switch (this.type) {
                        case "string":
                            data = this.data.substring(this.index, nextIndex);
                            break;
                        case "uint8array":
                            data = this.data.subarray(this.index, nextIndex);
                            break;
                        case "array":
                        case "nodebuffer":
                            data = this.data.slice(this.index, nextIndex);
                            break;
                    }
                    this.index = nextIndex;
                    return this.push({
                        data: data,
                        meta: {
                            percent: this.max ? this.index / this.max * 100 : 0
                        }
                    });
                }
            };

            module.exports = DataWorker;

        }, {
            "../utils": 32,
            "./GenericWorker": 28
        }],
        28: [function(require, module, exports) {
            'use strict';

            /**
             * A worker that does nothing but passing chunks to the next one. This is like
             * a nodejs stream but with some differences. On the good side :
             * - it works on IE 6-9 without any issue / polyfill
             * - it weights less than the full dependencies bundled with browserify
             * - it forwards errors (no need to declare an error handler EVERYWHERE)
             *
             * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
             * object containing anything (`percent` for example), see each worker for more
             * details. The latter is the real data (String, Uint8Array, etc).
             *
             * @constructor
             * @param {String} name the name of the stream (mainly used for debugging purposes)
             */
            function GenericWorker(name) {
                // the name of the worker
                this.name = name || "default";
                // an object containing metadata about the workers chain
                this.streamInfo = {};
                // an error which happened when the worker was paused
                this.generatedError = null;
                // an object containing metadata to be merged by this worker into the general metadata
                this.extraStreamInfo = {};
                // true if the stream is paused (and should not do anything), false otherwise
                this.isPaused = true;
                // true if the stream is finished (and should not do anything), false otherwise
                this.isFinished = false;
                // true if the stream is locked to prevent further structure updates (pipe), false otherwise
                this.isLocked = false;
                // the event listeners
                this._listeners = {
                    'data': [],
                    'end': [],
                    'error': []
                };
                // the previous worker, if any
                this.previous = null;
            }

            GenericWorker.prototype = {
                /**
                 * Push a chunk to the next workers.
                 * @param {Object} chunk the chunk to push
                 */
                push: function(chunk) {
                    this.emit("data", chunk);
                },
                /**
                 * End the stream.
                 * @return {Boolean} true if this call ended the worker, false otherwise.
                 */
                end: function() {
                    if (this.isFinished) {
                        return false;
                    }

                    this.flush();
                    try {
                        this.emit("end");
                        this.cleanUp();
                        this.isFinished = true;
                    } catch (e) {
                        this.emit("error", e);
                    }
                    return true;
                },
                /**
                 * End the stream with an error.
                 * @param {Error} e the error which caused the premature end.
                 * @return {Boolean} true if this call ended the worker with an error, false otherwise.
                 */
                error: function(e) {
                    if (this.isFinished) {
                        return false;
                    }

                    if (this.isPaused) {
                        this.generatedError = e;
                    } else {
                        this.isFinished = true;

                        this.emit("error", e);

                        // in the workers chain exploded in the middle of the chain,
                        // the error event will go downward but we also need to notify
                        // workers upward that there has been an error.
                        if (this.previous) {
                            this.previous.error(e);
                        }

                        this.cleanUp();
                    }
                    return true;
                },
                /**
                 * Add a callback on an event.
                 * @param {String} name the name of the event (data, end, error)
                 * @param {Function} listener the function to call when the event is triggered
                 * @return {GenericWorker} the current object for chainability
                 */
                on: function(name, listener) {
                    this._listeners[name].push(listener);
                    return this;
                },
                /**
                 * Clean any references when a worker is ending.
                 */
                cleanUp: function() {
                    this.streamInfo = this.generatedError = this.extraStreamInfo = null;
                    this._listeners = [];
                },
                /**
                 * Trigger an event. This will call registered callback with the provided arg.
                 * @param {String} name the name of the event (data, end, error)
                 * @param {Object} arg the argument to call the callback with.
                 */
                emit: function(name, arg) {
                    if (this._listeners[name]) {
                        for (var i = 0; i < this._listeners[name].length; i++) {
                            this._listeners[name][i].call(this, arg);
                        }
                    }
                },
                /**
                 * Chain a worker with an other.
                 * @param {Worker} next the worker receiving events from the current one.
                 * @return {worker} the next worker for chainability
                 */
                pipe: function(next) {
                    return next.registerPrevious(this);
                },
                /**
                 * Same as `pipe` in the other direction.
                 * Using an API with `pipe(next)` is very easy.
                 * Implementing the API with the point of view of the next one registering
                 * a source is easier, see the ZipFileWorker.
                 * @param {Worker} previous the previous worker, sending events to this one
                 * @return {Worker} the current worker for chainability
                 */
                registerPrevious: function(previous) {
                    if (this.isLocked) {
                        throw new Error("The stream '" + this + "' has already been used.");
                    }

                    // sharing the streamInfo...
                    this.streamInfo = previous.streamInfo;
                    // ... and adding our own bits
                    this.mergeStreamInfo();
                    this.previous = previous;
                    var self = this;
                    previous.on('data', function(chunk) {
                        self.processChunk(chunk);
                    });
                    previous.on('end', function() {
                        self.end();
                    });
                    previous.on('error', function(e) {
                        self.error(e);
                    });
                    return this;
                },
                /**
                 * Pause the stream so it doesn't send events anymore.
                 * @return {Boolean} true if this call paused the worker, false otherwise.
                 */
                pause: function() {
                    if (this.isPaused || this.isFinished) {
                        return false;
                    }
                    this.isPaused = true;

                    if (this.previous) {
                        this.previous.pause();
                    }
                    return true;
                },
                /**
                 * Resume a paused stream.
                 * @return {Boolean} true if this call resumed the worker, false otherwise.
                 */
                resume: function() {
                    if (!this.isPaused || this.isFinished) {
                        return false;
                    }
                    this.isPaused = false;

                    // if true, the worker tried to resume but failed
                    var withError = false;
                    if (this.generatedError) {
                        this.error(this.generatedError);
                        withError = true;
                    }
                    if (this.previous) {
                        this.previous.resume();
                    }

                    return !withError;
                },
                /**
                 * Flush any remaining bytes as the stream is ending.
                 */
                flush: function() {},
                /**
                 * Process a chunk. This is usually the method overridden.
                 * @param {Object} chunk the chunk to process.
                 */
                processChunk: function(chunk) {
                    this.push(chunk);
                },
                /**
                 * Add a key/value to be added in the workers chain streamInfo once activated.
                 * @param {String} key the key to use
                 * @param {Object} value the associated value
                 * @return {Worker} the current worker for chainability
                 */
                withStreamInfo: function(key, value) {
                    this.extraStreamInfo[key] = value;
                    this.mergeStreamInfo();
                    return this;
                },
                /**
                 * Merge this worker's streamInfo into the chain's streamInfo.
                 */
                mergeStreamInfo: function() {
                    for (var key in this.extraStreamInfo) {
                        if (!this.extraStreamInfo.hasOwnProperty(key)) {
                            continue;
                        }
                        this.streamInfo[key] = this.extraStreamInfo[key];
                    }
                },

                /**
                 * Lock the stream to prevent further updates on the workers chain.
                 * After calling this method, all calls to pipe will fail.
                 */
                lock: function() {
                    if (this.isLocked) {
                        throw new Error("The stream '" + this + "' has already been used.");
                    }
                    this.isLocked = true;
                    if (this.previous) {
                        this.previous.lock();
                    }
                },

                /**
                 *
                 * Pretty print the workers chain.
                 */
                toString: function() {
                    var me = "Worker " + this.name;
                    if (this.previous) {
                        return this.previous + " -> " + me;
                    } else {
                        return me;
                    }
                }
            };

            module.exports = GenericWorker;

        }, {}],
        29: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var ConvertWorker = require('./ConvertWorker');
            var GenericWorker = require('./GenericWorker');
            var base64 = require('../base64');
            var support = require("../support");
            var external = require("../external");

            var NodejsStreamOutputAdapter = null;
            if (support.nodestream) {
                try {
                    NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
                } catch (e) {}
            }

            /**
             * Apply the final transformation of the data. If the user wants a Blob for
             * example, it's easier to work with an U8intArray and finally do the
             * ArrayBuffer/Blob conversion.
             * @param {String} resultType the name of the final type
             * @param {String} chunkType the type of the data in the given array.
             * @param {Array} dataArray the array containing the data chunks to concatenate
             * @param {String|Uint8Array|Buffer} content the content to transform
             * @param {String} mimeType the mime type of the content, if applicable.
             * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
             */
            function transformZipOutput(resultType, chunkType, dataArray, mimeType) {
                var content = null;
                switch (resultType) {
                    case "blob":
                        return utils.newBlob(dataArray, mimeType);
                    case "base64":
                        content = concat(chunkType, dataArray);
                        return base64.encode(content);
                    default:
                        content = concat(chunkType, dataArray);
                        return utils.transformTo(resultType, content);
                }
            }

            /**
             * Concatenate an array of data of the given type.
             * @param {String} type the type of the data in the given array.
             * @param {Array} dataArray the array containing the data chunks to concatenate
             * @return {String|Uint8Array|Buffer} the concatenated data
             * @throws Error if the asked type is unsupported
             */
            function concat(type, dataArray) {
                var i, index = 0,
                    res = null,
                    totalLength = 0;
                for (i = 0; i < dataArray.length; i++) {
                    totalLength += dataArray[i].length;
                }
                switch (type) {
                    case "string":
                        return dataArray.join("");
                    case "array":
                        return Array.prototype.concat.apply([], dataArray);
                    case "uint8array":
                        res = new Uint8Array(totalLength);
                        for (i = 0; i < dataArray.length; i++) {
                            res.set(dataArray[i], index);
                            index += dataArray[i].length;
                        }
                        return res;
                    case "nodebuffer":
                        return Buffer.concat(dataArray);
                    default:
                        throw new Error("concat : unsupported type '" + type + "'");
                }
            }

            /**
             * Listen a StreamHelper, accumulate its content and concatenate it into a
             * complete block.
             * @param {StreamHelper} helper the helper to use.
             * @param {Function} updateCallback a callback called on each update. Called
             * with one arg :
             * - the metadata linked to the update received.
             * @return Promise the promise for the accumulation.
             */
            function accumulate(helper, updateCallback) {
                return new external.Promise(function(resolve, reject) {
                    var dataArray = [];
                    var chunkType = helper._internalType,
                        resultType = helper._outputType,
                        mimeType = helper._mimeType;
                    helper
                        .on('data', function(data, meta) {
                            dataArray.push(data);
                            if (updateCallback) {
                                updateCallback(meta);
                            }
                        })
                        .on('error', function(err) {
                            dataArray = [];
                            reject(err);
                        })
                        .on('end', function() {
                            try {
                                var result = transformZipOutput(resultType, chunkType, dataArray, mimeType);
                                resolve(result);
                            } catch (e) {
                                reject(e);
                            }
                            dataArray = [];
                        })
                        .resume();
                });
            }

            /**
             * An helper to easily use workers outside of JSZip.
             * @constructor
             * @param {Worker} worker the worker to wrap
             * @param {String} outputType the type of data expected by the use
             * @param {String} mimeType the mime type of the content, if applicable.
             */
            function StreamHelper(worker, outputType, mimeType) {
                var internalType = outputType;
                switch (outputType) {
                    case "blob":
                        internalType = "arraybuffer";
                        break;
                    case "arraybuffer":
                        internalType = "uint8array";
                        break;
                    case "base64":
                        internalType = "string";
                        break;
                }

                try {
                    // the type used internally
                    this._internalType = internalType;
                    // the type used to output results
                    this._outputType = outputType;
                    // the mime type
                    this._mimeType = mimeType;
                    utils.checkSupport(internalType);
                    this._worker = worker.pipe(new ConvertWorker(internalType));
                    // the last workers can be rewired without issues but we need to
                    // prevent any updates on previous workers.
                    worker.lock();
                } catch (e) {
                    this._worker = new GenericWorker("error");
                    this._worker.error(e);
                }
            }

            StreamHelper.prototype = {
                /**
                 * Listen a StreamHelper, accumulate its content and concatenate it into a
                 * complete block.
                 * @param {Function} updateCb the update callback.
                 * @return Promise the promise for the accumulation.
                 */
                accumulate: function(updateCb) {
                    return accumulate(this, updateCb);
                },
                /**
                 * Add a listener on an event triggered on a stream.
                 * @param {String} evt the name of the event
                 * @param {Function} fn the listener
                 * @return {StreamHelper} the current helper.
                 */
                on: function(evt, fn) {
                    var self = this;

                    if (evt === "data") {
                        this._worker.on(evt, function(chunk) {
                            fn.call(self, chunk.data, chunk.meta);
                        });
                    } else {
                        this._worker.on(evt, function() {
                            utils.delay(fn, arguments, self);
                        });
                    }
                    return this;
                },
                /**
                 * Resume the flow of chunks.
                 * @return {StreamHelper} the current helper.
                 */
                resume: function() {
                    utils.delay(this._worker.resume, [], this._worker);
                    return this;
                },
                /**
                 * Pause the flow of chunks.
                 * @return {StreamHelper} the current helper.
                 */
                pause: function() {
                    this._worker.pause();
                    return this;
                },
                /**
                 * Return a nodejs stream for this helper.
                 * @param {Function} updateCb the update callback.
                 * @return {NodejsStreamOutputAdapter} the nodejs stream.
                 */
                toNodejsStream: function(updateCb) {
                    utils.checkSupport("nodestream");
                    if (this._outputType !== "nodebuffer") {
                        // an object stream containing blob/arraybuffer/uint8array/string
                        // is strange and I don't know if it would be useful.
                        // I you find this comment and have a good usecase, please open a
                        // bug report !
                        throw new Error(this._outputType + " is not supported by this method");
                    }

                    return new NodejsStreamOutputAdapter(this, {
                        objectMode: this._outputType !== "nodebuffer"
                    }, updateCb);
                }
            };


            module.exports = StreamHelper;

        }, {
            "../base64": 1,
            "../external": 6,
            "../nodejs/NodejsStreamOutputAdapter": 13,
            "../support": 30,
            "../utils": 32,
            "./ConvertWorker": 24,
            "./GenericWorker": 28
        }],
        30: [function(require, module, exports) {
            'use strict';

            exports.base64 = true;
            exports.array = true;
            exports.string = true;
            exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
            exports.nodebuffer = typeof Buffer !== "undefined";
            // contains true if JSZip can read/generate Uint8Array, false otherwise.
            exports.uint8array = typeof Uint8Array !== "undefined";

            if (typeof ArrayBuffer === "undefined") {
                exports.blob = false;
            } else {
                var buffer = new ArrayBuffer(0);
                try {
                    exports.blob = new Blob([buffer], {
                        type: "application/zip"
                    }).size === 0;
                } catch (e) {
                    try {
                        var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                        var builder = new Builder();
                        builder.append(buffer);
                        exports.blob = builder.getBlob('application/zip').size === 0;
                    } catch (e) {
                        exports.blob = false;
                    }
                }
            }

            try {
                exports.nodestream = !!require('readable-stream').Readable;
            } catch (e) {
                exports.nodestream = false;
            }

        }, {
            "readable-stream": 16
        }],
        31: [function(require, module, exports) {
            'use strict';

            var utils = require('./utils');
            var support = require('./support');
            var nodejsUtils = require('./nodejsUtils');
            var GenericWorker = require('./stream/GenericWorker');

            /**
             * The following functions come from pako, from pako/lib/utils/strings
             * released under the MIT license, see pako https://github.com/nodeca/pako/
             */

            // Table with utf8 lengths (calculated by first byte of sequence)
            // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
            // because max possible codepoint is 0x10ffff
            var _utf8len = new Array(256);
            for (var i = 0; i < 256; i++) {
                _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
            }
            _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

            // convert string to array (typed, when possible)
            var string2buf = function(str) {
                var buf, c, c2, m_pos, i, str_len = str.length,
                    buf_len = 0;

                // count binary size
                for (m_pos = 0; m_pos < str_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 0xfc00) === 0xdc00) {
                            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                            m_pos++;
                        }
                    }
                    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
                }

                // allocate buffer
                if (support.uint8array) {
                    buf = new Uint8Array(buf_len);
                } else {
                    buf = new Array(buf_len);
                }

                // convert
                for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 0xfc00) === 0xdc00) {
                            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                            m_pos++;
                        }
                    }
                    if (c < 0x80) {
                        /* one byte */
                        buf[i++] = c;
                    } else if (c < 0x800) {
                        /* two bytes */
                        buf[i++] = 0xC0 | (c >>> 6);
                        buf[i++] = 0x80 | (c & 0x3f);
                    } else if (c < 0x10000) {
                        /* three bytes */
                        buf[i++] = 0xE0 | (c >>> 12);
                        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                        buf[i++] = 0x80 | (c & 0x3f);
                    } else {
                        /* four bytes */
                        buf[i++] = 0xf0 | (c >>> 18);
                        buf[i++] = 0x80 | (c >>> 12 & 0x3f);
                        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                        buf[i++] = 0x80 | (c & 0x3f);
                    }
                }

                return buf;
            };

            // Calculate max possible position in utf8 buffer,
            // that will not break sequence. If that's not possible
            // - (very small limits) return max size as is.
            //
            // buf[] - utf8 bytes array
            // max   - length limit (mandatory);
            var utf8border = function(buf, max) {
                var pos;

                max = max || buf.length;
                if (max > buf.length) {
                    max = buf.length;
                }

                // go back from last position, until start of sequence found
                pos = max - 1;
                while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
                    pos--;
                }

                // Fuckup - very small and broken sequence,
                // return max, because we should return something anyway.
                if (pos < 0) {
                    return max;
                }

                // If we came to start of buffer - that means vuffer is too small,
                // return max too.
                if (pos === 0) {
                    return max;
                }

                return (pos + _utf8len[buf[pos]] > max) ? pos : max;
            };

            // convert array to string
            var buf2string = function(buf) {
                var str, i, out, c, c_len;
                var len = buf.length;

                // Reserve max possible length (2 words per char)
                // NB: by unknown reasons, Array is significantly faster for
                //     String.fromCharCode.apply than Uint16Array.
                var utf16buf = new Array(len * 2);

                for (out = 0, i = 0; i < len;) {
                    c = buf[i++];
                    // quick process ascii
                    if (c < 0x80) {
                        utf16buf[out++] = c;
                        continue;
                    }

                    c_len = _utf8len[c];
                    // skip 5 & 6 byte codes
                    if (c_len > 4) {
                        utf16buf[out++] = 0xfffd;
                        i += c_len - 1;
                        continue;
                    }

                    // apply mask on first byte
                    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
                    // join the rest
                    while (c_len > 1 && i < len) {
                        c = (c << 6) | (buf[i++] & 0x3f);
                        c_len--;
                    }

                    // terminated by end of string?
                    if (c_len > 1) {
                        utf16buf[out++] = 0xfffd;
                        continue;
                    }

                    if (c < 0x10000) {
                        utf16buf[out++] = c;
                    } else {
                        c -= 0x10000;
                        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                        utf16buf[out++] = 0xdc00 | (c & 0x3ff);
                    }
                }

                // shrinkBuf(utf16buf, out)
                if (utf16buf.length !== out) {
                    if (utf16buf.subarray) {
                        utf16buf = utf16buf.subarray(0, out);
                    } else {
                        utf16buf.length = out;
                    }
                }

                // return String.fromCharCode.apply(null, utf16buf);
                return utils.applyFromCharCode(utf16buf);
            };


            // That's all for the pako functions.


            /**
             * Transform a javascript string into an array (typed if possible) of bytes,
             * UTF-8 encoded.
             * @param {String} str the string to encode
             * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
             */
            exports.utf8encode = function utf8encode(str) {
                if (support.nodebuffer) {
                    return nodejsUtils.newBuffer(str, "utf-8");
                }

                return string2buf(str);
            };


            /**
             * Transform a bytes array (or a representation) representing an UTF-8 encoded
             * string into a javascript string.
             * @param {Array|Uint8Array|Buffer} buf the data de decode
             * @return {String} the decoded string.
             */
            exports.utf8decode = function utf8decode(buf) {
                if (support.nodebuffer) {
                    return utils.transformTo("nodebuffer", buf).toString("utf-8");
                }

                buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

                return buf2string(buf);
            };

            /**
             * A worker to decode utf8 encoded binary chunks into string chunks.
             * @constructor
             */
            function Utf8DecodeWorker() {
                GenericWorker.call(this, "utf-8 decode");
                // the last bytes if a chunk didn't end with a complete codepoint.
                this.leftOver = null;
            }
            utils.inherits(Utf8DecodeWorker, GenericWorker);

            /**
             * @see GenericWorker.processChunk
             */
            Utf8DecodeWorker.prototype.processChunk = function(chunk) {

                var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

                // 1st step, re-use what's left of the previous chunk
                if (this.leftOver && this.leftOver.length) {
                    if (support.uint8array) {
                        var previousData = data;
                        data = new Uint8Array(previousData.length + this.leftOver.length);
                        data.set(this.leftOver, 0);
                        data.set(previousData, this.leftOver.length);
                    } else {
                        data = this.leftOver.concat(data);
                    }
                    this.leftOver = null;
                }

                var nextBoundary = utf8border(data);
                var usableData = data;
                if (nextBoundary !== data.length) {
                    if (support.uint8array) {
                        usableData = data.subarray(0, nextBoundary);
                        this.leftOver = data.subarray(nextBoundary, data.length);
                    } else {
                        usableData = data.slice(0, nextBoundary);
                        this.leftOver = data.slice(nextBoundary, data.length);
                    }
                }

                this.push({
                    data: exports.utf8decode(usableData),
                    meta: chunk.meta
                });
            };

            /**
             * @see GenericWorker.flush
             */
            Utf8DecodeWorker.prototype.flush = function() {
                if (this.leftOver && this.leftOver.length) {
                    this.push({
                        data: exports.utf8decode(this.leftOver),
                        meta: {}
                    });
                    this.leftOver = null;
                }
            };
            exports.Utf8DecodeWorker = Utf8DecodeWorker;

            /**
             * A worker to endcode string chunks into utf8 encoded binary chunks.
             * @constructor
             */
            function Utf8EncodeWorker() {
                GenericWorker.call(this, "utf-8 encode");
            }
            utils.inherits(Utf8EncodeWorker, GenericWorker);

            /**
             * @see GenericWorker.processChunk
             */
            Utf8EncodeWorker.prototype.processChunk = function(chunk) {
                this.push({
                    data: exports.utf8encode(chunk.data),
                    meta: chunk.meta
                });
            };
            exports.Utf8EncodeWorker = Utf8EncodeWorker;

        }, {
            "./nodejsUtils": 14,
            "./stream/GenericWorker": 28,
            "./support": 30,
            "./utils": 32
        }],
        32: [function(require, module, exports) {
            'use strict';

            var support = require('./support');
            var base64 = require('./base64');
            var nodejsUtils = require('./nodejsUtils');
            var setImmediate = require('core-js/library/fn/set-immediate');
            var external = require("./external");


            /**
             * Convert a string that pass as a "binary string": it should represent a byte
             * array but may have > 255 char codes. Be sure to take only the first byte
             * and returns the byte array.
             * @param {String} str the string to transform.
             * @return {Array|Uint8Array} the string in a binary format.
             */
            function string2binary(str) {
                var result = null;
                if (support.uint8array) {
                    result = new Uint8Array(str.length);
                } else {
                    result = new Array(str.length);
                }
                return stringToArrayLike(str, result);
            }

            /**
             * Create a new blob with the given content and the given type.
             * @param {Array[String|ArrayBuffer]} parts the content to put in the blob. DO NOT use
             * an Uint8Array because the stock browser of android 4 won't accept it (it
             * will be silently converted to a string, "[object Uint8Array]").
             * @param {String} type the mime type of the blob.
             * @return {Blob} the created blob.
             */
            exports.newBlob = function(parts, type) {
                exports.checkSupport("blob");

                try {
                    // Blob constructor
                    return new Blob(parts, {
                        type: type
                    });
                } catch (e) {

                    try {
                        // deprecated, browser only, old way
                        var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                        var builder = new Builder();
                        for (var i = 0; i < parts.length; i++) {
                            builder.append(parts[i]);
                        }
                        return builder.getBlob(type);
                    } catch (e) {

                        // well, fuck ?!
                        throw new Error("Bug : can't construct the Blob.");
                    }
                }


            };
            /**
             * The identity function.
             * @param {Object} input the input.
             * @return {Object} the same input.
             */
            function identity(input) {
                return input;
            }

            /**
             * Fill in an array with a string.
             * @param {String} str the string to use.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
             * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
             */
            function stringToArrayLike(str, array) {
                for (var i = 0; i < str.length; ++i) {
                    array[i] = str.charCodeAt(i) & 0xFF;
                }
                return array;
            }

            /**
             * An helper for the function arrayLikeToString.
             * This contains static informations and functions that
             * can be optimized by the browser JIT compiler.
             */
            var arrayToStringHelper = {
                /**
                 * Transform an array of int into a string, chunk by chunk.
                 * See the performances notes on arrayLikeToString.
                 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
                 * @param {String} type the type of the array.
                 * @param {Integer} chunk the chunk size.
                 * @return {String} the resulting string.
                 * @throws Error if the chunk is too big for the stack.
                 */
                stringifyByChunk: function(array, type, chunk) {
                    var result = [],
                        k = 0,
                        len = array.length;
                    // shortcut
                    if (len <= chunk) {
                        return String.fromCharCode.apply(null, array);
                    }
                    while (k < len) {
                        if (type === "array" || type === "nodebuffer") {
                            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
                        } else {
                            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
                        }
                        k += chunk;
                    }
                    return result.join("");
                },
                /**
                 * Call String.fromCharCode on every item in the array.
                 * This is the naive implementation, which generate A LOT of intermediate string.
                 * This should be used when everything else fail.
                 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
                 * @return {String} the result.
                 */
                stringifyByChar: function(array) {
                    var resultStr = "";
                    for (var i = 0; i < array.length; i++) {
                        resultStr += String.fromCharCode(array[i]);
                    }
                    return resultStr;
                },
                applyCanBeUsed: {
                    /**
                     * true if the browser accepts to use String.fromCharCode on Uint8Array
                     */
                    uint8array: (function() {
                        try {
                            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                        } catch (e) {
                            return false;
                        }
                    })(),
                    /**
                     * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
                     */
                    nodebuffer: (function() {
                        try {
                            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.newBuffer(1)).length === 1;
                        } catch (e) {
                            return false;
                        }
                    })()
                }
            };

            /**
             * Transform an array-like object to a string.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
             * @return {String} the result.
             */
            function arrayLikeToString(array) {
                // Performances notes :
                // --------------------
                // String.fromCharCode.apply(null, array) is the fastest, see
                // see http://jsperf.com/converting-a-uint8array-to-a-string/2
                // but the stack is limited (and we can get huge arrays !).
                //
                // result += String.fromCharCode(array[i]); generate too many strings !
                //
                // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
                // TODO : we now have workers that split the work. Do we still need that ?
                var chunk = 65536,
                    type = exports.getTypeOf(array),
                    canUseApply = true;
                if (type === "uint8array") {
                    canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
                } else if (type === "nodebuffer") {
                    canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
                }

                if (canUseApply) {
                    while (chunk > 1) {
                        try {
                            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
                        } catch (e) {
                            chunk = Math.floor(chunk / 2);
                        }
                    }
                }

                // no apply or chunk error : slow and painful algorithm
                // default browser on android 4.*
                return arrayToStringHelper.stringifyByChar(array);
            }

            exports.applyFromCharCode = arrayLikeToString;


            /**
             * Copy the data from an array-like to an other array-like.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
             * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
             */
            function arrayLikeToArrayLike(arrayFrom, arrayTo) {
                for (var i = 0; i < arrayFrom.length; i++) {
                    arrayTo[i] = arrayFrom[i];
                }
                return arrayTo;
            }

            // a matrix containing functions to transform everything into everything.
            var transform = {};

            // string to ?
            transform["string"] = {
                "string": identity,
                "array": function(input) {
                    return stringToArrayLike(input, new Array(input.length));
                },
                "arraybuffer": function(input) {
                    return transform["string"]["uint8array"](input).buffer;
                },
                "uint8array": function(input) {
                    return stringToArrayLike(input, new Uint8Array(input.length));
                },
                "nodebuffer": function(input) {
                    return stringToArrayLike(input, nodejsUtils.newBuffer(input.length));
                }
            };

            // array to ?
            transform["array"] = {
                "string": arrayLikeToString,
                "array": identity,
                "arraybuffer": function(input) {
                    return (new Uint8Array(input)).buffer;
                },
                "uint8array": function(input) {
                    return new Uint8Array(input);
                },
                "nodebuffer": function(input) {
                    return nodejsUtils.newBuffer(input);
                }
            };

            // arraybuffer to ?
            transform["arraybuffer"] = {
                "string": function(input) {
                    return arrayLikeToString(new Uint8Array(input));
                },
                "array": function(input) {
                    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
                },
                "arraybuffer": identity,
                "uint8array": function(input) {
                    return new Uint8Array(input);
                },
                "nodebuffer": function(input) {
                    return nodejsUtils.newBuffer(new Uint8Array(input));
                }
            };

            // uint8array to ?
            transform["uint8array"] = {
                "string": arrayLikeToString,
                "array": function(input) {
                    return arrayLikeToArrayLike(input, new Array(input.length));
                },
                "arraybuffer": function(input) {
                    // copy the uint8array: DO NOT propagate the original ArrayBuffer, it
                    // can be way larger (the whole zip file for example).
                    var copy = new Uint8Array(input.length);
                    if (input.length) {
                        copy.set(input, 0);
                    }
                    return copy.buffer;
                },
                "uint8array": identity,
                "nodebuffer": function(input) {
                    return nodejsUtils.newBuffer(input);
                }
            };

            // nodebuffer to ?
            transform["nodebuffer"] = {
                "string": arrayLikeToString,
                "array": function(input) {
                    return arrayLikeToArrayLike(input, new Array(input.length));
                },
                "arraybuffer": function(input) {
                    return transform["nodebuffer"]["uint8array"](input).buffer;
                },
                "uint8array": function(input) {
                    return arrayLikeToArrayLike(input, new Uint8Array(input.length));
                },
                "nodebuffer": identity
            };

            /**
             * Transform an input into any type.
             * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
             * If no output type is specified, the unmodified input will be returned.
             * @param {String} outputType the output type.
             * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
             * @throws {Error} an Error if the browser doesn't support the requested output type.
             */
            exports.transformTo = function(outputType, input) {
                if (!input) {
                    // undefined, null, etc
                    // an empty string won't harm.
                    input = "";
                }
                if (!outputType) {
                    return input;
                }
                exports.checkSupport(outputType);
                var inputType = exports.getTypeOf(input);
                var result = transform[inputType][outputType](input);
                return result;
            };

            /**
             * Return the type of the input.
             * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
             * @param {Object} input the input to identify.
             * @return {String} the (lowercase) type of the input.
             */
            exports.getTypeOf = function(input) {
                if (typeof input === "string") {
                    return "string";
                }
                if (Object.prototype.toString.call(input) === "[object Array]") {
                    return "array";
                }
                if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
                    return "nodebuffer";
                }
                if (support.uint8array && input instanceof Uint8Array) {
                    return "uint8array";
                }
                if (support.arraybuffer && input instanceof ArrayBuffer) {
                    return "arraybuffer";
                }
            };

            /**
             * Throw an exception if the type is not supported.
             * @param {String} type the type to check.
             * @throws {Error} an Error if the browser doesn't support the requested type.
             */
            exports.checkSupport = function(type) {
                var supported = support[type.toLowerCase()];
                if (!supported) {
                    throw new Error(type + " is not supported by this platform");
                }
            };

            exports.MAX_VALUE_16BITS = 65535;
            exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

            /**
             * Prettify a string read as binary.
             * @param {string} str the string to prettify.
             * @return {string} a pretty string.
             */
            exports.pretty = function(str) {
                var res = '',
                    code, i;
                for (i = 0; i < (str || "").length; i++) {
                    code = str.charCodeAt(i);
                    res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
                }
                return res;
            };

            /**
             * Defer the call of a function.
             * @param {Function} callback the function to call asynchronously.
             * @param {Array} args the arguments to give to the callback.
             */
            exports.delay = function(callback, args, self) {
                setImmediate(function() {
                    callback.apply(self || null, args || []);
                });
            };

            /**
             * Extends a prototype with an other, without calling a constructor with
             * side effects. Inspired by nodejs' `utils.inherits`
             * @param {Function} ctor the constructor to augment
             * @param {Function} superCtor the parent constructor to use
             */
            exports.inherits = function(ctor, superCtor) {
                var Obj = function() {};
                Obj.prototype = superCtor.prototype;
                ctor.prototype = new Obj();
            };

            /**
             * Merge the objects passed as parameters into a new one.
             * @private
             * @param {...Object} var_args All objects to merge.
             * @return {Object} a new object with the data of the others.
             */
            exports.extend = function() {
                var result = {},
                    i, attr;
                for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
                    for (attr in arguments[i]) {
                        if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                            result[attr] = arguments[i][attr];
                        }
                    }
                }
                return result;
            };

            /**
             * Transform arbitrary content into a Promise.
             * @param {String} name a name for the content being processed.
             * @param {Object} inputData the content to process.
             * @param {Boolean} isBinary true if the content is not an unicode string
             * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
             * @param {Boolean} isBase64 true if the string content is encoded with base64.
             * @return {Promise} a promise in a format usable by JSZip.
             */
            exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

                // if inputData is already a promise, this flatten it.
                var promise = external.Promise.resolve(inputData).then(function(data) {


                    var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

                    if (isBlob && typeof FileReader !== "undefined") {
                        return new external.Promise(function(resolve, reject) {
                            var reader = new FileReader();

                            reader.onload = function(e) {
                                resolve(e.target.result);
                            };
                            reader.onerror = function(e) {
                                reject(e.target.error);
                            };
                            reader.readAsArrayBuffer(data);
                        });
                    } else {
                        return data;
                    }
                });

                return promise.then(function(data) {
                    var dataType = exports.getTypeOf(data);

                    if (!dataType) {
                        return external.Promise.reject(
                            new Error("The data of '" + name + "' is in an unsupported format !")
                        );
                    }
                    // special case : it's way easier to work with Uint8Array than with ArrayBuffer
                    if (dataType === "arraybuffer") {
                        data = exports.transformTo("uint8array", data);
                    } else if (dataType === "string") {
                        if (isBase64) {
                            data = base64.decode(data);
                        } else if (isBinary) {
                            // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                            if (isOptimizedBinaryString !== true) {
                                // this is a string, not in a base64 format.
                                // Be sure that this is a correct "binary string"
                                data = string2binary(data);
                            }
                        }
                    }
                    return data;
                });
            };

        }, {
            "./base64": 1,
            "./external": 6,
            "./nodejsUtils": 14,
            "./support": 30,
            "core-js/library/fn/set-immediate": 36
        }],
        33: [function(require, module, exports) {
            'use strict';
            var readerFor = require('./reader/readerFor');
            var utils = require('./utils');
            var sig = require('./signature');
            var ZipEntry = require('./zipEntry');
            var utf8 = require('./utf8');
            var support = require('./support');
            //  class ZipEntries {{{
            /**
             * All the entries in the zip file.
             * @constructor
             * @param {Object} loadOptions Options for loading the stream.
             */
            function ZipEntries(loadOptions) {
                this.files = [];
                this.loadOptions = loadOptions;
            }
            ZipEntries.prototype = {
                /**
                 * Check that the reader is on the speficied signature.
                 * @param {string} expectedSignature the expected signature.
                 * @throws {Error} if it is an other signature.
                 */
                checkSignature: function(expectedSignature) {
                    if (!this.reader.readAndCheckSignature(expectedSignature)) {
                        this.reader.index -= 4;
                        var signature = this.reader.readString(4);
                        throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
                    }
                },
                /**
                 * Check if the given signature is at the given index.
                 * @param {number} askedIndex the index to check.
                 * @param {string} expectedSignature the signature to expect.
                 * @return {boolean} true if the signature is here, false otherwise.
                 */
                isSignature: function(askedIndex, expectedSignature) {
                    var currentIndex = this.reader.index;
                    this.reader.setIndex(askedIndex);
                    var signature = this.reader.readString(4);
                    var result = signature === expectedSignature;
                    this.reader.setIndex(currentIndex);
                    return result;
                },
                /**
                 * Read the end of the central directory.
                 */
                readBlockEndOfCentral: function() {
                    this.diskNumber = this.reader.readInt(2);
                    this.diskWithCentralDirStart = this.reader.readInt(2);
                    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
                    this.centralDirRecords = this.reader.readInt(2);
                    this.centralDirSize = this.reader.readInt(4);
                    this.centralDirOffset = this.reader.readInt(4);

                    this.zipCommentLength = this.reader.readInt(2);
                    // warning : the encoding depends of the system locale
                    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
                    // On a windows machine, this field is encoded with the localized windows code page.
                    var zipComment = this.reader.readData(this.zipCommentLength);
                    var decodeParamType = support.uint8array ? "uint8array" : "array";
                    // To get consistent behavior with the generation part, we will assume that
                    // this is utf8 encoded unless specified otherwise.
                    var decodeContent = utils.transformTo(decodeParamType, zipComment);
                    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
                },
                /**
                 * Read the end of the Zip 64 central directory.
                 * Not merged with the method readEndOfCentral :
                 * The end of central can coexist with its Zip64 brother,
                 * I don't want to read the wrong number of bytes !
                 */
                readBlockZip64EndOfCentral: function() {
                    this.zip64EndOfCentralSize = this.reader.readInt(8);
                    this.reader.skip(4);
                    // this.versionMadeBy = this.reader.readString(2);
                    // this.versionNeeded = this.reader.readInt(2);
                    this.diskNumber = this.reader.readInt(4);
                    this.diskWithCentralDirStart = this.reader.readInt(4);
                    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
                    this.centralDirRecords = this.reader.readInt(8);
                    this.centralDirSize = this.reader.readInt(8);
                    this.centralDirOffset = this.reader.readInt(8);

                    this.zip64ExtensibleData = {};
                    var extraDataSize = this.zip64EndOfCentralSize - 44,
                        index = 0,
                        extraFieldId,
                        extraFieldLength,
                        extraFieldValue;
                    while (index < extraDataSize) {
                        extraFieldId = this.reader.readInt(2);
                        extraFieldLength = this.reader.readInt(4);
                        extraFieldValue = this.reader.readData(extraFieldLength);
                        this.zip64ExtensibleData[extraFieldId] = {
                            id: extraFieldId,
                            length: extraFieldLength,
                            value: extraFieldValue
                        };
                    }
                },
                /**
                 * Read the end of the Zip 64 central directory locator.
                 */
                readBlockZip64EndOfCentralLocator: function() {
                    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
                    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
                    this.disksCount = this.reader.readInt(4);
                    if (this.disksCount > 1) {
                        throw new Error("Multi-volumes zip are not supported");
                    }
                },
                /**
                 * Read the local files, based on the offset read in the central part.
                 */
                readLocalFiles: function() {
                    var i, file;
                    for (i = 0; i < this.files.length; i++) {
                        file = this.files[i];
                        this.reader.setIndex(file.localHeaderOffset);
                        this.checkSignature(sig.LOCAL_FILE_HEADER);
                        file.readLocalPart(this.reader);
                        file.handleUTF8();
                        file.processAttributes();
                    }
                },
                /**
                 * Read the central directory.
                 */
                readCentralDir: function() {
                    var file;

                    this.reader.setIndex(this.centralDirOffset);
                    while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
                        file = new ZipEntry({
                            zip64: this.zip64
                        }, this.loadOptions);
                        file.readCentralPart(this.reader);
                        this.files.push(file);
                    }

                    if (this.centralDirRecords !== this.files.length) {
                        if (this.centralDirRecords !== 0 && this.files.length === 0) {
                            // We expected some records but couldn't find ANY.
                            // This is really suspicious, as if something went wrong.
                            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                        } else {
                            // We found some records but not all.
                            // Something is wrong but we got something for the user: no error here.
                            // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
                        }
                    }
                },
                /**
                 * Read the end of central directory.
                 */
                readEndOfCentral: function() {
                    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
                    if (offset < 0) {
                        // Check if the content is a truncated zip or complete garbage.
                        // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
                        // extractible zip for example) but it can give a good hint.
                        // If an ajax request was used without responseType, we will also
                        // get unreadable data.
                        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

                        if (isGarbage) {
                            throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                        } else {
                            throw new Error("Corrupted zip: can't find end of central directory");
                        }

                    }
                    this.reader.setIndex(offset);
                    var endOfCentralDirOffset = offset;
                    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
                    this.readBlockEndOfCentral();


                    /* extract from the zip spec :
                        4)  If one of the fields in the end of central directory
                            record is too small to hold required data, the field
                            should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                            ZIP64 format record should be created.
                        5)  The end of central directory record and the
                            Zip64 end of central directory locator record must
                            reside on the same disk when splitting or spanning
                            an archive.
                     */
                    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
                        this.zip64 = true;

                        /*
                        Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
                        the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
                        all numbers as 64-bit double precision IEEE 754 floating point numbers.
                        So, we have 53bits for integers and bitwise operations treat everything as 32bits.
                        see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
                        and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
                        */

                        // should look for a zip64 EOCD locator
                        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                        if (offset < 0) {
                            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                        }
                        this.reader.setIndex(offset);
                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                        this.readBlockZip64EndOfCentralLocator();

                        // now the zip64 EOCD record
                        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                            // console.warn("ZIP64 end of central directory not where expected.");
                            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                            }
                        }
                        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                        this.readBlockZip64EndOfCentral();
                    }

                    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
                    if (this.zip64) {
                        expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
                        expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
                    }

                    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

                    if (extraBytes > 0) {
                        // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
                        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                            // The offsets seem wrong, but we have something at the specified offset.
                            // So… we keep it.
                        } else {
                            // the offset is wrong, update the "zero" of the reader
                            // this happens if data has been prepended (crx files for example)
                            this.reader.zero = extraBytes;
                        }
                    } else if (extraBytes < 0) {
                        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
                    }
                },
                prepareReader: function(data) {
                    this.reader = readerFor(data);
                },
                /**
                 * Read a zip file and create ZipEntries.
                 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
                 */
                load: function(data) {
                    this.prepareReader(data);
                    this.readEndOfCentral();
                    this.readCentralDir();
                    this.readLocalFiles();
                }
            };
            // }}} end of ZipEntries
            module.exports = ZipEntries;

        }, {
            "./reader/readerFor": 22,
            "./signature": 23,
            "./support": 30,
            "./utf8": 31,
            "./utils": 32,
            "./zipEntry": 34
        }],
        34: [function(require, module, exports) {
            'use strict';
            var readerFor = require('./reader/readerFor');
            var utils = require('./utils');
            var CompressedObject = require('./compressedObject');
            var crc32fn = require('./crc32');
            var utf8 = require('./utf8');
            var compressions = require('./compressions');
            var support = require('./support');

            var MADE_BY_DOS = 0x00;
            var MADE_BY_UNIX = 0x03;

            /**
             * Find a compression registered in JSZip.
             * @param {string} compressionMethod the method magic to find.
             * @return {Object|null} the JSZip compression object, null if none found.
             */
            var findCompression = function(compressionMethod) {
                for (var method in compressions) {
                    if (!compressions.hasOwnProperty(method)) {
                        continue;
                    }
                    if (compressions[method].magic === compressionMethod) {
                        return compressions[method];
                    }
                }
                return null;
            };

            // class ZipEntry {{{
            /**
             * An entry in the zip file.
             * @constructor
             * @param {Object} options Options of the current file.
             * @param {Object} loadOptions Options for loading the stream.
             */
            function ZipEntry(options, loadOptions) {
                this.options = options;
                this.loadOptions = loadOptions;
            }
            ZipEntry.prototype = {
                /**
                 * say if the file is encrypted.
                 * @return {boolean} true if the file is encrypted, false otherwise.
                 */
                isEncrypted: function() {
                    // bit 1 is set
                    return (this.bitFlag & 0x0001) === 0x0001;
                },
                /**
                 * say if the file has utf-8 filename/comment.
                 * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
                 */
                useUTF8: function() {
                    // bit 11 is set
                    return (this.bitFlag & 0x0800) === 0x0800;
                },
                /**
                 * Read the local part of a zip file and add the info in this object.
                 * @param {DataReader} reader the reader to use.
                 */
                readLocalPart: function(reader) {
                    var compression, localExtraFieldsLength;

                    // we already know everything from the central dir !
                    // If the central dir data are false, we are doomed.
                    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
                    // The less data we get here, the more reliable this should be.
                    // Let's skip the whole header and dash to the data !
                    reader.skip(22);
                    // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
                    // Strangely, the filename here is OK.
                    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
                    // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
                    // Search "unzip mismatching "local" filename continuing with "central" filename version" on
                    // the internet.
                    //
                    // I think I see the logic here : the central directory is used to display
                    // content and the local directory is used to extract the files. Mixing / and \
                    // may be used to display \ to windows users and use / when extracting the files.
                    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
                    this.fileNameLength = reader.readInt(2);
                    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
                    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
                    this.fileName = reader.readData(this.fileNameLength);
                    reader.skip(localExtraFieldsLength);

                    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
                        throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
                    }

                    compression = findCompression(this.compressionMethod);
                    if (compression === null) { // no compression found
                        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
                    }
                    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
                },

                /**
                 * Read the central part of a zip file and add the info in this object.
                 * @param {DataReader} reader the reader to use.
                 */
                readCentralPart: function(reader) {
                    this.versionMadeBy = reader.readInt(2);
                    reader.skip(2);
                    // this.versionNeeded = reader.readInt(2);
                    this.bitFlag = reader.readInt(2);
                    this.compressionMethod = reader.readString(2);
                    this.date = reader.readDate();
                    this.crc32 = reader.readInt(4);
                    this.compressedSize = reader.readInt(4);
                    this.uncompressedSize = reader.readInt(4);
                    var fileNameLength = reader.readInt(2);
                    this.extraFieldsLength = reader.readInt(2);
                    this.fileCommentLength = reader.readInt(2);
                    this.diskNumberStart = reader.readInt(2);
                    this.internalFileAttributes = reader.readInt(2);
                    this.externalFileAttributes = reader.readInt(4);
                    this.localHeaderOffset = reader.readInt(4);

                    if (this.isEncrypted()) {
                        throw new Error("Encrypted zip are not supported");
                    }

                    // will be read in the local part, see the comments there
                    reader.skip(fileNameLength);
                    this.readExtraFields(reader);
                    this.parseZIP64ExtraField(reader);
                    this.fileComment = reader.readData(this.fileCommentLength);
                },

                /**
                 * Parse the external file attributes and get the unix/dos permissions.
                 */
                processAttributes: function() {
                    this.unixPermissions = null;
                    this.dosPermissions = null;
                    var madeBy = this.versionMadeBy >> 8;

                    // Check if we have the DOS directory flag set.
                    // We look for it in the DOS and UNIX permissions
                    // but some unknown platform could set it as a compatibility flag.
                    this.dir = this.externalFileAttributes & 0x0010 ? true : false;

                    if (madeBy === MADE_BY_DOS) {
                        // first 6 bits (0 to 5)
                        this.dosPermissions = this.externalFileAttributes & 0x3F;
                    }

                    if (madeBy === MADE_BY_UNIX) {
                        this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
                        // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
                    }

                    // fail safe : if the name ends with a / it probably means a folder
                    if (!this.dir && this.fileNameStr.slice(-1) === '/') {
                        this.dir = true;
                    }
                },

                /**
                 * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
                 * @param {DataReader} reader the reader to use.
                 */
                parseZIP64ExtraField: function(reader) {

                    if (!this.extraFields[0x0001]) {
                        return;
                    }

                    // should be something, preparing the extra reader
                    var extraReader = readerFor(this.extraFields[0x0001].value);

                    // I really hope that these 64bits integer can fit in 32 bits integer, because js
                    // won't let us have more.
                    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
                        this.uncompressedSize = extraReader.readInt(8);
                    }
                    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
                        this.compressedSize = extraReader.readInt(8);
                    }
                    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
                        this.localHeaderOffset = extraReader.readInt(8);
                    }
                    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
                        this.diskNumberStart = extraReader.readInt(4);
                    }
                },
                /**
                 * Read the central part of a zip file and add the info in this object.
                 * @param {DataReader} reader the reader to use.
                 */
                readExtraFields: function(reader) {
                    var end = reader.index + this.extraFieldsLength,
                        extraFieldId,
                        extraFieldLength,
                        extraFieldValue;

                    if (!this.extraFields) {
                        this.extraFields = {};
                    }

                    while (reader.index < end) {
                        extraFieldId = reader.readInt(2);
                        extraFieldLength = reader.readInt(2);
                        extraFieldValue = reader.readData(extraFieldLength);

                        this.extraFields[extraFieldId] = {
                            id: extraFieldId,
                            length: extraFieldLength,
                            value: extraFieldValue
                        };
                    }
                },
                /**
                 * Apply an UTF8 transformation if needed.
                 */
                handleUTF8: function() {
                    var decodeParamType = support.uint8array ? "uint8array" : "array";
                    if (this.useUTF8()) {
                        this.fileNameStr = utf8.utf8decode(this.fileName);
                        this.fileCommentStr = utf8.utf8decode(this.fileComment);
                    } else {
                        var upath = this.findExtraFieldUnicodePath();
                        if (upath !== null) {
                            this.fileNameStr = upath;
                        } else {
                            // ASCII text or unsupported code page
                            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
                        }

                        var ucomment = this.findExtraFieldUnicodeComment();
                        if (ucomment !== null) {
                            this.fileCommentStr = ucomment;
                        } else {
                            // ASCII text or unsupported code page
                            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
                        }
                    }
                },

                /**
                 * Find the unicode path declared in the extra field, if any.
                 * @return {String} the unicode path, null otherwise.
                 */
                findExtraFieldUnicodePath: function() {
                    var upathField = this.extraFields[0x7075];
                    if (upathField) {
                        var extraReader = readerFor(upathField.value);

                        // wrong version
                        if (extraReader.readInt(1) !== 1) {
                            return null;
                        }

                        // the crc of the filename changed, this field is out of date.
                        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                            return null;
                        }

                        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
                    }
                    return null;
                },

                /**
                 * Find the unicode comment declared in the extra field, if any.
                 * @return {String} the unicode comment, null otherwise.
                 */
                findExtraFieldUnicodeComment: function() {
                    var ucommentField = this.extraFields[0x6375];
                    if (ucommentField) {
                        var extraReader = readerFor(ucommentField.value);

                        // wrong version
                        if (extraReader.readInt(1) !== 1) {
                            return null;
                        }

                        // the crc of the comment changed, this field is out of date.
                        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                            return null;
                        }

                        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
                    }
                    return null;
                }
            };
            module.exports = ZipEntry;

        }, {
            "./compressedObject": 2,
            "./compressions": 3,
            "./crc32": 4,
            "./reader/readerFor": 22,
            "./support": 30,
            "./utf8": 31,
            "./utils": 32
        }],
        35: [function(require, module, exports) {
            'use strict';

            var StreamHelper = require('./stream/StreamHelper');
            var DataWorker = require('./stream/DataWorker');
            var utf8 = require('./utf8');
            var CompressedObject = require('./compressedObject');
            var GenericWorker = require('./stream/GenericWorker');

            /**
             * A simple object representing a file in the zip file.
             * @constructor
             * @param {string} name the name of the file
             * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
             * @param {Object} options the options of the file
             */
            var ZipObject = function(name, data, options) {
                this.name = name;
                this.dir = options.dir;
                this.date = options.date;
                this.comment = options.comment;
                this.unixPermissions = options.unixPermissions;
                this.dosPermissions = options.dosPermissions;

                this._data = data;
                this._dataBinary = options.binary;
                // keep only the compression
                this.options = {
                    compression: options.compression,
                    compressionOptions: options.compressionOptions
                };
            };

            ZipObject.prototype = {
                /**
                 * Create an internal stream for the content of this object.
                 * @param {String} type the type of each chunk.
                 * @return StreamHelper the stream.
                 */
                internalStream: function(type) {
                    var outputType = type.toLowerCase();
                    var askUnicodeString = outputType === "string" || outputType === "text";
                    if (outputType === "binarystring" || outputType === "text") {
                        outputType = "string";
                    }
                    var result = this._decompressWorker();

                    var isUnicodeString = !this._dataBinary;

                    if (isUnicodeString && !askUnicodeString) {
                        result = result.pipe(new utf8.Utf8EncodeWorker());
                    }
                    if (!isUnicodeString && askUnicodeString) {
                        result = result.pipe(new utf8.Utf8DecodeWorker());
                    }

                    return new StreamHelper(result, outputType, "");
                },

                /**
                 * Prepare the content in the asked type.
                 * @param {String} type the type of the result.
                 * @param {Function} onUpdate a function to call on each internal update.
                 * @return Promise the promise of the result.
                 */
                async: function(type, onUpdate) {
                    return this.internalStream(type).accumulate(onUpdate);
                },

                /**
                 * Prepare the content as a nodejs stream.
                 * @param {String} type the type of each chunk.
                 * @param {Function} onUpdate a function to call on each internal update.
                 * @return Stream the stream.
                 */
                nodeStream: function(type, onUpdate) {
                    return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
                },

                /**
                 * Return a worker for the compressed content.
                 * @private
                 * @param {Object} compression the compression object to use.
                 * @param {Object} compressionOptions the options to use when compressing.
                 * @return Worker the worker.
                 */
                _compressWorker: function(compression, compressionOptions) {
                    if (
                        this._data instanceof CompressedObject &&
                        this._data.compression.magic === compression.magic
                    ) {
                        return this._data.getCompressedWorker();
                    } else {
                        var result = this._decompressWorker();
                        if (!this._dataBinary) {
                            result = result.pipe(new utf8.Utf8EncodeWorker());
                        }
                        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
                    }
                },
                /**
                 * Return a worker for the decompressed content.
                 * @private
                 * @return Worker the worker.
                 */
                _decompressWorker: function() {
                    if (this._data instanceof CompressedObject) {
                        return this._data.getContentWorker();
                    } else if (this._data instanceof GenericWorker) {
                        return this._data;
                    } else {
                        return new DataWorker(this._data);
                    }
                }
            };

            var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
            var removedFn = function() {
                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            };

            for (var i = 0; i < removedMethods.length; i++) {
                ZipObject.prototype[removedMethods[i]] = removedFn;
            }
            module.exports = ZipObject;

        }, {
            "./compressedObject": 2,
            "./stream/DataWorker": 27,
            "./stream/GenericWorker": 28,
            "./stream/StreamHelper": 29,
            "./utf8": 31
        }],
        36: [function(require, module, exports) {
            require('../modules/web.immediate');
            module.exports = require('../modules/_core').setImmediate;
        }, {
            "../modules/_core": 40,
            "../modules/web.immediate": 56
        }],
        37: [function(require, module, exports) {
            module.exports = function(it) {
                if (typeof it != 'function') throw TypeError(it + ' is not a function!');
                return it;
            };
        }, {}],
        38: [function(require, module, exports) {
            var isObject = require('./_is-object');
            module.exports = function(it) {
                if (!isObject(it)) throw TypeError(it + ' is not an object!');
                return it;
            };
        }, {
            "./_is-object": 51
        }],
        39: [function(require, module, exports) {
            var toString = {}.toString;

            module.exports = function(it) {
                return toString.call(it).slice(8, -1);
            };
        }, {}],
        40: [function(require, module, exports) {
            var core = module.exports = {
                version: '2.3.0'
            };
            if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
        }, {}],
        41: [function(require, module, exports) {
            // optional / simple context binding
            var aFunction = require('./_a-function');
            module.exports = function(fn, that, length) {
                aFunction(fn);
                if (that === undefined) return fn;
                switch (length) {
                    case 1:
                        return function(a) {
                            return fn.call(that, a);
                        };
                    case 2:
                        return function(a, b) {
                            return fn.call(that, a, b);
                        };
                    case 3:
                        return function(a, b, c) {
                            return fn.call(that, a, b, c);
                        };
                }
                return function( /* ...args */ ) {
                    return fn.apply(that, arguments);
                };
            };
        }, {
            "./_a-function": 37
        }],
        42: [function(require, module, exports) {
            // Thank's IE8 for his funny defineProperty
            module.exports = !require('./_fails')(function() {
                return Object.defineProperty({}, 'a', {
                    get: function() {
                        return 7;
                    }
                }).a != 7;
            });
        }, {
            "./_fails": 45
        }],
        43: [function(require, module, exports) {
            var isObject = require('./_is-object'),
                document = require('./_global').document
                // in old IE typeof document.createElement is 'object'
                ,
                is = isObject(document) && isObject(document.createElement);
            module.exports = function(it) {
                return is ? document.createElement(it) : {};
            };
        }, {
            "./_global": 46,
            "./_is-object": 51
        }],
        44: [function(require, module, exports) {
            var global = require('./_global'),
                core = require('./_core'),
                ctx = require('./_ctx'),
                hide = require('./_hide'),
                PROTOTYPE = 'prototype';

            var $export = function(type, name, source) {
                var IS_FORCED = type & $export.F,
                    IS_GLOBAL = type & $export.G,
                    IS_STATIC = type & $export.S,
                    IS_PROTO = type & $export.P,
                    IS_BIND = type & $export.B,
                    IS_WRAP = type & $export.W,
                    exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
                    expProto = exports[PROTOTYPE],
                    target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
                    key, own, out;
                if (IS_GLOBAL) source = name;
                for (key in source) {
                    // contains in native
                    own = !IS_FORCED && target && target[key] !== undefined;
                    if (own && key in exports) continue;
                    // export native or passed
                    out = own ? target[key] : source[key];
                    // prevent global pollution for namespaces
                    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
                        // bind timers to global for call from export context
                        :
                        IS_BIND && own ? ctx(out, global)
                        // wrap global constructors for prevent change them in library
                        :
                        IS_WRAP && target[key] == out ? (function(C) {
                            var F = function(a, b, c) {
                                if (this instanceof C) {
                                    switch (arguments.length) {
                                        case 0:
                                            return new C;
                                        case 1:
                                            return new C(a);
                                        case 2:
                                            return new C(a, b);
                                    }
                                    return new C(a, b, c);
                                }
                                return C.apply(this, arguments);
                            };
                            F[PROTOTYPE] = C[PROTOTYPE];
                            return F;
                            // make static versions for prototype methods
                        })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
                    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
                    if (IS_PROTO) {
                        (exports.virtual || (exports.virtual = {}))[key] = out;
                        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
                        if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
                    }
                }
            };
            // type bitmap
            $export.F = 1; // forced
            $export.G = 2; // global
            $export.S = 4; // static
            $export.P = 8; // proto
            $export.B = 16; // bind
            $export.W = 32; // wrap
            $export.U = 64; // safe
            $export.R = 128; // real proto method for `library` 
            module.exports = $export;
        }, {
            "./_core": 40,
            "./_ctx": 41,
            "./_global": 46,
            "./_hide": 47
        }],
        45: [function(require, module, exports) {
            module.exports = function(exec) {
                try {
                    return !!exec();
                } catch (e) {
                    return true;
                }
            };
        }, {}],
        46: [function(require, module, exports) {
            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
            var global = module.exports = typeof window != 'undefined' && window.Math == Math ?
                window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
            if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
        }, {}],
        47: [function(require, module, exports) {
            var dP = require('./_object-dp'),
                createDesc = require('./_property-desc');
            module.exports = require('./_descriptors') ? function(object, key, value) {
                return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
                object[key] = value;
                return object;
            };
        }, {
            "./_descriptors": 42,
            "./_object-dp": 52,
            "./_property-desc": 53
        }],
        48: [function(require, module, exports) {
            module.exports = require('./_global').document && document.documentElement;
        }, {
            "./_global": 46
        }],
        49: [function(require, module, exports) {
            module.exports = !require('./_descriptors') && !require('./_fails')(function() {
                return Object.defineProperty(require('./_dom-create')('div'), 'a', {
                    get: function() {
                        return 7;
                    }
                }).a != 7;
            });
        }, {
            "./_descriptors": 42,
            "./_dom-create": 43,
            "./_fails": 45
        }],
        50: [function(require, module, exports) {
            // fast apply, http://jsperf.lnkit.com/fast-apply/5
            module.exports = function(fn, args, that) {
                var un = that === undefined;
                switch (args.length) {
                    case 0:
                        return un ? fn() :
                            fn.call(that);
                    case 1:
                        return un ? fn(args[0]) :
                            fn.call(that, args[0]);
                    case 2:
                        return un ? fn(args[0], args[1]) :
                            fn.call(that, args[0], args[1]);
                    case 3:
                        return un ? fn(args[0], args[1], args[2]) :
                            fn.call(that, args[0], args[1], args[2]);
                    case 4:
                        return un ? fn(args[0], args[1], args[2], args[3]) :
                            fn.call(that, args[0], args[1], args[2], args[3]);
                }
                return fn.apply(that, args);
            };
        }, {}],
        51: [function(require, module, exports) {
            module.exports = function(it) {
                return typeof it === 'object' ? it !== null : typeof it === 'function';
            };
        }, {}],
        52: [function(require, module, exports) {
            var anObject = require('./_an-object'),
                IE8_DOM_DEFINE = require('./_ie8-dom-define'),
                toPrimitive = require('./_to-primitive'),
                dP = Object.defineProperty;

            exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPrimitive(P, true);
                anObject(Attributes);
                if (IE8_DOM_DEFINE) try {
                    return dP(O, P, Attributes);
                } catch (e) { /* empty */ }
                if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
                if ('value' in Attributes) O[P] = Attributes.value;
                return O;
            };
        }, {
            "./_an-object": 38,
            "./_descriptors": 42,
            "./_ie8-dom-define": 49,
            "./_to-primitive": 55
        }],
        53: [function(require, module, exports) {
            module.exports = function(bitmap, value) {
                return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value: value
                };
            };
        }, {}],
        54: [function(require, module, exports) {
            var ctx = require('./_ctx'),
                invoke = require('./_invoke'),
                html = require('./_html'),
                cel = require('./_dom-create'),
                global = require('./_global'),
                process = global.process,
                setTask = global.setImmediate,
                clearTask = global.clearImmediate,
                MessageChannel = global.MessageChannel,
                counter = 0,
                queue = {},
                ONREADYSTATECHANGE = 'onreadystatechange',
                defer, channel, port;
            var run = function() {
                var id = +this;
                if (queue.hasOwnProperty(id)) {
                    var fn = queue[id];
                    delete queue[id];
                    fn();
                }
            };
            var listener = function(event) {
                run.call(event.data);
            };
            // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
            if (!setTask || !clearTask) {
                setTask = function setImmediate(fn) {
                    var args = [],
                        i = 1;
                    while (arguments.length > i) args.push(arguments[i++]);
                    queue[++counter] = function() {
                        invoke(typeof fn == 'function' ? fn : Function(fn), args);
                    };
                    defer(counter);
                    return counter;
                };
                clearTask = function clearImmediate(id) {
                    delete queue[id];
                };
                // Node.js 0.8-
                if (require('./_cof')(process) == 'process') {
                    defer = function(id) {
                        process.nextTick(ctx(run, id, 1));
                    };
                    // Browsers with MessageChannel, includes WebWorkers
                } else if (MessageChannel) {
                    channel = new MessageChannel;
                    port = channel.port2;
                    channel.port1.onmessage = listener;
                    defer = ctx(port.postMessage, port, 1);
                    // Browsers with postMessage, skip WebWorkers
                    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
                } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
                    defer = function(id) {
                        global.postMessage(id + '', '*');
                    };
                    global.addEventListener('message', listener, false);
                    // IE8-
                } else if (ONREADYSTATECHANGE in cel('script')) {
                    defer = function(id) {
                        html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
                            html.removeChild(this);
                            run.call(id);
                        };
                    };
                    // Rest old browsers
                } else {
                    defer = function(id) {
                        setTimeout(ctx(run, id, 1), 0);
                    };
                }
            }
            module.exports = {
                set: setTask,
                clear: clearTask
            };
        }, {
            "./_cof": 39,
            "./_ctx": 41,
            "./_dom-create": 43,
            "./_global": 46,
            "./_html": 48,
            "./_invoke": 50
        }],
        55: [function(require, module, exports) {
            // 7.1.1 ToPrimitive(input [, PreferredType])
            var isObject = require('./_is-object');
            // instead of the ES6 spec version, we didn't implement @@toPrimitive case
            // and the second argument - flag - preferred type is a string
            module.exports = function(it, S) {
                if (!isObject(it)) return it;
                var fn, val;
                if (S && typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
                if (typeof(fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
                if (!S && typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
                throw TypeError("Can't convert object to primitive value");
            };
        }, {
            "./_is-object": 51
        }],
        56: [function(require, module, exports) {
            var $export = require('./_export'),
                $task = require('./_task');
            $export($export.G + $export.B, {
                setImmediate: $task.set,
                clearImmediate: $task.clear
            });
        }, {
            "./_export": 44,
            "./_task": 54
        }],
        57: [function(require, module, exports) {
            (function(global) {
                'use strict';
                var Mutation = global.MutationObserver || global.WebKitMutationObserver;

                var scheduleDrain;

                {
                    if (Mutation) {
                        var called = 0;
                        var observer = new Mutation(nextTick);
                        var element = global.document.createTextNode('');
                        observer.observe(element, {
                            characterData: true
                        });
                        scheduleDrain = function() {
                            element.data = (called = ++called % 2);
                        };
                    } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                        var channel = new global.MessageChannel();
                        channel.port1.onmessage = nextTick;
                        scheduleDrain = function() {
                            channel.port2.postMessage(0);
                        };
                    } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                        scheduleDrain = function() {

                            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                            var scriptEl = global.document.createElement('script');
                            scriptEl.onreadystatechange = function() {
                                nextTick();

                                scriptEl.onreadystatechange = null;
                                scriptEl.parentNode.removeChild(scriptEl);
                                scriptEl = null;
                            };
                            global.document.documentElement.appendChild(scriptEl);
                        };
                    } else {
                        scheduleDrain = function() {
                            setTimeout(nextTick, 0);
                        };
                    }
                }

                var draining;
                var queue = [];
                //named nextTick for less confusing stack traces
                function nextTick() {
                    draining = true;
                    var i, oldQueue;
                    var len = queue.length;
                    while (len) {
                        oldQueue = queue;
                        queue = [];
                        i = -1;
                        while (++i < len) {
                            oldQueue[i]();
                        }
                        len = queue.length;
                    }
                    draining = false;
                }

                module.exports = immediate;

                function immediate(task) {
                    if (queue.push(task) === 1 && !draining) {
                        scheduleDrain();
                    }
                }

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        58: [function(require, module, exports) {
            'use strict';
            var immediate = require('immediate');

            /* istanbul ignore next */
            function INTERNAL() {}

            var handlers = {};

            var REJECTED = ['REJECTED'];
            var FULFILLED = ['FULFILLED'];
            var PENDING = ['PENDING'];

            module.exports = Promise;

            function Promise(resolver) {
                if (typeof resolver !== 'function') {
                    throw new TypeError('resolver must be a function');
                }
                this.state = PENDING;
                this.queue = [];
                this.outcome = void 0;
                if (resolver !== INTERNAL) {
                    safelyResolveThenable(this, resolver);
                }
            }

            Promise.prototype["catch"] = function(onRejected) {
                return this.then(null, onRejected);
            };
            Promise.prototype.then = function(onFulfilled, onRejected) {
                if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
                    typeof onRejected !== 'function' && this.state === REJECTED) {
                    return this;
                }
                var promise = new this.constructor(INTERNAL);
                if (this.state !== PENDING) {
                    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                    unwrap(promise, resolver, this.outcome);
                } else {
                    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
                }

                return promise;
            };

            function QueueItem(promise, onFulfilled, onRejected) {
                this.promise = promise;
                if (typeof onFulfilled === 'function') {
                    this.onFulfilled = onFulfilled;
                    this.callFulfilled = this.otherCallFulfilled;
                }
                if (typeof onRejected === 'function') {
                    this.onRejected = onRejected;
                    this.callRejected = this.otherCallRejected;
                }
            }
            QueueItem.prototype.callFulfilled = function(value) {
                handlers.resolve(this.promise, value);
            };
            QueueItem.prototype.otherCallFulfilled = function(value) {
                unwrap(this.promise, this.onFulfilled, value);
            };
            QueueItem.prototype.callRejected = function(value) {
                handlers.reject(this.promise, value);
            };
            QueueItem.prototype.otherCallRejected = function(value) {
                unwrap(this.promise, this.onRejected, value);
            };

            function unwrap(promise, func, value) {
                immediate(function() {
                    var returnValue;
                    try {
                        returnValue = func(value);
                    } catch (e) {
                        return handlers.reject(promise, e);
                    }
                    if (returnValue === promise) {
                        handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
                    } else {
                        handlers.resolve(promise, returnValue);
                    }
                });
            }

            handlers.resolve = function(self, value) {
                var result = tryCatch(getThen, value);
                if (result.status === 'error') {
                    return handlers.reject(self, result.value);
                }
                var thenable = result.value;

                if (thenable) {
                    safelyResolveThenable(self, thenable);
                } else {
                    self.state = FULFILLED;
                    self.outcome = value;
                    var i = -1;
                    var len = self.queue.length;
                    while (++i < len) {
                        self.queue[i].callFulfilled(value);
                    }
                }
                return self;
            };
            handlers.reject = function(self, error) {
                self.state = REJECTED;
                self.outcome = error;
                var i = -1;
                var len = self.queue.length;
                while (++i < len) {
                    self.queue[i].callRejected(error);
                }
                return self;
            };

            function getThen(obj) {
                // Make sure we only access the accessor once as required by the spec
                var then = obj && obj.then;
                if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
                    return function appyThen() {
                        then.apply(obj, arguments);
                    };
                }
            }

            function safelyResolveThenable(self, thenable) {
                // Either fulfill, reject or reject with error
                var called = false;

                function onError(value) {
                    if (called) {
                        return;
                    }
                    called = true;
                    handlers.reject(self, value);
                }

                function onSuccess(value) {
                    if (called) {
                        return;
                    }
                    called = true;
                    handlers.resolve(self, value);
                }

                function tryToUnwrap() {
                    thenable(onSuccess, onError);
                }

                var result = tryCatch(tryToUnwrap);
                if (result.status === 'error') {
                    onError(result.value);
                }
            }

            function tryCatch(func, value) {
                var out = {};
                try {
                    out.value = func(value);
                    out.status = 'success';
                } catch (e) {
                    out.status = 'error';
                    out.value = e;
                }
                return out;
            }

            Promise.resolve = resolve;

            function resolve(value) {
                if (value instanceof this) {
                    return value;
                }
                return handlers.resolve(new this(INTERNAL), value);
            }

            Promise.reject = reject;

            function reject(reason) {
                var promise = new this(INTERNAL);
                return handlers.reject(promise, reason);
            }

            Promise.all = all;

            function all(iterable) {
                var self = this;
                if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                    return this.reject(new TypeError('must be an array'));
                }

                var len = iterable.length;
                var called = false;
                if (!len) {
                    return this.resolve([]);
                }

                var values = new Array(len);
                var resolved = 0;
                var i = -1;
                var promise = new this(INTERNAL);

                while (++i < len) {
                    allResolver(iterable[i], i);
                }
                return promise;

                function allResolver(value, i) {
                    self.resolve(value).then(resolveFromAll, function(error) {
                        if (!called) {
                            called = true;
                            handlers.reject(promise, error);
                        }
                    });

                    function resolveFromAll(outValue) {
                        values[i] = outValue;
                        if (++resolved === len && !called) {
                            called = true;
                            handlers.resolve(promise, values);
                        }
                    }
                }
            }

            Promise.race = race;

            function race(iterable) {
                var self = this;
                if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                    return this.reject(new TypeError('must be an array'));
                }

                var len = iterable.length;
                var called = false;
                if (!len) {
                    return this.resolve([]);
                }

                var i = -1;
                var promise = new this(INTERNAL);

                while (++i < len) {
                    resolver(iterable[i]);
                }
                return promise;

                function resolver(value) {
                    self.resolve(value).then(function(response) {
                        if (!called) {
                            called = true;
                            handlers.resolve(promise, response);
                        }
                    }, function(error) {
                        if (!called) {
                            called = true;
                            handlers.reject(promise, error);
                        }
                    });
                }
            }

        }, {
            "immediate": 57
        }],
        59: [function(require, module, exports) {
            // Top level file is just a mixin of submodules & constants
            'use strict';

            var assign = require('./lib/utils/common').assign;

            var deflate = require('./lib/deflate');
            var inflate = require('./lib/inflate');
            var constants = require('./lib/zlib/constants');

            var pako = {};

            assign(pako, deflate, inflate, constants);

            module.exports = pako;

        }, {
            "./lib/deflate": 60,
            "./lib/inflate": 61,
            "./lib/utils/common": 62,
            "./lib/zlib/constants": 65
        }],
        60: [function(require, module, exports) {
            'use strict';


            var zlib_deflate = require('./zlib/deflate');
            var utils = require('./utils/common');
            var strings = require('./utils/strings');
            var msg = require('./zlib/messages');
            var ZStream = require('./zlib/zstream');

            var toString = Object.prototype.toString;

            /* Public constants ==========================================================*/
            /* ===========================================================================*/

            var Z_NO_FLUSH = 0;
            var Z_FINISH = 4;

            var Z_OK = 0;
            var Z_STREAM_END = 1;
            var Z_SYNC_FLUSH = 2;

            var Z_DEFAULT_COMPRESSION = -1;

            var Z_DEFAULT_STRATEGY = 0;

            var Z_DEFLATED = 8;

            /* ===========================================================================*/


            /**
             * class Deflate
             *
             * Generic JS-style wrapper for zlib calls. If you don't need
             * streaming behaviour - use more simple functions: [[deflate]],
             * [[deflateRaw]] and [[gzip]].
             **/

            /* internal
             * Deflate.chunks -> Array
             *
             * Chunks of output data, if [[Deflate#onData]] not overriden.
             **/

            /**
             * Deflate.result -> Uint8Array|Array
             *
             * Compressed result, generated by default [[Deflate#onData]]
             * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
             * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
             * push a chunk with explicit flush (call [[Deflate#push]] with
             * `Z_SYNC_FLUSH` param).
             **/

            /**
             * Deflate.err -> Number
             *
             * Error code after deflate finished. 0 (Z_OK) on success.
             * You will not need it in real life, because deflate errors
             * are possible only on wrong options or bad `onData` / `onEnd`
             * custom handlers.
             **/

            /**
             * Deflate.msg -> String
             *
             * Error message, if [[Deflate.err]] != 0
             **/


            /**
             * new Deflate(options)
             * - options (Object): zlib deflate options.
             *
             * Creates new deflator instance with specified params. Throws exception
             * on bad params. Supported options:
             *
             * - `level`
             * - `windowBits`
             * - `memLevel`
             * - `strategy`
             * - `dictionary`
             *
             * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
             * for more information on these.
             *
             * Additional options, for internal needs:
             *
             * - `chunkSize` - size of generated data chunks (16K by default)
             * - `raw` (Boolean) - do raw deflate
             * - `gzip` (Boolean) - create gzip wrapper
             * - `to` (String) - if equal to 'string', then result will be "binary string"
             *    (each char code [0..255])
             * - `header` (Object) - custom header for gzip
             *   - `text` (Boolean) - true if compressed data believed to be text
             *   - `time` (Number) - modification time, unix timestamp
             *   - `os` (Number) - operation system code
             *   - `extra` (Array) - array of bytes with extra data (max 65536)
             *   - `name` (String) - file name (binary string)
             *   - `comment` (String) - comment (binary string)
             *   - `hcrc` (Boolean) - true if header crc should be added
             *
             * ##### Example:
             *
             * ```javascript
             * var pako = require('pako')
             *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
             *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
             *
             * var deflate = new pako.Deflate({ level: 3});
             *
             * deflate.push(chunk1, false);
             * deflate.push(chunk2, true);  // true -> last chunk
             *
             * if (deflate.err) { throw new Error(deflate.err); }
             *
             * console.log(deflate.result);
             * ```
             **/
            function Deflate(options) {
                if (!(this instanceof Deflate)) return new Deflate(options);

                this.options = utils.assign({
                    level: Z_DEFAULT_COMPRESSION,
                    method: Z_DEFLATED,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: Z_DEFAULT_STRATEGY,
                    to: ''
                }, options || {});

                var opt = this.options;

                if (opt.raw && (opt.windowBits > 0)) {
                    opt.windowBits = -opt.windowBits;
                } else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
                    opt.windowBits += 16;
                }

                this.err = 0; // error code, if happens (0 = Z_OK)
                this.msg = ''; // error message
                this.ended = false; // used to avoid multiple onEnd() calls
                this.chunks = []; // chunks of compressed data

                this.strm = new ZStream();
                this.strm.avail_out = 0;

                var status = zlib_deflate.deflateInit2(
                    this.strm,
                    opt.level,
                    opt.method,
                    opt.windowBits,
                    opt.memLevel,
                    opt.strategy
                );

                if (status !== Z_OK) {
                    throw new Error(msg[status]);
                }

                if (opt.header) {
                    zlib_deflate.deflateSetHeader(this.strm, opt.header);
                }

                if (opt.dictionary) {
                    var dict;
                    // Convert data if needed
                    if (typeof opt.dictionary === 'string') {
                        // If we need to compress text, change encoding to utf8.
                        dict = strings.string2buf(opt.dictionary);
                    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                        dict = new Uint8Array(opt.dictionary);
                    } else {
                        dict = opt.dictionary;
                    }

                    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

                    if (status !== Z_OK) {
                        throw new Error(msg[status]);
                    }

                    this._dict_set = true;
                }
            }

            /**
             * Deflate#push(data[, mode]) -> Boolean
             * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
             *   converted to utf8 byte sequence.
             * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
             *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
             *
             * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
             * new compressed chunks. Returns `true` on success. The last data block must have
             * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
             * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
             * can use mode Z_SYNC_FLUSH, keeping the compression context.
             *
             * On fail call [[Deflate#onEnd]] with error code and return false.
             *
             * We strongly recommend to use `Uint8Array` on input for best speed (output
             * array format is detected automatically). Also, don't skip last param and always
             * use the same type in your code (boolean or number). That will improve JS speed.
             *
             * For regular `Array`-s make sure all elements are [0..255].
             *
             * ##### Example
             *
             * ```javascript
             * push(chunk, false); // push one of data chunks
             * ...
             * push(chunk, true);  // push last chunk
             * ```
             **/
            Deflate.prototype.push = function(data, mode) {
                var strm = this.strm;
                var chunkSize = this.options.chunkSize;
                var status, _mode;

                if (this.ended) {
                    return false;
                }

                _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

                // Convert data if needed
                if (typeof data === 'string') {
                    // If we need to compress text, change encoding to utf8.
                    strm.input = strings.string2buf(data);
                } else if (toString.call(data) === '[object ArrayBuffer]') {
                    strm.input = new Uint8Array(data);
                } else {
                    strm.input = data;
                }

                strm.next_in = 0;
                strm.avail_in = strm.input.length;

                do {
                    if (strm.avail_out === 0) {
                        strm.output = new utils.Buf8(chunkSize);
                        strm.next_out = 0;
                        strm.avail_out = chunkSize;
                    }
                    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

                    if (status !== Z_STREAM_END && status !== Z_OK) {
                        this.onEnd(status);
                        this.ended = true;
                        return false;
                    }
                    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
                        if (this.options.to === 'string') {
                            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                        } else {
                            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                        }
                    }
                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

                // Finalize on the last chunk.
                if (_mode === Z_FINISH) {
                    status = zlib_deflate.deflateEnd(this.strm);
                    this.onEnd(status);
                    this.ended = true;
                    return status === Z_OK;
                }

                // callback interim results if Z_SYNC_FLUSH.
                if (_mode === Z_SYNC_FLUSH) {
                    this.onEnd(Z_OK);
                    strm.avail_out = 0;
                    return true;
                }

                return true;
            };


            /**
             * Deflate#onData(chunk) -> Void
             * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
             *   on js engine support. When string output requested, each chunk
             *   will be string.
             *
             * By default, stores data blocks in `chunks[]` property and glue
             * those in `onEnd`. Override this handler, if you need another behaviour.
             **/
            Deflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
            };


            /**
             * Deflate#onEnd(status) -> Void
             * - status (Number): deflate status. 0 (Z_OK) on success,
             *   other if not.
             *
             * Called once after you tell deflate that the input stream is
             * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
             * or if an error happened. By default - join collected chunks,
             * free memory and fill `results` / `err` properties.
             **/
            Deflate.prototype.onEnd = function(status) {
                // On success - join
                if (status === Z_OK) {
                    if (this.options.to === 'string') {
                        this.result = this.chunks.join('');
                    } else {
                        this.result = utils.flattenChunks(this.chunks);
                    }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
            };


            /**
             * deflate(data[, options]) -> Uint8Array|Array|String
             * - data (Uint8Array|Array|String): input data to compress.
             * - options (Object): zlib deflate options.
             *
             * Compress `data` with deflate algorithm and `options`.
             *
             * Supported options are:
             *
             * - level
             * - windowBits
             * - memLevel
             * - strategy
             * - dictionary
             *
             * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
             * for more information on these.
             *
             * Sugar (options):
             *
             * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
             *   negative windowBits implicitly.
             * - `to` (String) - if equal to 'string', then result will be "binary string"
             *    (each char code [0..255])
             *
             * ##### Example:
             *
             * ```javascript
             * var pako = require('pako')
             *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
             *
             * console.log(pako.deflate(data));
             * ```
             **/
            function deflate(input, options) {
                var deflator = new Deflate(options);

                deflator.push(input, true);

                // That will never happens, if you don't cheat with options :)
                if (deflator.err) {
                    throw deflator.msg || msg[deflator.err];
                }

                return deflator.result;
            }


            /**
             * deflateRaw(data[, options]) -> Uint8Array|Array|String
             * - data (Uint8Array|Array|String): input data to compress.
             * - options (Object): zlib deflate options.
             *
             * The same as [[deflate]], but creates raw data, without wrapper
             * (header and adler32 crc).
             **/
            function deflateRaw(input, options) {
                options = options || {};
                options.raw = true;
                return deflate(input, options);
            }


            /**
             * gzip(data[, options]) -> Uint8Array|Array|String
             * - data (Uint8Array|Array|String): input data to compress.
             * - options (Object): zlib deflate options.
             *
             * The same as [[deflate]], but create gzip wrapper instead of
             * deflate one.
             **/
            function gzip(input, options) {
                options = options || {};
                options.gzip = true;
                return deflate(input, options);
            }


            exports.Deflate = Deflate;
            exports.deflate = deflate;
            exports.deflateRaw = deflateRaw;
            exports.gzip = gzip;

        }, {
            "./utils/common": 62,
            "./utils/strings": 63,
            "./zlib/deflate": 67,
            "./zlib/messages": 72,
            "./zlib/zstream": 74
        }],
        61: [function(require, module, exports) {
            'use strict';


            var zlib_inflate = require('./zlib/inflate');
            var utils = require('./utils/common');
            var strings = require('./utils/strings');
            var c = require('./zlib/constants');
            var msg = require('./zlib/messages');
            var ZStream = require('./zlib/zstream');
            var GZheader = require('./zlib/gzheader');

            var toString = Object.prototype.toString;

            /**
             * class Inflate
             *
             * Generic JS-style wrapper for zlib calls. If you don't need
             * streaming behaviour - use more simple functions: [[inflate]]
             * and [[inflateRaw]].
             **/

            /* internal
             * inflate.chunks -> Array
             *
             * Chunks of output data, if [[Inflate#onData]] not overriden.
             **/

            /**
             * Inflate.result -> Uint8Array|Array|String
             *
             * Uncompressed result, generated by default [[Inflate#onData]]
             * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
             * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
             * push a chunk with explicit flush (call [[Inflate#push]] with
             * `Z_SYNC_FLUSH` param).
             **/

            /**
             * Inflate.err -> Number
             *
             * Error code after inflate finished. 0 (Z_OK) on success.
             * Should be checked if broken data possible.
             **/

            /**
             * Inflate.msg -> String
             *
             * Error message, if [[Inflate.err]] != 0
             **/


            /**
             * new Inflate(options)
             * - options (Object): zlib inflate options.
             *
             * Creates new inflator instance with specified params. Throws exception
             * on bad params. Supported options:
             *
             * - `windowBits`
             * - `dictionary`
             *
             * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
             * for more information on these.
             *
             * Additional options, for internal needs:
             *
             * - `chunkSize` - size of generated data chunks (16K by default)
             * - `raw` (Boolean) - do raw inflate
             * - `to` (String) - if equal to 'string', then result will be converted
             *   from utf8 to utf16 (javascript) string. When string output requested,
             *   chunk length can differ from `chunkSize`, depending on content.
             *
             * By default, when no options set, autodetect deflate/gzip data format via
             * wrapper header.
             *
             * ##### Example:
             *
             * ```javascript
             * var pako = require('pako')
             *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
             *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
             *
             * var inflate = new pako.Inflate({ level: 3});
             *
             * inflate.push(chunk1, false);
             * inflate.push(chunk2, true);  // true -> last chunk
             *
             * if (inflate.err) { throw new Error(inflate.err); }
             *
             * console.log(inflate.result);
             * ```
             **/
            function Inflate(options) {
                if (!(this instanceof Inflate)) return new Inflate(options);

                this.options = utils.assign({
                    chunkSize: 16384,
                    windowBits: 0,
                    to: ''
                }, options || {});

                var opt = this.options;

                // Force window size for `raw` data, if not set directly,
                // because we have no header for autodetect.
                if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
                    opt.windowBits = -opt.windowBits;
                    if (opt.windowBits === 0) {
                        opt.windowBits = -15;
                    }
                }

                // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
                if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
                    !(options && options.windowBits)) {
                    opt.windowBits += 32;
                }

                // Gzip header has no info about windows size, we can do autodetect only
                // for deflate. So, if window size not set, force it to max when gzip possible
                if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
                    // bit 3 (16) -> gzipped data
                    // bit 4 (32) -> autodetect gzip/deflate
                    if ((opt.windowBits & 15) === 0) {
                        opt.windowBits |= 15;
                    }
                }

                this.err = 0; // error code, if happens (0 = Z_OK)
                this.msg = ''; // error message
                this.ended = false; // used to avoid multiple onEnd() calls
                this.chunks = []; // chunks of compressed data

                this.strm = new ZStream();
                this.strm.avail_out = 0;

                var status = zlib_inflate.inflateInit2(
                    this.strm,
                    opt.windowBits
                );

                if (status !== c.Z_OK) {
                    throw new Error(msg[status]);
                }

                this.header = new GZheader();

                zlib_inflate.inflateGetHeader(this.strm, this.header);
            }

            /**
             * Inflate#push(data[, mode]) -> Boolean
             * - data (Uint8Array|Array|ArrayBuffer|String): input data
             * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
             *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
             *
             * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
             * new output chunks. Returns `true` on success. The last data block must have
             * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
             * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
             * can use mode Z_SYNC_FLUSH, keeping the decompression context.
             *
             * On fail call [[Inflate#onEnd]] with error code and return false.
             *
             * We strongly recommend to use `Uint8Array` on input for best speed (output
             * format is detected automatically). Also, don't skip last param and always
             * use the same type in your code (boolean or number). That will improve JS speed.
             *
             * For regular `Array`-s make sure all elements are [0..255].
             *
             * ##### Example
             *
             * ```javascript
             * push(chunk, false); // push one of data chunks
             * ...
             * push(chunk, true);  // push last chunk
             * ```
             **/
            Inflate.prototype.push = function(data, mode) {
                var strm = this.strm;
                var chunkSize = this.options.chunkSize;
                var dictionary = this.options.dictionary;
                var status, _mode;
                var next_out_utf8, tail, utf8str;
                var dict;

                // Flag to properly process Z_BUF_ERROR on testing inflate call
                // when we check that all output data was flushed.
                var allowBufError = false;

                if (this.ended) {
                    return false;
                }
                _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

                // Convert data if needed
                if (typeof data === 'string') {
                    // Only binary strings can be decompressed on practice
                    strm.input = strings.binstring2buf(data);
                } else if (toString.call(data) === '[object ArrayBuffer]') {
                    strm.input = new Uint8Array(data);
                } else {
                    strm.input = data;
                }

                strm.next_in = 0;
                strm.avail_in = strm.input.length;

                do {
                    if (strm.avail_out === 0) {
                        strm.output = new utils.Buf8(chunkSize);
                        strm.next_out = 0;
                        strm.avail_out = chunkSize;
                    }

                    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

                    if (status === c.Z_NEED_DICT && dictionary) {
                        // Convert data if needed
                        if (typeof dictionary === 'string') {
                            dict = strings.string2buf(dictionary);
                        } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
                            dict = new Uint8Array(dictionary);
                        } else {
                            dict = dictionary;
                        }

                        status = zlib_inflate.inflateSetDictionary(this.strm, dict);

                    }

                    if (status === c.Z_BUF_ERROR && allowBufError === true) {
                        status = c.Z_OK;
                        allowBufError = false;
                    }

                    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                        this.onEnd(status);
                        this.ended = true;
                        return false;
                    }

                    if (strm.next_out) {
                        if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

                            if (this.options.to === 'string') {

                                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

                                tail = strm.next_out - next_out_utf8;
                                utf8str = strings.buf2string(strm.output, next_out_utf8);

                                // move tail
                                strm.next_out = tail;
                                strm.avail_out = chunkSize - tail;
                                if (tail) {
                                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                                }

                                this.onData(utf8str);

                            } else {
                                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                            }
                        }
                    }

                    // When no more input data, we should check that internal inflate buffers
                    // are flushed. The only way to do it when avail_out = 0 - run one more
                    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
                    // Here we set flag to process this error properly.
                    //
                    // NOTE. Deflate does not return error in this case and does not needs such
                    // logic.
                    if (strm.avail_in === 0 && strm.avail_out === 0) {
                        allowBufError = true;
                    }

                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

                if (status === c.Z_STREAM_END) {
                    _mode = c.Z_FINISH;
                }

                // Finalize on the last chunk.
                if (_mode === c.Z_FINISH) {
                    status = zlib_inflate.inflateEnd(this.strm);
                    this.onEnd(status);
                    this.ended = true;
                    return status === c.Z_OK;
                }

                // callback interim results if Z_SYNC_FLUSH.
                if (_mode === c.Z_SYNC_FLUSH) {
                    this.onEnd(c.Z_OK);
                    strm.avail_out = 0;
                    return true;
                }

                return true;
            };


            /**
             * Inflate#onData(chunk) -> Void
             * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
             *   on js engine support. When string output requested, each chunk
             *   will be string.
             *
             * By default, stores data blocks in `chunks[]` property and glue
             * those in `onEnd`. Override this handler, if you need another behaviour.
             **/
            Inflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
            };


            /**
             * Inflate#onEnd(status) -> Void
             * - status (Number): inflate status. 0 (Z_OK) on success,
             *   other if not.
             *
             * Called either after you tell inflate that the input stream is
             * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
             * or if an error happened. By default - join collected chunks,
             * free memory and fill `results` / `err` properties.
             **/
            Inflate.prototype.onEnd = function(status) {
                // On success - join
                if (status === c.Z_OK) {
                    if (this.options.to === 'string') {
                        // Glue & convert here, until we teach pako to send
                        // utf8 alligned strings to onData
                        this.result = this.chunks.join('');
                    } else {
                        this.result = utils.flattenChunks(this.chunks);
                    }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
            };


            /**
             * inflate(data[, options]) -> Uint8Array|Array|String
             * - data (Uint8Array|Array|String): input data to decompress.
             * - options (Object): zlib inflate options.
             *
             * Decompress `data` with inflate/ungzip and `options`. Autodetect
             * format via wrapper header by default. That's why we don't provide
             * separate `ungzip` method.
             *
             * Supported options are:
             *
             * - windowBits
             *
             * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
             * for more information.
             *
             * Sugar (options):
             *
             * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
             *   negative windowBits implicitly.
             * - `to` (String) - if equal to 'string', then result will be converted
             *   from utf8 to utf16 (javascript) string. When string output requested,
             *   chunk length can differ from `chunkSize`, depending on content.
             *
             *
             * ##### Example:
             *
             * ```javascript
             * var pako = require('pako')
             *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
             *   , output;
             *
             * try {
             *   output = pako.inflate(input);
             * } catch (err)
             *   console.log(err);
             * }
             * ```
             **/
            function inflate(input, options) {
                var inflator = new Inflate(options);

                inflator.push(input, true);

                // That will never happens, if you don't cheat with options :)
                if (inflator.err) {
                    throw inflator.msg || msg[inflator.err];
                }

                return inflator.result;
            }


            /**
             * inflateRaw(data[, options]) -> Uint8Array|Array|String
             * - data (Uint8Array|Array|String): input data to decompress.
             * - options (Object): zlib inflate options.
             *
             * The same as [[inflate]], but creates raw data, without wrapper
             * (header and adler32 crc).
             **/
            function inflateRaw(input, options) {
                options = options || {};
                options.raw = true;
                return inflate(input, options);
            }


            /**
             * ungzip(data[, options]) -> Uint8Array|Array|String
             * - data (Uint8Array|Array|String): input data to decompress.
             * - options (Object): zlib inflate options.
             *
             * Just shortcut to [[inflate]], because it autodetects format
             * by header.content. Done for convenience.
             **/


            exports.Inflate = Inflate;
            exports.inflate = inflate;
            exports.inflateRaw = inflateRaw;
            exports.ungzip = inflate;

        }, {
            "./utils/common": 62,
            "./utils/strings": 63,
            "./zlib/constants": 65,
            "./zlib/gzheader": 68,
            "./zlib/inflate": 70,
            "./zlib/messages": 72,
            "./zlib/zstream": 74
        }],
        62: [function(require, module, exports) {
            'use strict';


            var TYPED_OK = (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


            exports.assign = function(obj /*from1, from2, from3, ...*/ ) {
                var sources = Array.prototype.slice.call(arguments, 1);
                while (sources.length) {
                    var source = sources.shift();
                    if (!source) {
                        continue;
                    }

                    if (typeof source !== 'object') {
                        throw new TypeError(source + 'must be non-object');
                    }

                    for (var p in source) {
                        if (source.hasOwnProperty(p)) {
                            obj[p] = source[p];
                        }
                    }
                }

                return obj;
            };


            // reduce buffer size, avoiding mem copy
            exports.shrinkBuf = function(buf, size) {
                if (buf.length === size) {
                    return buf;
                }
                if (buf.subarray) {
                    return buf.subarray(0, size);
                }
                buf.length = size;
                return buf;
            };


            var fnTyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                    if (src.subarray && dest.subarray) {
                        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                        return;
                    }
                    // Fallback to ordinary array
                    for (var i = 0; i < len; i++) {
                        dest[dest_offs + i] = src[src_offs + i];
                    }
                },
                // Join array of chunks to single array.
                flattenChunks: function(chunks) {
                    var i, l, len, pos, chunk, result;

                    // calculate data length
                    len = 0;
                    for (i = 0, l = chunks.length; i < l; i++) {
                        len += chunks[i].length;
                    }

                    // join chunks
                    result = new Uint8Array(len);
                    pos = 0;
                    for (i = 0, l = chunks.length; i < l; i++) {
                        chunk = chunks[i];
                        result.set(chunk, pos);
                        pos += chunk.length;
                    }

                    return result;
                }
            };

            var fnUntyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                    for (var i = 0; i < len; i++) {
                        dest[dest_offs + i] = src[src_offs + i];
                    }
                },
                // Join array of chunks to single array.
                flattenChunks: function(chunks) {
                    return [].concat.apply([], chunks);
                }
            };


            // Enable/Disable typed arrays use, for testing
            //
            exports.setTyped = function(on) {
                if (on) {
                    exports.Buf8 = Uint8Array;
                    exports.Buf16 = Uint16Array;
                    exports.Buf32 = Int32Array;
                    exports.assign(exports, fnTyped);
                } else {
                    exports.Buf8 = Array;
                    exports.Buf16 = Array;
                    exports.Buf32 = Array;
                    exports.assign(exports, fnUntyped);
                }
            };

            exports.setTyped(TYPED_OK);

        }, {}],
        63: [function(require, module, exports) {
            // String encode/decode helpers
            'use strict';


            var utils = require('./common');


            // Quick check if we can use fast array to bin string conversion
            //
            // - apply(Array) can fail on Android 2.2
            // - apply(Uint8Array) can fail on iOS 5.1 Safary
            //
            var STR_APPLY_OK = true;
            var STR_APPLY_UIA_OK = true;

            try {
                String.fromCharCode.apply(null, [0]);
            } catch (__) {
                STR_APPLY_OK = false;
            }
            try {
                String.fromCharCode.apply(null, new Uint8Array(1));
            } catch (__) {
                STR_APPLY_UIA_OK = false;
            }


            // Table with utf8 lengths (calculated by first byte of sequence)
            // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
            // because max possible codepoint is 0x10ffff
            var _utf8len = new utils.Buf8(256);
            for (var q = 0; q < 256; q++) {
                _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
            }
            _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


            // convert string to array (typed, when possible)
            exports.string2buf = function(str) {
                var buf, c, c2, m_pos, i, str_len = str.length,
                    buf_len = 0;

                // count binary size
                for (m_pos = 0; m_pos < str_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 0xfc00) === 0xdc00) {
                            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                            m_pos++;
                        }
                    }
                    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
                }

                // allocate buffer
                buf = new utils.Buf8(buf_len);

                // convert
                for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 0xfc00) === 0xdc00) {
                            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                            m_pos++;
                        }
                    }
                    if (c < 0x80) {
                        /* one byte */
                        buf[i++] = c;
                    } else if (c < 0x800) {
                        /* two bytes */
                        buf[i++] = 0xC0 | (c >>> 6);
                        buf[i++] = 0x80 | (c & 0x3f);
                    } else if (c < 0x10000) {
                        /* three bytes */
                        buf[i++] = 0xE0 | (c >>> 12);
                        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                        buf[i++] = 0x80 | (c & 0x3f);
                    } else {
                        /* four bytes */
                        buf[i++] = 0xf0 | (c >>> 18);
                        buf[i++] = 0x80 | (c >>> 12 & 0x3f);
                        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                        buf[i++] = 0x80 | (c & 0x3f);
                    }
                }

                return buf;
            };

            // Helper (used in 2 places)
            function buf2binstring(buf, len) {
                // use fallback for big arrays to avoid stack overflow
                if (len < 65537) {
                    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
                        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                    }
                }

                var result = '';
                for (var i = 0; i < len; i++) {
                    result += String.fromCharCode(buf[i]);
                }
                return result;
            }


            // Convert byte array to binary string
            exports.buf2binstring = function(buf) {
                return buf2binstring(buf, buf.length);
            };


            // Convert binary string (typed, when possible)
            exports.binstring2buf = function(str) {
                var buf = new utils.Buf8(str.length);
                for (var i = 0, len = buf.length; i < len; i++) {
                    buf[i] = str.charCodeAt(i);
                }
                return buf;
            };


            // convert array to string
            exports.buf2string = function(buf, max) {
                var i, out, c, c_len;
                var len = max || buf.length;

                // Reserve max possible length (2 words per char)
                // NB: by unknown reasons, Array is significantly faster for
                //     String.fromCharCode.apply than Uint16Array.
                var utf16buf = new Array(len * 2);

                for (out = 0, i = 0; i < len;) {
                    c = buf[i++];
                    // quick process ascii
                    if (c < 0x80) {
                        utf16buf[out++] = c;
                        continue;
                    }

                    c_len = _utf8len[c];
                    // skip 5 & 6 byte codes
                    if (c_len > 4) {
                        utf16buf[out++] = 0xfffd;
                        i += c_len - 1;
                        continue;
                    }

                    // apply mask on first byte
                    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
                    // join the rest
                    while (c_len > 1 && i < len) {
                        c = (c << 6) | (buf[i++] & 0x3f);
                        c_len--;
                    }

                    // terminated by end of string?
                    if (c_len > 1) {
                        utf16buf[out++] = 0xfffd;
                        continue;
                    }

                    if (c < 0x10000) {
                        utf16buf[out++] = c;
                    } else {
                        c -= 0x10000;
                        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                        utf16buf[out++] = 0xdc00 | (c & 0x3ff);
                    }
                }

                return buf2binstring(utf16buf, out);
            };


            // Calculate max possible position in utf8 buffer,
            // that will not break sequence. If that's not possible
            // - (very small limits) return max size as is.
            //
            // buf[] - utf8 bytes array
            // max   - length limit (mandatory);
            exports.utf8border = function(buf, max) {
                var pos;

                max = max || buf.length;
                if (max > buf.length) {
                    max = buf.length;
                }

                // go back from last position, until start of sequence found
                pos = max - 1;
                while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
                    pos--;
                }

                // Fuckup - very small and broken sequence,
                // return max, because we should return something anyway.
                if (pos < 0) {
                    return max;
                }

                // If we came to start of buffer - that means vuffer is too small,
                // return max too.
                if (pos === 0) {
                    return max;
                }

                return (pos + _utf8len[buf[pos]] > max) ? pos : max;
            };

        }, {
            "./common": 62
        }],
        64: [function(require, module, exports) {
            'use strict';

            // Note: adler32 takes 12% for level 0 and 2% for level 6.
            // It doesn't worth to make additional optimizationa as in original.
            // Small size is preferable.

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            function adler32(adler, buf, len, pos) {
                var s1 = (adler & 0xffff) | 0,
                    s2 = ((adler >>> 16) & 0xffff) | 0,
                    n = 0;

                while (len !== 0) {
                    // Set limit ~ twice less than 5552, to keep
                    // s2 in 31-bits, because we force signed ints.
                    // in other case %= will fail.
                    n = len > 2000 ? 2000 : len;
                    len -= n;

                    do {
                        s1 = (s1 + buf[pos++]) | 0;
                        s2 = (s2 + s1) | 0;
                    } while (--n);

                    s1 %= 65521;
                    s2 %= 65521;
                }

                return (s1 | (s2 << 16)) | 0;
            }


            module.exports = adler32;

        }, {}],
        65: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            module.exports = {

                /* Allowed flush values; see deflate() and inflate() below for details */
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,

                /* Return codes for the compression/decompression functions. Negative values
                 * are errors, positive values are used for special but normal events.
                 */
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                //Z_MEM_ERROR:     -4,
                Z_BUF_ERROR: -5,
                //Z_VERSION_ERROR: -6,

                /* compression levels */
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,


                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,

                /* Possible values of the data_type field (though see inflate()) */
                Z_BINARY: 0,
                Z_TEXT: 1,
                //Z_ASCII:                1, // = Z_TEXT (deprecated)
                Z_UNKNOWN: 2,

                /* The deflate compression method */
                Z_DEFLATED: 8
                    //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };

        }, {}],
        66: [function(require, module, exports) {
            'use strict';

            // Note: we can't get significant speed boost here.
            // So write code to minimize size - no pregenerated tables
            // and array tools dependencies.

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            // Use ordinary array, since untyped makes no boost here
            function makeTable() {
                var c, table = [];

                for (var n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++) {
                        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                    }
                    table[n] = c;
                }

                return table;
            }

            // Create table on load. Just 255 signed longs. Not a problem.
            var crcTable = makeTable();


            function crc32(crc, buf, len, pos) {
                var t = crcTable,
                    end = pos + len;

                crc ^= -1;

                for (var i = pos; i < end; i++) {
                    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
                }

                return (crc ^ (-1)); // >>> 0;
            }


            module.exports = crc32;

        }, {}],
        67: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            var utils = require('../utils/common');
            var trees = require('./trees');
            var adler32 = require('./adler32');
            var crc32 = require('./crc32');
            var msg = require('./messages');

            /* Public constants ==========================================================*/
            /* ===========================================================================*/


            /* Allowed flush values; see deflate() and inflate() below for details */
            var Z_NO_FLUSH = 0;
            var Z_PARTIAL_FLUSH = 1;
            //var Z_SYNC_FLUSH    = 2;
            var Z_FULL_FLUSH = 3;
            var Z_FINISH = 4;
            var Z_BLOCK = 5;
            //var Z_TREES         = 6;


            /* Return codes for the compression/decompression functions. Negative values
             * are errors, positive values are used for special but normal events.
             */
            var Z_OK = 0;
            var Z_STREAM_END = 1;
            //var Z_NEED_DICT     = 2;
            //var Z_ERRNO         = -1;
            var Z_STREAM_ERROR = -2;
            var Z_DATA_ERROR = -3;
            //var Z_MEM_ERROR     = -4;
            var Z_BUF_ERROR = -5;
            //var Z_VERSION_ERROR = -6;


            /* compression levels */
            //var Z_NO_COMPRESSION      = 0;
            //var Z_BEST_SPEED          = 1;
            //var Z_BEST_COMPRESSION    = 9;
            var Z_DEFAULT_COMPRESSION = -1;


            var Z_FILTERED = 1;
            var Z_HUFFMAN_ONLY = 2;
            var Z_RLE = 3;
            var Z_FIXED = 4;
            var Z_DEFAULT_STRATEGY = 0;

            /* Possible values of the data_type field (though see inflate()) */
            //var Z_BINARY              = 0;
            //var Z_TEXT                = 1;
            //var Z_ASCII               = 1; // = Z_TEXT
            var Z_UNKNOWN = 2;


            /* The deflate compression method */
            var Z_DEFLATED = 8;

            /*============================================================================*/


            var MAX_MEM_LEVEL = 9;
            /* Maximum value for memLevel in deflateInit2 */
            var MAX_WBITS = 15;
            /* 32K LZ77 window */
            var DEF_MEM_LEVEL = 8;


            var LENGTH_CODES = 29;
            /* number of length codes, not counting the special END_BLOCK code */
            var LITERALS = 256;
            /* number of literal bytes 0..255 */
            var L_CODES = LITERALS + 1 + LENGTH_CODES;
            /* number of Literal or Length codes, including the END_BLOCK code */
            var D_CODES = 30;
            /* number of distance codes */
            var BL_CODES = 19;
            /* number of codes used to transfer the bit lengths */
            var HEAP_SIZE = 2 * L_CODES + 1;
            /* maximum heap size */
            var MAX_BITS = 15;
            /* All codes must not exceed MAX_BITS bits */

            var MIN_MATCH = 3;
            var MAX_MATCH = 258;
            var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

            var PRESET_DICT = 0x20;

            var INIT_STATE = 42;
            var EXTRA_STATE = 69;
            var NAME_STATE = 73;
            var COMMENT_STATE = 91;
            var HCRC_STATE = 103;
            var BUSY_STATE = 113;
            var FINISH_STATE = 666;

            var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
            var BS_BLOCK_DONE = 2; /* block flush performed */
            var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
            var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

            var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

            function err(strm, errorCode) {
                strm.msg = msg[errorCode];
                return errorCode;
            }

            function rank(f) {
                return ((f) << 1) - ((f) > 4 ? 9 : 0);
            }

            function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                    buf[len] = 0;
                }
            }


            /* =========================================================================
             * Flush as much pending output as possible. All deflate() output goes
             * through this function so some applications may wish to modify it
             * to avoid allocating a large strm->output buffer and copying into it.
             * (See also read_buf()).
             */
            function flush_pending(strm) {
                var s = strm.state;

                //_tr_flush_bits(s);
                var len = s.pending;
                if (len > strm.avail_out) {
                    len = strm.avail_out;
                }
                if (len === 0) {
                    return;
                }

                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
                strm.next_out += len;
                s.pending_out += len;
                strm.total_out += len;
                strm.avail_out -= len;
                s.pending -= len;
                if (s.pending === 0) {
                    s.pending_out = 0;
                }
            }


            function flush_block_only(s, last) {
                trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
                s.block_start = s.strstart;
                flush_pending(s.strm);
            }


            function put_byte(s, b) {
                s.pending_buf[s.pending++] = b;
            }


            /* =========================================================================
             * Put a short in the pending buffer. The 16-bit value is put in MSB order.
             * IN assertion: the stream state is correct and there is enough room in
             * pending_buf.
             */
            function putShortMSB(s, b) {
                //  put_byte(s, (Byte)(b >> 8));
                //  put_byte(s, (Byte)(b & 0xff));
                s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
                s.pending_buf[s.pending++] = b & 0xff;
            }


            /* ===========================================================================
             * Read a new buffer from the current input stream, update the adler32
             * and total number of bytes read.  All deflate() input goes through
             * this function so some applications may wish to modify it to avoid
             * allocating a large strm->input buffer and copying from it.
             * (See also flush_pending()).
             */
            function read_buf(strm, buf, start, size) {
                var len = strm.avail_in;

                if (len > size) {
                    len = size;
                }
                if (len === 0) {
                    return 0;
                }

                strm.avail_in -= len;

                // zmemcpy(buf, strm->next_in, len);
                utils.arraySet(buf, strm.input, strm.next_in, len, start);
                if (strm.state.wrap === 1) {
                    strm.adler = adler32(strm.adler, buf, len, start);
                } else if (strm.state.wrap === 2) {
                    strm.adler = crc32(strm.adler, buf, len, start);
                }

                strm.next_in += len;
                strm.total_in += len;

                return len;
            }


            /* ===========================================================================
             * Set match_start to the longest match starting at the given string and
             * return its length. Matches shorter or equal to prev_length are discarded,
             * in which case the result is equal to prev_length and match_start is
             * garbage.
             * IN assertions: cur_match is the head of the hash chain for the current
             *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
             * OUT assertion: the match length is not greater than s->lookahead.
             */
            function longest_match(s, cur_match) {
                var chain_length = s.max_chain_length; /* max hash chain length */
                var scan = s.strstart; /* current string */
                var match; /* matched string */
                var len; /* length of current match */
                var best_len = s.prev_length; /* best match length so far */
                var nice_match = s.nice_match; /* stop if match long enough */
                var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
                    s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;

                var _win = s.window; // shortcut

                var wmask = s.w_mask;
                var prev = s.prev;

                /* Stop when cur_match becomes <= limit. To simplify the code,
                 * we prevent matches with the string of window index 0.
                 */

                var strend = s.strstart + MAX_MATCH;
                var scan_end1 = _win[scan + best_len - 1];
                var scan_end = _win[scan + best_len];

                /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
                 * It is easy to get rid of this optimization if necessary.
                 */
                // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

                /* Do not waste too much time if we already have a good match: */
                if (s.prev_length >= s.good_match) {
                    chain_length >>= 2;
                }
                /* Do not look for matches beyond the end of the input. This is necessary
                 * to make deflate deterministic.
                 */
                if (nice_match > s.lookahead) {
                    nice_match = s.lookahead;
                }

                // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

                do {
                    // Assert(cur_match < s->strstart, "no future");
                    match = cur_match;

                    /* Skip to next match if the match length cannot increase
                     * or if the match length is less than 2.  Note that the checks below
                     * for insufficient lookahead only occur occasionally for performance
                     * reasons.  Therefore uninitialized memory will be accessed, and
                     * conditional jumps will be made that depend on those values.
                     * However the length of the match is limited to the lookahead, so
                     * the output of deflate is not affected by the uninitialized values.
                     */

                    if (_win[match + best_len] !== scan_end ||
                        _win[match + best_len - 1] !== scan_end1 ||
                        _win[match] !== _win[scan] ||
                        _win[++match] !== _win[scan + 1]) {
                        continue;
                    }

                    /* The check at best_len-1 can be removed because it will be made
                     * again later. (This heuristic is not always a win.)
                     * It is not necessary to compare scan[2] and match[2] since they
                     * are always equal when the other bytes match, given that
                     * the hash keys are equal and that HASH_BITS >= 8.
                     */
                    scan += 2;
                    match++;
                    // Assert(*scan == *match, "match[2]?");

                    /* We check for insufficient lookahead only every 8th comparison;
                     * the 256th check will be made at strstart+258.
                     */
                    do {
                        /*jshint noempty:false*/
                    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                        _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                        _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                        _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                        scan < strend);

                    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

                    len = MAX_MATCH - (strend - scan);
                    scan = strend - MAX_MATCH;

                    if (len > best_len) {
                        s.match_start = cur_match;
                        best_len = len;
                        if (len >= nice_match) {
                            break;
                        }
                        scan_end1 = _win[scan + best_len - 1];
                        scan_end = _win[scan + best_len];
                    }
                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

                if (best_len <= s.lookahead) {
                    return best_len;
                }
                return s.lookahead;
            }


            /* ===========================================================================
             * Fill the window when the lookahead becomes insufficient.
             * Updates strstart and lookahead.
             *
             * IN assertion: lookahead < MIN_LOOKAHEAD
             * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
             *    At least one byte has been read, or avail_in == 0; reads are
             *    performed for at least two bytes (required for the zip translate_eol
             *    option -- not supported here).
             */
            function fill_window(s) {
                var _w_size = s.w_size;
                var p, n, m, more, str;

                //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

                do {
                    more = s.window_size - s.lookahead - s.strstart;

                    // JS ints have 32 bit, block below not needed
                    /* Deal with !@#$% 64K limit: */
                    //if (sizeof(int) <= 2) {
                    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                    //        more = wsize;
                    //
                    //  } else if (more == (unsigned)(-1)) {
                    //        /* Very unlikely, but possible on 16 bit machine if
                    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
                    //         */
                    //        more--;
                    //    }
                    //}


                    /* If the window is almost full and there is insufficient lookahead,
                     * move the upper half to the lower one to make room in the upper half.
                     */
                    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                        s.match_start -= _w_size;
                        s.strstart -= _w_size;
                        /* we now have strstart >= MAX_DIST */
                        s.block_start -= _w_size;

                        /* Slide the hash table (could be avoided with 32 bit values
                         at the expense of memory usage). We slide even when level == 0
                         to keep the hash table consistent if we switch back to level > 0
                         later. (Using level 0 permanently is not an optimal usage of
                         zlib, so we don't care about this pathological case.)
                         */

                        n = s.hash_size;
                        p = n;
                        do {
                            m = s.head[--p];
                            s.head[p] = (m >= _w_size ? m - _w_size : 0);
                        } while (--n);

                        n = _w_size;
                        p = n;
                        do {
                            m = s.prev[--p];
                            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
                            /* If n is not on any hash chain, prev[n] is garbage but
                             * its value will never be used.
                             */
                        } while (--n);

                        more += _w_size;
                    }
                    if (s.strm.avail_in === 0) {
                        break;
                    }

                    /* If there was no sliding:
                     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
                     *    more == window_size - lookahead - strstart
                     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
                     * => more >= window_size - 2*WSIZE + 2
                     * In the BIG_MEM or MMAP case (not yet supported),
                     *   window_size == input_size + MIN_LOOKAHEAD  &&
                     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
                     * Otherwise, window_size == 2*WSIZE so more >= 2.
                     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
                     */
                    //Assert(more >= 2, "more < 2");
                    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                    s.lookahead += n;

                    /* Initialize the hash value now that we have some input: */
                    if (s.lookahead + s.insert >= MIN_MATCH) {
                        str = s.strstart - s.insert;
                        s.ins_h = s.window[str];

                        /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
                        //#if MIN_MATCH != 3
                        //        Call update_hash() MIN_MATCH-3 more times
                        //#endif
                        while (s.insert) {
                            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

                            s.prev[str & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = str;
                            str++;
                            s.insert--;
                            if (s.lookahead + s.insert < MIN_MATCH) {
                                break;
                            }
                        }
                    }
                    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
                     * but this is not important since only literal bytes will be emitted.
                     */

                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

                /* If the WIN_INIT bytes after the end of the current data have never been
                 * written, then zero those bytes in order to avoid memory check reports of
                 * the use of uninitialized (or uninitialised as Julian writes) bytes by
                 * the longest match routines.  Update the high water mark for the next
                 * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
                 * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
                 */
                //  if (s.high_water < s.window_size) {
                //    var curr = s.strstart + s.lookahead;
                //    var init = 0;
                //
                //    if (s.high_water < curr) {
                //      /* Previous high water mark below current data -- zero WIN_INIT
                //       * bytes or up to end of window, whichever is less.
                //       */
                //      init = s.window_size - curr;
                //      if (init > WIN_INIT)
                //        init = WIN_INIT;
                //      zmemzero(s->window + curr, (unsigned)init);
                //      s->high_water = curr + init;
                //    }
                //    else if (s->high_water < (ulg)curr + WIN_INIT) {
                //      /* High water mark at or above current data, but below current data
                //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
                //       * to end of window, whichever is less.
                //       */
                //      init = (ulg)curr + WIN_INIT - s->high_water;
                //      if (init > s->window_size - s->high_water)
                //        init = s->window_size - s->high_water;
                //      zmemzero(s->window + s->high_water, (unsigned)init);
                //      s->high_water += init;
                //    }
                //  }
                //
                //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
                //    "not enough room for search");
            }

            /* ===========================================================================
             * Copy without compression as much as possible from the input stream, return
             * the current block state.
             * This function does not insert new strings in the dictionary since
             * uncompressible data is probably not useful. This function is used
             * only for the level=0 compression option.
             * NOTE: this function should be optimized to avoid extra copying from
             * window to pending_buf.
             */
            function deflate_stored(s, flush) {
                /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
                 * to pending_buf_size, and each stored block has a 5 byte header:
                 */
                var max_block_size = 0xffff;

                if (max_block_size > s.pending_buf_size - 5) {
                    max_block_size = s.pending_buf_size - 5;
                }

                /* Copy as much as possible from input to output: */
                for (;;) {
                    /* Fill the window as much as possible: */
                    if (s.lookahead <= 1) {

                        //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                        //  s->block_start >= (long)s->w_size, "slide too late");
                        //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
                        //        s.block_start >= s.w_size)) {
                        //        throw  new Error("slide too late");
                        //      }

                        fill_window(s);
                        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }

                        if (s.lookahead === 0) {
                            break;
                        }
                        /* flush the current block */
                    }
                    //Assert(s->block_start >= 0L, "block gone");
                    //    if (s.block_start < 0) throw new Error("block gone");

                    s.strstart += s.lookahead;
                    s.lookahead = 0;

                    /* Emit a stored block if pending_buf will be full: */
                    var max_start = s.block_start + max_block_size;

                    if (s.strstart === 0 || s.strstart >= max_start) {
                        /* strstart == 0 is possible when wraparound on 16-bit machine */
                        s.lookahead = s.strstart - max_start;
                        s.strstart = max_start;
                        /*** FLUSH_BLOCK(s, 0); ***/
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                        /***/


                    }
                    /* Flush if we may have to slide, otherwise block_start may become
                     * negative and the data will be gone:
                     */
                    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
                        /*** FLUSH_BLOCK(s, 0); ***/
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                        /***/
                    }
                }

                s.insert = 0;

                if (flush === Z_FINISH) {
                    /*** FLUSH_BLOCK(s, 1); ***/
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    /***/
                    return BS_FINISH_DONE;
                }

                if (s.strstart > s.block_start) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }

                return BS_NEED_MORE;
            }

            /* ===========================================================================
             * Compress as much as possible from the input stream, return the current
             * block state.
             * This function does not perform lazy evaluation of matches and inserts
             * new strings in the dictionary only for unmatched strings or for short
             * matches. It is used only for the fast compression options.
             */
            function deflate_fast(s, flush) {
                var hash_head; /* head of the hash chain */
                var bflush; /* set if current block must be flushed */

                for (;;) {
                    /* Make sure that we always have enough lookahead, except
                     * at the end of the input file. We need MAX_MATCH bytes
                     * for the next match, plus MIN_MATCH bytes to insert the
                     * string following the next match.
                     */
                    if (s.lookahead < MIN_LOOKAHEAD) {
                        fill_window(s);
                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break; /* flush the current block */
                        }
                    }

                    /* Insert the string window[strstart .. strstart+2] in the
                     * dictionary, and set hash_head to the head of the hash chain:
                     */
                    hash_head = 0 /*NIL*/ ;
                    if (s.lookahead >= MIN_MATCH) {
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                    }

                    /* Find the longest match, discarding those <= prev_length.
                     * At this point we have always match_length < MIN_MATCH
                     */
                    if (hash_head !== 0 /*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
                        /* To simplify the code, we prevent matches with the string
                         * of window index 0 (in particular we have to avoid a match
                         * of the string with itself at the start of the input file).
                         */
                        s.match_length = longest_match(s, hash_head);
                        /* longest_match() sets match_start */
                    }
                    if (s.match_length >= MIN_MATCH) {
                        // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                        /*** _tr_tally_dist(s, s.strstart - s.match_start,
                                       s.match_length - MIN_MATCH, bflush); ***/
                        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

                        s.lookahead -= s.match_length;

                        /* Insert new strings in the hash table only if the match length
                         * is not too large. This saves time but degrades compression.
                         */
                        if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
                            s.match_length--; /* string at strstart already in table */
                            do {
                                s.strstart++;
                                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                                s.head[s.ins_h] = s.strstart;
                                /***/
                                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                                 * always MIN_MATCH bytes ahead.
                                 */
                            } while (--s.match_length !== 0);
                            s.strstart++;
                        } else {
                            s.strstart += s.match_length;
                            s.match_length = 0;
                            s.ins_h = s.window[s.strstart];
                            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

                            //#if MIN_MATCH != 3
                            //                Call UPDATE_HASH() MIN_MATCH-3 more times
                            //#endif
                            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                             * matter since it will be recomputed at next deflate call.
                             */
                        }
                    } else {
                        /* No match, output a literal byte */
                        //Tracevv((stderr,"%c", s.window[s.strstart]));
                        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

                        s.lookahead--;
                        s.strstart++;
                    }
                    if (bflush) {
                        /*** FLUSH_BLOCK(s, 0); ***/
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                        /***/
                    }
                }
                s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
                if (flush === Z_FINISH) {
                    /*** FLUSH_BLOCK(s, 1); ***/
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    /***/
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
                return BS_BLOCK_DONE;
            }

            /* ===========================================================================
             * Same as above, but achieves better compression. We use a lazy
             * evaluation for matches: a match is finally adopted only if there is
             * no better match at the next window position.
             */
            function deflate_slow(s, flush) {
                var hash_head; /* head of hash chain */
                var bflush; /* set if current block must be flushed */

                var max_insert;

                /* Process the input block. */
                for (;;) {
                    /* Make sure that we always have enough lookahead, except
                     * at the end of the input file. We need MAX_MATCH bytes
                     * for the next match, plus MIN_MATCH bytes to insert the
                     * string following the next match.
                     */
                    if (s.lookahead < MIN_LOOKAHEAD) {
                        fill_window(s);
                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break;
                        } /* flush the current block */
                    }

                    /* Insert the string window[strstart .. strstart+2] in the
                     * dictionary, and set hash_head to the head of the hash chain:
                     */
                    hash_head = 0 /*NIL*/ ;
                    if (s.lookahead >= MIN_MATCH) {
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                    }

                    /* Find the longest match, discarding those <= prev_length.
                     */
                    s.prev_length = s.match_length;
                    s.prev_match = s.match_start;
                    s.match_length = MIN_MATCH - 1;

                    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match &&
                        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD) /*MAX_DIST(s)*/ ) {
                        /* To simplify the code, we prevent matches with the string
                         * of window index 0 (in particular we have to avoid a match
                         * of the string with itself at the start of the input file).
                         */
                        s.match_length = longest_match(s, hash_head);
                        /* longest_match() sets match_start */

                        if (s.match_length <= 5 &&
                            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ ))) {

                            /* If prev_match is also MIN_MATCH, match_start is garbage
                             * but we will ignore the current match anyway.
                             */
                            s.match_length = MIN_MATCH - 1;
                        }
                    }
                    /* If there was a match at the previous step and the current
                     * match is not better, output the previous match:
                     */
                    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                        max_insert = s.strstart + s.lookahead - MIN_MATCH;
                        /* Do not insert strings in hash table beyond this. */

                        //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                        /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                                       s.prev_length - MIN_MATCH, bflush);***/
                        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                        /* Insert in hash table all strings up to the end of the match.
                         * strstart-1 and strstart are already inserted. If there is not
                         * enough lookahead, the last two strings are not inserted in
                         * the hash table.
                         */
                        s.lookahead -= s.prev_length - 1;
                        s.prev_length -= 2;
                        do {
                            if (++s.strstart <= max_insert) {
                                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                                s.head[s.ins_h] = s.strstart;
                                /***/
                            }
                        } while (--s.prev_length !== 0);
                        s.match_available = 0;
                        s.match_length = MIN_MATCH - 1;
                        s.strstart++;

                        if (bflush) {
                            /*** FLUSH_BLOCK(s, 0); ***/
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                            /***/
                        }

                    } else if (s.match_available) {
                        /* If there was no match at the previous position, output a
                         * single literal. If there was a match but the current match
                         * is longer, truncate the previous match to a single literal.
                         */
                        //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

                        if (bflush) {
                            /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                            flush_block_only(s, false);
                            /***/
                        }
                        s.strstart++;
                        s.lookahead--;
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    } else {
                        /* There is no previous match to compare with, wait for
                         * the next step to decide.
                         */
                        s.match_available = 1;
                        s.strstart++;
                        s.lookahead--;
                    }
                }
                //Assert (flush != Z_NO_FLUSH, "no flush?");
                if (s.match_available) {
                    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

                    s.match_available = 0;
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                    /*** FLUSH_BLOCK(s, 1); ***/
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    /***/
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }

                return BS_BLOCK_DONE;
            }


            /* ===========================================================================
             * For Z_RLE, simply look for runs of bytes, generate matches only of distance
             * one.  Do not maintain a hash table.  (It will be regenerated if this run of
             * deflate switches away from Z_RLE.)
             */
            function deflate_rle(s, flush) {
                var bflush; /* set if current block must be flushed */
                var prev; /* byte at distance one to match */
                var scan, strend; /* scan goes up to strend for length of run */

                var _win = s.window;

                for (;;) {
                    /* Make sure that we always have enough lookahead, except
                     * at the end of the input file. We need MAX_MATCH bytes
                     * for the longest run, plus one for the unrolled loop.
                     */
                    if (s.lookahead <= MAX_MATCH) {
                        fill_window(s);
                        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break;
                        } /* flush the current block */
                    }

                    /* See how many times the previous byte repeats */
                    s.match_length = 0;
                    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                        scan = s.strstart - 1;
                        prev = _win[scan];
                        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                            strend = s.strstart + MAX_MATCH;
                            do {
                                /*jshint noempty:false*/
                            } while (prev === _win[++scan] && prev === _win[++scan] &&
                                prev === _win[++scan] && prev === _win[++scan] &&
                                prev === _win[++scan] && prev === _win[++scan] &&
                                prev === _win[++scan] && prev === _win[++scan] &&
                                scan < strend);
                            s.match_length = MAX_MATCH - (strend - scan);
                            if (s.match_length > s.lookahead) {
                                s.match_length = s.lookahead;
                            }
                        }
                        //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
                    }

                    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
                    if (s.match_length >= MIN_MATCH) {
                        //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                        /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

                        s.lookahead -= s.match_length;
                        s.strstart += s.match_length;
                        s.match_length = 0;
                    } else {
                        /* No match, output a literal byte */
                        //Tracevv((stderr,"%c", s->window[s->strstart]));
                        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

                        s.lookahead--;
                        s.strstart++;
                    }
                    if (bflush) {
                        /*** FLUSH_BLOCK(s, 0); ***/
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                        /***/
                    }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                    /*** FLUSH_BLOCK(s, 1); ***/
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    /***/
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
                return BS_BLOCK_DONE;
            }

            /* ===========================================================================
             * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
             * (It will be regenerated if this run of deflate switches away from Huffman.)
             */
            function deflate_huff(s, flush) {
                var bflush; /* set if current block must be flushed */

                for (;;) {
                    /* Make sure that we have a literal to write. */
                    if (s.lookahead === 0) {
                        fill_window(s);
                        if (s.lookahead === 0) {
                            if (flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                            }
                            break; /* flush the current block */
                        }
                    }

                    /* Output a literal byte */
                    s.match_length = 0;
                    //Tracevv((stderr,"%c", s->window[s->strstart]));
                    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                    if (bflush) {
                        /*** FLUSH_BLOCK(s, 0); ***/
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                        /***/
                    }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                    /*** FLUSH_BLOCK(s, 1); ***/
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    /***/
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
                return BS_BLOCK_DONE;
            }

            /* Values for max_lazy_match, good_match and max_chain_length, depending on
             * the desired pack level (0..9). The values given below have been tuned to
             * exclude worst case performance for pathological files. Better values may be
             * found for specific files.
             */
            function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length;
                this.max_lazy = max_lazy;
                this.nice_length = nice_length;
                this.max_chain = max_chain;
                this.func = func;
            }

            var configuration_table;

            configuration_table = [
                /*      good lazy nice chain */
                new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
                new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
                new Config(4, 5, 16, 8, deflate_fast), /* 2 */
                new Config(4, 6, 32, 32, deflate_fast), /* 3 */

                new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
                new Config(8, 16, 32, 32, deflate_slow), /* 5 */
                new Config(8, 16, 128, 128, deflate_slow), /* 6 */
                new Config(8, 32, 128, 256, deflate_slow), /* 7 */
                new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
                new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
            ];


            /* ===========================================================================
             * Initialize the "longest match" routines for a new zlib stream
             */
            function lm_init(s) {
                s.window_size = 2 * s.w_size;

                /*** CLEAR_HASH(s); ***/
                zero(s.head); // Fill with NIL (= 0);

                /* Set the default configuration parameters:
                 */
                s.max_lazy_match = configuration_table[s.level].max_lazy;
                s.good_match = configuration_table[s.level].good_length;
                s.nice_match = configuration_table[s.level].nice_length;
                s.max_chain_length = configuration_table[s.level].max_chain;

                s.strstart = 0;
                s.block_start = 0;
                s.lookahead = 0;
                s.insert = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                s.ins_h = 0;
            }


            function DeflateState() {
                this.strm = null; /* pointer back to this zlib stream */
                this.status = 0; /* as the name implies */
                this.pending_buf = null; /* output still pending */
                this.pending_buf_size = 0; /* size of pending_buf */
                this.pending_out = 0; /* next pending byte to output to the stream */
                this.pending = 0; /* nb of bytes in the pending buffer */
                this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
                this.gzhead = null; /* gzip header information to write */
                this.gzindex = 0; /* where in extra, name, or comment */
                this.method = Z_DEFLATED; /* can only be DEFLATED */
                this.last_flush = -1; /* value of flush param for previous deflate call */

                this.w_size = 0; /* LZ77 window size (32K by default) */
                this.w_bits = 0; /* log2(w_size)  (8..16) */
                this.w_mask = 0; /* w_size - 1 */

                this.window = null;
                /* Sliding window. Input bytes are read into the second half of the window,
                 * and move to the first half later to keep a dictionary of at least wSize
                 * bytes. With this organization, matches are limited to a distance of
                 * wSize-MAX_MATCH bytes, but this ensures that IO is always
                 * performed with a length multiple of the block size.
                 */

                this.window_size = 0;
                /* Actual size of window: 2*wSize, except when the user input buffer
                 * is directly used as sliding window.
                 */

                this.prev = null;
                /* Link to older string with same hash index. To limit the size of this
                 * array to 64K, this link is maintained only for the last 32K strings.
                 * An index in this array is thus a window index modulo 32K.
                 */

                this.head = null; /* Heads of the hash chains or NIL. */

                this.ins_h = 0; /* hash index of string to be inserted */
                this.hash_size = 0; /* number of elements in hash table */
                this.hash_bits = 0; /* log2(hash_size) */
                this.hash_mask = 0; /* hash_size-1 */

                this.hash_shift = 0;
                /* Number of bits by which ins_h must be shifted at each input
                 * step. It must be such that after MIN_MATCH steps, the oldest
                 * byte no longer takes part in the hash key, that is:
                 *   hash_shift * MIN_MATCH >= hash_bits
                 */

                this.block_start = 0;
                /* Window position at the beginning of the current output block. Gets
                 * negative when the window is moved backwards.
                 */

                this.match_length = 0; /* length of best match */
                this.prev_match = 0; /* previous match */
                this.match_available = 0; /* set if previous match exists */
                this.strstart = 0; /* start of string to insert */
                this.match_start = 0; /* start of matching string */
                this.lookahead = 0; /* number of valid bytes ahead in window */

                this.prev_length = 0;
                /* Length of the best match at previous step. Matches not greater than this
                 * are discarded. This is used in the lazy match evaluation.
                 */

                this.max_chain_length = 0;
                /* To speed up deflation, hash chains are never searched beyond this
                 * length.  A higher limit improves compression ratio but degrades the
                 * speed.
                 */

                this.max_lazy_match = 0;
                /* Attempt to find a better match only when the current match is strictly
                 * smaller than this value. This mechanism is used only for compression
                 * levels >= 4.
                 */
                // That's alias to max_lazy_match, don't use directly
                //this.max_insert_length = 0;
                /* Insert new strings in the hash table only if the match length is not
                 * greater than this length. This saves time but degrades compression.
                 * max_insert_length is used only for compression levels <= 3.
                 */

                this.level = 0; /* compression level (1..9) */
                this.strategy = 0; /* favor or force Huffman coding*/

                this.good_match = 0;
                /* Use a faster search when the previous match is longer than this */

                this.nice_match = 0; /* Stop searching when current match exceeds this */

                /* used by trees.c: */

                /* Didn't use ct_data typedef below to suppress compiler warning */

                // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
                // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
                // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

                // Use flat array of DOUBLE size, with interleaved fata,
                // because JS does not support effective
                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                zero(this.dyn_ltree);
                zero(this.dyn_dtree);
                zero(this.bl_tree);

                this.l_desc = null; /* desc. for literal tree */
                this.d_desc = null; /* desc. for distance tree */
                this.bl_desc = null; /* desc. for bit length tree */

                //ush bl_count[MAX_BITS+1];
                this.bl_count = new utils.Buf16(MAX_BITS + 1);
                /* number of codes at each bit length for an optimal tree */

                //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
                this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
                zero(this.heap);

                this.heap_len = 0; /* number of elements in the heap */
                this.heap_max = 0; /* element of largest frequency */
                /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
                 * The same heap array is used to build all trees.
                 */

                this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
                zero(this.depth);
                /* Depth of each subtree used as tie breaker for trees of equal frequency
                 */

                this.l_buf = 0; /* buffer index for literals or lengths */

                this.lit_bufsize = 0;
                /* Size of match buffer for literals/lengths.  There are 4 reasons for
                 * limiting lit_bufsize to 64K:
                 *   - frequencies can be kept in 16 bit counters
                 *   - if compression is not successful for the first block, all input
                 *     data is still in the window so we can still emit a stored block even
                 *     when input comes from standard input.  (This can also be done for
                 *     all blocks if lit_bufsize is not greater than 32K.)
                 *   - if compression is not successful for a file smaller than 64K, we can
                 *     even emit a stored file instead of a stored block (saving 5 bytes).
                 *     This is applicable only for zip (not gzip or zlib).
                 *   - creating new Huffman trees less frequently may not provide fast
                 *     adaptation to changes in the input data statistics. (Take for
                 *     example a binary file with poorly compressible code followed by
                 *     a highly compressible string table.) Smaller buffer sizes give
                 *     fast adaptation but have of course the overhead of transmitting
                 *     trees more frequently.
                 *   - I can't count above 4
                 */

                this.last_lit = 0; /* running index in l_buf */

                this.d_buf = 0;
                /* Buffer index for distances. To simplify the code, d_buf and l_buf have
                 * the same number of elements. To use different lengths, an extra flag
                 * array would be necessary.
                 */

                this.opt_len = 0; /* bit length of current block with optimal trees */
                this.static_len = 0; /* bit length of current block with static trees */
                this.matches = 0; /* number of string matches in current block */
                this.insert = 0; /* bytes at end of window left to insert */


                this.bi_buf = 0;
                /* Output buffer. bits are inserted starting at the bottom (least
                 * significant bits).
                 */
                this.bi_valid = 0;
                /* Number of valid bits in bi_buf.  All bits above the last valid bit
                 * are always zero.
                 */

                // Used for window memory init. We safely ignore it for JS. That makes
                // sense only for pointers and memory check tools.
                //this.high_water = 0;
                /* High water mark offset in window for initialized bytes -- bytes above
                 * this are set to zero in order to avoid memory check warnings when
                 * longest match routines access bytes past the input.  This is then
                 * updated to the new high water mark.
                 */
            }


            function deflateResetKeep(strm) {
                var s;

                if (!strm || !strm.state) {
                    return err(strm, Z_STREAM_ERROR);
                }

                strm.total_in = strm.total_out = 0;
                strm.data_type = Z_UNKNOWN;

                s = strm.state;
                s.pending = 0;
                s.pending_out = 0;

                if (s.wrap < 0) {
                    s.wrap = -s.wrap;
                    /* was made negative by deflate(..., Z_FINISH); */
                }
                s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
                strm.adler = (s.wrap === 2) ?
                    0 // crc32(0, Z_NULL, 0)
                    :
                    1; // adler32(0, Z_NULL, 0)
                s.last_flush = Z_NO_FLUSH;
                trees._tr_init(s);
                return Z_OK;
            }


            function deflateReset(strm) {
                var ret = deflateResetKeep(strm);
                if (ret === Z_OK) {
                    lm_init(strm.state);
                }
                return ret;
            }


            function deflateSetHeader(strm, head) {
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                if (strm.state.wrap !== 2) {
                    return Z_STREAM_ERROR;
                }
                strm.state.gzhead = head;
                return Z_OK;
            }


            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                if (!strm) { // === Z_NULL
                    return Z_STREAM_ERROR;
                }
                var wrap = 1;

                if (level === Z_DEFAULT_COMPRESSION) {
                    level = 6;
                }

                if (windowBits < 0) { /* suppress zlib wrapper */
                    wrap = 0;
                    windowBits = -windowBits;
                } else if (windowBits > 15) {
                    wrap = 2; /* write gzip wrapper instead */
                    windowBits -= 16;
                }


                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
                    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
                    strategy < 0 || strategy > Z_FIXED) {
                    return err(strm, Z_STREAM_ERROR);
                }


                if (windowBits === 8) {
                    windowBits = 9;
                }
                /* until 256-byte window bug fixed */

                var s = new DeflateState();

                strm.state = s;
                s.strm = strm;

                s.wrap = wrap;
                s.gzhead = null;
                s.w_bits = windowBits;
                s.w_size = 1 << s.w_bits;
                s.w_mask = s.w_size - 1;

                s.hash_bits = memLevel + 7;
                s.hash_size = 1 << s.hash_bits;
                s.hash_mask = s.hash_size - 1;
                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

                s.window = new utils.Buf8(s.w_size * 2);
                s.head = new utils.Buf16(s.hash_size);
                s.prev = new utils.Buf16(s.w_size);

                // Don't need mem init magic for JS.
                //s.high_water = 0;  /* nothing written to s->window yet */

                s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

                s.pending_buf_size = s.lit_bufsize * 4;

                //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
                //s->pending_buf = (uchf *) overlay;
                s.pending_buf = new utils.Buf8(s.pending_buf_size);

                // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
                //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
                s.d_buf = 1 * s.lit_bufsize;

                //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
                s.l_buf = (1 + 2) * s.lit_bufsize;

                s.level = level;
                s.strategy = strategy;
                s.method = method;

                return deflateReset(strm);
            }

            function deflateInit(strm, level) {
                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
            }


            function deflate(strm, flush) {
                var old_flush, s;
                var beg, val; // for gzip header write only

                if (!strm || !strm.state ||
                    flush > Z_BLOCK || flush < 0) {
                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                }

                s = strm.state;

                if (!strm.output ||
                    (!strm.input && strm.avail_in !== 0) ||
                    (s.status === FINISH_STATE && flush !== Z_FINISH)) {
                    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
                }

                s.strm = strm; /* just in case */
                old_flush = s.last_flush;
                s.last_flush = flush;

                /* Write the header */
                if (s.status === INIT_STATE) {

                    if (s.wrap === 2) { // GZIP header
                        strm.adler = 0; //crc32(0L, Z_NULL, 0);
                        put_byte(s, 31);
                        put_byte(s, 139);
                        put_byte(s, 8);
                        if (!s.gzhead) { // s->gzhead == Z_NULL
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, s.level === 9 ? 2 :
                                (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                                    4 : 0));
                            put_byte(s, OS_CODE);
                            s.status = BUSY_STATE;
                        } else {
                            put_byte(s, (s.gzhead.text ? 1 : 0) +
                                (s.gzhead.hcrc ? 2 : 0) +
                                (!s.gzhead.extra ? 0 : 4) +
                                (!s.gzhead.name ? 0 : 8) +
                                (!s.gzhead.comment ? 0 : 16)
                            );
                            put_byte(s, s.gzhead.time & 0xff);
                            put_byte(s, (s.gzhead.time >> 8) & 0xff);
                            put_byte(s, (s.gzhead.time >> 16) & 0xff);
                            put_byte(s, (s.gzhead.time >> 24) & 0xff);
                            put_byte(s, s.level === 9 ? 2 :
                                (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                                    4 : 0));
                            put_byte(s, s.gzhead.os & 0xff);
                            if (s.gzhead.extra && s.gzhead.extra.length) {
                                put_byte(s, s.gzhead.extra.length & 0xff);
                                put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
                            }
                            if (s.gzhead.hcrc) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                            }
                            s.gzindex = 0;
                            s.status = EXTRA_STATE;
                        }
                    } else // DEFLATE header
                    {
                        var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
                        var level_flags = -1;

                        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                            level_flags = 0;
                        } else if (s.level < 6) {
                            level_flags = 1;
                        } else if (s.level === 6) {
                            level_flags = 2;
                        } else {
                            level_flags = 3;
                        }
                        header |= (level_flags << 6);
                        if (s.strstart !== 0) {
                            header |= PRESET_DICT;
                        }
                        header += 31 - (header % 31);

                        s.status = BUSY_STATE;
                        putShortMSB(s, header);

                        /* Save the adler32 of the preset dictionary: */
                        if (s.strstart !== 0) {
                            putShortMSB(s, strm.adler >>> 16);
                            putShortMSB(s, strm.adler & 0xffff);
                        }
                        strm.adler = 1; // adler32(0L, Z_NULL, 0);
                    }
                }

                //#ifdef GZIP
                if (s.status === EXTRA_STATE) {
                    if (s.gzhead.extra /* != Z_NULL*/ ) {
                        beg = s.pending; /* start of bytes to update crc */

                        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                    break;
                                }
                            }
                            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                            s.gzindex++;
                        }
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        if (s.gzindex === s.gzhead.extra.length) {
                            s.gzindex = 0;
                            s.status = NAME_STATE;
                        }
                    } else {
                        s.status = NAME_STATE;
                    }
                }
                if (s.status === NAME_STATE) {
                    if (s.gzhead.name /* != Z_NULL*/ ) {
                        beg = s.pending; /* start of bytes to update crc */
                        //int val;

                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                    val = 1;
                                    break;
                                }
                            }
                            // JS specific: little magic to add zero terminator to end of string
                            if (s.gzindex < s.gzhead.name.length) {
                                val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                            } else {
                                val = 0;
                            }
                            put_byte(s, val);
                        } while (val !== 0);

                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        if (val === 0) {
                            s.gzindex = 0;
                            s.status = COMMENT_STATE;
                        }
                    } else {
                        s.status = COMMENT_STATE;
                    }
                }
                if (s.status === COMMENT_STATE) {
                    if (s.gzhead.comment /* != Z_NULL*/ ) {
                        beg = s.pending; /* start of bytes to update crc */
                        //int val;

                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                    val = 1;
                                    break;
                                }
                            }
                            // JS specific: little magic to add zero terminator to end of string
                            if (s.gzindex < s.gzhead.comment.length) {
                                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                            } else {
                                val = 0;
                            }
                            put_byte(s, val);
                        } while (val !== 0);

                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        if (val === 0) {
                            s.status = HCRC_STATE;
                        }
                    } else {
                        s.status = HCRC_STATE;
                    }
                }
                if (s.status === HCRC_STATE) {
                    if (s.gzhead.hcrc) {
                        if (s.pending + 2 > s.pending_buf_size) {
                            flush_pending(strm);
                        }
                        if (s.pending + 2 <= s.pending_buf_size) {
                            put_byte(s, strm.adler & 0xff);
                            put_byte(s, (strm.adler >> 8) & 0xff);
                            strm.adler = 0; //crc32(0L, Z_NULL, 0);
                            s.status = BUSY_STATE;
                        }
                    } else {
                        s.status = BUSY_STATE;
                    }
                }
                //#endif

                /* Flush as much pending output as possible */
                if (s.pending !== 0) {
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                        /* Since avail_out is 0, deflate will be called again with
                         * more output space, but possibly with both pending and
                         * avail_in equal to zero. There won't be anything to do,
                         * but this is not an error situation so make sure we
                         * return OK instead of BUF_ERROR at next call of deflate:
                         */
                        s.last_flush = -1;
                        return Z_OK;
                    }

                    /* Make sure there is something to do and avoid duplicate consecutive
                     * flushes. For repeated and useless calls with Z_FINISH, we keep
                     * returning Z_STREAM_END instead of Z_BUF_ERROR.
                     */
                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
                    flush !== Z_FINISH) {
                    return err(strm, Z_BUF_ERROR);
                }

                /* User must not provide more input after the first FINISH: */
                if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                    return err(strm, Z_BUF_ERROR);
                }

                /* Start a new block or continue the current one.
                 */
                if (strm.avail_in !== 0 || s.lookahead !== 0 ||
                    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
                    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
                        (s.strategy === Z_RLE ? deflate_rle(s, flush) :
                            configuration_table[s.level].func(s, flush));

                    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                        s.status = FINISH_STATE;
                    }
                    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                        if (strm.avail_out === 0) {
                            s.last_flush = -1;
                            /* avoid BUF_ERROR next call, see above */
                        }
                        return Z_OK;
                        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                         * of deflate should use the same flush parameter to make sure
                         * that the flush is complete. So we don't have to output an
                         * empty block here, this will be done at next call. This also
                         * ensures that for a very small output buffer, we emit at most
                         * one empty block.
                         */
                    }
                    if (bstate === BS_BLOCK_DONE) {
                        if (flush === Z_PARTIAL_FLUSH) {
                            trees._tr_align(s);
                        } else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

                            trees._tr_stored_block(s, 0, 0, false);
                            /* For a full flush, this empty block will be recognized
                             * as a special marker by inflate_sync().
                             */
                            if (flush === Z_FULL_FLUSH) {
                                /*** CLEAR_HASH(s); ***/
                                /* forget history */
                                zero(s.head); // Fill with NIL (= 0);

                                if (s.lookahead === 0) {
                                    s.strstart = 0;
                                    s.block_start = 0;
                                    s.insert = 0;
                                }
                            }
                        }
                        flush_pending(strm);
                        if (strm.avail_out === 0) {
                            s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                            return Z_OK;
                        }
                    }
                }
                //Assert(strm->avail_out > 0, "bug2");
                //if (strm.avail_out <= 0) { throw new Error("bug2");}

                if (flush !== Z_FINISH) {
                    return Z_OK;
                }
                if (s.wrap <= 0) {
                    return Z_STREAM_END;
                }

                /* Write the trailer */
                if (s.wrap === 2) {
                    put_byte(s, strm.adler & 0xff);
                    put_byte(s, (strm.adler >> 8) & 0xff);
                    put_byte(s, (strm.adler >> 16) & 0xff);
                    put_byte(s, (strm.adler >> 24) & 0xff);
                    put_byte(s, strm.total_in & 0xff);
                    put_byte(s, (strm.total_in >> 8) & 0xff);
                    put_byte(s, (strm.total_in >> 16) & 0xff);
                    put_byte(s, (strm.total_in >> 24) & 0xff);
                } else {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 0xffff);
                }

                flush_pending(strm);
                /* If avail_out is zero, the application will call deflate again
                 * to flush the rest.
                 */
                if (s.wrap > 0) {
                    s.wrap = -s.wrap;
                }
                /* write the trailer only once! */
                return s.pending !== 0 ? Z_OK : Z_STREAM_END;
            }

            function deflateEnd(strm) {
                var status;

                if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/ ) {
                    return Z_STREAM_ERROR;
                }

                status = strm.state.status;
                if (status !== INIT_STATE &&
                    status !== EXTRA_STATE &&
                    status !== NAME_STATE &&
                    status !== COMMENT_STATE &&
                    status !== HCRC_STATE &&
                    status !== BUSY_STATE &&
                    status !== FINISH_STATE
                ) {
                    return err(strm, Z_STREAM_ERROR);
                }

                strm.state = null;

                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
            }


            /* =========================================================================
             * Initializes the compression dictionary from the given byte
             * sequence without producing any compressed output.
             */
            function deflateSetDictionary(strm, dictionary) {
                var dictLength = dictionary.length;

                var s;
                var str, n;
                var wrap;
                var avail;
                var next;
                var input;
                var tmpDict;

                if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/ ) {
                    return Z_STREAM_ERROR;
                }

                s = strm.state;
                wrap = s.wrap;

                if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
                    return Z_STREAM_ERROR;
                }

                /* when using zlib wrappers, compute Adler-32 for provided dictionary */
                if (wrap === 1) {
                    /* adler32(strm->adler, dictionary, dictLength); */
                    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
                }

                s.wrap = 0; /* avoid computing Adler-32 in read_buf */

                /* if dictionary would fill window, just replace the history */
                if (dictLength >= s.w_size) {
                    if (wrap === 0) { /* already empty otherwise */
                        /*** CLEAR_HASH(s); ***/
                        zero(s.head); // Fill with NIL (= 0);
                        s.strstart = 0;
                        s.block_start = 0;
                        s.insert = 0;
                    }
                    /* use the tail */
                    // dictionary = dictionary.slice(dictLength - s.w_size);
                    tmpDict = new utils.Buf8(s.w_size);
                    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                    dictionary = tmpDict;
                    dictLength = s.w_size;
                }
                /* insert dictionary into window and hash */
                avail = strm.avail_in;
                next = strm.next_in;
                input = strm.input;
                strm.avail_in = dictLength;
                strm.next_in = 0;
                strm.input = dictionary;
                fill_window(s);
                while (s.lookahead >= MIN_MATCH) {
                    str = s.strstart;
                    n = s.lookahead - (MIN_MATCH - 1);
                    do {
                        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

                        s.prev[str & s.w_mask] = s.head[s.ins_h];

                        s.head[s.ins_h] = str;
                        str++;
                    } while (--n);
                    s.strstart = str;
                    s.lookahead = MIN_MATCH - 1;
                    fill_window(s);
                }
                s.strstart += s.lookahead;
                s.block_start = s.strstart;
                s.insert = s.lookahead;
                s.lookahead = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                strm.next_in = next;
                strm.input = input;
                strm.avail_in = avail;
                s.wrap = wrap;
                return Z_OK;
            }


            exports.deflateInit = deflateInit;
            exports.deflateInit2 = deflateInit2;
            exports.deflateReset = deflateReset;
            exports.deflateResetKeep = deflateResetKeep;
            exports.deflateSetHeader = deflateSetHeader;
            exports.deflate = deflate;
            exports.deflateEnd = deflateEnd;
            exports.deflateSetDictionary = deflateSetDictionary;
            exports.deflateInfo = 'pako deflate (from Nodeca project)';

            /* Not implemented
            exports.deflateBound = deflateBound;
            exports.deflateCopy = deflateCopy;
            exports.deflateParams = deflateParams;
            exports.deflatePending = deflatePending;
            exports.deflatePrime = deflatePrime;
            exports.deflateTune = deflateTune;
            */

        }, {
            "../utils/common": 62,
            "./adler32": 64,
            "./crc32": 66,
            "./messages": 72,
            "./trees": 73
        }],
        68: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            function GZheader() {
                /* true if compressed data believed to be text */
                this.text = 0;
                /* modification time */
                this.time = 0;
                /* extra flags (not used when writing a gzip file) */
                this.xflags = 0;
                /* operating system */
                this.os = 0;
                /* pointer to extra field or Z_NULL if none */
                this.extra = null;
                /* extra field length (valid if extra != Z_NULL) */
                this.extra_len = 0; // Actually, we don't need it in JS,
                // but leave for few code modifications

                //
                // Setup limits is not necessary because in js we should not preallocate memory
                // for inflate use constant limit in 65536 bytes
                //

                /* space at extra (only when reading header) */
                // this.extra_max  = 0;
                /* pointer to zero-terminated file name or Z_NULL */
                this.name = '';
                /* space at name (only when reading header) */
                // this.name_max   = 0;
                /* pointer to zero-terminated comment or Z_NULL */
                this.comment = '';
                /* space at comment (only when reading header) */
                // this.comm_max   = 0;
                /* true if there was or will be a header crc */
                this.hcrc = 0;
                /* true when done reading gzip header (not used when writing a gzip file) */
                this.done = false;
            }

            module.exports = GZheader;

        }, {}],
        69: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            // See state defs from inflate.js
            var BAD = 30; /* got a data error -- remain here until reset */
            var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

            /*
               Decode literal, length, and distance codes and write out the resulting
               literal and match bytes until either not enough input or output is
               available, an end-of-block is encountered, or a data error is encountered.
               When large enough input and output buffers are supplied to inflate(), for
               example, a 16K input buffer and a 64K output buffer, more than 95% of the
               inflate execution time is spent in this routine.

               Entry assumptions:

                    state.mode === LEN
                    strm.avail_in >= 6
                    strm.avail_out >= 258
                    start >= strm.avail_out
                    state.bits < 8

               On return, state.mode is one of:

                    LEN -- ran out of enough output space or enough available input
                    TYPE -- reached end of block code, inflate() to interpret next block
                    BAD -- error in block data

               Notes:

                - The maximum input bits used by a length/distance pair is 15 bits for the
                  length code, 5 bits for the length extra, 15 bits for the distance code,
                  and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
                  Therefore if strm.avail_in >= 6, then there is enough input to avoid
                  checking for available input while decoding.

                - The maximum bytes that a single length/distance pair can output is 258
                  bytes, which is the maximum length that can be coded.  inflate_fast()
                  requires strm.avail_out >= 258 for each loop to avoid checking for
                  output space.
             */
            module.exports = function inflate_fast(strm, start) {
                var state;
                var _in; /* local strm.input */
                var last; /* have enough input while in < last */
                var _out; /* local strm.output */
                var beg; /* inflate()'s initial strm.output */
                var end; /* while out < end, enough space available */
                //#ifdef INFLATE_STRICT
                var dmax; /* maximum distance from zlib header */
                //#endif
                var wsize; /* window size or zero if not using window */
                var whave; /* valid bytes in the window */
                var wnext; /* window write index */
                // Use `s_window` instead `window`, avoid conflict with instrumentation tools
                var s_window; /* allocated sliding window, if wsize != 0 */
                var hold; /* local strm.hold */
                var bits; /* local strm.bits */
                var lcode; /* local strm.lencode */
                var dcode; /* local strm.distcode */
                var lmask; /* mask for first level of length codes */
                var dmask; /* mask for first level of distance codes */
                var here; /* retrieved table entry */
                var op; /* code bits, operation, extra bits, or */
                /*  window position, window bytes to copy */
                var len; /* match length, unused bytes */
                var dist; /* match distance */
                var from; /* where to copy match from */
                var from_source;


                var input, output; // JS specific, because we have no pointers

                /* copy state to local variables */
                state = strm.state;
                //here = state.here;
                _in = strm.next_in;
                input = strm.input;
                last = _in + (strm.avail_in - 5);
                _out = strm.next_out;
                output = strm.output;
                beg = _out - (start - strm.avail_out);
                end = _out + (strm.avail_out - 257);
                //#ifdef INFLATE_STRICT
                dmax = state.dmax;
                //#endif
                wsize = state.wsize;
                whave = state.whave;
                wnext = state.wnext;
                s_window = state.window;
                hold = state.hold;
                bits = state.bits;
                lcode = state.lencode;
                dcode = state.distcode;
                lmask = (1 << state.lenbits) - 1;
                dmask = (1 << state.distbits) - 1;


                /* decode literals and length/distances until end-of-block or not enough
                   input data or output space */

                top:
                    do {
                        if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                        }

                        here = lcode[hold & lmask];

                        dolen:
                            for (;;) { // Goto emulation
                                op = here >>> 24 /*here.bits*/ ;
                                hold >>>= op;
                                bits -= op;
                                op = (here >>> 16) & 0xff /*here.op*/ ;
                                if (op === 0) { /* literal */
                                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                    //        "inflate:         literal '%c'\n" :
                                    //        "inflate:         literal 0x%02x\n", here.val));
                                    output[_out++] = here & 0xffff /*here.val*/ ;
                                } else if (op & 16) { /* length base */
                                    len = here & 0xffff /*here.val*/ ;
                                    op &= 15; /* number of extra bits */
                                    if (op) {
                                        if (bits < op) {
                                            hold += input[_in++] << bits;
                                            bits += 8;
                                        }
                                        len += hold & ((1 << op) - 1);
                                        hold >>>= op;
                                        bits -= op;
                                    }
                                    //Tracevv((stderr, "inflate:         length %u\n", len));
                                    if (bits < 15) {
                                        hold += input[_in++] << bits;
                                        bits += 8;
                                        hold += input[_in++] << bits;
                                        bits += 8;
                                    }
                                    here = dcode[hold & dmask];

                                    dodist:
                                        for (;;) { // goto emulation
                                            op = here >>> 24 /*here.bits*/ ;
                                            hold >>>= op;
                                            bits -= op;
                                            op = (here >>> 16) & 0xff /*here.op*/ ;

                                            if (op & 16) { /* distance base */
                                                dist = here & 0xffff /*here.val*/ ;
                                                op &= 15; /* number of extra bits */
                                                if (bits < op) {
                                                    hold += input[_in++] << bits;
                                                    bits += 8;
                                                    if (bits < op) {
                                                        hold += input[_in++] << bits;
                                                        bits += 8;
                                                    }
                                                }
                                                dist += hold & ((1 << op) - 1);
                                                //#ifdef INFLATE_STRICT
                                                if (dist > dmax) {
                                                    strm.msg = 'invalid distance too far back';
                                                    state.mode = BAD;
                                                    break top;
                                                }
                                                //#endif
                                                hold >>>= op;
                                                bits -= op;
                                                //Tracevv((stderr, "inflate:         distance %u\n", dist));
                                                op = _out - beg; /* max distance in output */
                                                if (dist > op) { /* see if copy from window */
                                                    op = dist - op; /* distance back in window */
                                                    if (op > whave) {
                                                        if (state.sane) {
                                                            strm.msg = 'invalid distance too far back';
                                                            state.mode = BAD;
                                                            break top;
                                                        }

                                                        // (!) This block is disabled in zlib defailts,
                                                        // don't enable it for binary compatibility
                                                        //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                                        //                if (len <= op - whave) {
                                                        //                  do {
                                                        //                    output[_out++] = 0;
                                                        //                  } while (--len);
                                                        //                  continue top;
                                                        //                }
                                                        //                len -= op - whave;
                                                        //                do {
                                                        //                  output[_out++] = 0;
                                                        //                } while (--op > whave);
                                                        //                if (op === 0) {
                                                        //                  from = _out - dist;
                                                        //                  do {
                                                        //                    output[_out++] = output[from++];
                                                        //                  } while (--len);
                                                        //                  continue top;
                                                        //                }
                                                        //#endif
                                                    }
                                                    from = 0; // window index
                                                    from_source = s_window;
                                                    if (wnext === 0) { /* very common case */
                                                        from += wsize - op;
                                                        if (op < len) { /* some from window */
                                                            len -= op;
                                                            do {
                                                                output[_out++] = s_window[from++];
                                                            } while (--op);
                                                            from = _out - dist; /* rest from output */
                                                            from_source = output;
                                                        }
                                                    } else if (wnext < op) { /* wrap around window */
                                                        from += wsize + wnext - op;
                                                        op -= wnext;
                                                        if (op < len) { /* some from end of window */
                                                            len -= op;
                                                            do {
                                                                output[_out++] = s_window[from++];
                                                            } while (--op);
                                                            from = 0;
                                                            if (wnext < len) { /* some from start of window */
                                                                op = wnext;
                                                                len -= op;
                                                                do {
                                                                    output[_out++] = s_window[from++];
                                                                } while (--op);
                                                                from = _out - dist; /* rest from output */
                                                                from_source = output;
                                                            }
                                                        }
                                                    } else { /* contiguous in window */
                                                        from += wnext - op;
                                                        if (op < len) { /* some from window */
                                                            len -= op;
                                                            do {
                                                                output[_out++] = s_window[from++];
                                                            } while (--op);
                                                            from = _out - dist; /* rest from output */
                                                            from_source = output;
                                                        }
                                                    }
                                                    while (len > 2) {
                                                        output[_out++] = from_source[from++];
                                                        output[_out++] = from_source[from++];
                                                        output[_out++] = from_source[from++];
                                                        len -= 3;
                                                    }
                                                    if (len) {
                                                        output[_out++] = from_source[from++];
                                                        if (len > 1) {
                                                            output[_out++] = from_source[from++];
                                                        }
                                                    }
                                                } else {
                                                    from = _out - dist; /* copy direct from output */
                                                    do { /* minimum length is three */
                                                        output[_out++] = output[from++];
                                                        output[_out++] = output[from++];
                                                        output[_out++] = output[from++];
                                                        len -= 3;
                                                    } while (len > 2);
                                                    if (len) {
                                                        output[_out++] = output[from++];
                                                        if (len > 1) {
                                                            output[_out++] = output[from++];
                                                        }
                                                    }
                                                }
                                            } else if ((op & 64) === 0) { /* 2nd level distance code */
                                                here = dcode[(here & 0xffff) /*here.val*/ + (hold & ((1 << op) - 1))];
                                                continue dodist;
                                            } else {
                                                strm.msg = 'invalid distance code';
                                                state.mode = BAD;
                                                break top;
                                            }

                                            break; // need to emulate goto via "continue"
                                        }
                                } else if ((op & 64) === 0) { /* 2nd level length code */
                                    here = lcode[(here & 0xffff) /*here.val*/ + (hold & ((1 << op) - 1))];
                                    continue dolen;
                                } else if (op & 32) { /* end-of-block */
                                    //Tracevv((stderr, "inflate:         end of block\n"));
                                    state.mode = TYPE;
                                    break top;
                                } else {
                                    strm.msg = 'invalid literal/length code';
                                    state.mode = BAD;
                                    break top;
                                }

                                break; // need to emulate goto via "continue"
                            }
                    } while (_in < last && _out < end);

                /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
                len = bits >> 3;
                _in -= len;
                bits -= len << 3;
                hold &= (1 << bits) - 1;

                /* update state and return */
                strm.next_in = _in;
                strm.next_out = _out;
                strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
                strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
                state.hold = hold;
                state.bits = bits;
                return;
            };

        }, {}],
        70: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            var utils = require('../utils/common');
            var adler32 = require('./adler32');
            var crc32 = require('./crc32');
            var inflate_fast = require('./inffast');
            var inflate_table = require('./inftrees');

            var CODES = 0;
            var LENS = 1;
            var DISTS = 2;

            /* Public constants ==========================================================*/
            /* ===========================================================================*/


            /* Allowed flush values; see deflate() and inflate() below for details */
            //var Z_NO_FLUSH      = 0;
            //var Z_PARTIAL_FLUSH = 1;
            //var Z_SYNC_FLUSH    = 2;
            //var Z_FULL_FLUSH    = 3;
            var Z_FINISH = 4;
            var Z_BLOCK = 5;
            var Z_TREES = 6;


            /* Return codes for the compression/decompression functions. Negative values
             * are errors, positive values are used for special but normal events.
             */
            var Z_OK = 0;
            var Z_STREAM_END = 1;
            var Z_NEED_DICT = 2;
            //var Z_ERRNO         = -1;
            var Z_STREAM_ERROR = -2;
            var Z_DATA_ERROR = -3;
            var Z_MEM_ERROR = -4;
            var Z_BUF_ERROR = -5;
            //var Z_VERSION_ERROR = -6;

            /* The deflate compression method */
            var Z_DEFLATED = 8;


            /* STATES ====================================================================*/
            /* ===========================================================================*/


            var HEAD = 1; /* i: waiting for magic header */
            var FLAGS = 2; /* i: waiting for method and flags (gzip) */
            var TIME = 3; /* i: waiting for modification time (gzip) */
            var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
            var EXLEN = 5; /* i: waiting for extra length (gzip) */
            var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
            var NAME = 7; /* i: waiting for end of file name (gzip) */
            var COMMENT = 8; /* i: waiting for end of comment (gzip) */
            var HCRC = 9; /* i: waiting for header crc (gzip) */
            var DICTID = 10; /* i: waiting for dictionary check value */
            var DICT = 11; /* waiting for inflateSetDictionary() call */
            var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
            var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
            var STORED = 14; /* i: waiting for stored size (length and complement) */
            var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
            var COPY = 16; /* i/o: waiting for input or output to copy stored block */
            var TABLE = 17; /* i: waiting for dynamic block table lengths */
            var LENLENS = 18; /* i: waiting for code length code lengths */
            var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
            var LEN_ = 20; /* i: same as LEN below, but only first time in */
            var LEN = 21; /* i: waiting for length/lit/eob code */
            var LENEXT = 22; /* i: waiting for length extra bits */
            var DIST = 23; /* i: waiting for distance code */
            var DISTEXT = 24; /* i: waiting for distance extra bits */
            var MATCH = 25; /* o: waiting for output space to copy string */
            var LIT = 26; /* o: waiting for output space to write literal */
            var CHECK = 27; /* i: waiting for 32-bit check value */
            var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
            var DONE = 29; /* finished check, done -- remain here until reset */
            var BAD = 30; /* got a data error -- remain here until reset */
            var MEM = 31; /* got an inflate() memory error -- remain here until reset */
            var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

            /* ===========================================================================*/



            var ENOUGH_LENS = 852;
            var ENOUGH_DISTS = 592;
            //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

            var MAX_WBITS = 15;
            /* 32K LZ77 window */
            var DEF_WBITS = MAX_WBITS;


            function zswap32(q) {
                return (((q >>> 24) & 0xff) +
                    ((q >>> 8) & 0xff00) +
                    ((q & 0xff00) << 8) +
                    ((q & 0xff) << 24));
            }


            function InflateState() {
                this.mode = 0; /* current inflate mode */
                this.last = false; /* true if processing last block */
                this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
                this.havedict = false; /* true if dictionary provided */
                this.flags = 0; /* gzip header method and flags (0 if zlib) */
                this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
                this.check = 0; /* protected copy of check value */
                this.total = 0; /* protected copy of output count */
                // TODO: may be {}
                this.head = null; /* where to save gzip header information */

                /* sliding window */
                this.wbits = 0; /* log base 2 of requested window size */
                this.wsize = 0; /* window size or zero if not using window */
                this.whave = 0; /* valid bytes in the window */
                this.wnext = 0; /* window write index */
                this.window = null; /* allocated sliding window, if needed */

                /* bit accumulator */
                this.hold = 0; /* input bit accumulator */
                this.bits = 0; /* number of bits in "in" */

                /* for string and stored block copying */
                this.length = 0; /* literal or length of data to copy */
                this.offset = 0; /* distance back to copy string from */

                /* for table and code decoding */
                this.extra = 0; /* extra bits needed */

                /* fixed and dynamic code tables */
                this.lencode = null; /* starting table for length/literal codes */
                this.distcode = null; /* starting table for distance codes */
                this.lenbits = 0; /* index bits for lencode */
                this.distbits = 0; /* index bits for distcode */

                /* dynamic table building */
                this.ncode = 0; /* number of code length code lengths */
                this.nlen = 0; /* number of length code lengths */
                this.ndist = 0; /* number of distance code lengths */
                this.have = 0; /* number of code lengths in lens[] */
                this.next = null; /* next available space in codes[] */

                this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
                this.work = new utils.Buf16(288); /* work area for code table building */

                /*
                 because we don't have pointers in js, we use lencode and distcode directly
                 as buffers so we don't need codes
                */
                //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
                this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
                this.distdyn = null; /* dynamic table for distance codes (JS specific) */
                this.sane = 0; /* if false, allow invalid distance too far */
                this.back = 0; /* bits back of last unprocessed length/lit */
                this.was = 0; /* initial length of match */
            }

            function inflateResetKeep(strm) {
                var state;

                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                strm.total_in = strm.total_out = state.total = 0;
                strm.msg = ''; /*Z_NULL*/
                if (state.wrap) { /* to support ill-conceived Java test suite */
                    strm.adler = state.wrap & 1;
                }
                state.mode = HEAD;
                state.last = 0;
                state.havedict = 0;
                state.dmax = 32768;
                state.head = null /*Z_NULL*/ ;
                state.hold = 0;
                state.bits = 0;
                //state.lencode = state.distcode = state.next = state.codes;
                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

                state.sane = 1;
                state.back = -1;
                //Tracev((stderr, "inflate: reset\n"));
                return Z_OK;
            }

            function inflateReset(strm) {
                var state;

                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                state.wsize = 0;
                state.whave = 0;
                state.wnext = 0;
                return inflateResetKeep(strm);

            }

            function inflateReset2(strm, windowBits) {
                var wrap;
                var state;

                /* get the state */
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;

                /* extract wrap request from windowBits parameter */
                if (windowBits < 0) {
                    wrap = 0;
                    windowBits = -windowBits;
                } else {
                    wrap = (windowBits >> 4) + 1;
                    if (windowBits < 48) {
                        windowBits &= 15;
                    }
                }

                /* set number of window bits, free window if different */
                if (windowBits && (windowBits < 8 || windowBits > 15)) {
                    return Z_STREAM_ERROR;
                }
                if (state.window !== null && state.wbits !== windowBits) {
                    state.window = null;
                }

                /* update state and reset the rest of it */
                state.wrap = wrap;
                state.wbits = windowBits;
                return inflateReset(strm);
            }

            function inflateInit2(strm, windowBits) {
                var ret;
                var state;

                if (!strm) {
                    return Z_STREAM_ERROR;
                }
                //strm.msg = Z_NULL;                 /* in case we return an error */

                state = new InflateState();

                //if (state === Z_NULL) return Z_MEM_ERROR;
                //Tracev((stderr, "inflate: allocated\n"));
                strm.state = state;
                state.window = null /*Z_NULL*/ ;
                ret = inflateReset2(strm, windowBits);
                if (ret !== Z_OK) {
                    strm.state = null /*Z_NULL*/ ;
                }
                return ret;
            }

            function inflateInit(strm) {
                return inflateInit2(strm, DEF_WBITS);
            }


            /*
             Return state with length and distance decoding tables and index sizes set to
             fixed code decoding.  Normally this returns fixed tables from inffixed.h.
             If BUILDFIXED is defined, then instead this routine builds the tables the
             first time it's called, and returns those tables the first time and
             thereafter.  This reduces the size of the code by about 2K bytes, in
             exchange for a little execution time.  However, BUILDFIXED should not be
             used for threaded applications, since the rewriting of the tables and virgin
             may not be thread-safe.
             */
            var virgin = true;

            var lenfix, distfix; // We have no pointers in JS, so keep tables separate

            function fixedtables(state) {
                /* build fixed huffman tables if first call (may not be thread safe) */
                if (virgin) {
                    var sym;

                    lenfix = new utils.Buf32(512);
                    distfix = new utils.Buf32(32);

                    /* literal/length table */
                    sym = 0;
                    while (sym < 144) {
                        state.lens[sym++] = 8;
                    }
                    while (sym < 256) {
                        state.lens[sym++] = 9;
                    }
                    while (sym < 280) {
                        state.lens[sym++] = 7;
                    }
                    while (sym < 288) {
                        state.lens[sym++] = 8;
                    }

                    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                        bits: 9
                    });

                    /* distance table */
                    sym = 0;
                    while (sym < 32) {
                        state.lens[sym++] = 5;
                    }

                    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                        bits: 5
                    });

                    /* do this just once */
                    virgin = false;
                }

                state.lencode = lenfix;
                state.lenbits = 9;
                state.distcode = distfix;
                state.distbits = 5;
            }


            /*
             Update the window with the last wsize (normally 32K) bytes written before
             returning.  If window does not exist yet, create it.  This is only called
             when a window is already in use, or when output has been written during this
             inflate call, but the end of the deflate stream has not been reached yet.
             It is also called to create a window for dictionary data when a dictionary
             is loaded.

             Providing output buffers larger than 32K to inflate() should provide a speed
             advantage, since only the last 32K of output is copied to the sliding window
             upon return from inflate(), and since all distances after the first 32K of
             output will fall in the output data, making match copies simpler and faster.
             The advantage may be dependent on the size of the processor's data caches.
             */
            function updatewindow(strm, src, end, copy) {
                var dist;
                var state = strm.state;

                /* if it hasn't been done already, allocate space for the window */
                if (state.window === null) {
                    state.wsize = 1 << state.wbits;
                    state.wnext = 0;
                    state.whave = 0;

                    state.window = new utils.Buf8(state.wsize);
                }

                /* copy state->wsize or less output bytes into the circular window */
                if (copy >= state.wsize) {
                    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                    state.wnext = 0;
                    state.whave = state.wsize;
                } else {
                    dist = state.wsize - state.wnext;
                    if (dist > copy) {
                        dist = copy;
                    }
                    //zmemcpy(state->window + state->wnext, end - copy, dist);
                    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                    copy -= dist;
                    if (copy) {
                        //zmemcpy(state->window, end - copy, copy);
                        utils.arraySet(state.window, src, end - copy, copy, 0);
                        state.wnext = copy;
                        state.whave = state.wsize;
                    } else {
                        state.wnext += dist;
                        if (state.wnext === state.wsize) {
                            state.wnext = 0;
                        }
                        if (state.whave < state.wsize) {
                            state.whave += dist;
                        }
                    }
                }
                return 0;
            }

            function inflate(strm, flush) {
                var state;
                var input, output; // input/output buffers
                var next; /* next input INDEX */
                var put; /* next output INDEX */
                var have, left; /* available input and output */
                var hold; /* bit buffer */
                var bits; /* bits in bit buffer */
                var _in, _out; /* save starting available input and output */
                var copy; /* number of stored or match bytes to copy */
                var from; /* where to copy match bytes from */
                var from_source;
                var here = 0; /* current decoding table entry */
                var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
                //var last;                   /* parent table entry */
                var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
                var len; /* length to copy for repeats, bits to drop */
                var ret; /* return code */
                var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
                var opts;

                var n; // temporary var for NEED_BITS

                var order = /* permutation of code lengths */
                    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


                if (!strm || !strm.state || !strm.output ||
                    (!strm.input && strm.avail_in !== 0)) {
                    return Z_STREAM_ERROR;
                }

                state = strm.state;
                if (state.mode === TYPE) {
                    state.mode = TYPEDO;
                } /* skip check */


                //--- LOAD() ---
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                //---

                _in = have;
                _out = left;
                ret = Z_OK;

                inf_leave: // goto emulation
                    for (;;) {
                        switch (state.mode) {
                            case HEAD:
                                if (state.wrap === 0) {
                                    state.mode = TYPEDO;
                                    break;
                                }
                                //=== NEEDBITS(16);
                                while (bits < 16) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                if ((state.wrap & 2) && hold === 0x8b1f) { /* gzip header */
                                    state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;
                                    //=== CRC2(state.check, hold);
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                    //===//

                                    //=== INITBITS();
                                    hold = 0;
                                    bits = 0;
                                    //===//
                                    state.mode = FLAGS;
                                    break;
                                }
                                state.flags = 0; /* expect zlib header */
                                if (state.head) {
                                    state.head.done = false;
                                }
                                if (!(state.wrap & 1) || /* check if zlib header allowed */
                                    (((hold & 0xff) /*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
                                    strm.msg = 'incorrect header check';
                                    state.mode = BAD;
                                    break;
                                }
                                if ((hold & 0x0f) /*BITS(4)*/ !== Z_DEFLATED) {
                                    strm.msg = 'unknown compression method';
                                    state.mode = BAD;
                                    break;
                                }
                                //--- DROPBITS(4) ---//
                                hold >>>= 4;
                                bits -= 4;
                                //---//
                                len = (hold & 0x0f) /*BITS(4)*/ + 8;
                                if (state.wbits === 0) {
                                    state.wbits = len;
                                } else if (len > state.wbits) {
                                    strm.msg = 'invalid window size';
                                    state.mode = BAD;
                                    break;
                                }
                                state.dmax = 1 << len;
                                //Tracev((stderr, "inflate:   zlib header ok\n"));
                                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;
                                state.mode = hold & 0x200 ? DICTID : TYPE;
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                break;
                            case FLAGS:
                                //=== NEEDBITS(16); */
                                while (bits < 16) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.flags = hold;
                                if ((state.flags & 0xff) !== Z_DEFLATED) {
                                    strm.msg = 'unknown compression method';
                                    state.mode = BAD;
                                    break;
                                }
                                if (state.flags & 0xe000) {
                                    strm.msg = 'unknown header flags set';
                                    state.mode = BAD;
                                    break;
                                }
                                if (state.head) {
                                    state.head.text = ((hold >> 8) & 1);
                                }
                                if (state.flags & 0x0200) {
                                    //=== CRC2(state.check, hold);
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                    //===//
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = TIME;
                                /* falls through */
                            case TIME:
                                //=== NEEDBITS(32); */
                                while (bits < 32) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                if (state.head) {
                                    state.head.time = hold;
                                }
                                if (state.flags & 0x0200) {
                                    //=== CRC4(state.check, hold)
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    hbuf[2] = (hold >>> 16) & 0xff;
                                    hbuf[3] = (hold >>> 24) & 0xff;
                                    state.check = crc32(state.check, hbuf, 4, 0);
                                    //===
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = OS;
                                /* falls through */
                            case OS:
                                //=== NEEDBITS(16); */
                                while (bits < 16) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                if (state.head) {
                                    state.head.xflags = (hold & 0xff);
                                    state.head.os = (hold >> 8);
                                }
                                if (state.flags & 0x0200) {
                                    //=== CRC2(state.check, hold);
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                    //===//
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = EXLEN;
                                /* falls through */
                            case EXLEN:
                                if (state.flags & 0x0400) {
                                    //=== NEEDBITS(16); */
                                    while (bits < 16) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    state.length = hold;
                                    if (state.head) {
                                        state.head.extra_len = hold;
                                    }
                                    if (state.flags & 0x0200) {
                                        //=== CRC2(state.check, hold);
                                        hbuf[0] = hold & 0xff;
                                        hbuf[1] = (hold >>> 8) & 0xff;
                                        state.check = crc32(state.check, hbuf, 2, 0);
                                        //===//
                                    }
                                    //=== INITBITS();
                                    hold = 0;
                                    bits = 0;
                                    //===//
                                } else if (state.head) {
                                    state.head.extra = null /*Z_NULL*/ ;
                                }
                                state.mode = EXTRA;
                                /* falls through */
                            case EXTRA:
                                if (state.flags & 0x0400) {
                                    copy = state.length;
                                    if (copy > have) {
                                        copy = have;
                                    }
                                    if (copy) {
                                        if (state.head) {
                                            len = state.head.extra_len - state.length;
                                            if (!state.head.extra) {
                                                // Use untyped array for more conveniend processing later
                                                state.head.extra = new Array(state.head.extra_len);
                                            }
                                            utils.arraySet(
                                                state.head.extra,
                                                input,
                                                next,
                                                // extra field is limited to 65536 bytes
                                                // - no need for additional size check
                                                copy,
                                                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                                len
                                            );
                                            //zmemcpy(state.head.extra + len, next,
                                            //        len + copy > state.head.extra_max ?
                                            //        state.head.extra_max - len : copy);
                                        }
                                        if (state.flags & 0x0200) {
                                            state.check = crc32(state.check, input, copy, next);
                                        }
                                        have -= copy;
                                        next += copy;
                                        state.length -= copy;
                                    }
                                    if (state.length) {
                                        break inf_leave;
                                    }
                                }
                                state.length = 0;
                                state.mode = NAME;
                                /* falls through */
                            case NAME:
                                if (state.flags & 0x0800) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    copy = 0;
                                    do {
                                        // TODO: 2 or 1 bytes?
                                        len = input[next + copy++];
                                        /* use constant limit because in js we should not preallocate memory */
                                        if (state.head && len &&
                                            (state.length < 65536 /*state.head.name_max*/ )) {
                                            state.head.name += String.fromCharCode(len);
                                        }
                                    } while (len && copy < have);

                                    if (state.flags & 0x0200) {
                                        state.check = crc32(state.check, input, copy, next);
                                    }
                                    have -= copy;
                                    next += copy;
                                    if (len) {
                                        break inf_leave;
                                    }
                                } else if (state.head) {
                                    state.head.name = null;
                                }
                                state.length = 0;
                                state.mode = COMMENT;
                                /* falls through */
                            case COMMENT:
                                if (state.flags & 0x1000) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    copy = 0;
                                    do {
                                        len = input[next + copy++];
                                        /* use constant limit because in js we should not preallocate memory */
                                        if (state.head && len &&
                                            (state.length < 65536 /*state.head.comm_max*/ )) {
                                            state.head.comment += String.fromCharCode(len);
                                        }
                                    } while (len && copy < have);
                                    if (state.flags & 0x0200) {
                                        state.check = crc32(state.check, input, copy, next);
                                    }
                                    have -= copy;
                                    next += copy;
                                    if (len) {
                                        break inf_leave;
                                    }
                                } else if (state.head) {
                                    state.head.comment = null;
                                }
                                state.mode = HCRC;
                                /* falls through */
                            case HCRC:
                                if (state.flags & 0x0200) {
                                    //=== NEEDBITS(16); */
                                    while (bits < 16) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    if (hold !== (state.check & 0xffff)) {
                                        strm.msg = 'header crc mismatch';
                                        state.mode = BAD;
                                        break;
                                    }
                                    //=== INITBITS();
                                    hold = 0;
                                    bits = 0;
                                    //===//
                                }
                                if (state.head) {
                                    state.head.hcrc = ((state.flags >> 9) & 1);
                                    state.head.done = true;
                                }
                                strm.adler = state.check = 0;
                                state.mode = TYPE;
                                break;
                            case DICTID:
                                //=== NEEDBITS(32); */
                                while (bits < 32) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                strm.adler = state.check = zswap32(hold);
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = DICT;
                                /* falls through */
                            case DICT:
                                if (state.havedict === 0) {
                                    //--- RESTORE() ---
                                    strm.next_out = put;
                                    strm.avail_out = left;
                                    strm.next_in = next;
                                    strm.avail_in = have;
                                    state.hold = hold;
                                    state.bits = bits;
                                    //---
                                    return Z_NEED_DICT;
                                }
                                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;
                                state.mode = TYPE;
                                /* falls through */
                            case TYPE:
                                if (flush === Z_BLOCK || flush === Z_TREES) {
                                    break inf_leave;
                                }
                                /* falls through */
                            case TYPEDO:
                                if (state.last) {
                                    //--- BYTEBITS() ---//
                                    hold >>>= bits & 7;
                                    bits -= bits & 7;
                                    //---//
                                    state.mode = CHECK;
                                    break;
                                }
                                //=== NEEDBITS(3); */
                                while (bits < 3) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.last = (hold & 0x01) /*BITS(1)*/ ;
                                //--- DROPBITS(1) ---//
                                hold >>>= 1;
                                bits -= 1;
                                //---//

                                switch ((hold & 0x03) /*BITS(2)*/ ) {
                                    case 0:
                                        /* stored block */
                                        //Tracev((stderr, "inflate:     stored block%s\n",
                                        //        state.last ? " (last)" : ""));
                                        state.mode = STORED;
                                        break;
                                    case 1:
                                        /* fixed block */
                                        fixedtables(state);
                                        //Tracev((stderr, "inflate:     fixed codes block%s\n",
                                        //        state.last ? " (last)" : ""));
                                        state.mode = LEN_; /* decode codes */
                                        if (flush === Z_TREES) {
                                            //--- DROPBITS(2) ---//
                                            hold >>>= 2;
                                            bits -= 2;
                                            //---//
                                            break inf_leave;
                                        }
                                        break;
                                    case 2:
                                        /* dynamic block */
                                        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                                        //        state.last ? " (last)" : ""));
                                        state.mode = TABLE;
                                        break;
                                    case 3:
                                        strm.msg = 'invalid block type';
                                        state.mode = BAD;
                                }
                                //--- DROPBITS(2) ---//
                                hold >>>= 2;
                                bits -= 2;
                                //---//
                                break;
                            case STORED:
                                //--- BYTEBITS() ---// /* go to byte boundary */
                                hold >>>= bits & 7;
                                bits -= bits & 7;
                                //---//
                                //=== NEEDBITS(32); */
                                while (bits < 32) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                                    strm.msg = 'invalid stored block lengths';
                                    state.mode = BAD;
                                    break;
                                }
                                state.length = hold & 0xffff;
                                //Tracev((stderr, "inflate:       stored length %u\n",
                                //        state.length));
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = COPY_;
                                if (flush === Z_TREES) {
                                    break inf_leave;
                                }
                                /* falls through */
                            case COPY_:
                                state.mode = COPY;
                                /* falls through */
                            case COPY:
                                copy = state.length;
                                if (copy) {
                                    if (copy > have) {
                                        copy = have;
                                    }
                                    if (copy > left) {
                                        copy = left;
                                    }
                                    if (copy === 0) {
                                        break inf_leave;
                                    }
                                    //--- zmemcpy(put, next, copy); ---
                                    utils.arraySet(output, input, next, copy, put);
                                    //---//
                                    have -= copy;
                                    next += copy;
                                    left -= copy;
                                    put += copy;
                                    state.length -= copy;
                                    break;
                                }
                                //Tracev((stderr, "inflate:       stored end\n"));
                                state.mode = TYPE;
                                break;
                            case TABLE:
                                //=== NEEDBITS(14); */
                                while (bits < 14) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.nlen = (hold & 0x1f) /*BITS(5)*/ + 257;
                                //--- DROPBITS(5) ---//
                                hold >>>= 5;
                                bits -= 5;
                                //---//
                                state.ndist = (hold & 0x1f) /*BITS(5)*/ + 1;
                                //--- DROPBITS(5) ---//
                                hold >>>= 5;
                                bits -= 5;
                                //---//
                                state.ncode = (hold & 0x0f) /*BITS(4)*/ + 4;
                                //--- DROPBITS(4) ---//
                                hold >>>= 4;
                                bits -= 4;
                                //---//
                                //#ifndef PKZIP_BUG_WORKAROUND
                                if (state.nlen > 286 || state.ndist > 30) {
                                    strm.msg = 'too many length or distance symbols';
                                    state.mode = BAD;
                                    break;
                                }
                                //#endif
                                //Tracev((stderr, "inflate:       table sizes ok\n"));
                                state.have = 0;
                                state.mode = LENLENS;
                                /* falls through */
                            case LENLENS:
                                while (state.have < state.ncode) {
                                    //=== NEEDBITS(3);
                                    while (bits < 3) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    state.lens[order[state.have++]] = (hold & 0x07); //BITS(3);
                                    //--- DROPBITS(3) ---//
                                    hold >>>= 3;
                                    bits -= 3;
                                    //---//
                                }
                                while (state.have < 19) {
                                    state.lens[order[state.have++]] = 0;
                                }
                                // We have separate tables & no pointers. 2 commented lines below not needed.
                                //state.next = state.codes;
                                //state.lencode = state.next;
                                // Switch to use dynamic table
                                state.lencode = state.lendyn;
                                state.lenbits = 7;

                                opts = {
                                    bits: state.lenbits
                                };
                                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                                state.lenbits = opts.bits;

                                if (ret) {
                                    strm.msg = 'invalid code lengths set';
                                    state.mode = BAD;
                                    break;
                                }
                                //Tracev((stderr, "inflate:       code lengths ok\n"));
                                state.have = 0;
                                state.mode = CODELENS;
                                /* falls through */
                            case CODELENS:
                                while (state.have < state.nlen + state.ndist) {
                                    for (;;) {
                                        here = state.lencode[hold & ((1 << state.lenbits) - 1)]; /*BITS(state.lenbits)*/
                                        here_bits = here >>> 24;
                                        here_op = (here >>> 16) & 0xff;
                                        here_val = here & 0xffff;

                                        if ((here_bits) <= bits) {
                                            break;
                                        }
                                        //--- PULLBYTE() ---//
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                        //---//
                                    }
                                    if (here_val < 16) {
                                        //--- DROPBITS(here.bits) ---//
                                        hold >>>= here_bits;
                                        bits -= here_bits;
                                        //---//
                                        state.lens[state.have++] = here_val;
                                    } else {
                                        if (here_val === 16) {
                                            //=== NEEDBITS(here.bits + 2);
                                            n = here_bits + 2;
                                            while (bits < n) {
                                                if (have === 0) {
                                                    break inf_leave;
                                                }
                                                have--;
                                                hold += input[next++] << bits;
                                                bits += 8;
                                            }
                                            //===//
                                            //--- DROPBITS(here.bits) ---//
                                            hold >>>= here_bits;
                                            bits -= here_bits;
                                            //---//
                                            if (state.have === 0) {
                                                strm.msg = 'invalid bit length repeat';
                                                state.mode = BAD;
                                                break;
                                            }
                                            len = state.lens[state.have - 1];
                                            copy = 3 + (hold & 0x03); //BITS(2);
                                            //--- DROPBITS(2) ---//
                                            hold >>>= 2;
                                            bits -= 2;
                                            //---//
                                        } else if (here_val === 17) {
                                            //=== NEEDBITS(here.bits + 3);
                                            n = here_bits + 3;
                                            while (bits < n) {
                                                if (have === 0) {
                                                    break inf_leave;
                                                }
                                                have--;
                                                hold += input[next++] << bits;
                                                bits += 8;
                                            }
                                            //===//
                                            //--- DROPBITS(here.bits) ---//
                                            hold >>>= here_bits;
                                            bits -= here_bits;
                                            //---//
                                            len = 0;
                                            copy = 3 + (hold & 0x07); //BITS(3);
                                            //--- DROPBITS(3) ---//
                                            hold >>>= 3;
                                            bits -= 3;
                                            //---//
                                        } else {
                                            //=== NEEDBITS(here.bits + 7);
                                            n = here_bits + 7;
                                            while (bits < n) {
                                                if (have === 0) {
                                                    break inf_leave;
                                                }
                                                have--;
                                                hold += input[next++] << bits;
                                                bits += 8;
                                            }
                                            //===//
                                            //--- DROPBITS(here.bits) ---//
                                            hold >>>= here_bits;
                                            bits -= here_bits;
                                            //---//
                                            len = 0;
                                            copy = 11 + (hold & 0x7f); //BITS(7);
                                            //--- DROPBITS(7) ---//
                                            hold >>>= 7;
                                            bits -= 7;
                                            //---//
                                        }
                                        if (state.have + copy > state.nlen + state.ndist) {
                                            strm.msg = 'invalid bit length repeat';
                                            state.mode = BAD;
                                            break;
                                        }
                                        while (copy--) {
                                            state.lens[state.have++] = len;
                                        }
                                    }
                                }

                                /* handle error breaks in while */
                                if (state.mode === BAD) {
                                    break;
                                }

                                /* check for end-of-block code (better have one) */
                                if (state.lens[256] === 0) {
                                    strm.msg = 'invalid code -- missing end-of-block';
                                    state.mode = BAD;
                                    break;
                                }

                                /* build code tables -- note: do not change the lenbits or distbits
                                   values here (9 and 6) without reading the comments in inftrees.h
                                   concerning the ENOUGH constants, which depend on those values */
                                state.lenbits = 9;

                                opts = {
                                    bits: state.lenbits
                                };
                                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                                // We have separate tables & no pointers. 2 commented lines below not needed.
                                // state.next_index = opts.table_index;
                                state.lenbits = opts.bits;
                                // state.lencode = state.next;

                                if (ret) {
                                    strm.msg = 'invalid literal/lengths set';
                                    state.mode = BAD;
                                    break;
                                }

                                state.distbits = 6;
                                //state.distcode.copy(state.codes);
                                // Switch to use dynamic table
                                state.distcode = state.distdyn;
                                opts = {
                                    bits: state.distbits
                                };
                                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                                // We have separate tables & no pointers. 2 commented lines below not needed.
                                // state.next_index = opts.table_index;
                                state.distbits = opts.bits;
                                // state.distcode = state.next;

                                if (ret) {
                                    strm.msg = 'invalid distances set';
                                    state.mode = BAD;
                                    break;
                                }
                                //Tracev((stderr, 'inflate:       codes ok\n'));
                                state.mode = LEN_;
                                if (flush === Z_TREES) {
                                    break inf_leave;
                                }
                                /* falls through */
                            case LEN_:
                                state.mode = LEN;
                                /* falls through */
                            case LEN:
                                if (have >= 6 && left >= 258) {
                                    //--- RESTORE() ---
                                    strm.next_out = put;
                                    strm.avail_out = left;
                                    strm.next_in = next;
                                    strm.avail_in = have;
                                    state.hold = hold;
                                    state.bits = bits;
                                    //---
                                    inflate_fast(strm, _out);
                                    //--- LOAD() ---
                                    put = strm.next_out;
                                    output = strm.output;
                                    left = strm.avail_out;
                                    next = strm.next_in;
                                    input = strm.input;
                                    have = strm.avail_in;
                                    hold = state.hold;
                                    bits = state.bits;
                                    //---

                                    if (state.mode === TYPE) {
                                        state.back = -1;
                                    }
                                    break;
                                }
                                state.back = 0;
                                for (;;) {
                                    here = state.lencode[hold & ((1 << state.lenbits) - 1)]; /*BITS(state.lenbits)*/
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;

                                    if (here_bits <= bits) {
                                        break;
                                    }
                                    //--- PULLBYTE() ---//
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                    //---//
                                }
                                if (here_op && (here_op & 0xf0) === 0) {
                                    last_bits = here_bits;
                                    last_op = here_op;
                                    last_val = here_val;
                                    for (;;) {
                                        here = state.lencode[last_val +
                                            ((hold & ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >> last_bits)];
                                        here_bits = here >>> 24;
                                        here_op = (here >>> 16) & 0xff;
                                        here_val = here & 0xffff;

                                        if ((last_bits + here_bits) <= bits) {
                                            break;
                                        }
                                        //--- PULLBYTE() ---//
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                        //---//
                                    }
                                    //--- DROPBITS(last.bits) ---//
                                    hold >>>= last_bits;
                                    bits -= last_bits;
                                    //---//
                                    state.back += last_bits;
                                }
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                state.back += here_bits;
                                state.length = here_val;
                                if (here_op === 0) {
                                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                    //        "inflate:         literal '%c'\n" :
                                    //        "inflate:         literal 0x%02x\n", here.val));
                                    state.mode = LIT;
                                    break;
                                }
                                if (here_op & 32) {
                                    //Tracevv((stderr, "inflate:         end of block\n"));
                                    state.back = -1;
                                    state.mode = TYPE;
                                    break;
                                }
                                if (here_op & 64) {
                                    strm.msg = 'invalid literal/length code';
                                    state.mode = BAD;
                                    break;
                                }
                                state.extra = here_op & 15;
                                state.mode = LENEXT;
                                /* falls through */
                            case LENEXT:
                                if (state.extra) {
                                    //=== NEEDBITS(state.extra);
                                    n = state.extra;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    state.length += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/ ;
                                    //--- DROPBITS(state.extra) ---//
                                    hold >>>= state.extra;
                                    bits -= state.extra;
                                    //---//
                                    state.back += state.extra;
                                }
                                //Tracevv((stderr, "inflate:         length %u\n", state.length));
                                state.was = state.length;
                                state.mode = DIST;
                                /* falls through */
                            case DIST:
                                for (;;) {
                                    here = state.distcode[hold & ((1 << state.distbits) - 1)]; /*BITS(state.distbits)*/
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;

                                    if ((here_bits) <= bits) {
                                        break;
                                    }
                                    //--- PULLBYTE() ---//
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                    //---//
                                }
                                if ((here_op & 0xf0) === 0) {
                                    last_bits = here_bits;
                                    last_op = here_op;
                                    last_val = here_val;
                                    for (;;) {
                                        here = state.distcode[last_val +
                                            ((hold & ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >> last_bits)];
                                        here_bits = here >>> 24;
                                        here_op = (here >>> 16) & 0xff;
                                        here_val = here & 0xffff;

                                        if ((last_bits + here_bits) <= bits) {
                                            break;
                                        }
                                        //--- PULLBYTE() ---//
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                        //---//
                                    }
                                    //--- DROPBITS(last.bits) ---//
                                    hold >>>= last_bits;
                                    bits -= last_bits;
                                    //---//
                                    state.back += last_bits;
                                }
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                state.back += here_bits;
                                if (here_op & 64) {
                                    strm.msg = 'invalid distance code';
                                    state.mode = BAD;
                                    break;
                                }
                                state.offset = here_val;
                                state.extra = (here_op) & 15;
                                state.mode = DISTEXT;
                                /* falls through */
                            case DISTEXT:
                                if (state.extra) {
                                    //=== NEEDBITS(state.extra);
                                    n = state.extra;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    state.offset += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/ ;
                                    //--- DROPBITS(state.extra) ---//
                                    hold >>>= state.extra;
                                    bits -= state.extra;
                                    //---//
                                    state.back += state.extra;
                                }
                                //#ifdef INFLATE_STRICT
                                if (state.offset > state.dmax) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break;
                                }
                                //#endif
                                //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                                state.mode = MATCH;
                                /* falls through */
                            case MATCH:
                                if (left === 0) {
                                    break inf_leave;
                                }
                                copy = _out - left;
                                if (state.offset > copy) { /* copy from window */
                                    copy = state.offset - copy;
                                    if (copy > state.whave) {
                                        if (state.sane) {
                                            strm.msg = 'invalid distance too far back';
                                            state.mode = BAD;
                                            break;
                                        }
                                        // (!) This block is disabled in zlib defailts,
                                        // don't enable it for binary compatibility
                                        //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                        //          Trace((stderr, "inflate.c too far\n"));
                                        //          copy -= state.whave;
                                        //          if (copy > state.length) { copy = state.length; }
                                        //          if (copy > left) { copy = left; }
                                        //          left -= copy;
                                        //          state.length -= copy;
                                        //          do {
                                        //            output[put++] = 0;
                                        //          } while (--copy);
                                        //          if (state.length === 0) { state.mode = LEN; }
                                        //          break;
                                        //#endif
                                    }
                                    if (copy > state.wnext) {
                                        copy -= state.wnext;
                                        from = state.wsize - copy;
                                    } else {
                                        from = state.wnext - copy;
                                    }
                                    if (copy > state.length) {
                                        copy = state.length;
                                    }
                                    from_source = state.window;
                                } else { /* copy from output */
                                    from_source = output;
                                    from = put - state.offset;
                                    copy = state.length;
                                }
                                if (copy > left) {
                                    copy = left;
                                }
                                left -= copy;
                                state.length -= copy;
                                do {
                                    output[put++] = from_source[from++];
                                } while (--copy);
                                if (state.length === 0) {
                                    state.mode = LEN;
                                }
                                break;
                            case LIT:
                                if (left === 0) {
                                    break inf_leave;
                                }
                                output[put++] = state.length;
                                left--;
                                state.mode = LEN;
                                break;
                            case CHECK:
                                if (state.wrap) {
                                    //=== NEEDBITS(32);
                                    while (bits < 32) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        // Use '|' insdead of '+' to make sure that result is signed
                                        hold |= input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    _out -= left;
                                    strm.total_out += _out;
                                    state.total += _out;
                                    if (_out) {
                                        strm.adler = state.check =
                                            /*UPDATE(state.check, put - _out, _out);*/
                                            (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

                                    }
                                    _out = left;
                                    // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                                        strm.msg = 'incorrect data check';
                                        state.mode = BAD;
                                        break;
                                    }
                                    //=== INITBITS();
                                    hold = 0;
                                    bits = 0;
                                    //===//
                                    //Tracev((stderr, "inflate:   check matches trailer\n"));
                                }
                                state.mode = LENGTH;
                                /* falls through */
                            case LENGTH:
                                if (state.wrap && state.flags) {
                                    //=== NEEDBITS(32);
                                    while (bits < 32) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    if (hold !== (state.total & 0xffffffff)) {
                                        strm.msg = 'incorrect length check';
                                        state.mode = BAD;
                                        break;
                                    }
                                    //=== INITBITS();
                                    hold = 0;
                                    bits = 0;
                                    //===//
                                    //Tracev((stderr, "inflate:   length matches trailer\n"));
                                }
                                state.mode = DONE;
                                /* falls through */
                            case DONE:
                                ret = Z_STREAM_END;
                                break inf_leave;
                            case BAD:
                                ret = Z_DATA_ERROR;
                                break inf_leave;
                            case MEM:
                                return Z_MEM_ERROR;
                            case SYNC:
                                /* falls through */
                            default:
                                return Z_STREAM_ERROR;
                        }
                    }

                // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

                /*
                   Return from inflate(), updating the total counts and the check value.
                   If there was no progress during the inflate() call, return a buffer
                   error.  Call updatewindow() to create and/or update the window state.
                   Note: a memory error from inflate() is non-recoverable.
                 */

                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                //---

                if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                        (state.mode < CHECK || flush !== Z_FINISH))) {
                    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                        state.mode = MEM;
                        return Z_MEM_ERROR;
                    }
                }
                _in -= strm.avail_in;
                _out -= strm.avail_out;
                strm.total_in += _in;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap && _out) {
                    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                        (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
                }
                strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
                    ret = Z_BUF_ERROR;
                }
                return ret;
            }

            function inflateEnd(strm) {

                if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {
                    return Z_STREAM_ERROR;
                }

                var state = strm.state;
                if (state.window) {
                    state.window = null;
                }
                strm.state = null;
                return Z_OK;
            }

            function inflateGetHeader(strm, head) {
                var state;

                /* check state */
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                if ((state.wrap & 2) === 0) {
                    return Z_STREAM_ERROR;
                }

                /* save header structure */
                state.head = head;
                head.done = false;
                return Z_OK;
            }

            function inflateSetDictionary(strm, dictionary) {
                var dictLength = dictionary.length;

                var state;
                var dictid;
                var ret;

                /* check state */
                if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */ ) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;

                if (state.wrap !== 0 && state.mode !== DICT) {
                    return Z_STREAM_ERROR;
                }

                /* check for correct dictionary identifier */
                if (state.mode === DICT) {
                    dictid = 1; /* adler32(0, null, 0)*/
                    /* dictid = adler32(dictid, dictionary, dictLength); */
                    dictid = adler32(dictid, dictionary, dictLength, 0);
                    if (dictid !== state.check) {
                        return Z_DATA_ERROR;
                    }
                }
                /* copy dictionary to window using updatewindow(), which will amend the
                 existing dictionary if appropriate */
                ret = updatewindow(strm, dictionary, dictLength, dictLength);
                if (ret) {
                    state.mode = MEM;
                    return Z_MEM_ERROR;
                }
                state.havedict = 1;
                // Tracev((stderr, "inflate:   dictionary set\n"));
                return Z_OK;
            }

            exports.inflateReset = inflateReset;
            exports.inflateReset2 = inflateReset2;
            exports.inflateResetKeep = inflateResetKeep;
            exports.inflateInit = inflateInit;
            exports.inflateInit2 = inflateInit2;
            exports.inflate = inflate;
            exports.inflateEnd = inflateEnd;
            exports.inflateGetHeader = inflateGetHeader;
            exports.inflateSetDictionary = inflateSetDictionary;
            exports.inflateInfo = 'pako inflate (from Nodeca project)';

            /* Not implemented
            exports.inflateCopy = inflateCopy;
            exports.inflateGetDictionary = inflateGetDictionary;
            exports.inflateMark = inflateMark;
            exports.inflatePrime = inflatePrime;
            exports.inflateSync = inflateSync;
            exports.inflateSyncPoint = inflateSyncPoint;
            exports.inflateUndermine = inflateUndermine;
            */

        }, {
            "../utils/common": 62,
            "./adler32": 64,
            "./crc32": 66,
            "./inffast": 69,
            "./inftrees": 71
        }],
        71: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            var utils = require('../utils/common');

            var MAXBITS = 15;
            var ENOUGH_LENS = 852;
            var ENOUGH_DISTS = 592;
            //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

            var CODES = 0;
            var LENS = 1;
            var DISTS = 2;

            var lbase = [ /* Length codes 257..285 base */
                3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
                35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
            ];

            var lext = [ /* Length codes 257..285 extra */
                16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
                19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
            ];

            var dbase = [ /* Distance codes 0..29 base */
                1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
                257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
                8193, 12289, 16385, 24577, 0, 0
            ];

            var dext = [ /* Distance codes 0..29 extra */
                16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
                23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
                28, 28, 29, 29, 64, 64
            ];

            module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                var bits = opts.bits;
                //here = opts.here; /* table entry for duplication */

                var len = 0; /* a code's length in bits */
                var sym = 0; /* index of code symbols */
                var min = 0,
                    max = 0; /* minimum and maximum code lengths */
                var root = 0; /* number of index bits for root table */
                var curr = 0; /* number of index bits for current table */
                var drop = 0; /* code bits to drop for sub-table */
                var left = 0; /* number of prefix codes available */
                var used = 0; /* code entries in table used */
                var huff = 0; /* Huffman code */
                var incr; /* for incrementing code, index */
                var fill; /* index for replicating entries */
                var low; /* low bits for current root entry */
                var mask; /* mask for low root bits */
                var next; /* next available space in table */
                var base = null; /* base value table to use */
                var base_index = 0;
                //  var shoextra;    /* extra bits table to use */
                var end; /* use base and extra for symbol > end */
                var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
                var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
                var extra = null;
                var extra_index = 0;

                var here_bits, here_op, here_val;

                /*
                 Process a set of code lengths to create a canonical Huffman code.  The
                 code lengths are lens[0..codes-1].  Each length corresponds to the
                 symbols 0..codes-1.  The Huffman code is generated by first sorting the
                 symbols by length from short to long, and retaining the symbol order
                 for codes with equal lengths.  Then the code starts with all zero bits
                 for the first code of the shortest length, and the codes are integer
                 increments for the same length, and zeros are appended as the length
                 increases.  For the deflate format, these bits are stored backwards
                 from their more natural integer increment ordering, and so when the
                 decoding tables are built in the large loop below, the integer codes
                 are incremented backwards.

                 This routine assumes, but does not check, that all of the entries in
                 lens[] are in the range 0..MAXBITS.  The caller must assure this.
                 1..MAXBITS is interpreted as that code length.  zero means that that
                 symbol does not occur in this code.

                 The codes are sorted by computing a count of codes for each length,
                 creating from that a table of starting indices for each length in the
                 sorted table, and then entering the symbols in order in the sorted
                 table.  The sorted table is work[], with that space being provided by
                 the caller.

                 The length counts are used for other purposes as well, i.e. finding
                 the minimum and maximum length codes, determining if there are any
                 codes at all, checking for a valid set of lengths, and looking ahead
                 at length counts to determine sub-table sizes when building the
                 decoding tables.
                 */

                /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
                for (len = 0; len <= MAXBITS; len++) {
                    count[len] = 0;
                }
                for (sym = 0; sym < codes; sym++) {
                    count[lens[lens_index + sym]]++;
                }

                /* bound code lengths, force root to be within code lengths */
                root = bits;
                for (max = MAXBITS; max >= 1; max--) {
                    if (count[max] !== 0) {
                        break;
                    }
                }
                if (root > max) {
                    root = max;
                }
                if (max === 0) { /* no symbols to code at all */
                    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
                    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
                    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
                    table[table_index++] = (1 << 24) | (64 << 16) | 0;


                    //table.op[opts.table_index] = 64;
                    //table.bits[opts.table_index] = 1;
                    //table.val[opts.table_index++] = 0;
                    table[table_index++] = (1 << 24) | (64 << 16) | 0;

                    opts.bits = 1;
                    return 0; /* no symbols, but wait for decoding to report error */
                }
                for (min = 1; min < max; min++) {
                    if (count[min] !== 0) {
                        break;
                    }
                }
                if (root < min) {
                    root = min;
                }

                /* check for an over-subscribed or incomplete set of lengths */
                left = 1;
                for (len = 1; len <= MAXBITS; len++) {
                    left <<= 1;
                    left -= count[len];
                    if (left < 0) {
                        return -1;
                    } /* over-subscribed */
                }
                if (left > 0 && (type === CODES || max !== 1)) {
                    return -1; /* incomplete set */
                }

                /* generate offsets into symbol table for each length for sorting */
                offs[1] = 0;
                for (len = 1; len < MAXBITS; len++) {
                    offs[len + 1] = offs[len] + count[len];
                }

                /* sort symbols by length, by symbol order within each length */
                for (sym = 0; sym < codes; sym++) {
                    if (lens[lens_index + sym] !== 0) {
                        work[offs[lens[lens_index + sym]]++] = sym;
                    }
                }

                /*
                 Create and fill in decoding tables.  In this loop, the table being
                 filled is at next and has curr index bits.  The code being used is huff
                 with length len.  That code is converted to an index by dropping drop
                 bits off of the bottom.  For codes where len is less than drop + curr,
                 those top drop + curr - len bits are incremented through all values to
                 fill the table with replicated entries.

                 root is the number of index bits for the root table.  When len exceeds
                 root, sub-tables are created pointed to by the root entry with an index
                 of the low root bits of huff.  This is saved in low to check for when a
                 new sub-table should be started.  drop is zero when the root table is
                 being filled, and drop is root when sub-tables are being filled.

                 When a new sub-table is needed, it is necessary to look ahead in the
                 code lengths to determine what size sub-table is needed.  The length
                 counts are used for this, and so count[] is decremented as codes are
                 entered in the tables.

                 used keeps track of how many table entries have been allocated from the
                 provided *table space.  It is checked for LENS and DIST tables against
                 the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
                 the initial root table size constants.  See the comments in inftrees.h
                 for more information.

                 sym increments through all symbols, and the loop terminates when
                 all codes of length max, i.e. all codes, have been processed.  This
                 routine permits incomplete codes, so another loop after this one fills
                 in the rest of the decoding tables with invalid code markers.
                 */

                /* set up for code type */
                // poor man optimization - use if-else instead of switch,
                // to avoid deopts in old v8
                if (type === CODES) {
                    base = extra = work; /* dummy value--not used */
                    end = 19;

                } else if (type === LENS) {
                    base = lbase;
                    base_index -= 257;
                    extra = lext;
                    extra_index -= 257;
                    end = 256;

                } else { /* DISTS */
                    base = dbase;
                    extra = dext;
                    end = -1;
                }

                /* initialize opts for loop */
                huff = 0; /* starting code */
                sym = 0; /* starting code symbol */
                len = min; /* starting code length */
                next = table_index; /* current table to fill in */
                curr = root; /* current table index bits */
                drop = 0; /* current bits to drop from code for index */
                low = -1; /* trigger new sub-table when len > root */
                used = 1 << root; /* use root table entries */
                mask = used - 1; /* mask for comparing low */

                /* check available table space */
                if ((type === LENS && used > ENOUGH_LENS) ||
                    (type === DISTS && used > ENOUGH_DISTS)) {
                    return 1;
                }

                /* process all codes and make table entries */
                for (;;) {
                    /* create table entry */
                    here_bits = len - drop;
                    if (work[sym] < end) {
                        here_op = 0;
                        here_val = work[sym];
                    } else if (work[sym] > end) {
                        here_op = extra[extra_index + work[sym]];
                        here_val = base[base_index + work[sym]];
                    } else {
                        here_op = 32 + 64; /* end of block */
                        here_val = 0;
                    }

                    /* replicate for those indices with low len bits equal to huff */
                    incr = 1 << (len - drop);
                    fill = 1 << curr;
                    min = fill; /* save offset to next table */
                    do {
                        fill -= incr;
                        table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
                    } while (fill !== 0);

                    /* backwards increment the len-bit code huff */
                    incr = 1 << (len - 1);
                    while (huff & incr) {
                        incr >>= 1;
                    }
                    if (incr !== 0) {
                        huff &= incr - 1;
                        huff += incr;
                    } else {
                        huff = 0;
                    }

                    /* go to next symbol, update count, len */
                    sym++;
                    if (--count[len] === 0) {
                        if (len === max) {
                            break;
                        }
                        len = lens[lens_index + work[sym]];
                    }

                    /* create new sub-table if needed */
                    if (len > root && (huff & mask) !== low) {
                        /* if first time, transition to sub-tables */
                        if (drop === 0) {
                            drop = root;
                        }

                        /* increment past last table */
                        next += min; /* here min is 1 << curr */

                        /* determine length of next table */
                        curr = len - drop;
                        left = 1 << curr;
                        while (curr + drop < max) {
                            left -= count[curr + drop];
                            if (left <= 0) {
                                break;
                            }
                            curr++;
                            left <<= 1;
                        }

                        /* check for enough space */
                        used += 1 << curr;
                        if ((type === LENS && used > ENOUGH_LENS) ||
                            (type === DISTS && used > ENOUGH_DISTS)) {
                            return 1;
                        }

                        /* point entry in root table to sub-table */
                        low = huff & mask;
                        /*table.op[low] = curr;
                        table.bits[low] = root;
                        table.val[low] = next - opts.table_index;*/
                        table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
                    }
                }

                /* fill in remaining table entry if code is incomplete (guaranteed to have
                 at most one remaining entry, since if the code is incomplete, the
                 maximum code length that was allowed to get this far is one bit) */
                if (huff !== 0) {
                    //table.op[next + huff] = 64;            /* invalid code marker */
                    //table.bits[next + huff] = len - drop;
                    //table.val[next + huff] = 0;
                    table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
                }

                /* set return parameters */
                //opts.table_index += used;
                opts.bits = root;
                return 0;
            };

        }, {
            "../utils/common": 62
        }],
        72: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            module.exports = {
                2: 'need dictionary',
                /* Z_NEED_DICT       2  */
                1: 'stream end',
                /* Z_STREAM_END      1  */
                0: '',
                /* Z_OK              0  */
                '-1': 'file error',
                /* Z_ERRNO         (-1) */
                '-2': 'stream error',
                /* Z_STREAM_ERROR  (-2) */
                '-3': 'data error',
                /* Z_DATA_ERROR    (-3) */
                '-4': 'insufficient memory',
                /* Z_MEM_ERROR     (-4) */
                '-5': 'buffer error',
                /* Z_BUF_ERROR     (-5) */
                '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
            };

        }, {}],
        73: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            var utils = require('../utils/common');

            /* Public constants ==========================================================*/
            /* ===========================================================================*/


            //var Z_FILTERED          = 1;
            //var Z_HUFFMAN_ONLY      = 2;
            //var Z_RLE               = 3;
            var Z_FIXED = 4;
            //var Z_DEFAULT_STRATEGY  = 0;

            /* Possible values of the data_type field (though see inflate()) */
            var Z_BINARY = 0;
            var Z_TEXT = 1;
            //var Z_ASCII             = 1; // = Z_TEXT
            var Z_UNKNOWN = 2;

            /*============================================================================*/


            function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                    buf[len] = 0;
                }
            }

            // From zutil.h

            var STORED_BLOCK = 0;
            var STATIC_TREES = 1;
            var DYN_TREES = 2;
            /* The three kinds of block type */

            var MIN_MATCH = 3;
            var MAX_MATCH = 258;
            /* The minimum and maximum match lengths */

            // From deflate.h
            /* ===========================================================================
             * Internal compression state.
             */

            var LENGTH_CODES = 29;
            /* number of length codes, not counting the special END_BLOCK code */

            var LITERALS = 256;
            /* number of literal bytes 0..255 */

            var L_CODES = LITERALS + 1 + LENGTH_CODES;
            /* number of Literal or Length codes, including the END_BLOCK code */

            var D_CODES = 30;
            /* number of distance codes */

            var BL_CODES = 19;
            /* number of codes used to transfer the bit lengths */

            var HEAP_SIZE = 2 * L_CODES + 1;
            /* maximum heap size */

            var MAX_BITS = 15;
            /* All codes must not exceed MAX_BITS bits */

            var Buf_size = 16;
            /* size of bit buffer in bi_buf */


            /* ===========================================================================
             * Constants
             */

            var MAX_BL_BITS = 7;
            /* Bit length codes must not exceed MAX_BL_BITS bits */

            var END_BLOCK = 256;
            /* end of block literal code */

            var REP_3_6 = 16;
            /* repeat previous bit length 3-6 times (2 bits of repeat count) */

            var REPZ_3_10 = 17;
            /* repeat a zero length 3-10 times  (3 bits of repeat count) */

            var REPZ_11_138 = 18;
            /* repeat a zero length 11-138 times  (7 bits of repeat count) */

            /* eslint-disable comma-spacing,array-bracket-spacing */
            var extra_lbits = /* extra bits for each length code */
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

            var extra_dbits = /* extra bits for each distance code */
                [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

            var extra_blbits = /* extra bits for each bit length code */
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

            var bl_order =
                [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            /* eslint-enable comma-spacing,array-bracket-spacing */

            /* The lengths of the bit length codes are sent in order of decreasing
             * probability, to avoid transmitting the lengths for unused bit length codes.
             */

            /* ===========================================================================
             * Local data. These are initialized only once.
             */

            // We pre-fill arrays with 0 to avoid uninitialized gaps

            var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

            // !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
            var static_ltree = new Array((L_CODES + 2) * 2);
            zero(static_ltree);
            /* The static literal tree. Since the bit lengths are imposed, there is no
             * need for the L_CODES extra codes used during heap construction. However
             * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
             * below).
             */

            var static_dtree = new Array(D_CODES * 2);
            zero(static_dtree);
            /* The static distance tree. (Actually a trivial tree since all codes use
             * 5 bits.)
             */

            var _dist_code = new Array(DIST_CODE_LEN);
            zero(_dist_code);
            /* Distance codes. The first 256 values correspond to the distances
             * 3 .. 258, the last 256 values correspond to the top 8 bits of
             * the 15 bit distances.
             */

            var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
            zero(_length_code);
            /* length code for each normalized match length (0 == MIN_MATCH) */

            var base_length = new Array(LENGTH_CODES);
            zero(base_length);
            /* First normalized length for each code (0 = MIN_MATCH) */

            var base_dist = new Array(D_CODES);
            zero(base_dist);
            /* First normalized distance for each code (0 = distance of 1) */


            function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

                this.static_tree = static_tree; /* static tree or NULL */
                this.extra_bits = extra_bits; /* extra bits for each code or NULL */
                this.extra_base = extra_base; /* base index for extra_bits */
                this.elems = elems; /* max number of elements in the tree */
                this.max_length = max_length; /* max bit length for the codes */

                // show if `static_tree` has data or dummy - needed for monomorphic objects
                this.has_stree = static_tree && static_tree.length;
            }


            var static_l_desc;
            var static_d_desc;
            var static_bl_desc;


            function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree; /* the dynamic tree */
                this.max_code = 0; /* largest code with non zero frequency */
                this.stat_desc = stat_desc; /* the corresponding static tree */
            }



            function d_code(dist) {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
            }


            /* ===========================================================================
             * Output a short LSB first on the stream.
             * IN assertion: there is enough room in pendingBuf.
             */
            function put_short(s, w) {
                //    put_byte(s, (uch)((w) & 0xff));
                //    put_byte(s, (uch)((ush)(w) >> 8));
                s.pending_buf[s.pending++] = (w) & 0xff;
                s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
            }


            /* ===========================================================================
             * Send a value on a given number of bits.
             * IN assertion: length <= 16 and value fits in length bits.
             */
            function send_bits(s, value, length) {
                if (s.bi_valid > (Buf_size - length)) {
                    s.bi_buf |= (value << s.bi_valid) & 0xffff;
                    put_short(s, s.bi_buf);
                    s.bi_buf = value >> (Buf_size - s.bi_valid);
                    s.bi_valid += length - Buf_size;
                } else {
                    s.bi_buf |= (value << s.bi_valid) & 0xffff;
                    s.bi_valid += length;
                }
            }


            function send_code(s, c, tree) {
                send_bits(s, tree[c * 2] /*.Code*/ , tree[c * 2 + 1] /*.Len*/ );
            }


            /* ===========================================================================
             * Reverse the first len bits of a code, using straightforward code (a faster
             * method would use a table)
             * IN assertion: 1 <= len <= 15
             */
            function bi_reverse(code, len) {
                var res = 0;
                do {
                    res |= code & 1;
                    code >>>= 1;
                    res <<= 1;
                } while (--len > 0);
                return res >>> 1;
            }


            /* ===========================================================================
             * Flush the bit buffer, keeping at most 7 bits in it.
             */
            function bi_flush(s) {
                if (s.bi_valid === 16) {
                    put_short(s, s.bi_buf);
                    s.bi_buf = 0;
                    s.bi_valid = 0;

                } else if (s.bi_valid >= 8) {
                    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
                    s.bi_buf >>= 8;
                    s.bi_valid -= 8;
                }
            }


            /* ===========================================================================
             * Compute the optimal bit lengths for a tree and update the total bit length
             * for the current block.
             * IN assertion: the fields freq and dad are set, heap[heap_max] and
             *    above are the tree nodes sorted by increasing frequency.
             * OUT assertions: the field len is set to the optimal bit length, the
             *     array bl_count contains the frequencies for each bit length.
             *     The length opt_len is updated; static_len is also updated if stree is
             *     not null.
             */
            function gen_bitlen(s, desc)
            //    deflate_state *s;
            //    tree_desc *desc;    /* the tree descriptor */
            {
                var tree = desc.dyn_tree;
                var max_code = desc.max_code;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var extra = desc.stat_desc.extra_bits;
                var base = desc.stat_desc.extra_base;
                var max_length = desc.stat_desc.max_length;
                var h; /* heap index */
                var n, m; /* iterate over the tree elements */
                var bits; /* bit length */
                var xbits; /* extra bits */
                var f; /* frequency */
                var overflow = 0; /* number of elements with bit length too large */

                for (bits = 0; bits <= MAX_BITS; bits++) {
                    s.bl_count[bits] = 0;
                }

                /* In a first pass, compute the optimal bit lengths (which may
                 * overflow in the case of the bit length tree).
                 */
                tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                    n = s.heap[h];
                    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
                    if (bits > max_length) {
                        bits = max_length;
                        overflow++;
                    }
                    tree[n * 2 + 1] /*.Len*/ = bits;
                    /* We overwrite tree[n].Dad which is no longer needed */

                    if (n > max_code) {
                        continue;
                    } /* not a leaf node */

                    s.bl_count[bits]++;
                    xbits = 0;
                    if (n >= base) {
                        xbits = extra[n - base];
                    }
                    f = tree[n * 2] /*.Freq*/ ;
                    s.opt_len += f * (bits + xbits);
                    if (has_stree) {
                        s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
                    }
                }
                if (overflow === 0) {
                    return;
                }

                // Trace((stderr,"\nbit length overflow\n"));
                /* This happens for example on obj2 and pic of the Calgary corpus */

                /* Find the first bit length which could increase: */
                do {
                    bits = max_length - 1;
                    while (s.bl_count[bits] === 0) {
                        bits--;
                    }
                    s.bl_count[bits]--; /* move one leaf down the tree */
                    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
                    s.bl_count[max_length]--;
                    /* The brother of the overflow item also moves one step up,
                     * but this does not affect bl_count[max_length]
                     */
                    overflow -= 2;
                } while (overflow > 0);

                /* Now recompute all bit lengths, scanning in increasing frequency.
                 * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
                 * lengths instead of fixing only the wrong ones. This idea is taken
                 * from 'ar' written by Haruhiko Okumura.)
                 */
                for (bits = max_length; bits !== 0; bits--) {
                    n = s.bl_count[bits];
                    while (n !== 0) {
                        m = s.heap[--h];
                        if (m > max_code) {
                            continue;
                        }
                        if (tree[m * 2 + 1] /*.Len*/ !== bits) {
                            // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                            s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/ ) * tree[m * 2] /*.Freq*/ ;
                            tree[m * 2 + 1] /*.Len*/ = bits;
                        }
                        n--;
                    }
                }
            }


            /* ===========================================================================
             * Generate the codes for a given tree and bit counts (which need not be
             * optimal).
             * IN assertion: the array bl_count contains the bit length statistics for
             * the given tree and the field len is set for all tree elements.
             * OUT assertion: the field code is set for all tree elements of non
             *     zero code length.
             */
            function gen_codes(tree, max_code, bl_count)
            //    ct_data *tree;             /* the tree to decorate */
            //    int max_code;              /* largest code with non zero frequency */
            //    ushf *bl_count;            /* number of codes at each bit length */
            {
                var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
                var code = 0; /* running code value */
                var bits; /* bit index */
                var n; /* code index */

                /* The distribution counts are first used to generate the code values
                 * without bit reversal.
                 */
                for (bits = 1; bits <= MAX_BITS; bits++) {
                    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
                }
                /* Check that the bit counts in bl_count are consistent. The last code
                 * must be all ones.
                 */
                //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
                //        "inconsistent bit counts");
                //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

                for (n = 0; n <= max_code; n++) {
                    var len = tree[n * 2 + 1] /*.Len*/ ;
                    if (len === 0) {
                        continue;
                    }
                    /* Now reverse the bits */
                    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

                    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
                    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
                }
            }


            /* ===========================================================================
             * Initialize the various 'constant' tables.
             */
            function tr_static_init() {
                var n; /* iterates over tree elements */
                var bits; /* bit counter */
                var length; /* length value */
                var code; /* code value */
                var dist; /* distance index */
                var bl_count = new Array(MAX_BITS + 1);
                /* number of codes at each bit length for an optimal tree */

                // do check in _tr_init()
                //if (static_init_done) return;

                /* For some embedded targets, global variables are not initialized: */
                /*#ifdef NO_INIT_GLOBAL_POINTERS
                  static_l_desc.static_tree = static_ltree;
                  static_l_desc.extra_bits = extra_lbits;
                  static_d_desc.static_tree = static_dtree;
                  static_d_desc.extra_bits = extra_dbits;
                  static_bl_desc.extra_bits = extra_blbits;
                #endif*/

                /* Initialize the mapping length (0..255) -> length code (0..28) */
                length = 0;
                for (code = 0; code < LENGTH_CODES - 1; code++) {
                    base_length[code] = length;
                    for (n = 0; n < (1 << extra_lbits[code]); n++) {
                        _length_code[length++] = code;
                    }
                }
                //Assert (length == 256, "tr_static_init: length != 256");
                /* Note that the length 255 (match length 258) can be represented
                 * in two different ways: code 284 + 5 bits or code 285, so we
                 * overwrite length_code[255] to use the best encoding:
                 */
                _length_code[length - 1] = code;

                /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
                dist = 0;
                for (code = 0; code < 16; code++) {
                    base_dist[code] = dist;
                    for (n = 0; n < (1 << extra_dbits[code]); n++) {
                        _dist_code[dist++] = code;
                    }
                }
                //Assert (dist == 256, "tr_static_init: dist != 256");
                dist >>= 7; /* from now on, all distances are divided by 128 */
                for (; code < D_CODES; code++) {
                    base_dist[code] = dist << 7;
                    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
                        _dist_code[256 + dist++] = code;
                    }
                }
                //Assert (dist == 256, "tr_static_init: 256+dist != 512");

                /* Construct the codes of the static literal tree */
                for (bits = 0; bits <= MAX_BITS; bits++) {
                    bl_count[bits] = 0;
                }

                n = 0;
                while (n <= 143) {
                    static_ltree[n * 2 + 1] /*.Len*/ = 8;
                    n++;
                    bl_count[8]++;
                }
                while (n <= 255) {
                    static_ltree[n * 2 + 1] /*.Len*/ = 9;
                    n++;
                    bl_count[9]++;
                }
                while (n <= 279) {
                    static_ltree[n * 2 + 1] /*.Len*/ = 7;
                    n++;
                    bl_count[7]++;
                }
                while (n <= 287) {
                    static_ltree[n * 2 + 1] /*.Len*/ = 8;
                    n++;
                    bl_count[8]++;
                }
                /* Codes 286 and 287 do not exist, but we must include them in the
                 * tree construction to get a canonical Huffman tree (longest code
                 * all ones)
                 */
                gen_codes(static_ltree, L_CODES + 1, bl_count);

                /* The static distance tree is trivial: */
                for (n = 0; n < D_CODES; n++) {
                    static_dtree[n * 2 + 1] /*.Len*/ = 5;
                    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
                }

                // Now data ready and we can init static trees
                static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
                static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

                //static_init_done = true;
            }


            /* ===========================================================================
             * Initialize a new block.
             */
            function init_block(s) {
                var n; /* iterates over tree elements */

                /* Initialize the trees. */
                for (n = 0; n < L_CODES; n++) {
                    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
                }
                for (n = 0; n < D_CODES; n++) {
                    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
                }
                for (n = 0; n < BL_CODES; n++) {
                    s.bl_tree[n * 2] /*.Freq*/ = 0;
                }

                s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
                s.opt_len = s.static_len = 0;
                s.last_lit = s.matches = 0;
            }


            /* ===========================================================================
             * Flush the bit buffer and align the output on a byte boundary
             */
            function bi_windup(s) {
                if (s.bi_valid > 8) {
                    put_short(s, s.bi_buf);
                } else if (s.bi_valid > 0) {
                    //put_byte(s, (Byte)s->bi_buf);
                    s.pending_buf[s.pending++] = s.bi_buf;
                }
                s.bi_buf = 0;
                s.bi_valid = 0;
            }

            /* ===========================================================================
             * Copy a stored block, storing first the length and its
             * one's complement if requested.
             */
            function copy_block(s, buf, len, header)
            //DeflateState *s;
            //charf    *buf;    /* the input data */
            //unsigned len;     /* its length */
            //int      header;  /* true if block header must be written */
            {
                bi_windup(s); /* align on byte boundary */

                if (header) {
                    put_short(s, len);
                    put_short(s, ~len);
                }
                //  while (len--) {
                //    put_byte(s, *buf++);
                //  }
                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
                s.pending += len;
            }

            /* ===========================================================================
             * Compares to subtrees, using the tree depth as tie breaker when
             * the subtrees have equal frequency. This minimizes the worst case length.
             */
            function smaller(tree, n, m, depth) {
                var _n2 = n * 2;
                var _m2 = m * 2;
                return (tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ ||
                    (tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m]));
            }

            /* ===========================================================================
             * Restore the heap property by moving down the tree starting at node k,
             * exchanging a node with the smallest of its two sons if necessary, stopping
             * when the heap property is re-established (each father smaller than its
             * two sons).
             */
            function pqdownheap(s, tree, k)
            //    deflate_state *s;
            //    ct_data *tree;  /* the tree to restore */
            //    int k;               /* node to move down */
            {
                var v = s.heap[k];
                var j = k << 1; /* left son of k */
                while (j <= s.heap_len) {
                    /* Set j to the smallest of the two sons: */
                    if (j < s.heap_len &&
                        smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                        j++;
                    }
                    /* Exit if v is smaller than both sons */
                    if (smaller(tree, v, s.heap[j], s.depth)) {
                        break;
                    }

                    /* Exchange v with the smallest son */
                    s.heap[k] = s.heap[j];
                    k = j;

                    /* And continue down the tree, setting j to the left son of k */
                    j <<= 1;
                }
                s.heap[k] = v;
            }


            // inlined manually
            // var SMALLEST = 1;

            /* ===========================================================================
             * Send the block data compressed using the given Huffman trees
             */
            function compress_block(s, ltree, dtree)
            //    deflate_state *s;
            //    const ct_data *ltree; /* literal tree */
            //    const ct_data *dtree; /* distance tree */
            {
                var dist; /* distance of matched string */
                var lc; /* match length or unmatched char (if dist == 0) */
                var lx = 0; /* running index in l_buf */
                var code; /* the code to send */
                var extra; /* number of extra bits to send */

                if (s.last_lit !== 0) {
                    do {
                        dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
                        lc = s.pending_buf[s.l_buf + lx];
                        lx++;

                        if (dist === 0) {
                            send_code(s, lc, ltree); /* send a literal byte */
                            //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                        } else {
                            /* Here, lc is the match length - MIN_MATCH */
                            code = _length_code[lc];
                            send_code(s, code + LITERALS + 1, ltree); /* send the length code */
                            extra = extra_lbits[code];
                            if (extra !== 0) {
                                lc -= base_length[code];
                                send_bits(s, lc, extra); /* send the extra length bits */
                            }
                            dist--; /* dist is now the match distance - 1 */
                            code = d_code(dist);
                            //Assert (code < D_CODES, "bad d_code");

                            send_code(s, code, dtree); /* send the distance code */
                            extra = extra_dbits[code];
                            if (extra !== 0) {
                                dist -= base_dist[code];
                                send_bits(s, dist, extra); /* send the extra distance bits */
                            }
                        } /* literal or match pair ? */

                        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                        //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                        //       "pendingBuf overflow");

                    } while (lx < s.last_lit);
                }

                send_code(s, END_BLOCK, ltree);
            }


            /* ===========================================================================
             * Construct one Huffman tree and assigns the code bit strings and lengths.
             * Update the total bit length for the current block.
             * IN assertion: the field freq is set for all tree elements.
             * OUT assertions: the fields len and code are set to the optimal bit length
             *     and corresponding code. The length opt_len is updated; static_len is
             *     also updated if stree is not null. The field max_code is set.
             */
            function build_tree(s, desc)
            //    deflate_state *s;
            //    tree_desc *desc; /* the tree descriptor */
            {
                var tree = desc.dyn_tree;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var elems = desc.stat_desc.elems;
                var n, m; /* iterate over heap elements */
                var max_code = -1; /* largest code with non zero frequency */
                var node; /* new node being created */

                /* Construct the initial heap, with least frequent element in
                 * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
                 * heap[0] is not used.
                 */
                s.heap_len = 0;
                s.heap_max = HEAP_SIZE;

                for (n = 0; n < elems; n++) {
                    if (tree[n * 2] /*.Freq*/ !== 0) {
                        s.heap[++s.heap_len] = max_code = n;
                        s.depth[n] = 0;

                    } else {
                        tree[n * 2 + 1] /*.Len*/ = 0;
                    }
                }

                /* The pkzip format requires that at least one distance code exists,
                 * and that at least one bit should be sent even if there is only one
                 * possible code. So to avoid special checks later on we force at least
                 * two codes of non zero frequency.
                 */
                while (s.heap_len < 2) {
                    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
                    tree[node * 2] /*.Freq*/ = 1;
                    s.depth[node] = 0;
                    s.opt_len--;

                    if (has_stree) {
                        s.static_len -= stree[node * 2 + 1] /*.Len*/ ;
                    }
                    /* node is 0 or 1 so it does not have extra bits */
                }
                desc.max_code = max_code;

                /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
                 * establish sub-heaps of increasing lengths:
                 */
                for (n = (s.heap_len >> 1 /*int /2*/ ); n >= 1; n--) {
                    pqdownheap(s, tree, n);
                }

                /* Construct the Huffman tree by repeatedly combining the least two
                 * frequent nodes.
                 */
                node = elems; /* next internal node of the tree */
                do {
                    //pqremove(s, tree, n);  /* n = node of least frequency */
                    /*** pqremove ***/
                    n = s.heap[1 /*SMALLEST*/ ];
                    s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];
                    pqdownheap(s, tree, 1 /*SMALLEST*/ );
                    /***/

                    m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */

                    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
                    s.heap[--s.heap_max] = m;

                    /* Create a new node father of n and m */
                    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/ ;
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

                    /* and insert the new node in the heap */
                    s.heap[1 /*SMALLEST*/ ] = node++;
                    pqdownheap(s, tree, 1 /*SMALLEST*/ );

                } while (s.heap_len >= 2);

                s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];

                /* At this point, the fields freq and dad are set. We can now
                 * generate the bit lengths.
                 */
                gen_bitlen(s, desc);

                /* The field len is now set, we can generate the bit codes */
                gen_codes(tree, max_code, s.bl_count);
            }


            /* ===========================================================================
             * Scan a literal or distance tree to determine the frequencies of the codes
             * in the bit length tree.
             */
            function scan_tree(s, tree, max_code)
            //    deflate_state *s;
            //    ct_data *tree;   /* the tree to be scanned */
            //    int max_code;    /* and its largest code of non zero frequency */
            {
                var n; /* iterates over all tree elements */
                var prevlen = -1; /* last emitted length */
                var curlen; /* length of current code */

                var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */

                var count = 0; /* repeat count of the current code */
                var max_count = 7; /* max repeat count */
                var min_count = 4; /* min repeat count */

                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                }
                tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

                for (n = 0; n <= max_code; n++) {
                    curlen = nextlen;
                    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;

                    if (++count < max_count && curlen === nextlen) {
                        continue;

                    } else if (count < min_count) {
                        s.bl_tree[curlen * 2] /*.Freq*/ += count;

                    } else if (curlen !== 0) {

                        if (curlen !== prevlen) {
                            s.bl_tree[curlen * 2] /*.Freq*/ ++;
                        }
                        s.bl_tree[REP_3_6 * 2] /*.Freq*/ ++;

                    } else if (count <= 10) {
                        s.bl_tree[REPZ_3_10 * 2] /*.Freq*/ ++;

                    } else {
                        s.bl_tree[REPZ_11_138 * 2] /*.Freq*/ ++;
                    }

                    count = 0;
                    prevlen = curlen;

                    if (nextlen === 0) {
                        max_count = 138;
                        min_count = 3;

                    } else if (curlen === nextlen) {
                        max_count = 6;
                        min_count = 3;

                    } else {
                        max_count = 7;
                        min_count = 4;
                    }
                }
            }


            /* ===========================================================================
             * Send a literal or distance tree in compressed form, using the codes in
             * bl_tree.
             */
            function send_tree(s, tree, max_code)
            //    deflate_state *s;
            //    ct_data *tree; /* the tree to be scanned */
            //    int max_code;       /* and its largest code of non zero frequency */
            {
                var n; /* iterates over all tree elements */
                var prevlen = -1; /* last emitted length */
                var curlen; /* length of current code */

                var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */

                var count = 0; /* repeat count of the current code */
                var max_count = 7; /* max repeat count */
                var min_count = 4; /* min repeat count */

                /* tree[max_code+1].Len = -1; */
                /* guard already set */
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                }

                for (n = 0; n <= max_code; n++) {
                    curlen = nextlen;
                    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;

                    if (++count < max_count && curlen === nextlen) {
                        continue;

                    } else if (count < min_count) {
                        do {
                            send_code(s, curlen, s.bl_tree);
                        } while (--count !== 0);

                    } else if (curlen !== 0) {
                        if (curlen !== prevlen) {
                            send_code(s, curlen, s.bl_tree);
                            count--;
                        }
                        //Assert(count >= 3 && count <= 6, " 3_6?");
                        send_code(s, REP_3_6, s.bl_tree);
                        send_bits(s, count - 3, 2);

                    } else if (count <= 10) {
                        send_code(s, REPZ_3_10, s.bl_tree);
                        send_bits(s, count - 3, 3);

                    } else {
                        send_code(s, REPZ_11_138, s.bl_tree);
                        send_bits(s, count - 11, 7);
                    }

                    count = 0;
                    prevlen = curlen;
                    if (nextlen === 0) {
                        max_count = 138;
                        min_count = 3;

                    } else if (curlen === nextlen) {
                        max_count = 6;
                        min_count = 3;

                    } else {
                        max_count = 7;
                        min_count = 4;
                    }
                }
            }


            /* ===========================================================================
             * Construct the Huffman tree for the bit lengths and return the index in
             * bl_order of the last bit length code to send.
             */
            function build_bl_tree(s) {
                var max_blindex; /* index of last bit length code of non zero freq */

                /* Determine the bit length frequencies for literal and distance trees */
                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

                /* Build the bit length tree: */
                build_tree(s, s.bl_desc);
                /* opt_len now includes the length of the tree representations, except
                 * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
                 */

                /* Determine the number of bit length codes to send. The pkzip format
                 * requires that at least 4 bit length codes be sent. (appnote.txt says
                 * 3 but the actual value used is 4.)
                 */
                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
                        break;
                    }
                }
                /* Update opt_len to include the bit length tree and counts */
                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
                //        s->opt_len, s->static_len));

                return max_blindex;
            }


            /* ===========================================================================
             * Send the header for a block using dynamic Huffman trees: the counts, the
             * lengths of the bit length codes, the literal tree and the distance tree.
             * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
             */
            function send_all_trees(s, lcodes, dcodes, blcodes)
            //    deflate_state *s;
            //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
            {
                var rank; /* index in bl_order */

                //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
                //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
                //        "too many codes");
                //Tracev((stderr, "\nbl counts: "));
                send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
                send_bits(s, dcodes - 1, 5);
                send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
                for (rank = 0; rank < blcodes; rank++) {
                    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
                    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/ , 3);
                }
                //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

                send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
                //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

                send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
                //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
            }


            /* ===========================================================================
             * Check if the data type is TEXT or BINARY, using the following algorithm:
             * - TEXT if the two conditions below are satisfied:
             *    a) There are no non-portable control characters belonging to the
             *       "black list" (0..6, 14..25, 28..31).
             *    b) There is at least one printable character belonging to the
             *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
             * - BINARY otherwise.
             * - The following partially-portable control characters form a
             *   "gray list" that is ignored in this detection algorithm:
             *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
             * IN assertion: the fields Freq of dyn_ltree are set.
             */
            function detect_data_type(s) {
                /* black_mask is the bit mask of black-listed bytes
                 * set bits 0..6, 14..25, and 28..31
                 * 0xf3ffc07f = binary 11110011111111111100000001111111
                 */
                var black_mask = 0xf3ffc07f;
                var n;

                /* Check for non-textual ("black-listed") bytes. */
                for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                    if ((black_mask & 1) && (s.dyn_ltree[n * 2] /*.Freq*/ !== 0)) {
                        return Z_BINARY;
                    }
                }

                /* Check for textual ("white-listed") bytes. */
                if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 ||
                    s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
                    return Z_TEXT;
                }
                for (n = 32; n < LITERALS; n++) {
                    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
                        return Z_TEXT;
                    }
                }

                /* There are no "black-listed" or "white-listed" bytes:
                 * this stream either is empty or has tolerated ("gray-listed") bytes only.
                 */
                return Z_BINARY;
            }


            var static_init_done = false;

            /* ===========================================================================
             * Initialize the tree data structures for a new zlib stream.
             */
            function _tr_init(s) {

                if (!static_init_done) {
                    tr_static_init();
                    static_init_done = true;
                }

                s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

                s.bi_buf = 0;
                s.bi_valid = 0;

                /* Initialize the first block of the first file: */
                init_block(s);
            }


            /* ===========================================================================
             * Send a stored block
             */
            function _tr_stored_block(s, buf, stored_len, last)
            //DeflateState *s;
            //charf *buf;       /* input block */
            //ulg stored_len;   /* length of input block */
            //int last;         /* one if this is the last block for a file */
            {
                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
                copy_block(s, buf, stored_len, true); /* with header */
            }


            /* ===========================================================================
             * Send one empty static block to give enough lookahead for inflate.
             * This takes 10 bits, of which 7 may remain in the bit buffer.
             */
            function _tr_align(s) {
                send_bits(s, STATIC_TREES << 1, 3);
                send_code(s, END_BLOCK, static_ltree);
                bi_flush(s);
            }


            /* ===========================================================================
             * Determine the best encoding for the current block: dynamic trees, static
             * trees or store, and output the encoded block to the zip file.
             */
            function _tr_flush_block(s, buf, stored_len, last)
            //DeflateState *s;
            //charf *buf;       /* input block, or NULL if too old */
            //ulg stored_len;   /* length of input block */
            //int last;         /* one if this is the last block for a file */
            {
                var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
                var max_blindex = 0; /* index of last bit length code of non zero freq */

                /* Build the Huffman trees unless a stored block is forced */
                if (s.level > 0) {

                    /* Check if the file is binary or text */
                    if (s.strm.data_type === Z_UNKNOWN) {
                        s.strm.data_type = detect_data_type(s);
                    }

                    /* Construct the literal and distance trees */
                    build_tree(s, s.l_desc);
                    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                    //        s->static_len));

                    build_tree(s, s.d_desc);
                    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                    //        s->static_len));
                    /* At this point, opt_len and static_len are the total bit lengths of
                     * the compressed block data, excluding the tree representations.
                     */

                    /* Build the bit length tree for the above two trees, and get the index
                     * in bl_order of the last bit length code to send.
                     */
                    max_blindex = build_bl_tree(s);

                    /* Determine the best encoding. Compute the block lengths in bytes. */
                    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
                    static_lenb = (s.static_len + 3 + 7) >>> 3;

                    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                    //        s->last_lit));

                    if (static_lenb <= opt_lenb) {
                        opt_lenb = static_lenb;
                    }

                } else {
                    // Assert(buf != (char*)0, "lost buf");
                    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
                }

                if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
                    /* 4: two words for the lengths */

                    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
                     * Otherwise we can't have processed more than WSIZE input bytes since
                     * the last block flush, because compression would have been
                     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
                     * transform a block into a stored block.
                     */
                    _tr_stored_block(s, buf, stored_len, last);

                } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

                    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                    compress_block(s, static_ltree, static_dtree);

                } else {
                    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                    compress_block(s, s.dyn_ltree, s.dyn_dtree);
                }
                // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
                /* The above check is made mod 2^32, for files larger than 512 MB
                 * and uLong implemented on 32 bits.
                 */
                init_block(s);

                if (last) {
                    bi_windup(s);
                }
                // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
                //       s->compressed_len-7*last));
            }

            /* ===========================================================================
             * Save the match info and tally the frequency counts. Return true if
             * the current block must be flushed.
             */
            function _tr_tally(s, dist, lc)
            //    deflate_state *s;
            //    unsigned dist;  /* distance of matched string */
            //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
            {
                //var out_length, in_length, dcode;

                s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

                s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
                s.last_lit++;

                if (dist === 0) {
                    /* lc is the unmatched char */
                    s.dyn_ltree[lc * 2] /*.Freq*/ ++;
                } else {
                    s.matches++;
                    /* Here, lc is the match length - MIN_MATCH */
                    dist--; /* dist = match distance - 1 */
                    //Assert((ush)dist < (ush)MAX_DIST(s) &&
                    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
                    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

                    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/ ++;
                    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/ ++;
                }

                // (!) This block is disabled in zlib defailts,
                // don't enable it for binary compatibility

                //#ifdef TRUNCATE_BLOCK
                //  /* Try to guess if it is profitable to stop the current block here */
                //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
                //    /* Compute an upper bound for the compressed length */
                //    out_length = s.last_lit*8;
                //    in_length = s.strstart - s.block_start;
                //
                //    for (dcode = 0; dcode < D_CODES; dcode++) {
                //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
                //    }
                //    out_length >>>= 3;
                //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
                //    //       s->last_lit, in_length, out_length,
                //    //       100L - out_length*100L/in_length));
                //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
                //      return true;
                //    }
                //  }
                //#endif

                return (s.last_lit === s.lit_bufsize - 1);
                /* We avoid equality with lit_bufsize because of wraparound at 64K
                 * on 16 bit machines and because stored blocks are restricted to
                 * 64K-1 bytes.
                 */
            }

            exports._tr_init = _tr_init;
            exports._tr_stored_block = _tr_stored_block;
            exports._tr_flush_block = _tr_flush_block;
            exports._tr_tally = _tr_tally;
            exports._tr_align = _tr_align;

        }, {
            "../utils/common": 62
        }],
        74: [function(require, module, exports) {
            'use strict';

            // (C) 1995-2013 Jean-loup Gailly and Mark Adler
            // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
            //
            // This software is provided 'as-is', without any express or implied
            // warranty. In no event will the authors be held liable for any damages
            // arising from the use of this software.
            //
            // Permission is granted to anyone to use this software for any purpose,
            // including commercial applications, and to alter it and redistribute it
            // freely, subject to the following restrictions:
            //
            // 1. The origin of this software must not be misrepresented; you must not
            //   claim that you wrote the original software. If you use this software
            //   in a product, an acknowledgment in the product documentation would be
            //   appreciated but is not required.
            // 2. Altered source versions must be plainly marked as such, and must not be
            //   misrepresented as being the original software.
            // 3. This notice may not be removed or altered from any source distribution.

            function ZStream() {
                /* next input byte */
                this.input = null; // JS specific, because we have no pointers
                this.next_in = 0;
                /* number of bytes available at input */
                this.avail_in = 0;
                /* total number of input bytes read so far */
                this.total_in = 0;
                /* next output byte should be put there */
                this.output = null; // JS specific, because we have no pointers
                this.next_out = 0;
                /* remaining free space at output */
                this.avail_out = 0;
                /* total number of bytes output so far */
                this.total_out = 0;
                /* last error message, NULL if no error */
                this.msg = '' /*Z_NULL*/ ;
                /* not visible by applications */
                this.state = null;
                /* best guess about the data type: binary or text */
                this.data_type = 2 /*Z_UNKNOWN*/ ;
                /* adler32 value of the uncompressed data */
                this.adler = 0;
            }

            module.exports = ZStream;

        }, {}]
    };

    var expose = init(cache,{},[10]);

    return expose(10);
});
define('skylark-data-zip/zip',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "./_stuk/jszip"
], function(skylark, langx,JSZip) {

    var zip = function(data, options) {
        var zip =  new JSZip();
        if (arguments.length>0) {
        	return zip.loadAsync(data, options);
        } else {
        	return zip;
        }
    };

    langx.mixin(zip, {
        "ZipFile": JSZip
    });

    return skylark.attach("data.zip", zip);

});
define('skylark-data-zip/main',[
    "skylark-langx/skylark",
    "./zip"
], function(skylark) {
    return skylark;
});

define('skylark-data-zip', ['skylark-data-zip/main'], function (main) { return main; });

define('skylark-net-http/Restful',[
    "skylark-langx-objects",
    "skylark-langx-strings",
    "skylark-langx-emitter/Evented",    
    "./Xhr"
],function(objects,strings,Evented,Xhr){
    var mixin = objects.mixin,
        substitute = strings.substitute;

    var Restful = Evented.inherit({
        "klassName" : "Restful",

        "idAttribute": "id",
        
        getBaseUrl : function(args) {
            //$$baseEndpoint : "/files/${fileId}/comments",
            var baseEndpoint = substitute(this.baseEndpoint,args),
                baseUrl = this.server + this.basePath + baseEndpoint;
            if (args[this.idAttribute]!==undefined) {
                baseUrl = baseUrl + "/" + args[this.idAttribute]; 
            }
            return baseUrl;
        },
        _head : function(args) {
            //get resource metadata .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
        },
        _get : function(args) {
            //get resource ,one or list .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, null if list
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            return Xhr.get(this.getBaseUrl(args),args);
        },
        _post  : function(args,verb) {
            //create or move resource .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "data" : body // the own data,required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            //verb : the verb ,ex: copy,touch,trash,untrash,watch
            var url = this.getBaseUrl(args);
            if (verb) {
                url = url + "/" + verb;
            }
            return Xhr.post(url, args);
        },

        _put  : function(args,verb) {
            //update resource .
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "data" : body // the own data,required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            //verb : the verb ,ex: copy,touch,trash,untrash,watch
            var url = this.getBaseUrl(args);
            if (verb) {
                url = url + "/" + verb;
            }
            return Xhr.put(url, args);
        },

        _delete : function(args) {
            //delete resource . 
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}         

            // HTTP request : DELETE http://center.utilhub.com/registry/v1/apps/{appid}
            var url = this.getBaseUrl(args);
            return Xhr.del(url);
        },

        _patch : function(args){
            //update resource metadata. 
            //args : id and other info for the resource ,ex
            //{
            //  "id" : 234,  // the own id, required
            //  "data" : body // the own data,required
            //  "fileId"   : 2 // the parent resource id, option by resource
            //}
            var url = this.getBaseUrl(args);
            return Xhr.patch(url, args);
        },
        query: function(params) {
            
            return this._post(params);
        },

        retrieve: function(params) {
            return this._get(params);
        },

        create: function(params) {
            return this._post(params);
        },

        update: function(params) {
            return this._put(params);
        },

        delete: function(params) {
            // HTTP request : DELETE http://center.utilhub.com/registry/v1/apps/{appid}
            return this._delete(params);
        },

        patch: function(params) {
           // HTTP request : PATCH http://center.utilhub.com/registry/v1/apps/{appid}
            return this._patch(params);
        },
        init: function(params) {
            mixin(this,params);
 //           this._xhr = XHRx();
       }
    });

    return Restful;
});
define('skylark-net-http/Upload',[
    "skylark-langx-types",
    "skylark-langx-objects",
    "skylark-langx-arrays",
    "skylark-langx-async/Deferred",
    "skylark-langx-emitter/Evented",    
    "./Xhr",
    "./http"
],function(types, objects, arrays, Deferred, Evented,Xhr, http){

    var blobSlice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;


    /*
     *Class for uploading files using xhr.
     */
    var Upload = Evented.inherit({
        klassName : "Upload",

        _construct : function(options) {
            this._options = objects.mixin({
                debug: false,
                url: '/upload',
                // maximum number of concurrent uploads
                maxConnections: 999,
                // To upload large files in smaller chunks, set the following option
                // to a preferred maximum chunk size. If set to 0, null or undefined,
                // or the browser does not support the required Blob API, files will
                // be uploaded as a whole.
                maxChunkSize: undefined,

                onProgress: function(id, fileName, loaded, total){
                },
                onComplete: function(id, fileName){
                },
                onCancel: function(id, fileName){
                },
                onFailure : function(id,fileName,e) {                    
                }
            },options);

            this._queue = [];
            // params for files in queue
            this._params = [];

            this._files = [];
            this._xhrs = [];

            // current loaded size in bytes for each file
            this._loaded = [];

        },

        /**
         * Adds file to the queue
         * Returns id to use with upload, cancel
         **/
        add: function(file){
            return this._files.push(file) - 1;
        },

        /**
         * Sends the file identified by id and additional query params to the server.
         */
        send: function(id, params){
            if (!this._files[id]) {
                // Already sended or canceled
                return ;
            }
            if (this._queue.indexOf(id)>-1) {
                // Already in the queue
                return;
            }
            var len = this._queue.push(id);

            var copy = objects.clone(params);

            this._params[id] = copy;

            // if too many active uploads, wait...
            if (len <= this._options.maxConnections){
                this._send(id, this._params[id]);
            }     
        },

        /**
         * Sends all files  and additional query params to the server.
         */
        sendAll: function(params){
           for( var id = 0; id <this._files.length; id++) {
                this.send(id,params);
            }
        },

        /**
         * Cancels file upload by id
         */
        cancel: function(id){
            this._cancel(id);
            this._dequeue(id);
        },

        /**
         * Cancells all uploads
         */
        cancelAll: function(){
            for (var i=0; i<this._queue.length; i++){
                this._cancel(this._queue[i]);
            }
            this._queue = [];
        },

        getName: function(id){
            var file = this._files[id];
            return file.fileName != null ? file.fileName : file.name;
        },

        getSize: function(id){
            var file = this._files[id];
            return file.fileSize != null ? file.fileSize : file.size;
        },

        /**
         * Returns uploaded bytes for file identified by id
         */
        getLoaded: function(id){
            return this._loaded[id] || 0;
        },


        /**
         * Sends the file identified by id and additional query params to the server
         * @param {Object} params name-value string pairs
         */
        _send: function(id, params){
            var options = this._options,
                name = this.getName(id),
                size = this.getSize(id),
                chunkSize = options.maxChunkSize || 0,
                curUploadingSize,
                curLoadedSize = 0,
                file = this._files[id],
                args = {
                    headers : {
                    }                    
                };

            this._loaded[id] = this._loaded[id] || 0;

            var xhr = this._xhrs[id] = new Xhr({
                url : options.url
            });

            if (chunkSize)  {

                args.data = blobSlice.call(
                    file,
                    this._loaded[id],
                    this._loaded[id] + chunkSize,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                curUploadingSize = args.data.size;
                // Expose the chunk bytes position range:
                args.headers["content-range"] = 'bytes ' + this._loaded[id] + '-' +
                    (this._loaded[id] + curUploadingSize - 1) + '/' + size;
                args.headers["Content-Type"] = "application/octet-stream";
            }  else {
                curUploadingSize = size;
                var formParamName =  params.formParamName,
                    formData = params.formData;

                if (formParamName) {
                    if (!formData) {
                        formData = new FormData();
                    }
                    formData.append(formParamName,file);
                    args.data = formData;
    
                } else {
                    args.headers["Content-Type"] = file.type || "application/octet-stream";
                    args.data = file;
                }
            }


            var self = this;
            xhr.post(
                args
            ).progress(function(e){
                if (e.lengthComputable){
                    curLoadedSize = curLoadedSize + e.loaded;
                    self._loaded[id] = self._loaded[id] + e.loaded;
                    self._options.onProgress(id, name, self._loaded[id], size);
                }
            }).then(function(){
                if (!self._files[id]) {
                    // the request was aborted/cancelled
                    return;
                }

                if (curLoadedSize < curUploadingSize) {
                    // Create a progress event if no final progress event
                    // with loaded equaling total has been triggered
                    // for this chunk:
                    self._loaded[id] = self._loaded[id] + curUploadingSize - curLoadedSize;
                    self._options.onProgress(id, name, self._loaded[id], size);                    
                }

                if (self._loaded[id] <size) {
                    // File upload not yet complete,
                    // continue with the next chunk:
                    self._send(id,params);
                } else {
                    self._options.onComplete(id,name);

                    self._files[id] = null;
                    self._xhrs[id] = null;
                    self._dequeue(id);
                }


            }).catch(function(e){
                self._options.onFailure(id,name,e);

                self._files[id] = null;
                self._xhrs[id] = null;
                self._dequeue(id);
            });
        },

        _cancel: function(id){
            this._options.onCancel(id, this.getName(id));

            this._files[id] = null;

            if (this._xhrs[id]){
                this._xhrs[id].abort();
                this._xhrs[id] = null;
            }
        },

        /**
         * Returns id of files being uploaded or
         * waiting for their turn
         */
        getQueue: function(){
            return this._queue;
        },


        /**
         * Removes element from queue, starts upload of next
         */
        _dequeue: function(id){
            var i = arrays.inArray(id,this._queue);
            this._queue.splice(i, 1);

            var max = this._options.maxConnections;

            if (this._queue.length >= max && i < max){
                var nextId = this._queue[max-1];
                this._send(nextId, this._params[nextId]);
            }
        }
    });

    return http.Upload = Upload;    
});
define('skylark-net-http/main',[
	"./http",
	"./Restful",
	"./Xhr",
	"./Upload"
],function(http){
	return http;
});
define('skylark-net-http', ['skylark-net-http/main'], function (main) { return main; });

define('skylark-data-color/colors',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
],function(skylark,langx) {
    /*
     * This module uses the following open source code:
     *   TinyColor v1.1.2
     *     https://github.com/bgrins/TinyColor
     *     Brian Grinstead, MIT License
     */

    var colors = skylark.colors =  skylark.colors || {};

    var trimLeft = /^[\s,#]+/,
        trimRight = /\s+$/,
        math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathRandom = math.random;


     // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = colors.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = colors.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = { };
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }
       


    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, color.s, color.v);
                ok = true;
                format = "hsv";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
                color.s = convertToPercentage(color.s);
                color.l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, color.s, color.l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if(max == min) {
            h = 0; // achromatic
        }
        else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
     function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b and a are contained in the set [0, 255]
    // Returns an 8 character hex
    function rgbaToHex(r, g, b, a) {

        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        return hex.join("");
    }



    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }

    var matchers = (function() {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    langx.mixin(colors,{
        inputToRGB : inputToRGB,
        rgbToRgb : rgbToRgb,
        rgbToHsl : rgbToHsl,
        hslToRgb : hslToRgb,
        rgbToHsv : rgbToHsv,
        rgbToHex : rgbToHex,
        rgbaToHex : rgbaToHex,
        boundAlpha : boundAlpha,
        bound01 : bound01,
        clamp01 : clamp01,
        parseIntFromHex : parseIntFromHex,
        isOnePointZero : isOnePointZero,
        isPercentage : isPercentage,
        pad2 : pad2,
        convertToPercentage : convertToPercentage,
        convertHexToDecimal : convertHexToDecimal,
        stringInputToObject : stringInputToObject

    });

    return skylark.attach("data.colors",colors);

});

define('skylark-data-color/Color',[
    "skylark-langx/langx",
    "./colors"
],function(langx,colors) {
    /*
     * This module uses the following open source code:
     *   TinyColor v1.1.2
     *     https://github.com/bgrins/TinyColor
     *     Brian Grinstead, MIT License
     */

    var inputToRGB = colors.inputToRGB,
        rgbToRgb = colors.rgbToRgb,
        rgbToHsl = colors.rgbToHsl,
        hslToRgb = colors.hslToRgb,
        rgbToHsv = colors.rgbToHsv,
        rgbToHex = colors.rgbToHex,
        rgbaToHex = colors.rgbaToHex,
        boundAlpha = colors.boundAlpha,
        bound01 = colors.bound01,
        clamp01 = colors.clamp01,
        parseIntFromHex = colors.parseIntFromHex,
        isOnePointZero = colors.isOnePointZero,
        isPercentage = colors.isPercentage,
        pad2 = colors.pad2,
        convertToPercentage = colors.convertToPercentage,
        convertHexToDecimal = colors.convertHexToDecimal,
        stringInputToObject = colors.stringInputToObject,
        hexNames = colors.hexNames;

    var tinyCounter = 0,
        math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathRandom = math.random;

	var Color = colors.Color = langx.klass({
		init : function(color, opts) {
	        color = (color) ? color : '';
    	    opts = opts || { };

	        // If input is already a Color, return itself
	        if (color instanceof Color) {
	           return color;
	        }

	        var rgb = inputToRGB(color);
	        this._originalInput = color,
	        this._r = rgb.r,
	        this._g = rgb.g,
	        this._b = rgb.b,
	        this._a = rgb.a,
	        this._roundA = mathRound(1000 * this._a) / 1000,
	        this._format = opts.format || rgb.format;
	        this._gradientType = opts.gradientType;

	        // Don't let the range of [0,255] come back in [0,1].
	        // Potentially lose a little bit of precision here, but will fix issues where
	        // .5 gets interpreted as half of the total, instead of half of 1
	        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
	        if (this._r < 1) { this._r = mathRound(this._r); }
	        if (this._g < 1) { this._g = mathRound(this._g); }
	        if (this._b < 1) { this._b = mathRound(this._b); }

	        this._ok = rgb.ok;
	        this._tc_id = tinyCounter++;
	    },

        isDark: function() {
            return this.getBrightness() < 128;
        },
        isLight: function() {
            return !this.isDark();
        },
        isValid: function() {
            return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
            return this._format;
        },
        getAlpha: function() {
            return this._a;
        },
        getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(1000 * this._a) / 1000;
            return this;
        },
        toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
              "hsv("  + h + ", " + s + "%, " + v + "%)" :
              "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        },
        toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
              "hsl("  + h + ", " + s + "%, " + l + "%)" :
              "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
        },
        toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function() {
            return rgbaToHex(this._r, this._g, this._b, this._a);
        },
        toHex8String: function() {
            return '#' + this.toHex8();
        },
        toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
              "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
              "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
            var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = Color(secondColor);
                secondHex8String = s.toHex8String();
            }

            return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
        },
        toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },

        _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function() {
            return this._applyModification(lighten, arguments);
        },
        brighten: function() {
            return this._applyModification(brighten, arguments);
        },
        darken: function() {
            return this._applyModification(darken, arguments);
        },
        desaturate: function() {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
            return this._applyModification(greyscale, arguments);
        },
        spin: function() {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
            return this._applyCombination(analogous, arguments);
        },
        complement: function() {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
            return this._applyCombination(tetrad, arguments);
        }
	});



    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    Color.fromRatio = function(color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return Color(color, opts);
    };

    // `equals`
    // Can be called with any Color input
    Color.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        return Color(color1).toRgbString() == Color(color2).toRgbString();
    };
    
    Color.random = function() {
        return Color.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };

   // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = Color(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return Color(hsl);
    }

    function saturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = Color(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return Color(hsl);
    }

    function greyscale(color) {
        return Color(color).desaturate(100);
    }

    function lighten (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = Color(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return Color(hsl);
    }

    function brighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var rgb = Color(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
        return Color(rgb);
    }

    function darken (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = Color(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return Color(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = Color(color).toHsl();
        var hue = (mathRound(hsl.h) + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return Color(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = Color(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return Color(hsl);
    }

    function triad(color) {
        var hsl = Color(color).toHsl();
        var h = hsl.h;
        return [
            Color(color),
            Color({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            Color({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function tetrad(color) {
        var hsl = Color(color).toHsl();
        var h = hsl.h;
        return [
            Color(color),
            Color({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            Color({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            Color({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function splitcomplement(color) {
        var hsl = Color(color).toHsl();
        var h = hsl.h;
        return [
            Color(color),
            Color({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
            Color({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
        ];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = Color(color).toHsl();
        var part = 360 / slices;
        var ret = [Color(color)];

        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(Color(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = Color(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(Color({ h: h, s: s, v: v}));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    Color.mix = function(color1, color2, amount) {
        amount = (amount === 0) ? 0 : (amount || 50);

        var rgb1 = Color(color1).toRgb();
        var rgb2 = Color(color2).toRgb();

        var p = amount / 100;
        var w = p * 2 - 1;
        var a = rgb2.a - rgb1.a;

        var w1;

        if (w * a == -1) {
            w1 = w;
        } else {
            w1 = (w + a) / (1 + w * a);
        }

        w1 = (w1 + 1) / 2;

        var w2 = 1 - w1;

        var rgba = {
            r: rgb2.r * w1 + rgb1.r * w2,
            g: rgb2.g * w1 + rgb1.g * w2,
            b: rgb2.b * w1 + rgb1.b * w2,
            a: rgb2.a * p  + rgb1.a * (1 - p)
        };

        return Color(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/AERT#color-contrast>

    // `readability`
    // Analyze the 2 colors and returns an object with the following properties:
    //    `brightness`: difference in brightness between the two colors
    //    `color`: difference in color/hue between the two colors
    Color.readability = function(color1, color2) {
        var c1 = Color(color1);
        var c2 = Color(color2);
        var rgb1 = c1.toRgb();
        var rgb2 = c2.toRgb();
        var brightnessA = c1.getBrightness();
        var brightnessB = c2.getBrightness();
        var colorDiff = (
            Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) +
            Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) +
            Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b)
        );

        return {
            brightness: Math.abs(brightnessA - brightnessB),
            color: colorDiff
        };
    };

    // `readable`
    // http://www.w3.org/TR/AERT#color-contrast
    // Ensure that foreground and background color combinations provide sufficient contrast.
    // *Example*
    //    Color.isReadable("#000", "#111") => false
    Color.isReadable = function(color1, color2) {
        var readability = Color.readability(color1, color2);
        return readability.brightness > 125 && readability.color > 500;
    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // *Example*
    //    Color.mostReadable("#123", ["#fff", "#000"]) => "#000"
    Color.mostReadable = function(baseColor, colorList) {
        var bestColor = null;
        var bestScore = 0;
        var bestIsReadable = false;
        for (var i=0; i < colorList.length; i++) {

            // We normalize both around the "acceptable" breaking point,
            // but rank brightness constrast higher than hue.

            var readability = Color.readability(baseColor, colorList[i]);
            var readable = readability.brightness > 125 && readability.color > 500;
            var score = 3 * (readability.brightness / 125) + (readability.color / 500);

            if ((readable && ! bestIsReadable) ||
                (readable && bestIsReadable && score > bestScore) ||
                ((! readable) && (! bestIsReadable) && score > bestScore)) {
                bestIsReadable = readable;
                bestScore = score;
                bestColor = Color(colorList[i]);
            }
        }
        return bestColor;
    };


	return Color;
});

define('skylark-widgets-colorpicker/ColorPicker',[
   "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-data-color/colors",
    "skylark-data-color/Color",
    "skylark-widgets-swt/swt",
    "skylark-widgets-swt/Widget"
],function(skylark, langx, browser, noder, eventer,finder, $, colors, Color, swt, Widget) {
    "use strict";

    var noop = langx.noop;
    // Spectrum Colorpicker v1.8.0
    // https://github.com/bgrins/spectrum
    // Author: Brian Grinstead
    // License: MIT


    var defaultOpts = {

        // Callbacks
        beforeShow: noop,
        move: noop,
        change: noop,
        show: noop,
        hide: noop,

        // Options
        color: false,
        flat: false,
        showInput: false,
        allowEmpty: false,
        showButtons: true,
        clickoutFiresChange: true,
        showInitial: false,
        showPalette: false,
        showPaletteOnly: false,
        hideAfterPaletteSelect: false,
        togglePaletteOnly: false,
        showSelectionPalette: true,
        localStorageKey: false,
        appendTo: "body",
        maxSelectionSize: 7,
        cancelText: "cancel",
        chooseText: "choose",
        togglePaletteMoreText: "more",
        togglePaletteLessText: "less",
        clearText: "Clear Color Selection",
        noColorSelectedText: "No Color Selected",
        preferredFormat: false,
        className: "", // Deprecated - use containerClassName and replacerClassName instead.
        containerClassName: "",
        replacerClassName: "",
        showAlpha: false,
        theme: "sp-light",
        palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],
        selectionPalette: [],
        disabled: false,
        offset: null
    },
    pickers = [],
    replaceInput = [
        "<div class='sp-replacer'>",
            "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
            "<div class='sp-dd'>&#9660;</div>",
        "</div>"
    ].join(''),
    markup = (function () {

        // IE7-10 does not support gradients with multiple stops, so we need to simulate
        //  that for the rainbow slider with 8 divs that each have a single gradient
        var gradientFix = "";
        if (browser.isIE) {
            for (var i = 1; i <= 6; i++) {
                gradientFix += "<div class='sp-" + i + "'></div>";
            }
        }

        return [
            "<div class='sp-container sp-hidden'>",
                "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                    "<div class='sp-palette-button-container sp-cf'>",
                        "<button type='button' class='sp-palette-toggle'></button>",
                    "</div>",
                "</div>",
                "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                        "<div class='sp-fill'></div>",
                        "<div class='sp-top-inner'>",
                            "<div class='sp-color'>",
                                "<div class='sp-sat'>",
                                    "<div class='sp-val'>",
                                        "<div class='sp-dragger'></div>",
                                    "</div>",
                                "</div>",
                            "</div>",
                            "<div class='sp-clear sp-clear-display'>",
                            "</div>",
                            "<div class='sp-hue'>",
                                "<div class='sp-slider'></div>",
                                gradientFix,
                            "</div>",
                        "</div>",
                        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    "</div>",
                    "<div class='sp-input-container sp-cf'>",
                        "<input class='sp-input' type='text' spellcheck='false'  />",
                    "</div>",
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                        "<a class='sp-cancel' href='#'></a>",
                        "<button type='button' class='sp-choose'></button>",
                    "</div>",
                "</div>",
            "</div>"
        ].join("");
    })();

    function paletteTemplate (p, color, className, opts) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var current = p[i];
            if(current) {
                var tiny = colors.Color(current);
                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
                c += (Color.equals(color, current)) ? " sp-thumb-active" : "";
                var formattedString = tiny.toString(opts.preferredFormat || "rgb");
                var swatchStyle = "background-color:" + tiny.toRgbString();
                html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
            } else {
                var cls = 'sp-clear-display';
                html.push($('<div />')
                    .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>')
                        .attr('title', opts.noColorSelectedText)
                    )
                    .html()
                );
            }
        }
        return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
    }

    function hideAll() {
        for (var i = 0; i < pickers.length; i++) {
            if (pickers[i]) {
                pickers[i].hide();
            }
        }
    }

    function instanceOptions(o, callbackContext) {
        var opts = langx.mixin({}, defaultOpts, o);
        opts.callbacks = {
            'move': bind(opts.move, callbackContext),
            'change': bind(opts.change, callbackContext),
            'show': bind(opts.show, callbackContext),
            'hide': bind(opts.hide, callbackContext),
            'beforeShow': bind(opts.beforeShow, callbackContext)
        };

        return opts;
    }

    function init(element, o) {

        var opts = instanceOptions(o, element),
            flat = opts.flat,
            showSelectionPalette = opts.showSelectionPalette,
            localStorageKey = opts.localStorageKey,
            theme = opts.theme,
            callbacks = opts.callbacks,
            resize = langx.debounce(reflow, 10),
            visible = false,
            isDragging = false,
            dragWidth = 0,
            dragHeight = 0,
            dragHelperHeight = 0,
            slideHeight = 0,
            slideWidth = 0,
            alphaWidth = 0,
            alphaSlideHelperWidth = 0,
            slideHelperHeight = 0,
            currentHue = 0,
            currentSaturation = 0,
            currentValue = 0,
            currentAlpha = 1,
            palette = [],
            paletteArray = [],
            paletteLookup = {},
            selectionPalette = opts.selectionPalette.slice(0),
            maxSelectionSize = opts.maxSelectionSize,
            draggingClass = "sp-dragging",
            shiftMovementDirection = null;

        var doc = element.ownerDocument,
            body = doc.body,
            boundElement = $(element),
            disabled = false,
            container = $(markup, doc).addClass(theme),
            pickerContainer = container.find(".sp-picker-container"),
            dragger = container.find(".sp-color"),
            dragHelper = container.find(".sp-dragger"),
            slider = container.find(".sp-hue"),
            slideHelper = container.find(".sp-slider"),
            alphaSliderInner = container.find(".sp-alpha-inner"),
            alphaSlider = container.find(".sp-alpha"),
            alphaSlideHelper = container.find(".sp-alpha-handle"),
            textInput = container.find(".sp-input"),
            paletteContainer = container.find(".sp-palette"),
            initialColorContainer = container.find(".sp-initial"),
            cancelButton = container.find(".sp-cancel"),
            clearButton = container.find(".sp-clear"),
            chooseButton = container.find(".sp-choose"),
            toggleButton = container.find(".sp-palette-toggle"),
            isInput = boundElement.is("input"),
            isInputTypeColor = isInput && boundElement.attr("type") === "color" && inputTypeColorSupport(),
            shouldReplace = isInput && !flat,
            replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]),
            offsetElement = (shouldReplace) ? replacer : boundElement,
            previewElement = replacer.find(".sp-preview-inner"),
            initialColor = opts.color || (isInput && boundElement.val()),
            colorOnShow = false,
            currentPreferredFormat = opts.preferredFormat,
            clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
            isEmpty = !initialColor,
            allowEmpty = opts.allowEmpty && !isInputTypeColor;

        function applyOptions() {

            if (opts.showPaletteOnly) {
                opts.showPalette = true;
            }

            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);

            if (opts.palette) {
                palette = opts.palette.slice(0);
                paletteArray = langx.isArray(palette[0]) ? palette : [palette];
                paletteLookup = {};
                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        var rgb = Color(paletteArray[i][j]).toRgbString();
                        paletteLookup[rgb] = true;
                    }
                }
            }

            container.toggleClass("sp-flat", flat);
            container.toggleClass("sp-input-disabled", !opts.showInput);
            container.toggleClass("sp-alpha-enabled", opts.showAlpha);
            container.toggleClass("sp-clear-enabled", allowEmpty);
            container.toggleClass("sp-buttons-disabled", !opts.showButtons);
            container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);
            container.toggleClass("sp-palette-disabled", !opts.showPalette);
            container.toggleClass("sp-palette-only", opts.showPaletteOnly);
            container.toggleClass("sp-initial-disabled", !opts.showInitial);
            container.addClass(opts.className).addClass(opts.containerClassName);

            reflow();
        }

        function initialize() {

            if (browser.isIE) {
                container.find("*:not(input)").attr("unselectable", "on");
            }

            applyOptions();

            if (shouldReplace) {
                boundElement.after(replacer).hide();
            }

            if (!allowEmpty) {
                clearButton.hide();
            }

            if (flat) {
                boundElement.after(container).hide();
            }
            else {

                var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
                if (appendTo.length !== 1) {
                    appendTo = $("body");
                }

                appendTo.append(container);
            }

            updateSelectionPaletteFromStorage();

            offsetElement.on("click.ColorPicker touchstart.ColorPicker", function (e) {
                if (!disabled) {
                    toggle();
                }

                e.stopPropagation();

                if (!$(e.target).is("input")) {
                    e.preventDefault();
                }
            });

            if(boundElement.is(":disabled") || (opts.disabled === true)) {
                disable();
            }

            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
            container.click(stopPropagation);

            // Handle user typed input
            textInput.change(setFromTextInput);
            textInput.on("paste", function () {
                setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });

            cancelButton.text(opts.cancelText);
            cancelButton.on("click.ColorPicker", function (e) {
                e.stopPropagation();
                e.preventDefault();
                revert();
                hide();
            });

            clearButton.attr("title", opts.clearText);
            clearButton.on("click.ColorPicker", function (e) {
                e.stopPropagation();
                e.preventDefault();
                isEmpty = true;
                move();

                if(flat) {
                    //for the flat style, this is a change event
                    updateOriginalInput(true);
                }
            });

            chooseButton.text(opts.chooseText);
            chooseButton.on("click.ColorPicker", function (e) {
                e.stopPropagation();
                e.preventDefault();

                if (browser.isIE && textInput.is(":focus")) {
                    textInput.trigger('change');
                }

                if (isValid()) {
                    updateOriginalInput(true);
                    hide();
                }
            });

            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            toggleButton.on("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();

                opts.showPaletteOnly = !opts.showPaletteOnly;

                // To make sure the Picker area is drawn on the right, next to the
                // Palette area (and not below the palette), first move the Palette
                // to the left to make space for the picker, plus 5px extra.
                // The 'applyOptions' function puts the whole container back into place
                // and takes care of the button-text and the sp-palette-only CSS class.
                if (!opts.showPaletteOnly && !flat) {
                    container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
                }
                applyOptions();
            });

            draggable(alphaSlider, function (dragX, dragY, e) {
                currentAlpha = (dragX / alphaWidth);
                isEmpty = false;
                if (e.shiftKey) {
                    currentAlpha = Math.round(currentAlpha * 10) / 10;
                }

                move();
            }, dragStart, dragStop);

            draggable(slider, function (dragX, dragY) {
                currentHue = parseFloat(dragY / slideHeight);
                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }
                move();
            }, dragStart, dragStop);

            draggable(dragger, function (dragX, dragY, e) {

                // shift+drag should snap the movement to either the x or y axis.
                if (!e.shiftKey) {
                    shiftMovementDirection = null;
                }
                else if (!shiftMovementDirection) {
                    var oldDragX = currentSaturation * dragWidth;
                    var oldDragY = dragHeight - (currentValue * dragHeight);
                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

                    shiftMovementDirection = furtherFromX ? "x" : "y";
                }

                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

                if (setSaturation) {
                    currentSaturation = parseFloat(dragX / dragWidth);
                }
                if (setValue) {
                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                }

                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }

                move();

            }, dragStart, dragStop);

            if (!!initialColor) {
                set(initialColor);

                // In case color was black - update the preview UI and set the format
                // since the set function will not run (default color is black).
                updateUI();
                currentPreferredFormat = opts.preferredFormat || Color(initialColor).format;

                addColorToSelectionPalette(initialColor);
            }
            else {
                updateUI();
            }

            if (flat) {
                show();
            }

            function paletteElementClick(e) {
                if (e.data && e.data.ignore) {
                    set($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                }
                else {
                    set($(e.target).closest(".sp-thumb-el").data("color"));
                    move();

                    // If the picker is going to close immediately, a palette selection
                    // is a change.  Otherwise, it's a move only.
                    if (opts.hideAfterPaletteSelect) {
                        updateOriginalInput(true);
                        hide();
                    } else {
                        updateOriginalInput();
                    }
                }

                return false;
            }

            var paletteEvent = browser.isIE ? "mousedown.ColorPicker" : "click.ColorPicker touchstart.ColorPicker";
            paletteContainer.on(paletteEvent, ".sp-thumb-el", paletteElementClick);
            initialColorContainer.on(paletteEvent, ".sp-thumb-el:nth-child(1)", { ignore: true }, paletteElementClick);
        }

        function updateSelectionPaletteFromStorage() {

            if (localStorageKey && window.localStorage) {

                // Migrate old palettes over to new format.  May want to remove this eventually.
                try {
                    var oldPalette = window.localStorage[localStorageKey].split(",#");
                    if (oldPalette.length > 1) {
                        delete window.localStorage[localStorageKey];
                        langx.each(oldPalette, function(i, c) {
                             addColorToSelectionPalette(c);
                        });
                    }
                }
                catch(e) { }

                try {
                    selectionPalette = window.localStorage[localStorageKey].split(";");
                }
                catch (e) { }
            }
        }

        function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
                var rgb = Color(color).toRgbString();
                if (!paletteLookup[rgb] && langx.inArray(rgb, selectionPalette) === -1) {
                    selectionPalette.push(rgb);
                    while(selectionPalette.length > maxSelectionSize) {
                        selectionPalette.shift();
                    }
                }

                if (localStorageKey && window.localStorage) {
                    try {
                        window.localStorage[localStorageKey] = selectionPalette.join(";");
                    }
                    catch(e) { }
                }
            }
        }

        function getUniqueSelectionPalette() {
            var unique = [];
            if (opts.showPalette) {
                for (var i = 0; i < selectionPalette.length; i++) {
                    var rgb = Color(selectionPalette[i]).toRgbString();

                    if (!paletteLookup[rgb]) {
                        unique.push(selectionPalette[i]);
                    }
                }
            }

            return unique.reverse().slice(0, opts.maxSelectionSize);
        }

        function drawPalette() {

            var currentColor = get();

            var html = langx.map(paletteArray, function (palette, i) {
                return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);
            });

            updateSelectionPaletteFromStorage();

            if (selectionPalette) {
                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
            }

            paletteContainer.html(html.join(""));
        }

        function drawInitial() {
            if (opts.showInitial) {
                var initial = colorOnShow;
                var current = get();
                initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));
            }
        }

        function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                reflow();
            }
            isDragging = true;
            container.addClass(draggingClass);
            shiftMovementDirection = null;
            boundElement.trigger('dragstart.ColorPicker', [ get() ]);
        }

        function dragStop() {
            isDragging = false;
            container.removeClass(draggingClass);
            boundElement.trigger('dragstop.ColorPicker', [ get() ]);
        }

        function setFromTextInput() {

            var value = textInput.val();

            if ((value === null || value === "") && allowEmpty) {
                set(null);
                move();
                updateOriginalInput();
            }
            else {
                var tiny = Color(value);
                if (tiny.isValid()) {
                    set(tiny);
                    move();
                    updateOriginalInput();
                }
                else {
                    textInput.addClass("sp-validation-error");
                }
            }
        }

        function toggle() {
            if (visible) {
                hide();
            }
            else {
                show();
            }
        }

        function show() {
            var event = eventer.create('beforeShow.ColorPicker');

            if (visible) {
                reflow();
                return;
            }

            boundElement.trigger(event, [ get() ]);

            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                return;
            }

            hideAll();
            visible = true;

            $(doc).on("keydown.ColorPicker", onkeydown);
            $(doc).on("click.ColorPicker", clickout);
            $(window).on("resize.ColorPicker", resize);
            replacer.addClass("sp-active");
            container.removeClass("sp-hidden");

            reflow();
            updateUI();

            colorOnShow = get();

            drawInitial();
            callbacks.show(colorOnShow);
            boundElement.trigger('show.ColorPicker', [ colorOnShow ]);
        }

        function onkeydown(e) {
            // Close on ESC
            if (e.keyCode === 27) {
                hide();
            }
        }

        function clickout(e) {
            // Return on right click.
            if (e.button == 2) { return; }

            // If a drag event was happening during the mouseup, don't hide
            // on click.
            if (isDragging) { return; }

            if (clickoutFiresChange) {
                updateOriginalInput(true);
            }
            else {
                revert();
            }
            hide();
        }

        function hide() {
            // Return if hiding is unnecessary
            if (!visible || flat) { return; }
            visible = false;

            $(doc).off("keydown.ColorPicker", onkeydown);
            $(doc).off("click.ColorPicker", clickout);
            $(window).off("resize.ColorPicker", resize);

            replacer.removeClass("sp-active");
            container.addClass("sp-hidden");

            callbacks.hide(get());
            boundElement.trigger('hide.ColorPicker', [ get() ]);
        }

        function revert() {
            set(colorOnShow, true);
            updateOriginalInput(true);
        }

        function set(color, ignoreFormatChange) {
            if (Color.equals(color, get())) {
                // Update UI just in case a validation error needs
                // to be cleared.
                updateUI();
                return;
            }

            var newColor, newHsv;
            if (!color && allowEmpty) {
                isEmpty = true;
            } else {
                isEmpty = false;
                newColor = colors.Color(color);
                newHsv = newColor.toHsv();

                currentHue = (newHsv.h % 360) / 360;
                currentSaturation = newHsv.s;
                currentValue = newHsv.v;
                currentAlpha = newHsv.a;
            }
            updateUI();

            if (newColor && newColor.isValid() && !ignoreFormatChange) {
                currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
            }
        }

        function get(opts) {
            opts = opts || { };

            if (allowEmpty && isEmpty) {
                return null;
            }

            return Color.fromRatio({
                h: currentHue,
                s: currentSaturation,
                v: currentValue,
                a: Math.round(currentAlpha * 1000) / 1000
            }, { format: opts.format || currentPreferredFormat });
        }

        function isValid() {
            return !textInput.hasClass("sp-validation-error");
        }

        function move() {
            updateUI();

            callbacks.move(get());
            boundElement.trigger('move.ColorPicker', [ get() ]);
        }

        function updateUI() {

            textInput.removeClass("sp-validation-error");

            updateHelperLocations();

            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = Color.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.css("background-color", flatColor.toHexString());

            // Get a format that alpha will be included in (hex and names ignore alpha)
            var format = currentPreferredFormat;
            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                    format = "rgb";
                }
            }

            var realColor = get({ format: format }),
                displayColor = '';

             //reset background info for preview element
            previewElement.removeClass("sp-clear-display");
            previewElement.css('background-color', 'transparent');

            if (!realColor && allowEmpty) {
                // Update the replaced elements background with icon indicating no color selection
                previewElement.addClass("sp-clear-display");
            }
            else {
                var realHex = realColor.toHexString(),
                    realRgb = realColor.toRgbString();

                // Update the replaced elements background color (with actual selected color)
                previewElement.css("background-color", realRgb);

                if (opts.showAlpha) {
                    var rgb = realColor.toRgb();
                    rgb.a = 0;
                    var realAlpha = Color(rgb).toRgbString();
                    var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

                    if (browser.isIE) {
                        alphaSliderInner.css("filter", Color(realAlpha).toFilter({ gradientType: 1 }, realHex));
                    }
                    else {
                        alphaSliderInner.css("background", "-webkit-" + gradient);
                        alphaSliderInner.css("background", "-moz-" + gradient);
                        alphaSliderInner.css("background", "-ms-" + gradient);
                        // Use current syntax gradient on unprefixed property.
                        alphaSliderInner.css("background",
                            "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");
                    }
                }

                displayColor = realColor.toString(format);
            }

            // Update the text entry input as it changes happen
            if (opts.showInput) {
                textInput.val(displayColor);
            }

            if (opts.showPalette) {
                drawPalette();
            }

            drawInitial();
        }

        function updateHelperLocations() {
            var s = currentSaturation;
            var v = currentValue;

            if(allowEmpty && isEmpty) {
                //if selected color is empty, hide the helpers
                alphaSlideHelper.hide();
                slideHelper.hide();
                dragHelper.hide();
            }
            else {
                //make sure helpers are visible
                alphaSlideHelper.show();
                slideHelper.show();
                dragHelper.show();

                // Where to show the little circle in that displays your current selected color
                var dragX = s * dragWidth;
                var dragY = dragHeight - (v * dragHeight);
                dragX = Math.max(
                    -dragHelperHeight,
                    Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
                );
                dragY = Math.max(
                    -dragHelperHeight,
                    Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
                );
                dragHelper.css({
                    "top": dragY + "px",
                    "left": dragX + "px"
                });

                var alphaX = currentAlpha * alphaWidth;
                alphaSlideHelper.css({
                    "left": (alphaX - (alphaSlideHelperWidth / 2)) + "px"
                });

                // Where to show the bar that displays your current selected hue
                var slideY = (currentHue) * slideHeight;
                slideHelper.css({
                    "top": (slideY - slideHelperHeight) + "px"
                });
            }
        }

        function updateOriginalInput(fireCallback) {
            var color = get(),
                displayColor = '',
                hasChanged = !Color.equals(color, colorOnShow);

            if (color) {
                displayColor = color.toString(currentPreferredFormat);
                // Update the selection palette with the current color
                addColorToSelectionPalette(color);
            }

            if (isInput) {
                boundElement.val(displayColor);
            }

            if (fireCallback && hasChanged) {
                callbacks.change(color);
                boundElement.trigger('change', [ color ]);
            }
        }

        function reflow() {
            if (!visible) {
                return; // Calculations would be useless and wouldn't be reliable anyways
            }
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();
            alphaWidth = alphaSlider.width();
            alphaSlideHelperWidth = alphaSlideHelper.width();

            if (!flat) {
                container.css("position", "absolute");
                if (opts.offset) {
                    container.offset(opts.offset);
                } else {
                    container.offset(getOffset(container, offsetElement));
                }
            }

            updateHelperLocations();

            if (opts.showPalette) {
                drawPalette();
            }

            boundElement.trigger('reflow.ColorPicker');
        }

        function destroy() {
            boundElement.show();
            offsetElement.off("click.ColorPicker touchstart.ColorPicker");
            container.remove();
            replacer.remove();
            pickers[spect.id] = null;
        }

        function option(optionName, optionValue) {
            if (optionName === undefined) {
                return langx.mixin({}, opts);
            }
            if (optionValue === undefined) {
                return opts[optionName];
            }

            opts[optionName] = optionValue;

            if (optionName === "preferredFormat") {
                currentPreferredFormat = opts.preferredFormat;
            }
            applyOptions();
        }

        function enable() {
            disabled = false;
            boundElement.attr("disabled", false);
            offsetElement.removeClass("sp-disabled");
        }

        function disable() {
            hide();
            disabled = true;
            boundElement.attr("disabled", true);
            offsetElement.addClass("sp-disabled");
        }

        function setOffset(coord) {
            opts.offset = coord;
            reflow();
        }

        initialize();

        var spect = {
            show: show,
            hide: hide,
            toggle: toggle,
            reflow: reflow,
            option: option,
            enable: enable,
            disable: disable,
            offset: setOffset,
            set: function (c) {
                set(c);
                updateOriginalInput();
            },
            get: get,
            destroy: destroy,
            container: container
        };

        spect.id = pickers.push(spect) - 1;

        return spect;
    }

    var ColorPicker = langx.Evented.inherit({
        klassName : "ColorPicker",

        init : init

    });


    /**
    * checkOffset - get the offset below/above and left/right element depending on screen position
    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
    */
    function getOffset(picker, input) {
        var extraY = 0;
        var dpWidth = picker.outerWidth();
        var dpHeight = picker.outerHeight();
        var inputHeight = input.outerHeight();
        var doc = picker[0].ownerDocument;
        var docElem = doc.documentElement;
        var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
        var viewHeight = docElem.clientHeight + $(doc).scrollTop();
        var offset = input.offset();
        var offsetLeft = offset.left;
        var offsetTop = offset.top;

        offsetTop += inputHeight;

        offsetLeft -=
            Math.min(offsetLeft, (offsetLeft + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offsetLeft + dpWidth - viewWidth) : 0);

        offsetTop -=
            Math.min(offsetTop, ((offsetTop + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + inputHeight - extraY) : extraY));

        return {
            top: offsetTop,
            bottom: offset.bottom,
            left: offsetLeft,
            right: offset.right,
            width: offset.width,
            height: offset.height
        };
    }

    /**
    * stopPropagation - makes the code only doing this a little easier to read in line
    */
    function stopPropagation(e) {
        e.stopPropagation();
    }

    /**
    * Create a function bound to a given object
    * Thanks to underscore.js
    */
    function bind(func, obj) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments, 2);
        return function () {
            return func.apply(obj, args.concat(slice.call(arguments)));
        };
    }

    /**
    * Lightweight drag helper.  Handles containment within the element, so that
    * when dragging, the x is within [0,element.width] and y is within [0,element.height]
    */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;
        var hasTouch = ('ontouchstart' in window);

        var duringDragEvents = {};
        duringDragEvents["selectstart"] = prevent;
        duringDragEvents["dragstart"] = prevent;
        duringDragEvents["touchmove mousemove"] = move;
        duringDragEvents["touchend mouseup"] = stop;

        function prevent(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }

        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (browser.isIE && doc.documentMode < 9 && !e.button) {
                    return stop();
                }

                var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
                var pageX = t0 && t0.pageX || e.pageX;
                var pageY = t0 && t0.pageY || e.pageY;

                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

                if (hasTouch) {
                    // Stop scrolling in iOS
                    prevent(e);
                }

                onmove.apply(element, [dragX, dragY, e]);
            }
        }

        function start(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();

                    $(doc).on(duringDragEvents);
                    $(doc.body).addClass("sp-dragging");

                    move(e);

                    prevent(e);
                }
            }
        }

        function stop() {
            if (dragging) {
                $(doc).off(duringDragEvents);
                $(doc.body).removeClass("sp-dragging");

                // Wait a tick before notifying observers to allow the click event
                // to fire in Chrome.
                setTimeout(function() {
                    onstop.apply(element, arguments);
                }, 0);
            }
            dragging = false;
        }

        $(element).on("touchstart mousedown", start);
    }

    /**
    * Define a query plugin
    */
    var dataID = "ColorPicker.id";
    
    function Plugin(opts, extra) {

        if (typeof opts == "string") {

            var returnValue = this;
            var args = Array.prototype.slice.call( arguments, 1 );

            this.each(function () {
                var spect = pickers[$(this).data(dataID)];
                if (spect) {
                    var method = spect[opts];
                    if (!method) {
                        throw new Error( "skylark-ui-colorpicker: no such method: '" + opts + "'" );
                    }

                    if (opts == "get") {
                        returnValue = spect.get();
                    }
                    else if (opts == "container") {
                        returnValue = spect.container;
                    }
                    else if (opts == "option") {
                        returnValue = spect.option.apply(spect, args);
                    }
                    else if (opts == "destroy") {
                        spect.destroy();
                        $(this).removeData(dataID);
                    }
                    else {
                        method.apply(spect, args);
                    }
                }
            });

            return returnValue;
        }

        // Initializing a new instance of ColorPicker
        return this.colorPicker("destroy").each(function () {
            var options = langx.mixin({}, $(this).data(), opts);
            var spect = ColorPicker(this, options);
            $(this).data(dataID, spect.id);
        });
    }

    ColorPicker.load = true;
    ColorPicker.loadOpts = {};
    ColorPicker.draggable = draggable;
    ColorPicker.defaults = defaultOpts;

    ColorPicker.localization = { };
    ColorPicker.palettes = { };

    $.fn.colorPicker = Plugin;

    return skylark.attach("ui.ColorPicker",ColorPicker);

});

define('skylark-widgets-colorpicker/i18n/texts_ja',[
	"../ColorPicker"
],function(ColorPicker) {
    var localization = ColorPicker.localization["ja"] = {
        cancelText: "中止",
        chooseText: "選択"
    };

    return localization;
});
define('skylark-widgets-colorpicker/i18n/texts_zh-cn',[
	"../ColorPicker"
],function(ColorPicker) {
    var localization = ColorPicker.localization["zh-cn"] = {
        cancelText: "取消",
        chooseText: "选择",
        clearText: "清除",
        togglePaletteMoreText: "更多选项",
        togglePaletteLessText: "隐藏",
        noColorSelectedText: "尚未选择任何颜色"
    };

    return localization;

});

define('skylark-widgets-colorpicker/i18n/texts_zh-tw',[
	"../ColorPicker"
],function(ColorPicker) {
    var localization = ColorPicker.localization["zh-tw"] = {
        cancelText: "取消",
        chooseText: "選擇",
        clearText: "清除",
        togglePaletteMoreText: "更多選項",
        togglePaletteLessText: "隱藏",
        noColorSelectedText: "尚未選擇任何顏色"
    };

    return localization;

});
define('skylark-widgets-colorpicker/main',[
    "./ColorPicker",
    "./i18n/texts_ja",
    "./i18n/texts_zh-cn",
    "./i18n/texts_zh-tw"
], function(ColorPicker) {
    return ColorPicker;
});

define('skylark-widgets-colorpicker', ['skylark-widgets-colorpicker/main'], function (main) { return main; });

define('skylark-widgets-gradienter/Drag',[],function() {
    /**************************************************
     * dom-drag.js
     * 09.25.2001
     * www.youngpup.net
     **************************************************
     * 10.28.2001 - fixed minor bug where events
     * sometimes fired off the handle, not the root.
     **************************************************/

    var Drag = {

        obj : null,

        gradx : null,

        init : function(o, oRoot, minX, maxX, minY, maxY, bSwapHorzRef, bSwapVertRef, fXMapper, fYMapper)
        {
            o.onmousedown	= Drag.start;

            o.hmode			= bSwapHorzRef ? false : true ;
            o.vmode			= bSwapVertRef ? false : true ;

            o.root = oRoot && oRoot != null ? oRoot : o ;

            if (o.hmode  && isNaN(parseInt(o.root.style.left  ))) o.root.style.left   = "0px";
           //if (o.vmode  && isNaN(parseInt(o.root.style.top   ))) o.root.style.top    = "0px";
            if (!o.hmode && isNaN(parseInt(o.root.style.right ))) o.root.style.right  = "0px";
           // if (!o.vmode && isNaN(parseInt(o.root.style.bottom))) o.root.style.bottom = "0px";

            o.minX	= typeof minX != 'undefined' ? minX : null;
            o.minY	= typeof minY != 'undefined' ? minY : null;
            o.maxX	= typeof maxX != 'undefined' ? maxX : null;
            o.maxY	= typeof maxY != 'undefined' ? maxY : null;

            o.xMapper = fXMapper ? fXMapper : null;
            o.yMapper = fYMapper ? fYMapper : null;

            o.root.onDragStart	= new Function();
            o.root.onDragEnd	= new Function();
            o.root.onDrag		= new Function();
        },

        start : function(e)
        {
            Drag.gradx.current_slider_id = "#"+this.id;

            var o = Drag.obj = this;
            e = Drag.fixE(e);
            var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
            var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
            o.root.onDragStart(x, y);

            o.lastMouseX	= e.clientX;
            o.lastMouseY	= e.clientY;

            if (o.hmode) {
                if (o.minX != null)	o.minMouseX	= e.clientX - x + o.minX;
                if (o.maxX != null)	o.maxMouseX	= o.minMouseX + o.maxX - o.minX;
            } else {
                if (o.minX != null) o.maxMouseX = -o.minX + e.clientX + x;
                if (o.maxX != null) o.minMouseX = -o.maxX + e.clientX + x;
            }

            if (o.vmode) {
                if (o.minY != null)	o.minMouseY	= e.clientY - y + o.minY;
                if (o.maxY != null)	o.maxMouseY	= o.minMouseY + o.maxY - o.minY;
            }
            else {
                if (o.minY != null) o.maxMouseY = -o.minY + e.clientY + y;
                if (o.maxY != null) o.minMouseY = -o.maxY + e.clientY + y;
            }

            document.onmousemove	= Drag.drag;
            document.onmouseup	= Drag.end;

            return false;
        },

        drag : function(e)
        {
            e = Drag.fixE(e);
            var o = Drag.obj;

            Drag.gradx.update_style_array();
            Drag.gradx.apply_style(Drag.gradx.panel, Drag.gradx.get_style_value());
            var left = Drag.gradx.gx("#"+o.id).css("left");


            if(parseInt(left) > 60 && parseInt(left) < 390) {
                Drag.gradx.gx("#gradx_slider_info") //info element cached before
                .css("left",left)
                .show();
                         
            }/*else {
                if(parseInt(left) > 120) {
                    left = "272px";
                }else{
                    left = "120px";
                }
                    
                gradx.gx("#gradx_slider_info") //info element cached before
                .css("left",left)
                .show();
                     
            }*/
             var color = Drag.gradx.gx("#"+o.id).css("backgroundColor");
            //but what happens if @color is not in RGB ? :(
            var rgb = Drag.gradx.get_rgb_obj(color);
            Drag.gradx.cp.colorPicker("set",rgb);


            var ey	= e.clientY;
            var ex	= e.clientX;
            var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
            var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
            var nx, ny;

            if (o.minX != null) ex = o.hmode ? Math.max(ex, o.minMouseX) : Math.min(ex, o.maxMouseX);
            if (o.maxX != null) ex = o.hmode ? Math.min(ex, o.maxMouseX) : Math.max(ex, o.minMouseX);
            if (o.minY != null) ey = o.vmode ? Math.max(ey, o.minMouseY) : Math.min(ey, o.maxMouseY);
            if (o.maxY != null) ey = o.vmode ? Math.min(ey, o.maxMouseY) : Math.max(ey, o.minMouseY);

            nx = x + ((ex - o.lastMouseX) * (o.hmode ? 1 : -1));
            ny = y + ((ey - o.lastMouseY) * (o.vmode ? 1 : -1));

            if (o.xMapper)		nx = o.xMapper(y)
            else if (o.yMapper)	ny = o.yMapper(x)

            Drag.obj.root.style[o.hmode ? "left" : "right"] = nx + "px";
            //Drag.obj.root.style[o.vmode ? "top" : "bottom"] = ny + "px";
            Drag.obj.lastMouseX	= ex;
            Drag.obj.lastMouseY	= ey;

            Drag.obj.root.onDrag(nx, ny);
            return false;
        },

        end : function()
        {
            document.onmousemove = null;
            document.onmouseup   = null;
            Drag.obj.root.onDragEnd(	parseInt(Drag.obj.root.style[Drag.obj.hmode ? "left" : "right"]), 
                parseInt(Drag.obj.root.style[Drag.obj.vmode ? "top" : "bottom"]));
            Drag.obj = null;
        },

        fixE : function(e)
        {
            if (typeof e == 'undefined') e = window.event;
            if (typeof e.layerX == 'undefined') e.layerX = e.offsetX;
            if (typeof e.layerY == 'undefined') e.layerY = e.offsetY;
            return e;
        }
    };

    return Drag;
});
define('skylark-widgets-gradienter/Gradienter',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-query",
    "skylark-data-color/colors",
    "skylark-data-color/Color",
    "skylark-widgets-swt/swt",
    "skylark-widgets-swt/Widget",
    "skylark-widgets-colorpicker/ColorPicker",
    "./Drag"
],function(skylark, langx, browser, noder, eventer,finder, $, colors, Color, swt, Widget,ColorPicker,Drag) {


    /*
     *
     * SAMPLE USAGE DETAILS :
     * 
     * sliders structure :
     *
     * [
     *  {
     *     color: "COLOR",
     *     position: "POSITION" //0 to 100 without % symbol
     *  },
     *  {
     *     ....
     *     ....
     *  },
     *  ....
     * ]
     *
     */

    'use strict';

    //make me jquery UI  independent
    if (typeof $.fn.draggable === "undefined") {

        $.fn.draggable = function() {
            //console.log(this);
            var ele = document.getElementById(this.attr("id"));
            ele.style.top = "121px";
            Drag.init(ele, null, 26, 426, 86, 86);
            return this;
        };


    }


    var gradX  = function(id, _options) {


        var options = {
            targets: [], //[element selector] -> array
            sliders: [],
            direction: 'left',
            //if linear left | top | right | bottom
            //if radial left | center | right , top | center | bottom 
            type: 'linear', //linear | circle | ellipse
            code_shown: false, //false | true
            change: function(sliders, styles) {
                //nothing to do here by default
            }
        },
    	
        //make global	
        gradx = Drag.gradx = {
            rand_RGB: [],
            rand_pos: [],
            id: null,
            slider_ids: [],
            slider_index: 0, //global index for sliders
            sliders: [], //contains styles of each slider
            direction: "left", //direction of gradient or position of centre in case of radial gradients
            type: "linear", //linear or radial
            shape: "cover", //radial gradient size
            slider_hovered: [],
            jQ_present: true,
            code_shown: false,
            load_jQ: function() {

                //handle any library conflicts here
                this.gx = $;
            },
            //very lazy to replace this by jQuery
            add_event: function(el, evt, evt_func) {
                add_event(el, evt, evt_func);
            },
            get_random_position: function() {
                var pos;

                do {
                    pos = parseInt(Math.random() * 100);
                }
                while (this.rand_pos.indexOf(pos) > -1);

                this.rand_pos.push(pos);
                return pos;

            },
            get_random_rgb: function() {

                var R, G, B, color;

                do {
                    R = parseInt(Math.random() * 255);
                    G = parseInt(Math.random() * 255);
                    B = parseInt(Math.random() * 255);

                    color = "rgb(" + R + ", " + G + ", " + B + ")";
                }
                while (this.rand_RGB.indexOf(color) > -1);

                this.rand_RGB.push(color);
                return color;

            },
            //if target element is specified the target's style (background) is updated
            update_target: function(values) {

                if (this.targets.length > 0) {
                    //target elements exist

                    var i, j, ele, len = this.targets.length, v_len = values.length;
                    for (i = 0; i < len; i++) {
                        ele = gradx.gx(this.targets[i]);

                        for (j = 0; j < v_len; j++) {
                            ele.css("background-image", values[j]);
                        }

                    }
                }
            },
            //apply styles on fly
            apply_style: function(ele, value) {

                var type = 'linear';

                if (gradx.type != 'linear') {
                    type = 'radial';
                }

                if (value.indexOf(this.direction) > -1) {
                    //add cross-browser compatibility
                    var values = [
                        "-webkit-" + type + "-gradient(" + value + ")",
                        "-moz-" + type + "-gradient(" + value + ")",
                        "-ms-" + type + "-gradient(" + value + ")",
                        "-o-" + type + "-gradient(" + value + ")",
                        type + "-gradient(" + value + ")"
                    ];
                } else {
                    //normal color
                    values = [value];
                }



                var len = values.length, css = '';

                while (len > 0) {
                    len--;
                    ele.css("background", values[len]);
                    css += "background: " + values[len] + ";\n";
                }

                //call the userdefined change function
                this.change(this.sliders, values);
                this.update_target(values);


                gradx.gx('#gradx_code').html(css);

            },
            //on load
            apply_default_styles: function() {
                this.update_style_array()
                var value = this.get_style_value();
                this.apply_style(this.panel, value);
            },
            //update the slider_values[] while dragging
            update_style_array: function() {

                this.sliders = [];

                var len = gradx.slider_ids.length,
                        i, offset, position, id;

                for (i = 0; i < len; i++) {
                    id = "#" + gradx.slider_ids[i];
                    offset = parseInt(gradx.gx(id).css("left"));
                    position = parseInt((offset / gradx.container_width) * 100);
                    position -= 6; //TODO: find why this is required
                    gradx.sliders.push([gradx.gx(id).css("background-color"), position]);

                }

                this.sliders.sort(function(A, B) {
                    if (A[1] > B[1])
                        return 1;
                    else
                        return -1;
                });
            },
            //creates the complete css background value to later apply style
            get_style_value: function() {

                var len = gradx.slider_ids.length;

                if (len === 1) {
                    //since only one slider , so simple background

                    style_str = this.sliders[0][0];
                } else {
                    var style_str = "", suffix = "";
                    for (var i = 0; i < len; i++) {
                        if (this.sliders[i][1] == "") {
                            style_str += suffix + (this.sliders[i][0]);

                        } else {
                            if (this.sliders[i][1] > 100) {
                                this.sliders[i][1] = 100;
                            }
                            style_str += suffix + (this.sliders[i][0] + " " + this.sliders[i][1] + "%");

                        }
                        suffix = " , "; //add , from next iteration
                    }

                    if (this.type == 'linear') {
                        //direction, [color stoppers]
                        style_str = this.direction + " , " + style_str; //add direction for gradient
                    } else {
                        //position, type size, [color stoppers]
                        style_str = this.direction + " , " + this.type + " " + this.shape + " , " + style_str;
                    }
                }

                return style_str;
            },
            //@input rgb string rgb(<red>,<green>,<blue>)
            //@output rgb object of form { r: <red> , g: <green> , b : <blue>}
            get_rgb_obj: function(rgb) {

                //rgb(r,g,b)
                rgb = rgb.split("(");
                //r,g,b)
                rgb = rgb[1];
                //r g b)
                rgb = rgb.split(",");

                return {
                    r: parseInt(rgb[0]),
                    g: parseInt(rgb[1]),
                    b: parseInt(rgb[2])
                };

            },
            load_info: function(ele) {
                var id = "#" + ele.id;
                this.current_slider_id = id;
                //check if current clicked element is an slider
                if (this.slider_ids.indexOf(ele.id) > -1) { //javascript does not has # in its id

                    var color = gradx.gx(id).css("backgroundColor");
                    //but what happens if @color is not in RGB ? :(
                    var rgb = this.get_rgb_obj(color);

                    var left = gradx.gx(id).css("left");
                    if (parseInt(left) > 26 && parseInt(left) < 426) {
                        gradx.gx("#gradx_slider_info") //info element cached before
                                .css("left", left)
                                .show();

                    } 
                    
                    this.set_colorpicker(rgb);
                    console.log(rgb);
                }

            },
            //add slider
            add_slider: function(sliders) {


                var id, slider, k, position, value, delta;


                if (sliders.length === 0) {
                    sliders = [//default sliders
                        {
                            color: gradx.get_random_rgb(),
                            position: gradx.get_random_position() //x percent of gradient panel(400px)
                        },
                        {
                            color: gradx.get_random_rgb(),
                            position: gradx.get_random_position()
                        }
                    ];

                }


                var obj = sliders;

                for (k in obj) {

                    if (typeof obj[k].position === "undefined")
                        break;

                    //convert % to px based on containers width
                    var delta = 26; //range: 26px tp 426px
                    position = parseInt((obj[k].position * this.container_width) / 100) + delta + "px";

                    id = "gradx_slider_" + (this.slider_index); //create an id for this slider
                    this.sliders.push(
                            [
                                obj[k].color,
                                obj[k].position
                            ]
                            );

                    this.slider_ids.push(id); //for reference wrt to id

                    slider = "<div class='gradx_slider' id='" + id + "'></div>";
                    gradx.gx("#gradx_start_sliders_" + this.id).append(slider);

                    gradx.gx('#' + id).css("backgroundColor", obj[k].color).css("left", position);
                    this.slider_index++;
                }

                for (var i = 0, len = this.slider_ids.length; i < len; i++) {

                    gradx.gx('#' + this.slider_ids[i]).draggable({
                        containment: 'parent',
                        axis: 'x',
                        start: function() {
                            if (gradx.jQ_present)
                                gradx.current_slider_id = "#" + gradx.gx(this).attr("id"); //got full jQuery power here !
                        },
                        drag: function() {

                            gradx.update_style_array();
                            gradx.apply_style(gradx.panel, gradx.get_style_value());
                            var left = gradx.gx(gradx.current_slider_id).css("left");


                            if (parseInt(left) > 26 && parseInt(left) < 426) {
                                gradx.gx("#gradx_slider_info") //info element cached before
                                        .css("left", left)
                                        .show();

                            } /*else {
                             if (parseInt(left) > 120) {
                             left = "272px";
                             } else {
                             left = "120px";
                             }
                             
                             gradx.gx("#gradx_slider_info") //info element cached before
                             .css("left", left)
                             .show();
                             
                             }*/
                            var color = gradx.gx(gradx.current_slider_id).css("backgroundColor");
                            //but what happens if @color is not in RGB ? :(
                            var rgb = gradx.get_rgb_obj(color);
                            gradx.cp.colorPicker("set", rgb);

                        }

                    }).click(function() {
                        gradx.load_info(this);
                        return false;
                    });
                }


            },
            set_colorpicker: function(clr) {
                gradx.cp.colorPicker({
                    move: function(color) {
                        if (gradx.current_slider_id != false) {
                            var rgba = color.toRgbString();
                            gradx.gx(gradx.current_slider_id).css('background-color', rgba);
                            gradx.update_style_array();
                            gradx.apply_style(gradx.panel, gradx.get_style_value());
                        }
                    },
                    change: function() {
                        gradx.gx("#gradx_slider_info").hide();
                    },
                    flat: true,
                    showAlpha: true,
                    color: clr,
                    clickoutFiresChange: true,
                    showInput: true,
                    showButtons: false

                });
            },
            generate_options: function(options) {

                var len = options.length,
                        name, state,
                        str = '';

                for (var i = 0; i < len; i++) {

                    name = options[i].split(" ");

                    name = name[0];

                    if (i < 2) {
                        state = name[1];
                    } else {
                        state = '';
                    }

                    name = name.replace("-", " ");

                    str += '<option value=' + options[i] + ' ' + state + '>' + name + '</option>';

                }

                return str;
            },
            generate_radial_options: function() {

                var options;
                options = ["horizontal-center disabled", "center selected", "left", "right"];
                gradx.gx('#gradx_gradient_subtype').html(gradx.generate_options(options));

                options = ["vertical-center disabled", "center selected", "top", "bottom"];
                gradx.gx('#gradx_gradient_subtype2').html(gradx.generate_options(options)).show();

            },
            generate_linear_options: function() {

                var options;
                options = ["horizontal-center disabled", "left selected", "right", "top", "bottom"];
                gradx.gx('#gradx_gradient_subtype').html(gradx.generate_options(options));

                gradx.gx('#gradx_gradient_subtype2').hide();

            },
            destroy: function() {
                var options = {
                    targets: [], //[element selector] -> array
                    sliders: [],
                    direction: 'left',
                    //if linear left | top | right | bottom
                    //if radial left | center | right , top | center | bottom 
                    type: 'linear', //linear | circle | ellipse
                    code_shown: false, //false | true
                    change: function(sliders, styles) {
                        //nothing to do here by default
                    }
                };

                for (var k in options) {
                    gradx[k] = options[k];
                }
            },
            load_gradx: function(id, sliders) {
                this.me = gradx.gx(id);
                this.id = id.replace("#", "");
                id = this.id;
                this.current_slider_id = false;
                var html = "<div class='gradx'>\n\
                            <div id='gradx_add_slider' class='gradx_add_slider gradx_btn'><i class='icon icon-add'></i>add</div>\n\
                            <div class='gradx_slectboxes'>\n\
                            <select id='gradx_gradient_type' class='gradx_gradient_type'>\n\
                                <option value='linear'>Linear</option>\n\
                                <option value='circle'>Radial - Circle</option>\n\
                                <option value='ellipse'>Radial - Ellipse</option>\n\
                            </select>\n\
                            <select id='gradx_gradient_subtype' class='gradx_gradient_type'>\n\
                                <option id='gradx_gradient_subtype_desc' value='gradient-direction' disabled>gradient direction</option>\n\
                                <option value='left' selected>Left</option>\n\
                                <option value='right'>Right</option>\n\
                                <option value='top'>Top</option>\n\
                                <option value='bottom'>Bottom</option>\n\
                            </select>\n\
                            <select id='gradx_gradient_subtype2' class='gradx_gradient_type gradx_hide'>\n\
                            </select>\n\
                            <select id='gradx_radial_gradient_size' class='gradx_gradient_type gradx_hide'>\n\
                            </select>\n\
                            </div>\n\
                            <div class='gradx_container' id='gradx_" + id + "'>\n\
                                <div id='gradx_stop_sliders_" + id + "'></div>\n\
                                <div class='gradx_panel' id='gradx_panel_" + id + "'></div>\n\
                                <div class='gradx_start_sliders' id='gradx_start_sliders_" + id + "'>\n\
                                    <div class='cp-default' id='gradx_slider_info'>\n\
                                        <div id='gradx_slider_controls'>\n\
                                            <div id='gradx_delete_slider' class='gradx_btn'><i class='icon icon-remove'></i>delete</div>\n\
                                        </div>\n\
                                        <div id='gradx_slider_content'></div>\n\
                                    </div> \n\
                                </div>\n\
                            </div>\n\
                            <div id='gradx_show_code' class='gradx_show_code gradx_btn'><i class='icon icon-file-css'></i><span>show the code</span></div>\n\
                            <div id='gradx_show_presets' style='display:none' class='gradx_show_presets gradx_btn'><i class='icon icon-preset'></i><span>show presets</span></div>\n\
                            <textarea class='gradx_code' id='gradx_code'></textarea>\n\
                        </div>";

                this.me.html(html);


                //generates html to select the different gradient sizes
                // *only available for radial gradients
                var gradient_size_val = ["gradient-size disabled", "closest-side selected", "closest-corner", "farthest-side", "farthest-corner", "contain", "cover"],
                        option_str = '';


                option_str = gradx.generate_options(gradient_size_val);

                gradx.gx('#gradx_radial_gradient_size').html(option_str);


                //cache divs for fast reference

                this.container = gradx.gx("#gradx_" + id);
                this.panel = gradx.gx("#gradx_panel_" + id);
                //.hide();
                //this.info.hide();
                this.container_width = 400 //HARDCODE;
                this.add_slider(sliders);


                gradx.add_event(document, 'click', function() {
    //            if(!gradx.jQ_present){
                    if (!gradx.slider_hovered[id]) {
                        gradx.gx("#gradx_slider_info").hide();
                        return false;
                    }
                });



                gradx.gx('#gradx_add_slider').click(function() {
                    gradx.add_slider([
                        {
                            color: gradx.get_random_rgb(),
                            position: gradx.get_random_position() //no % symbol
                        }
                    ]);
                    gradx.update_style_array();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                //cache the element
                gradx.cp = gradx.gx('#gradx_slider_content');

                //call the colorpicker plugin
                gradx.set_colorpicker("blue");

                gradx.gx('#gradx_delete_slider').click(function() {
                    gradx.gx(gradx.current_slider_id).remove();
                    gradx.gx("#gradx_slider_info").hide();
                    var id = gradx.current_slider_id.replace("#", "");

                    //remove all references from array for current deleted slider

                    for (var i = 0; i < gradx.slider_ids.length; i++) {
                        if (gradx.slider_ids[i] == id) {
                            gradx.slider_ids.splice(i, 1);
                        }
                    }

                    //apply modified style after removing the slider
                    gradx.update_style_array();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());

                    gradx.current_slider_id = false; //no slider is selected

                });

                gradx.gx('#gradx_code').focus(function() {
                    var $this = gradx.gx(this);
                    $this.select();

                    // Work around Chrome's little problem
                    $this.mouseup(function() {
                        // Prevent further mouseup intervention
                        $this.off("mouseup");
                        return false;
                    });
                });

                gradx.gx('#gradx_gradient_type').change(function() {

                    var type = gradx.gx(this).val(), options, option_str = '';

                    if (type !== "linear") {
                        //gradx.gx('#gradx_radial_gradient_size').show();

                        gradx.generate_radial_options();
                    } else {

                        gradx.generate_linear_options();
                        gradx.gx('#gradx_gradient_subtype').val("left");
                    }

                    gradx.type = type;
                    gradx.direction = gradx.gx('#gradx_gradient_subtype').val();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)
                });

                //change type onload userdefined
                if (this.type !== "linear") {
                    gradx.gx('#gradx_gradient_type').val(this.type);
                    gradx.generate_radial_options();

                    var h, v;

                    if (this.direction !== 'left') {
                        //user has passed his own direction
                        var center;
                        if (this.direction.indexOf(",") > -1) {
                            center = this.direction.split(",");
                        } else {
                            //tolerate user mistakes
                            center = this.direction.split(" ");
                        }

                        h = center[0];
                        v = center[1];

                        //update the center points in the corr. select boxes
                        gradx.gx('#gradx_gradient_subtype').val(h);
                        gradx.gx('#gradx_gradient_subtype2').val(v);
                    } else {
                        var h = gradx.gx('#gradx_gradient_subtype').val();
                        var v = gradx.gx('#gradx_gradient_subtype2').val();
                    }

                    gradx.direction = h + " " + v;
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)
                } else {

                    //change direction if not left
                    if (this.direction !== 'left') {
                        gradx.gx('#gradx_gradient_subtype').val(this.direction);
                    }
                }

                gradx.gx('#gradx_gradient_subtype').change(function() {

                    if (gradx.type === 'linear') {
                        gradx.direction = gradx.gx(this).val();
                    } else {
                        var h = gradx.gx(this).val();
                        var v = gradx.gx('#gradx_gradient_subtype2').val();
                        gradx.direction = h + " " + v;
                    }
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                gradx.gx('#gradx_gradient_subtype2').change(function() {

                    var h = gradx.gx('#gradx_gradient_subtype').val();
                    var v = gradx.gx(this).val();
                    gradx.direction = h + " " + v;
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                //not visible
                gradx.gx('#gradx_radial_gradient_size').change(function() {
                    gradx.shape = gradx.gx(this).val();
                    gradx.apply_style(gradx.panel, gradx.get_style_value());//(where,style)

                });

                gradx.gx('#gradx_show_code').click(function() {

                    if (gradx.code_shown) {
                        //hide it

                        gradx.code_shown = false;
                        gradx.gx('#gradx_show_code span').text("show the code");
                        gradx.gx("#gradx_code").hide();
                    }
                    else {
                        //show it

                        gradx.gx('#gradx_show_code span').text("hide the code");
                        gradx.gx("#gradx_code").show();
                        gradx.code_shown = true;
                    }
                });

                //show or hide onload
                if (gradx.code_shown) {
                    //show it

                    gradx.gx('#gradx_show_code span').text("hide the code");
                    gradx.gx("#gradx_code").show();

                }

                gradx.add_event(document.getElementById('gradx_slider_info'), 'mouseout', function() {
                    gradx.slider_hovered[id] = false;
                });
                gradx.add_event(document.getElementById('gradx_slider_info'), 'mouseover', function() {
                    gradx.slider_hovered[id] = true;

                });

            }




        };



        function  add_event(element, event, event_function)
        {
            if (element.attachEvent) //Internet Explorer
                element.attachEvent("on" + event, function() {
                    event_function.call(element);
                });
            else if (element.addEventListener) //Firefox & company
                element.addEventListener(event, event_function, false); //don't need the 'call' trick because in FF everything already works in the right way
        }
        ;



        //load jQuery library into gradx.gx
        gradx.load_jQ();


        /* merge _options into options */
        langx.mixin(options, _options);

        //apply options to gradx object

        for (var k in options) {

            //load the options into gradx object
            gradx[k] = options[k];

        }

        gradx.load_gradx(id, gradx.sliders);
        gradx.apply_default_styles();


    };

    return skylark.attach("widgets.Gradienter",gradX);
});
define('skylark-widgets-gradienter/main',[
    "./Gradienter",
], function(Gradienter) {
    return Gradienter;
});

define('skylark-widgets-gradienter', ['skylark-widgets-gradienter/main'], function (main) { return main; });

define('skylark-widgets-hierarchy/Hierarchy',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query"
],function(skylark,langx,browser,eventer,noder,geom,$){
	"use strict";

	var jstree = skylark.jstree =  skylark.jstree || {};

	var ajax = function(options) {
        return langx.Xhr.request(options.url,options);
    };
	/*
	$.ajax = $.ajax || function(options) {
        return langx.Xhr.request(options.url,options);
    };

    $.camelCase = langx.camelCase;

    $.each = langx.each;

    $.extend = function(target) {
        var deep, args = Array.prototype.slice.call(arguments, 1);
        if (typeof target == 'boolean') {
            deep = target
            target = args.shift()
        }
        if (args.length == 0) {
            args = [target];
            target = this;
        }
        args.forEach(function(arg) {
        	langx.mixin(target, arg, deep);
        });
        return target;
    };

    $.grep = function(elements, callback) {
        return filter.call(elements, callback)
    };

    $.isArray = langx.isArray;
    $.isEmptyObject = langx.isEmptyObject;
    $.isFunction = langx.isFunction;
    $.isWindow = langx.isWindow;
    $.isPlainObject = langx.isPlainObject;

    $.inArray = langx.inArray;

    $.makeArray = langx.makeArray;
    $.map = langx.map;

    $.noop = function() {
    };

    $.parseJSON = window.JSON.parse;

    $.proxy = langx.proxy;

    $.trim = langx.trim;
    $.type = langx.type;

    $.fn.stop = function() {
    	return this;
    }
	*/

	/*!
	 * jsTree {{VERSION}}
	 * http://jstree.com/
	 *
	 * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
	 *
	 * Licensed same as jquery - under the terms of the MIT License
	 *   http://www.opensource.org/licenses/mit-license.php
	 */

	// prevent another load? maybe there is a better way?
	if($.jstree) {
		return;
	}

	/**
	 * ### jsTree core functionality
	 */

	// internal variables
	var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		ccp_inst = false,
		themes_loaded = [],
		src = $('script:last').attr('src'),
		document = window.document; // local variable is always faster to access then a global

	/**
	 * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
	 * @name $.jstree
	 */
	$.jstree = {
		/**
		 * specifies the jstree version in use
		 * @name $.jstree.version
		 */
		version : '{{VERSION}}',
		/**
		 * holds all the default options used when creating new instances
		 * @name $.jstree.defaults
		 */
		defaults : {
			/**
			 * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
			 * @name $.jstree.defaults.plugins
			 */
			plugins : []
		},
		/**
		 * stores all loaded jstree plugins (used internally)
		 * @name $.jstree.plugins
		 */
		plugins : {},
		path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
		idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g,
		root : '#'
	};
	
	/**
	 * creates a jstree instance
	 * @name $.jstree.create(el [, options])
	 * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
	 * @param {Object} options options for this instance (extends `$.jstree.defaults`)
	 * @return {jsTree} the new instance
	 */
	$.jstree.create = function (el, options) {
		return new Tree(el,options);
	};

	/**
	 * remove all traces of jstree from the DOM and destroy all instances
	 * @name $.jstree.destroy()
	 */
	$.jstree.destroy = function () {
		$('.jstree:jstree').jstree('destroy');
		$(document).off('.jstree');
	};


	/**
	 * get a reference to an existing instance
	 *
	 * __Examples__
	 *
	 *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
	 *	// all of there will return the same instance
	 *	$.jstree.reference('tree');
	 *	$.jstree.reference('#tree');
	 *	$.jstree.reference($('#tree'));
	 *	$.jstree.reference(document.getElementByID('tree'));
	 *	$.jstree.reference('branch');
	 *	$.jstree.reference('#branch');
	 *	$.jstree.reference($('#branch'));
	 *	$.jstree.reference(document.getElementByID('branch'));
	 *
	 * @name $.jstree.reference(needle)
	 * @param {DOMElement|jQuery|String} needle
	 * @return {jsTree|null} the instance or `null` if not found
	 */
	$.jstree.reference = function (needle) {
		var tmp = null,
			obj = null;
		if(needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }

		if(!obj || !obj.length) {
			try { obj = $(needle); } catch (ignore) { }
		}
		if(!obj || !obj.length) {
			try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
		}
		if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
			tmp = obj;
		}
		else {
			$('.jstree').each(function () {
				var inst = $(this).data('jstree');
				if(inst && inst._model.data[needle]) {
					tmp = inst;
					return false;
				}
			});
		}
		return tmp;
	};

	/**
	 * Create an instance, get an instance or invoke a command on a instance.
	 *
	 * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
	 *
	 * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
	 *
	 * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
	 *
	 * In any other case - nothing is returned and chaining is not broken.
	 *
	 * __Examples__
	 *
	 *	$('#tree1').jstree(); // creates an instance
	 *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
	 *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
	 *	$('#tree2').jstree(); // get an existing instance (or create an instance)
	 *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
	 *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
	 *
	 * @name $().jstree([arg])
	 * @param {String|Object} arg
	 * @return {Mixed}
	 */
	$.fn.jstree = function (arg) {
		// check for string argument
		var is_method	= (typeof arg === 'string'),
			args		= Array.prototype.slice.call(arguments, 1),
			result		= null;
		if(arg === true && !this.length) { return false; }
		this.each(function () {
			// get the instance (if there is one) and method (if it exists)
			var instance = $.jstree.reference(this),
				method = is_method && instance ? instance[arg] : null;
			// if calling a method, and method is available - execute on the instance
			result = is_method && method ?
				method.apply(instance, args) :
				null;
			// if there is no instance and no method is being called - create one
			if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
				$.jstree.create(this, arg);
			}
			// if there is an instance and no method is called - return the instance
			if( (instance && !is_method) || arg === true ) {
				result = instance || false;
			}
			// if there was a method call which returned a result - break and return the value
			if(result !== null && result !== undefined) {
				return false;
			}
		});
		// if there was a method call with a valid return value - return that, otherwise continue the chain
		return result !== null && result !== undefined ?
			result : this;
	};

	/**
	 * stores all defaults for the core
	 * @name $.jstree.defaults.core
	 */
	$.jstree.defaults.core = {
		/**
		 * data configuration
		 *
		 * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
		 *
		 * You can also pass in a HTML string or a JSON array here.
		 *
		 * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.
		 * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
		 *
		 * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
		 *
		 * __Examples__
		 *
		 *	// AJAX
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : {
		 *				'url' : '/get/children/',
		 *				'data' : function (node) {
		 *					return { 'id' : node.id };
		 *				}
		 *			}
		 *		});
		 *
		 *	// direct data
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : [
		 *				'Simple root node',
		 *				{
		 *					'id' : 'node_2',
		 *					'text' : 'Root node with options',
		 *					'state' : { 'opened' : true, 'selected' : true },
		 *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
		 *				}
		 *			]
		 *		}
		 *	});
		 *
		 *	// function
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : function (obj, callback) {
		 *				callback.call(this, ['Root 1', 'Root 2']);
		 *			}
		 *		});
		 *
		 * @name $.jstree.defaults.core.data
		 */
		data			: false,
		/**
		 * configure the various strings used throughout the tree
		 *
		 * You can use an object where the key is the string you need to replace and the value is your replacement.
		 * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
		 * If left as `false` no replacement is made.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'strings' : {
		 *				'Loading ...' : 'Please wait ...'
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.strings
		 */
		strings			: false,
		/**
		 * determines what happens when a user tries to modify the structure of the tree
		 * If left as `false` all operations like create, rename, delete, move or copy are prevented.
		 * You can set this to `true` to allow all interactions or use a function to have better control.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'check_callback' : function (operation, node, node_parent, node_position, more) {
		 *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node', 'copy_node' or 'edit'
		 *				// in case of 'rename_node' node_position is filled with the new node name
		 *				return operation === 'rename_node' ? true : false;
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.check_callback
		 */
		check_callback	: false,
		/**
		 * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
		 * @name $.jstree.defaults.core.error
		 */
		error			: langx.noop,
		/**
		 * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
		 * @name $.jstree.defaults.core.animation
		 */
		animation		: 200,
		/**
		 * a boolean indicating if multiple nodes can be selected
		 * @name $.jstree.defaults.core.multiple
		 */
		multiple		: true,
		/**
		 * theme configuration object
		 * @name $.jstree.defaults.core.themes
		 */
		themes			: {
			/**
			 * the name of the theme to use (if left as `false` the default theme is used)
			 * @name $.jstree.defaults.core.themes.name
			 */
			name			: false,
			/**
			 * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
			 * @name $.jstree.defaults.core.themes.url
			 */
			url				: false,
			/**
			 * the location of all jstree themes - only used if `url` is set to `true`
			 * @name $.jstree.defaults.core.themes.dir
			 */
			dir				: false,
			/**
			 * a boolean indicating if connecting dots are shown
			 * @name $.jstree.defaults.core.themes.dots
			 */
			dots			: true,
			/**
			 * a boolean indicating if node icons are shown
			 * @name $.jstree.defaults.core.themes.icons
			 */
			icons			: true,
			/**
			 * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container
			 * @name $.jstree.defaults.core.themes.ellipsis
			 */
			ellipsis		: false,
			/**
			 * a boolean indicating if the tree background is striped
			 * @name $.jstree.defaults.core.themes.stripes
			 */
			stripes			: false,
			/**
			 * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
			 * @name $.jstree.defaults.core.themes.variant
			 */
			variant			: false,
			/**
			 * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
			 * @name $.jstree.defaults.core.themes.responsive
			 */
			responsive		: false
		},
		/**
		 * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
		 * @name $.jstree.defaults.core.expand_selected_onload
		 */
		expand_selected_onload : true,
		/**
		 * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
		 * @name $.jstree.defaults.core.worker
		 */
		worker : true,
		/**
		 * Force node text to plain text (and escape HTML). Defaults to `false`
		 * @name $.jstree.defaults.core.force_text
		 */
		force_text : false,
		/**
		 * Should the node should be toggled if the text is double clicked . Defaults to `true`
		 * @name $.jstree.defaults.core.dblclick_toggle
		 */
		dblclick_toggle : true,
		/**
		 * Should the loaded nodes be part of the state. Defaults to `false`
		 * @name $.jstree.defaults.core.loaded_state
		 */
		loaded_state : false,
		/**
		 * Should the last active node be focused when the tree container is blurred and the focused again. This helps working with screen readers. Defaults to `true`
		 * @name $.jstree.defaults.core.restore_focus
		 */
		restore_focus : true,
		/**
		 * Default keyboard shortcuts (an object where each key is the button name or combo - like 'enter', 'ctrl-space', 'p', etc and the value is the function to execute in the instance's scope)
		 * @name $.jstree.defaults.core.keyboard
		 */
		keyboard : {
			'ctrl-space': function (e) {
				// aria defines space only with Ctrl
				e.type = "click";
				$(e.currentTarget).trigger(e);
			},
			'enter': function (e) {
				// enter
				e.type = "click";
				$(e.currentTarget).trigger(e);
			},
			'left': function (e) {
				// left
				e.preventDefault();
				if(this.is_open(e.currentTarget)) {
					this.close_node(e.currentTarget);
				}
				else {
					var o = this.get_parent(e.currentTarget);
					if(o && o.id !== $.jstree.root) { this.get_node(o, true).children('.jstree-anchor').focus(); }
				}
			},
			'up': function (e) {
				// up
				e.preventDefault();
				var o = this.get_prev_dom(e.currentTarget);
				if(o && o.length) { o.children('.jstree-anchor').focus(); }
			},
			'right': function (e) {
				// right
				e.preventDefault();
				if(this.is_closed(e.currentTarget)) {
					this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
				}
				else if (this.is_open(e.currentTarget)) {
					var o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
					if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
				}
			},
			'down': function (e) {
				// down
				e.preventDefault();
				var o = this.get_next_dom(e.currentTarget);
				if(o && o.length) { o.children('.jstree-anchor').focus(); }
			},
			'*': function (e) {
				// aria defines * on numpad as open_all - not very common
				this.open_all();
			},
			'home': function (e) {
				// home
				e.preventDefault();
				var o = this._firstChild(this.get_container_ul()[0]);
				if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
			},
			'end': function (e) {
				// end
				e.preventDefault();
				this.element.find('.jstree-anchor').filter(':visible').last().focus();
			},
			'f2': function (e) {
				// f2 - safe to include - if check_callback is false it will fail
				e.preventDefault();
				this.edit(e.currentTarget);
			}
		}
	};

    var Tree = jstree.Tree = langx.Evented.inherit({
        klassName: "Tree",

		/**
		 * used to decorate an instance with a plugin. Used internally.
		 * @private
		 * @name plugin(deco [, opts])
		 * @param  {String} deco the plugin to decorate with
		 * @param  {Object} opts options for the plugin
		 * @return {jsTree}
		 */
		plugin : function (deco, opts) {
			var Child = $.jstree.plugins[deco];
			if(Child) {
				this._data[deco] = {};
				Child.prototype = this;
				return new Child(opts, this);
			}
			return this;
		},
		/**
		 * initialize the instance. Used internally.
		 * @private
		 * @name init(el, optons)
		 * @param {DOMElement|jQuery|String} el the element we are transforming
		 * @param {Object} options options for this instance
		 * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
		 */
		init : function (el, options) {
			this._id = ++instance_counter;
			this._cnt = 0;
			this._wrk = null;
			this._data = {
				core : {
					themes : {
						name : false,
						dots : false,
						icons : false,
						ellipsis : false
					},
					selected : [],
					last_error : {},
					working : false,
					worker_queue : [],
					focused : null
				}
			};

			var  opt = options,
				tmp = this;
			options = langx.extend(true, {}, $.jstree.defaults, options);
			if(opt && opt.plugins) {
				options.plugins = opt.plugins;
			}
			langx.each(options.plugins, function (i, k) {
				if(i !== 'core') {
					tmp = tmp.plugin(k, options[k]);
				}
			});

			$(el).data('jstree', tmp);

			tmp._model = {
				data : {},
				changed : [],
				force_full_redraw : false,
				redraw_timeout : false,
				default_state : {
					loaded : true,
					opened : false,
					selected : false,
					disabled : false
				}
			};
			tmp._model.data[$.jstree.root] = {
				id : $.jstree.root,
				parent : null,
				parents : [],
				children : [],
				children_d : [],
				state : { loaded : false }
			};

			tmp.element = $(el).addClass('jstree jstree-' + tmp._id);
			tmp.settings = options;

			tmp._data.core.ready = false;
			tmp._data.core.loaded = false;
			tmp._data.core.rtl = (tmp.element.css("direction") === "rtl");
			tmp.element[tmp._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
			tmp.element.attr('role','tree');
			if(tmp.settings.core.multiple) {
				tmp.element.attr('aria-multiselectable', true);
			}
			if(!tmp.element.attr('tabindex')) {
				tmp.element.attr('tabindex','0');
			}

			tmp.bind();
			/**
			 * triggered after all events are bound
			 * @event
			 * @name init.jstree
			 */
			tmp.trigger("init");

			tmp._data.core.original_container_html = tmp.element.find(" > ul > li").clone(true);
			tmp._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function() {
					return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
			tmp.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+tmp._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + tmp.get_string("Loading ...") + "</a></li></ul>");
			tmp.element.attr('aria-activedescendant','j' + tmp._id + '_loading');
			tmp._data.core.li_height = tmp.get_container_ul().children("li").first().outerHeight() || 24;
			tmp._data.core.node = tmp._create_prototype_node();
			/**
			 * triggered after the loading text is shown and before loading starts
			 * @event
			 * @name loading.jstree
			 */
			tmp.trigger("loading");
			tmp.load_node($.jstree.root);
			return tmp;
		},

		/**
		 * destroy an instance
		 * @name destroy()
		 * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
		 */
		destroy : function (keep_html) {
			/**
			 * triggered before the tree is destroyed
			 * @event
			 * @name destroy.jstree
			 */
			tmp.trigger("destroy");
			if(this._wrk) {
				try {
					window.URL.revokeObjectURL(this._wrk);
					this._wrk = null;
				}
				catch (ignore) { }
			}
			if(!keep_html) { this.element.empty(); }
			this.teardown();
		},
		/**
		 * Create a prototype node
		 * @name _create_prototype_node()
		 * @return {DOMElement}
		 */
		_create_prototype_node : function () {
			var _node = document.createElement('LI'), _temp1, _temp2;
			_node.setAttribute('role', 'treeitem');
			_temp1 = document.createElement('I');
			_temp1.className = 'jstree-icon jstree-ocl';
			_temp1.setAttribute('role', 'presentation');
			_node.appendChild(_temp1);
			_temp1 = document.createElement('A');
			_temp1.className = 'jstree-anchor';
			_temp1.setAttribute('href','#');
			_temp1.setAttribute('tabindex','-1');
			_temp2 = document.createElement('I');
			_temp2.className = 'jstree-icon jstree-themeicon';
			_temp2.setAttribute('role', 'presentation');
			_temp1.appendChild(_temp2);
			_node.appendChild(_temp1);
			_temp1 = _temp2 = null;

			return _node;
		},
		_kbevent_to_func : function (e) {
			var keys = {
				8: "Backspace", 9: "Tab", 13: "Return", 19: "Pause", 27: "Esc",
				32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home",
				37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "Print", 45: "Insert",
				46: "Delete", 96: "Numpad0", 97: "Numpad1", 98: "Numpad2", 99 : "Numpad3",
				100: "Numpad4", 101: "Numpad5", 102: "Numpad6", 103: "Numpad7",
				104: "Numpad8", 105: "Numpad9", '-13': "NumpadEnter", 112: "F1",
				113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7",
				119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "Numlock",
				145: "Scrolllock", 16: 'Shift', 17: 'Ctrl', 18: 'Alt',
				48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
				54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
				66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
				73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
				80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
				87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
				186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
				219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*', 173: '-'
			};
			var parts = [];
			if (e.ctrlKey) { parts.push('ctrl'); }
			if (e.altKey) { parts.push('alt'); }
			if (e.shiftKey) { parts.push('shift'); }
			parts.push(keys[e.which] || e.which);
			parts = parts.sort().join('-').toLowerCase();

			var kb = this.settings.core.keyboard, i, tmp;
			for (i in kb) {
				if (kb.hasOwnProperty(i)) {
					tmp = i;
					if (tmp !== '-' && tmp !== '+') {
						tmp = tmp.replace('--', '-MINUS').replace('+-', '-MINUS').replace('++', '-PLUS').replace('-+', '-PLUS');
						tmp = tmp.split(/-|\+/).sort().join('-').replace('MINUS', '-').replace('PLUS', '+').toLowerCase();
					}
					if (tmp === parts) {
						return kb[i];
					}
				}
			}
			return null;
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name teardown()
		 */
		teardown : function () {
			this.unbind();
			this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
			this.element = null;
		},
		/**
		 * bind all events. Used internally.
		 * @private
		 * @name bind()
		 */
		bind : function () {
			var word = '',
				tout = null,
				was_click = 0;
			this.element
				.on("dblclick.jstree", function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(document.selection && document.selection.empty) {
							document.selection.empty();
						}
						else {
							if(window.getSelection) {
								var sel = window.getSelection();
								try {
									sel.removeAllRanges();
									sel.collapse();
								} catch (ignore) { }
							}
						}
					})
				.on("mousedown.jstree", langx.proxy(function (e) {
						if(e.target === this.element[0]) {
							e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
							was_click = +(new Date()); // ie does not allow to prevent losing focus
						}
					}, this))
				.on("mousedown.jstree", ".jstree-ocl", function (e) {
						e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
					})
				.on("click.jstree", ".jstree-ocl", langx.proxy(function (e) {
						this.toggle_node(e.target);
					}, this))
				.on("dblclick.jstree", ".jstree-anchor", langx.proxy(function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(this.settings.core.dblclick_toggle) {
							this.toggle_node(e.target);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", langx.proxy(function (e) {
						e.preventDefault();
						if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
						this.activate_node(e.currentTarget, e);
					}, this))
				.on('keydown.jstree', '.jstree-anchor', langx.proxy(function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(this._data.core.rtl) {
							if(e.which === 37) { e.which = 39; }
							else if(e.which === 39) { e.which = 37; }
						}
						var f = this._kbevent_to_func(e);
						if (f) {
							var r = f.call(this, e);
							if (r === false || r === true) {
								return r;
							}
						}
					}, this))
				.on("load_node.jstree", langx.proxy(function (e, data) {
						if(data.status) {
							if(data.node.id === $.jstree.root && !this._data.core.loaded) {
								this._data.core.loaded = true;
								if(this._firstChild(this.get_container_ul()[0])) {
									this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
								}
								/**
								 * triggered after the root node is loaded for the first time
								 * @event
								 * @name loaded.jstree
								 */
								this.trigger("loaded");
							}
							if(!this._data.core.ready) {
								setTimeout(langx.proxy(function() {
									if(this.element && !this.get_container_ul().find('.jstree-loading').length) {
										this._data.core.ready = true;
										if(this._data.core.selected.length) {
											if(this.settings.core.expand_selected_onload) {
												var tmp = [], i, j;
												for(i = 0, j = this._data.core.selected.length; i < j; i++) {
													tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
												}
												tmp = $.vakata.array_unique(tmp);
												for(i = 0, j = tmp.length; i < j; i++) {
													this.open_node(tmp[i], false, 0);
												}
											}
											this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
										}
										/**
										 * triggered after all nodes are finished loading
										 * @event
										 * @name ready.jstree
										 */
										this.trigger("ready");
									}
								}, this), 0);
							}
						}
					}, this))
				// quick searching when the tree is focused
				.on('keypress.jstree', langx.proxy(function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(tout) { clearTimeout(tout); }
						tout = setTimeout(function () {
							word = '';
						}, 500);

						var chr = String.fromCharCode(e.which).toLowerCase(),
							col = this.element.find('.jstree-anchor').filter(':visible'),
							ind = col.index(document.activeElement) || 0,
							end = false;
						word += chr;

						// match for whole word from current node down (including the current node)
						if(word.length > 1) {
							col.slice(ind).each(langx.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// match for whole word from the beginning of the tree
							col.slice(0, ind).each(langx.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
						// list nodes that start with that letter (only if word consists of a single char)
						if(new RegExp('^' + chr.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '+$').test(word)) {
							// search for the next node starting with that letter
							col.slice(ind + 1).each(langx.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// search from the beginning
							col.slice(0, ind + 1).each(langx.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
					}, this))
				// THEME RELATED
				.on("init.jstree", langx.proxy(function () {
						var s = this.settings.core.themes;
						this._data.core.themes.dots			= s.dots;
						this._data.core.themes.stripes		= s.stripes;
						this._data.core.themes.icons		= s.icons;
						this._data.core.themes.ellipsis		= s.ellipsis;
						this.set_theme(s.name || "default", s.url);
						this.set_theme_variant(s.variant);
					}, this))
				.on("loading.jstree", langx.proxy(function () {
						this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
						this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
						this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
						this[ this._data.core.themes.ellipsis ? "show_ellipsis" : "hide_ellipsis" ]();
					}, this))
				.on('blur.jstree', '.jstree-anchor', langx.proxy(function (e) {
						this._data.core.focused = null;
						$(e.currentTarget).filter('.jstree-hovered').mouseleave();
						this.element.attr('tabindex', '0');
					}, this))
				.on('focus.jstree', '.jstree-anchor', langx.proxy(function (e) {
						var tmp = this.get_node(e.currentTarget);
						if(tmp && tmp.id) {
							this._data.core.focused = tmp.id;
						}
						this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
						$(e.currentTarget).mouseenter();
						this.element.attr('tabindex', '-1');
					}, this))
				.on('focus.jstree', langx.proxy(function () {
						if(+(new Date()) - was_click > 500 && !this._data.core.focused && this.settings.core.restore_focus) {
							was_click = 0;
							var act = this.get_node(this.element.attr('aria-activedescendant'), true);
							if(act) {
								act.find('> .jstree-anchor').focus();
							}
						}
					}, this))
				.on('mouseenter.jstree', '.jstree-anchor', langx.proxy(function (e) {
						this.hover_node(e.currentTarget);
					}, this))
				.on('mouseleave.jstree', '.jstree-anchor', langx.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name unbind()
		 */
		unbind : function () {
			this.element.off('.jstree');
			$(document).off('.jstree-' + this._id);
		},
		/**
		 * trigger an event. Used internally.
		 * @private
		 * @name trigger(ev [, data])
		 * @param  {String} ev the name of the event to trigger
		 * @param  {Object} data additional data to pass with the event
		 */
		trigger : function (ev, data) {
			if(!data) {
				data = {};
			}
			data.instance = this;
			this.element.trigger(ev.replace('.jstree','') + '.jstree', data);
		},
		/**
		 * returns the jQuery extended instance container
		 * @name get_container()
		 * @return {jQuery}
		 */
		get_container : function () {
			return this.element;
		},
		/**
		 * returns the jQuery extended main UL node inside the instance container. Used internally.
		 * @private
		 * @name get_container_ul()
		 * @return {jQuery}
		 */
		get_container_ul : function () {
			return this.element.children(".jstree-children").first();
		},
		/**
		 * gets string replacements (localization). Used internally.
		 * @private
		 * @name get_string(key)
		 * @param  {String} key
		 * @return {String}
		 */
		get_string : function (key) {
			var a = this.settings.core.strings;
			if(langx.isFunction(a)) { return a.call(this, key); }
			if(a && a[key]) { return a[key]; }
			return key;
		},
		/**
		 * gets the first child of a DOM node. Used internally.
		 * @private
		 * @name _firstChild(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_firstChild : function (dom) {
			dom = dom ? dom.firstChild : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the next sibling of a DOM node. Used internally.
		 * @private
		 * @name _nextSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_nextSibling : function (dom) {
			dom = dom ? dom.nextSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the previous sibling of a DOM node. Used internally.
		 * @private
		 * @name _previousSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_previousSibling : function (dom) {
			dom = dom ? dom.previousSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.previousSibling;
			}
			return dom;
		},
		/**
		 * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
		 * @name get_node(obj [, as_dom])
		 * @param  {mixed} obj
		 * @param  {Boolean} as_dom
		 * @return {Object|jQuery}
		 */
		get_node : function (obj, as_dom) {
			if(obj && obj.id) {
				obj = obj.id;
			}
			var dom;
			try {
				if(this._model.data[obj]) {
					obj = this._model.data[obj];
				}
				else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
					obj = this._model.data[obj.replace(/^#/, '')];
				}
				else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
					obj = this._model.data[$.jstree.root];
				}
				else {
					return false;
				}

				if(as_dom) {
					obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
				}
				return obj;
			} catch (ex) { return false; }
		},
		/**
		 * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
		 * @name get_path(obj [, glue, ids])
		 * @param  {mixed} obj the node
		 * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
		 * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
		 * @return {mixed}
		 */
		get_path : function (obj, glue, ids) {
			obj = obj.parents ? obj : this.get_node(obj);
			if(!obj || obj.id === $.jstree.root || !obj.parents) {
				return false;
			}
			var i, j, p = [];
			p.push(ids ? obj.id : obj.text);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
			}
			p = p.reverse().slice(1);
			return glue ? p.join(glue) : p;
		},
		/**
		 * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_next_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_next_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this._firstChild(this.get_container_ul()[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._nextSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			if(obj.hasClass("jstree-open")) {
				tmp = this._firstChild(obj.children('.jstree-children')[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				if(tmp !== null) {
					return $(tmp);
				}
			}
			tmp = obj[0];
			do {
				tmp = this._nextSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				return $(tmp);
			}
			return obj.parentsUntil(".jstree",".jstree-node").nextAll(".jstree-node:visible").first();
		},
		/**
		 * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_prev_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_prev_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this.get_container_ul()[0].lastChild;
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._previousSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._previousSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			tmp = obj[0];
			do {
				tmp = this._previousSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				obj = $(tmp);
				while(obj.hasClass("jstree-open")) {
					obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
				}
				return obj;
			}
			tmp = obj[0].parentNode.parentNode;
			return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
		},
		/**
		 * get the parent ID of a node
		 * @name get_parent(obj)
		 * @param  {mixed} obj
		 * @return {String}
		 */
		get_parent : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			return obj.parent;
		},
		/**
		 * get a jQuery collection of all the children of a node (node must be rendered), returns false on error
		 * @name get_children_dom(obj)
		 * @param  {mixed} obj
		 * @return {jQuery}
		 */
		get_children_dom : function (obj) {
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				return this.get_container_ul().children(".jstree-node");
			}
			if(!obj || !obj.length) {
				return false;
			}
			return obj.children(".jstree-children").children(".jstree-node");
		},
		/**
		 * checks if a node has children
		 * @name is_parent(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_parent : function (obj) {
			obj = this.get_node(obj);
			return obj && (obj.state.loaded === false || obj.children.length > 0);
		},
		/**
		 * checks if a node is loaded (its children are available)
		 * @name is_loaded(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loaded : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.loaded;
		},
		/**
		 * check if a node is currently loading (fetching children)
		 * @name is_loading(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loading : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.loading;
		},
		/**
		 * check if a node is opened
		 * @name is_open(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_open : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.opened;
		},
		/**
		 * check if a node is in a closed state
		 * @name is_closed(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_closed : function (obj) {
			obj = this.get_node(obj);
			return obj && this.is_parent(obj) && !obj.state.opened;
		},
		/**
		 * check if a node has no children
		 * @name is_leaf(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_leaf : function (obj) {
			return !this.is_parent(obj);
		},
		/**
		 * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
		 * @name load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
		 * @return {Boolean}
		 * @trigger load_node.jstree
		 */
		load_node : function (obj, callback) {
			var k, l, i, j, c;
			if(langx.isArray(obj)) {
				this._load_nodes(obj.slice(), callback);
				return true;
			}
			obj = this.get_node(obj);
			if(!obj) {
				if(callback) { callback.call(this, obj, false); }
				return false;
			}
			// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
			if(obj.state.loaded) {
				obj.state.loaded = false;
				for(i = 0, j = obj.parents.length; i < j; i++) {
					this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
						return langx.inArray(v, obj.children_d) === -1;
					});
				}
				for(k = 0, l = obj.children_d.length; k < l; k++) {
					if(this._model.data[obj.children_d[k]].state.selected) {
						c = true;
					}
					delete this._model.data[obj.children_d[k]];
				}
				if (c) {
					this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
						return langx.inArray(v, obj.children_d) === -1;
					});
				}
				obj.children = [];
				obj.children_d = [];
				if(c) {
					this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
				}
			}
			obj.state.failed = false;
			obj.state.loading = true;
			this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
			this._load_node(obj, langx.proxy(function (status) {
				obj = this._model.data[obj.id];
				obj.state.loading = false;
				obj.state.loaded = status;
				obj.state.failed = !obj.state.loaded;
				var dom = this.get_node(obj, true), i = 0, j = 0, m = this._model.data, has_children = false;
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(m[obj.children[i]] && !m[obj.children[i]].state.hidden) {
						has_children = true;
						break;
					}
				}
				if(obj.state.loaded && dom && dom.length) {
					dom.removeClass('jstree-closed jstree-open jstree-leaf');
					if (!has_children) {
						dom.addClass('jstree-leaf');
					}
					else {
						if (obj.id !== '#') {
							dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');
						}
					}
				}
				dom.removeClass("jstree-loading").attr('aria-busy',false);
				/**
				 * triggered after a node is loaded
				 * @event
				 * @name load_node.jstree
				 * @param {Object} node the node that was loading
				 * @param {Boolean} status was the node loaded successfully
				 */
				this.trigger('load_node', { "node" : obj, "status" : status });
				if(callback) {
					callback.call(this, obj, status);
				}
			}, this));
			return true;
		},
		/**
		 * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
		 * @private
		 * @name _load_nodes(nodes [, callback])
		 * @param  {array} nodes
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
		 */
		_load_nodes : function (nodes, callback, is_callback, force_reload) {
			var r = true,
				c = function () { this._load_nodes(nodes, callback, true); },
				m = this._model.data, i, j, tmp = [];
			for(i = 0, j = nodes.length; i < j; i++) {
				if(m[nodes[i]] && ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || (!is_callback && force_reload) )) {
					if(!this.is_loading(nodes[i])) {
						this.load_node(nodes[i], c);
					}
					r = false;
				}
			}
			if(r) {
				for(i = 0, j = nodes.length; i < j; i++) {
					if(m[nodes[i]] && m[nodes[i]].state.loaded) {
						tmp.push(nodes[i]);
					}
				}
				if(callback && !callback.done) {
					callback.call(this, tmp);
					callback.done = true;
				}
			}
		},
		/**
		 * loads all unloaded nodes
		 * @name load_all([obj, callback])
		 * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
		 * @param {function} callback a function to be executed once loading all the nodes is complete,
		 * @trigger load_all.jstree
		 */
		load_all : function (obj, callback) {
			if(!obj) { obj = $.jstree.root; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var to_load = [],
				m = this._model.data,
				c = m[obj.id].children_d,
				i, j;
			if(obj.state && !obj.state.loaded) {
				to_load.push(obj.id);
			}
			for(i = 0, j = c.length; i < j; i++) {
				if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
					to_load.push(c[i]);
				}
			}
			if(to_load.length) {
				this._load_nodes(to_load, function () {
					this.load_all(obj, callback);
				});
			}
			else {
				/**
				 * triggered after a load_all call completes
				 * @event
				 * @name load_all.jstree
				 * @param {Object} node the recursively loaded node
				 */
				if(callback) { callback.call(this, obj); }
				this.trigger('load_all', { "node" : obj });
			}
		},
		/**
		 * handles the actual loading of a node. Used only internally.
		 * @private
		 * @name _load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
		 * @return {Boolean}
		 */
		_load_node : function (obj, callback) {
			var s = this.settings.core.data, t;
			var notTextOrCommentNode = function notTextOrCommentNode () {
				return this.nodeType !== 3 && this.nodeType !== 8;
			};
			// use original HTML
			if(!s) {
				if(obj.id === $.jstree.root) {
					return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
						callback.call(this, status);
					});
				}
				else {
					return callback.call(this, false);
				}
				// return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
			}
			if(langx.isFunction(s)) {
				return s.call(this, obj, langx.proxy(function (d) {
					if(d === false) {
						callback.call(this, false);
					}
					else {
						this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(langx.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {
							callback.call(this, status);
						});
					}
					// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
				}, this));
			}
			if(typeof s === 'object') {
				if(s.url) {
					s = langx.extend(true, {}, s);
					if(langx.isFunction(s.url)) {
						s.url = s.url.call(this, obj);
					}
					if(langx.isFunction(s.data)) {
						s.data = s.data.call(this, obj);
					}
					return ajax(s)
						.done(langx.proxy(function (d,t,x) {
								var type = x.getResponseHeader('Content-Type');
								if((type && type.indexOf('json') !== -1) || typeof d === "object") {
									return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
									//return callback.call(this, this._append_json_data(obj, d));
								}
								if((type && type.indexOf('html') !== -1) || typeof d === "string") {
									return this._append_html_data(obj, $(langx.parseHTML(d)).filter(notTextOrCommentNode), function (status) { callback.call(this, status); });
									// return callback.call(this, this._append_html_data(obj, $(d)));
								}
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
								this.settings.core.error.call(this, this._data.core.last_error);
								return callback.call(this, false);
							}, this))
						.fail(langx.proxy(function (f) {
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
								callback.call(this, false);
								this.settings.core.error.call(this, this._data.core.last_error);
							}, this));
				}
				if (langx.isArray(s)) {
					t = langx.extend(true, [], s);
				} else if (langx.isPlainObject(s)) {
					t = langx.extend(true, {}, s);
				} else {
					t = s;
				}
				if(obj.id === $.jstree.root) {
					return this._append_json_data(obj, t, function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );
			}
			if(typeof s === 'string') {
				if(obj.id === $.jstree.root) {
					return this._append_html_data(obj, $(langx.parseHTML(s)).filter(notTextOrCommentNode), function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );
			}
			return callback.call(this, false);
		},
		/**
		 * adds a node to the list of nodes to redraw. Used only internally.
		 * @private
		 * @name _node_changed(obj [, callback])
		 * @param  {mixed} obj
		 */
		_node_changed : function (obj) {
			obj = this.get_node(obj);
      if (obj && langx.inArray(obj.id, this._model.changed) === -1) {
				this._model.changed.push(obj.id);
			}
		},
		/**
		 * appends HTML content to the tree. Used internally.
		 * @private
		 * @name _append_html_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the HTML string to parse and append
		 * @trigger model.jstree, changed.jstree
		 */
		_append_html_data : function (dom, data, cb) {
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			var dat = data.is('ul') ? data.children() : data,
				par = dom.id,
				chd = [],
				dpc = [],
				m = this._model.data,
				p = m[par],
				s = this._data.core.selected.length,
				tmp, i, j;
			dat.each(langx.proxy(function (i, v) {
				tmp = this._parse_model_from_html($(v), par, p.parents.concat());
				if(tmp) {
					chd.push(tmp);
					dpc.push(tmp);
					if(m[tmp].children_d.length) {
						dpc = dpc.concat(m[tmp].children_d);
					}
				}
			}, this));
			p.children = chd;
			p.children_d = dpc;
			for(i = 0, j = p.parents.length; i < j; i++) {
				m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
			}
			/**
			 * triggered when new data is inserted to the tree model
			 * @event
			 * @name model.jstree
			 * @param {Array} nodes an array of node IDs
			 * @param {String} parent the parent ID of the nodes
			 */
			this.trigger('model', { "nodes" : dpc, 'parent' : par });
			if(par !== $.jstree.root) {
				this._node_changed(par);
				this.redraw();
			}
			else {
				this.get_container_ul().children('.jstree-initial-node').remove();
				this.redraw(true);
			}
			if(this._data.core.selected.length !== s) {
				this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
			}
			cb.call(this, true);
		},
		/**
		 * appends JSON content to the tree. Used internally.
		 * @private
		 * @name _append_json_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the JSON object to parse and append
		 * @param  {Boolean} force_processing internal param - do not set
		 * @trigger model.jstree, changed.jstree
		 */
		_append_json_data : function (dom, data, cb, force_processing) {
			if(this.element === null) { return; }
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			// *%$@!!!
			if(data.d) {
				data = data.d;
				if(typeof data === "string") {
					data = JSON.parse(data);
				}
			}
			if(!langx.isArray(data)) { data = [data]; }
			var w = null,
				args = {
					'df'	: this._model.default_state,
					'dat'	: data,
					'par'	: dom.id,
					'm'		: this._model.data,
					't_id'	: this._id,
					't_cnt'	: this._cnt,
					'sel'	: this._data.core.selected
				},
				func = function (data, undefined) {
					if(data.data) { data = data.data; }
					var dat = data.dat,
						par = data.par,
						chd = [],
						dpc = [],
						add = [],
						df = data.df,
						t_id = data.t_id,
						t_cnt = data.t_cnt,
						m = data.m,
						p = m[par],
						sel = data.sel,
						tmp, i, j, rslt,
						parse_flat = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = d.id.toString(),
								i, j, c, e,
								tmp = {
									id			: tid,
									text		: d.text || '',
									icon		: d.icon !== undefined ? d.icon : true,
									parent		: p,
									parents		: ps,
									children	: d.children || [],
									children_d	: d.children_d || [],
									data		: d.data,
									state		: { },
									li_attr		: { id : false },
									a_attr		: { href : '#' },
									original	: false
								};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tid;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							m[tmp.id] = tmp;
							for(i = 0, j = tmp.children.length; i < j; i++) {
								c = parse_flat(m[tmp.children[i]], tmp.id, ps);
								e = m[c];
								tmp.children_d.push(c);
								if(e.children_d.length) {
									tmp.children_d = tmp.children_d.concat(e.children_d);
								}
							}
							delete d.data;
							delete d.children;
							m[tmp.id].original = d;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						},
						parse_nest = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = false, i, j, c, e, tmp;
							do {
								tid = 'j' + t_id + '_' + (++t_cnt);
							} while(m[tid]);

							tmp = {
								id			: false,
								text		: typeof d === 'string' ? d : '',
								icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
								parent		: p,
								parents		: ps,
								children	: [],
								children_d	: [],
								data		: null,
								state		: { },
								li_attr		: { id : false },
								a_attr		: { href : '#' },
								original	: false
							};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.id) { tmp.id = d.id.toString(); }
							if(d && d.text) { tmp.text = d.text; }
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(tmp.li_attr.id && !tmp.id) {
								tmp.id = tmp.li_attr.id.toString();
							}
							if(!tmp.id) {
								tmp.id = tid;
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tmp.id;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children.length) {
								for(i = 0, j = d.children.length; i < j; i++) {
									c = parse_nest(d.children[i], tmp.id, ps);
									e = m[c];
									tmp.children.push(c);
									if(e.children_d.length) {
										tmp.children_d = tmp.children_d.concat(e.children_d);
									}
								}
								tmp.children_d = tmp.children_d.concat(tmp.children);
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							delete d.data;
							delete d.children;
							tmp.original = d;
							m[tmp.id] = tmp;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						};

					if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
						// Flat JSON support (for easy import from DB):
						// 1) convert to object (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							if(!dat[i].children) {
								dat[i].children = [];
							}
							if(!dat[i].state) {
								dat[i].state = {};
							}
							m[dat[i].id.toString()] = dat[i];
						}
						// 2) populate children (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							if (!m[dat[i].parent.toString()]) {
								this._data.core.last_error = { 'error' : 'parse', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Node with invalid parent', 'data' : JSON.stringify({ 'id' : dat[i].id.toString(), 'parent' : dat[i].parent.toString() }) };
								this.settings.core.error.call(this, this._data.core.last_error);
								continue;
							}

							m[dat[i].parent.toString()].children.push(dat[i].id.toString());
							// populate parent.children_d
							p.children_d.push(dat[i].id.toString());
						}
						// 3) normalize && populate parents and children_d with recursion
						for(i = 0, j = p.children.length; i < j; i++) {
							tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
							dpc.push(tmp);
							if(m[tmp].children_d.length) {
								dpc = dpc.concat(m[tmp].children_d);
							}
						}
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					else {
						for(i = 0, j = dat.length; i < j; i++) {
							tmp = parse_nest(dat[i], par, p.parents.concat());
							if(tmp) {
								chd.push(tmp);
								dpc.push(tmp);
								if(m[tmp].children_d.length) {
									dpc = dpc.concat(m[tmp].children_d);
								}
							}
						}
						p.children = chd;
						p.children_d = dpc;
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					if(typeof window === 'undefined' || typeof window.document === 'undefined') {
						postMessage(rslt);
					}
					else {
						return rslt;
					}
				},
				rslt = function (rslt, worker) {
					if(this.element === null) { return; }
					this._cnt = rslt.cnt;
					var i, m = this._model.data;
					for (i in m) {
						if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && rslt.mod[i]) {
							rslt.mod[i].state.loading = true;
						}
					}
					this._model.data = rslt.mod; // breaks the reference in load_node - careful

					if(worker) {
						var j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice();
						m = this._model.data;
						// if selection was changed while calculating in worker
						if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
							// deselect nodes that are no longer selected
							for(i = 0, j = r.length; i < j; i++) {
								if(langx.inArray(r[i], a) === -1 && langx.inArray(r[i], s) === -1) {
									m[r[i]].state.selected = false;
								}
							}
							// select nodes that were selected in the mean time
							for(i = 0, j = s.length; i < j; i++) {
								if(langx.inArray(s[i], r) === -1) {
									m[s[i]].state.selected = true;
								}
							}
						}
					}
					if(rslt.add.length) {
						this._data.core.selected = this._data.core.selected.concat(rslt.add);
					}

					this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });

					if(rslt.par !== $.jstree.root) {
						this._node_changed(rslt.par);
						this.redraw();
					}
					else {
						// this.get_container_ul().children('.jstree-initial-node').remove();
						this.redraw(true);
					}
					if(rslt.add.length) {
						this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
					}
					cb.call(this, true);
				};
			if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
				try {
					if(this._wrk === null) {
						this._wrk = window.URL.createObjectURL(
							new window.Blob(
								['self.onmessage = ' + func.toString()],
								{type:"text/javascript"}
							)
						);
					}
					if(!this._data.core.working || force_processing) {
						this._data.core.working = true;
						w = new window.Worker(this._wrk);
						w.onmessage = langx.proxy(function (e) {
							rslt.call(this, e.data, true);
							try { w.terminate(); w = null; } catch(ignore) { }
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}, this);
						if(!args.par) {
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}
						else {
							w.postMessage(args);
						}
					}
					else {
						this._data.core.worker_queue.push([dom, data, cb, true]);
					}
				}
				catch(e) {
					rslt.call(this, func(args), false);
					if(this._data.core.worker_queue.length) {
						this._append_json_data.apply(this, this._data.core.worker_queue.shift());
					}
					else {
						this._data.core.working = false;
					}
				}
			}
			else {
				rslt.call(this, func(args), false);
			}
		},
		/**
		 * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_html(d [, p, ps])
		 * @param  {jQuery} d the jQuery object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_html : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = [].concat(ps); }
			if(p) { ps.unshift(p); }
			var c, e, m = this._model.data,
				data = {
					id			: false,
					text		: false,
					icon		: true,
					parent		: p,
					parents		: ps,
					children	: [],
					children_d	: [],
					data		: null,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				}, i, tmp, tid;
			for(i in this._model.default_state) {
				if(this._model.default_state.hasOwnProperty(i)) {
					data.state[i] = this._model.default_state[i];
				}
			}
			tmp = $.vakata.attributes(d, true);
			langx.each(tmp, function (i, v) {
				v = langx.trim(v);
				if(!v.length) { return true; }
				data.li_attr[i] = v;
				if(i === 'id') {
					data.id = v.toString();
				}
			});
			tmp = d.children('a').first();
			if(tmp.length) {
				tmp = $.vakata.attributes(tmp, true);
				langx.each(tmp, function (i, v) {
					v = langx.trim(v);
					if(v.length) {
						data.a_attr[i] = v;
					}
				});
			}
			tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
			tmp.children("ins, i, ul").remove();
			tmp = tmp.html();
			tmp = $('<div />').html(tmp);
			data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
			tmp = d.data();
			data.data = tmp ? langx.extend(true, {}, tmp) : null;
			data.state.opened = d.hasClass('jstree-open');
			data.state.selected = d.children('a').hasClass('jstree-clicked');
			data.state.disabled = d.children('a').hasClass('jstree-disabled');
			if(data.data && data.data.jstree) {
				for(i in data.data.jstree) {
					if(data.data.jstree.hasOwnProperty(i)) {
						data.state[i] = data.data.jstree[i];
					}
				}
			}
			tmp = d.children("a").children(".jstree-themeicon");
			if(tmp.length) {
				data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
			}
			if(data.state.icon !== undefined) {
				data.icon = data.state.icon;
			}
			if(data.icon === undefined || data.icon === null || data.icon === "") {
				data.icon = true;
			}
			tmp = d.children("ul").children("li");
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);
			data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
			if(tmp.length) {
				tmp.each(langx.proxy(function (i, v) {
					c = this._parse_model_from_html($(v), data.id, ps);
					e = this._model.data[c];
					data.children.push(c);
					if(e.children_d.length) {
						data.children_d = data.children_d.concat(e.children_d);
					}
				}, this));
				data.children_d = data.children_d.concat(data.children);
			}
			else {
				if(d.hasClass('jstree-closed')) {
					data.state.loaded = false;
				}
			}
			if(data.li_attr['class']) {
				data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
			}
			if(data.a_attr['class']) {
				data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
			}
			m[data.id] = data;
			if(data.state.selected) {
				this._data.core.selected.push(data.id);
			}
			return data.id;
		},
		/**
		 * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_flat_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_flat_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = d.id.toString(),
				m = this._model.data,
				df = this._model.default_state,
				i, j, c, e,
				tmp = {
					id			: tid,
					text		: d.text || '',
					icon		: d.icon !== undefined ? d.icon : true,
					parent		: p,
					parents		: ps,
					children	: d.children || [],
					children_d	: d.children_d || [],
					data		: d.data,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tid;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			m[tmp.id] = tmp;
			for(i = 0, j = tmp.children.length; i < j; i++) {
				c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
				e = m[c];
				tmp.children_d.push(c);
				if(e.children_d.length) {
					tmp.children_d = tmp.children_d.concat(e.children_d);
				}
			}
			delete d.data;
			delete d.children;
			m[tmp.id].original = d;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);

			tmp = {
				id			: false,
				text		: typeof d === 'string' ? d : '',
				icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
				parent		: p,
				parents		: ps,
				children	: [],
				children_d	: [],
				data		: null,
				state		: { },
				li_attr		: { id : false },
				a_attr		: { href : '#' },
				original	: false
			};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.id) { tmp.id = d.id.toString(); }
			if(d && d.text) { tmp.text = d.text; }
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(tmp.li_attr.id && !tmp.id) {
				tmp.id = tmp.li_attr.id.toString();
			}
			if(!tmp.id) {
				tmp.id = tid;
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tmp.id;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children.length) {
				for(i = 0, j = d.children.length; i < j; i++) {
					c = this._parse_model_from_json(d.children[i], tmp.id, ps);
					e = m[c];
					tmp.children.push(c);
					if(e.children_d.length) {
						tmp.children_d = tmp.children_d.concat(e.children_d);
					}
				}
				tmp.children_d = tmp.children_d.concat(tmp.children);
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			delete d.data;
			delete d.children;
			tmp.original = d;
			m[tmp.id] = tmp;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * redraws all nodes that need to be redrawn. Used internally.
		 * @private
		 * @name _redraw()
		 * @trigger redraw.jstree
		 */
		_redraw : function () {
			var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),
				f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
			for(i = 0, j = nodes.length; i < j; i++) {
				tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
				if(tmp && this._model.force_full_redraw) {
					f.appendChild(tmp);
				}
			}
			if(this._model.force_full_redraw) {
				f.className = this.get_container_ul()[0].className;
				f.setAttribute('role','group');
				this.element.empty().append(f);
				//this.get_container_ul()[0].appendChild(f);
			}
			if(fe !== null) {
				tmp = this.get_node(fe, true);
				if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
					tmp.children('.jstree-anchor').focus();
				}
				else {
					this._data.core.focused = null;
				}
			}
			this._model.force_full_redraw = false;
			this._model.changed = [];
			/**
			 * triggered after nodes are redrawn
			 * @event
			 * @name redraw.jstree
			 * @param {array} nodes the redrawn nodes
			 */
			this.trigger('redraw', { "nodes" : nodes });
		},
		/**
		 * redraws all nodes that need to be redrawn or optionally - the whole tree
		 * @name redraw([full])
		 * @param {Boolean} full if set to `true` all nodes are redrawn.
		 */
		redraw : function (full) {
			if(full) {
				this._model.force_full_redraw = true;
			}
			//if(this._model.redraw_timeout) {
			//	clearTimeout(this._model.redraw_timeout);
			//}
			//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
			this._redraw();
		},
		/**
		 * redraws a single node's children. Used internally.
		 * @private
		 * @name draw_children(node)
		 * @param {mixed} node the node whose children will be redrawn
		 */
		draw_children : function (node) {
			var obj = this.get_node(node),
				i = false,
				j = false,
				k = false,
				d = document;
			if(!obj) { return false; }
			if(obj.id === $.jstree.root) { return this.redraw(true); }
			node = this.get_node(node, true);
			if(!node || !node.length) { return false; } // TODO: quick toggle

			node.children('.jstree-children').remove();
			node = node[0];
			if(obj.children.length && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], true, true));
				}
				node.appendChild(k);
			}
		},
		/**
		 * redraws a single node. Used internally.
		 * @private
		 * @name redraw_node(node, deep, is_callback, force_render)
		 * @param {mixed} node the node to redraw
		 * @param {Boolean} deep should child nodes be redrawn too
		 * @param {Boolean} is_callback is this a recursion call
		 * @param {Boolean} force_render should children of closed parents be drawn anyway
		 */
		redraw_node : function (node, deep, is_callback, force_render) {
			var obj = this.get_node(node),
				par = false,
				ind = false,
				old = false,
				i = false,
				j = false,
				k = false,
				c = '',
				d = document,
				m = this._model.data,
				f = false,
				s = false,
				tmp = null,
				t = 0,
				l = 0,
				has_children = false,
				last_sibling = false;
			if(!obj) { return false; }
			if(obj.id === $.jstree.root) {  return this.redraw(true); }
			deep = deep || obj.children.length === 0;
			node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
			if(!node) {
				deep = true;
				//node = d.createElement('LI');
				if(!is_callback) {
					par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
					if(par !== null && (!par || !m[obj.parent].state.opened)) {
						return false;
					}
					ind = langx.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);
				}
			}
			else {
				node = $(node);
				if(!is_callback) {
					par = node.parent().parent()[0];
					if(par === this.element[0]) {
						par = null;
					}
					ind = node.index();
				}
				// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
				if(!deep && obj.children.length && !node.children('.jstree-children').length) {
					deep = true;
				}
				if(!deep) {
					old = node.children('.jstree-children')[0];
				}
				f = node.children('.jstree-anchor')[0] === document.activeElement;
				node.remove();
				//node = d.createElement('LI');
				//node = node[0];
			}
			node = this._data.core.node.cloneNode(true);
			// node is DOM, deep is boolean

			c = 'jstree-node ';
			for(i in obj.li_attr) {
				if(obj.li_attr.hasOwnProperty(i)) {
					if(i === 'id') { continue; }
					if(i !== 'class') {
						node.setAttribute(i, obj.li_attr[i]);
					}
					else {
						c += obj.li_attr[i];
					}
				}
			}
			if(!obj.a_attr.id) {
				obj.a_attr.id = obj.id + '_anchor';
			}
			node.setAttribute('aria-selected', !!obj.state.selected);
			node.setAttribute('aria-level', obj.parents.length);
			node.setAttribute('aria-labelledby', obj.a_attr.id);
			if(obj.state.disabled) {
				node.setAttribute('aria-disabled', true);
			}

			for(i = 0, j = obj.children.length; i < j; i++) {
				if(!m[obj.children[i]].state.hidden) {
					has_children = true;
					break;
				}
			}
			if(obj.parent !== null && m[obj.parent] && !obj.state.hidden) {
				i = langx.inArray(obj.id, m[obj.parent].children);
				last_sibling = obj.id;
				if(i !== -1) {
					i++;
					for(j = m[obj.parent].children.length; i < j; i++) {
						if(!m[m[obj.parent].children[i]].state.hidden) {
							last_sibling = m[obj.parent].children[i];
						}
						if(last_sibling !== obj.id) {
							break;
						}
					}
				}
			}

			if(obj.state.hidden) {
				c += ' jstree-hidden';
			}
			if (obj.state.loading) {
				c += ' jstree-loading';
			}
			if(obj.state.loaded && !has_children) {
				c += ' jstree-leaf';
			}
			else {
				c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
				node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
			}
			if(last_sibling === obj.id) {
				c += ' jstree-last';
			}
			node.id = obj.id;
			node.className = c;
			c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
			for(j in obj.a_attr) {
				if(obj.a_attr.hasOwnProperty(j)) {
					if(j === 'href' && obj.a_attr[j] === '#') { continue; }
					if(j !== 'class') {
						node.childNodes[1].setAttribute(j, obj.a_attr[j]);
					}
					else {
						c += ' ' + obj.a_attr[j];
					}
				}
			}
			if(c.length) {
				node.childNodes[1].className = 'jstree-anchor ' + c;
			}
			if((obj.icon && obj.icon !== true) || obj.icon === false) {
				if(obj.icon === false) {
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
				}
				else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
					node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';
				}
				else {
					node.childNodes[1].childNodes[0].style.backgroundImage = 'url("'+obj.icon+'")';
					node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
					node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
				}
			}

			if(this.settings.core.force_text) {
				node.childNodes[1].appendChild(d.createTextNode(obj.text));
			}
			else {
				node.childNodes[1].innerHTML += obj.text;
			}


			if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], deep, true));
				}
				node.appendChild(k);
			}
			if(old) {
				node.appendChild(old);
			}
			if(!is_callback) {
				// append back using par / ind
				if(!par) {
					par = this.element[0];
				}
				for(i = 0, j = par.childNodes.length; i < j; i++) {
					if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
						tmp = par.childNodes[i];
						break;
					}
				}
				if(!tmp) {
					tmp = d.createElement('UL');
					tmp.setAttribute('role', 'group');
					tmp.className = 'jstree-children';
					par.appendChild(tmp);
				}
				par = tmp;

				if(ind < par.childNodes.length) {
					par.insertBefore(node, par.childNodes[ind]);
				}
				else {
					par.appendChild(node);
				}
				if(f) {
					t = this.element[0].scrollTop;
					l = this.element[0].scrollLeft;
					node.childNodes[1].focus();
					this.element[0].scrollTop = t;
					this.element[0].scrollLeft = l;
				}
			}
			if(obj.state.opened && !obj.state.loaded) {
				obj.state.opened = false;
				setTimeout(langx.proxy(function () {
					this.open_node(obj.id, false, 0);
				}, this), 0);
			}
			return node;
		},
		/**
		 * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_node(obj [, callback, animation])
		 * @param {mixed} obj the node to open
		 * @param {Function} callback a function to execute once the node is opened
		 * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger open_node.jstree, after_open.jstree, before_open.jstree
		 */
		open_node : function (obj, callback, animation) {
			var t1, t2, d, t;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.open_node(obj[t1], callback, animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			if(!this.is_closed(obj)) {
				if(callback) {
					callback.call(this, obj, false);
				}
				return false;
			}
			if(!this.is_loaded(obj)) {
				if(this.is_loading(obj)) {
					return setTimeout(langx.proxy(function () {
						this.open_node(obj, callback, animation);
					}, this), 500);
				}
				this.load_node(obj, function (o, ok) {
					return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
				});
			}
			else {
				d = this.get_node(obj, true);
				t = this;
				if(d.length) {
					if(animation && d.children(".jstree-children").length) {
						d.children(".jstree-children").stop(true, true);
					}
					if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
						this.draw_children(obj);
						//d = this.get_node(obj, true);
					}
					if(!animation) {
						this.trigger('before_open', { "node" : obj });
						d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
						d[0].setAttribute("aria-expanded", true);
					}
					else {
						this.trigger('before_open', { "node" : obj });
						d
							.children(".jstree-children").css("display","none").end()
							.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
							.children(".jstree-children").stop(true, true)
								.slideDown(animation, function () {
									this.style.display = "";
									if (t.element) {
										t.trigger("after_open", { "node" : obj });
									}
								});
					}
				}
				obj.state.opened = true;
				if(callback) {
					callback.call(this, obj, true);
				}
				if(!d.length) {
					/**
					 * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
					 * @event
					 * @name before_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('before_open', { "node" : obj });
				}
				/**
				 * triggered when a node is opened (if there is an animation it will not be completed yet)
				 * @event
				 * @name open_node.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_node', { "node" : obj });
				if(!animation || !d.length) {
					/**
					 * triggered when a node is opened and the animation is complete
					 * @event
					 * @name after_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger("after_open", { "node" : obj });
				}
				return true;
			}
		},
		/**
		 * opens every parent of a node (node should be loaded)
		 * @name _open_to(obj)
		 * @param {mixed} obj the node to reveal
		 * @private
		 */
		_open_to : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			var i, j, p = obj.parents;
			for(i = 0, j = p.length; i < j; i+=1) {
				if(i !== $.jstree.root) {
					this.open_node(p[i], false, 0);
				}
			}
			return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
		},
		/**
		 * closes a node, hiding its children
		 * @name close_node(obj [, animation])
		 * @param {mixed} obj the node to close
		 * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger close_node.jstree, after_close.jstree
		 */
		close_node : function (obj, animation) {
			var t1, t2, t, d;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.close_node(obj[t1], animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			if(this.is_closed(obj)) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			t = this;
			d = this.get_node(obj, true);

			obj.state.opened = false;
			/**
			 * triggered when a node is closed (if there is an animation it will not be complete yet)
			 * @event
			 * @name close_node.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_node',{ "node" : obj });
			if(!d.length) {
				/**
				 * triggered when a node is closed and the animation is complete
				 * @event
				 * @name after_close.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger("after_close", { "node" : obj });
			}
			else {
				if(!animation) {
					d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
					d.attr("aria-expanded", false).children('.jstree-children').remove();
					this.trigger("after_close", { "node" : obj });
				}
				else {
					d
						.children(".jstree-children").attr("style","display:block !important").end()
						.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
						.children(".jstree-children").stop(true, true).slideUp(animation, function () {
							this.style.display = "";
							d.children('.jstree-children').remove();
							if (t.element) {
								t.trigger("after_close", { "node" : obj });
							}
						});
				}
			}
		},
		/**
		 * toggles a node - closing it if it is open, opening it if it is closed
		 * @name toggle_node(obj)
		 * @param {mixed} obj the node to toggle
		 */
		toggle_node : function (obj) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.toggle_node(obj[t1]);
				}
				return true;
			}
			if(this.is_closed(obj)) {
				return this.open_node(obj);
			}
			if(this.is_open(obj)) {
				return this.close_node(obj);
			}
		},
		/**
		 * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_all([obj, animation, original_obj])
		 * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
		 * @param {jQuery} reference to the node that started the process (internal use)
		 * @trigger open_all.jstree
		 */
		open_all : function (obj, animation, original_obj) {
			if(!obj) { obj = $.jstree.root; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					if(this.is_closed(this._model.data[obj.children_d[i]])) {
						this._model.data[obj.children_d[i]].state.opened = true;
					}
				}
				return this.trigger('open_all', { "node" : obj });
			}
			original_obj = original_obj || dom;
			_this = this;
			dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
			dom.each(function () {
				_this.open_node(
					this,
					function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
					animation || 0
				);
			});
			if(original_obj.find('.jstree-closed').length === 0) {
				/**
				 * triggered when an `open_all` call completes
				 * @event
				 * @name open_all.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_all', { "node" : this.get_node(original_obj) });
			}
		},
		/**
		 * closes all nodes within a node (or the tree), revaling their children
		 * @name close_all([obj, animation])
		 * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
		 * @trigger close_all.jstree
		 */
		close_all : function (obj, animation) {
			if(!obj) { obj = $.jstree.root; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),
				_this = this, i, j;
			if(dom.length) {
				dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
				$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				this._model.data[obj.children_d[i]].state.opened = false;
			}
			/**
			 * triggered when an `close_all` call completes
			 * @event
			 * @name close_all.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_all', { "node" : obj });
		},
		/**
		 * checks if a node is disabled (not selectable)
		 * @name is_disabled(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_disabled : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.disabled;
		},
		/**
		 * enables a node - so that it can be selected
		 * @name enable_node(obj)
		 * @param {mixed} obj the node to enable
		 * @trigger enable_node.jstree
		 */
		enable_node : function (obj) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			obj.state.disabled = false;
			this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
			/**
			 * triggered when an node is enabled
			 * @event
			 * @name enable_node.jstree
			 * @param {Object} node the enabled node
			 */
			this.trigger('enable_node', { 'node' : obj });
		},
		/**
		 * disables a node - so that it can not be selected
		 * @name disable_node(obj)
		 * @param {mixed} obj the node to disable
		 * @trigger disable_node.jstree
		 */
		disable_node : function (obj) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			obj.state.disabled = true;
			this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
			/**
			 * triggered when an node is disabled
			 * @event
			 * @name disable_node.jstree
			 * @param {Object} node the disabled node
			 */
			this.trigger('disable_node', { 'node' : obj });
		},
		/**
		 * determines if a node is hidden
		 * @name is_hidden(obj)
		 * @param {mixed} obj the node
		 */
		is_hidden : function (obj) {
			obj = this.get_node(obj);
			return obj.state.hidden === true;
		},
		/**
		 * hides a node - it is still in the structure but will not be visible
		 * @name hide_node(obj)
		 * @param {mixed} obj the node to hide
		 * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
		 * @trigger hide_node.jstree
		 */
		hide_node : function (obj, skip_redraw) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_node(obj[t1], true);
				}
				if (!skip_redraw) {
					this.redraw();
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			if(!obj.state.hidden) {
				obj.state.hidden = true;
				this._node_changed(obj.parent);
				if(!skip_redraw) {
					this.redraw();
				}
				/**
				 * triggered when an node is hidden
				 * @event
				 * @name hide_node.jstree
				 * @param {Object} node the hidden node
				 */
				this.trigger('hide_node', { 'node' : obj });
			}
		},
		/**
		 * shows a node
		 * @name show_node(obj)
		 * @param {mixed} obj the node to show
		 * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
		 * @trigger show_node.jstree
		 */
		show_node : function (obj, skip_redraw) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_node(obj[t1], true);
				}
				if (!skip_redraw) {
					this.redraw();
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			if(obj.state.hidden) {
				obj.state.hidden = false;
				this._node_changed(obj.parent);
				if(!skip_redraw) {
					this.redraw();
				}
				/**
				 * triggered when an node is shown
				 * @event
				 * @name show_node.jstree
				 * @param {Object} node the shown node
				 */
				this.trigger('show_node', { 'node' : obj });
			}
		},
		/**
		 * hides all nodes
		 * @name hide_all()
		 * @trigger hide_all.jstree
		 */
		hide_all : function (skip_redraw) {
			var i, m = this._model.data, ids = [];
			for(i in m) {
				if(m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {
					m[i].state.hidden = true;
					ids.push(i);
				}
			}
			this._model.force_full_redraw = true;
			if(!skip_redraw) {
				this.redraw();
			}
			/**
			 * triggered when all nodes are hidden
			 * @event
			 * @name hide_all.jstree
			 * @param {Array} nodes the IDs of all hidden nodes
			 */
			this.trigger('hide_all', { 'nodes' : ids });
			return ids;
		},
		/**
		 * shows all nodes
		 * @name show_all()
		 * @trigger show_all.jstree
		 */
		show_all : function (skip_redraw) {
			var i, m = this._model.data, ids = [];
			for(i in m) {
				if(m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {
					m[i].state.hidden = false;
					ids.push(i);
				}
			}
			this._model.force_full_redraw = true;
			if(!skip_redraw) {
				this.redraw();
			}
			/**
			 * triggered when all nodes are shown
			 * @event
			 * @name show_all.jstree
			 * @param {Array} nodes the IDs of all shown nodes
			 */
			this.trigger('show_all', { 'nodes' : ids });
			return ids;
		},
		/**
		 * called when a node is selected by the user. Used internally.
		 * @private
		 * @name activate_node(obj, e)
		 * @param {mixed} obj the node
		 * @param {Object} e the related event
		 * @trigger activate_node.jstree, changed.jstree
		 */
		activate_node : function (obj, e) {
			if(this.is_disabled(obj)) {
				return false;
			}
			if(!e || typeof e !== 'object') {
				e = {};
			}

			// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
			this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
			if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
			if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }

			if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
				if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
					this.deselect_node(obj, false, e);
				}
				else {
					this.deselect_all(true);
					this.select_node(obj, false, false, e);
					this._data.core.last_clicked = this.get_node(obj);
				}
			}
			else {
				if(e.shiftKey) {
					var o = this.get_node(obj).id,
						l = this._data.core.last_clicked.id,
						p = this.get_node(this._data.core.last_clicked.parent).children,
						c = false,
						i, j;
					for(i = 0, j = p.length; i < j; i += 1) {
						// separate IFs work whem o and l are the same
						if(p[i] === o) {
							c = !c;
						}
						if(p[i] === l) {
							c = !c;
						}
						if(!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
							if (!this.is_hidden(p[i])) {
								this.select_node(p[i], true, false, e);
							}
						}
						else {
							this.deselect_node(p[i], true, e);
						}
					}
					this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
				}
				else {
					if(!this.is_selected(obj)) {
						this.select_node(obj, false, false, e);
					}
					else {
						this.deselect_node(obj, false, e);
					}
				}
			}
			/**
			 * triggered when an node is clicked or intercated with by the user
			 * @event
			 * @name activate_node.jstree
			 * @param {Object} node
			 * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)
			 */
			this.trigger('activate_node', { 'node' : this.get_node(obj), 'event' : e });
		},
		/**
		 * applies the hover state on a node, called when a node is hovered by the user. Used internally.
		 * @private
		 * @name hover_node(obj)
		 * @param {mixed} obj
		 * @trigger hover_node.jstree
		 */
		hover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
				return false;
			}
			var o = this.element.find('.jstree-hovered'), t = this.element;
			if(o && o.length) { this.dehover_node(o); }

			obj.children('.jstree-anchor').addClass('jstree-hovered');
			/**
			 * triggered when an node is hovered
			 * @event
			 * @name hover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('hover_node', { 'node' : this.get_node(obj) });
			setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
		},
		/**
		 * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
		 * @private
		 * @name dehover_node(obj)
		 * @param {mixed} obj
		 * @trigger dehover_node.jstree
		 */
		dehover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
				return false;
			}
			obj.children('.jstree-anchor').removeClass('jstree-hovered');
			/**
			 * triggered when an node is no longer hovered
			 * @event
			 * @name dehover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('dehover_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * select a node
		 * @name select_node(obj [, supress_event, prevent_open])
		 * @param {mixed} obj an array can be used to select multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
		 * @trigger select_node.jstree, changed.jstree
		 */
		select_node : function (obj, supress_event, prevent_open, e) {
			var dom, t1, t2, th;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.select_node(obj[t1], supress_event, prevent_open, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.selected) {
				obj.state.selected = true;
				this._data.core.selected.push(obj.id);
				if(!prevent_open) {
					dom = this._open_to(obj);
				}
				if(dom && dom.length) {
					dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
				}
				/**
				 * triggered when an node is selected
				 * @event
				 * @name select_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this select_node
				 */
				this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					/**
					 * triggered when selection changes
					 * @event
					 * @name changed.jstree
					 * @param {Object} node
					 * @param {Object} action the action that caused the selection to change
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this changed event
					 */
					this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * deselect a node
		 * @name deselect_node(obj [, supress_event])
		 * @param {mixed} obj an array can be used to deselect multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_node.jstree, changed.jstree
		 */
		deselect_node : function (obj, supress_event, e) {
			var t1, t2, dom;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.deselect_node(obj[t1], supress_event, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.selected) {
				obj.state.selected = false;
				this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
				if(dom.length) {
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
				}
				/**
				 * triggered when an node is deselected
				 * @event
				 * @name deselect_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this deselect_node
				 */
				this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * select all nodes in the tree
		 * @name select_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger select_all.jstree, changed.jstree
		 */
		select_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are selected
			 * @event
			 * @name select_all.jstree
			 * @param {Array} selected the current selection
			 */
			this.trigger('select_all', { 'selected' : this._data.core.selected });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * deselect all selected nodes
		 * @name deselect_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_all.jstree, changed.jstree
		 */
		deselect_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = false;
				}
			}
			this._data.core.selected = [];
			this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
			/**
			 * triggered when all nodes are deselected
			 * @event
			 * @name deselect_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 */
			this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * checks if a node is selected
		 * @name is_selected(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 */
		is_selected : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			return obj.state.selected;
		},
		/**
		 * get an array of all selected nodes
		 * @name get_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_selected : function (full) {
			return full ? langx.map(this._data.core.selected, langx.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
		},
		/**
		 * get an array of all top level selected nodes (ignoring children of selected nodes)
		 * @name get_top_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_top_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? langx.map(tmp, langx.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		},
		/**
		 * get an array of all bottom level selected nodes (ignoring selected parents)
		 * @name get_bottom_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_bottom_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? langx.map(obj, langx.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		},
		/**
		 * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
		 * @name get_state()
		 * @private
		 * @return {Object}
		 */
		get_state : function () {
			var state	= {
				'core' : {
					'open' : [],
					'loaded' : [],
					'scroll' : {
						'left' : this.element.scrollLeft(),
						'top' : this.element.scrollTop()
					},
					/*!
					'themes' : {
						'name' : this.get_theme(),
						'icons' : this._data.core.themes.icons,
						'dots' : this._data.core.themes.dots
					},
					*/
					'selected' : []
				}
			}, i;
			for(i in this._model.data) {
				if(this._model.data.hasOwnProperty(i)) {
					if(i !== $.jstree.root) {
						if(this._model.data[i].state.loaded && this.settings.core.loaded_state) {
							state.core.loaded.push(i);
						}
						if(this._model.data[i].state.opened) {
							state.core.open.push(i);
						}
						if(this._model.data[i].state.selected) {
							state.core.selected.push(i);
						}
					}
				}
			}
			return state;
		},
		/**
		 * sets the state of the tree. Used internally.
		 * @name set_state(state [, callback])
		 * @private
		 * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.
		 * @param {Function} callback an optional function to execute once the state is restored.
		 * @trigger set_state.jstree
		 */
		set_state : function (state, callback) {
			if(state) {
				if(state.core && state.core.selected && state.core.initial_selection === undefined) {
					state.core.initial_selection = this._data.core.selected.concat([]).sort().join(',');
				}
				if(state.core) {
					var res, n, t, _this, i;
					if(state.core.loaded) {
						if(!this.settings.core.loaded_state || !langx.isArray(state.core.loaded) || !state.core.loaded.length) {
							delete state.core.loaded;
							this.set_state(state, callback);
						}
						else {
							this._load_nodes(state.core.loaded, function (nodes) {
								delete state.core.loaded;
								this.set_state(state, callback);
							});
						}
						return false;
					}
					if(state.core.open) {
						if(!langx.isArray(state.core.open) || !state.core.open.length) {
							delete state.core.open;
							this.set_state(state, callback);
						}
						else {
							this._load_nodes(state.core.open, function (nodes) {
								this.open_node(nodes, false, 0);
								delete state.core.open;
								this.set_state(state, callback);
							});
						}
						return false;
					}
					if(state.core.scroll) {
						if(state.core.scroll && state.core.scroll.left !== undefined) {
							this.element.scrollLeft(state.core.scroll.left);
						}
						if(state.core.scroll && state.core.scroll.top !== undefined) {
							this.element.scrollTop(state.core.scroll.top);
						}
						delete state.core.scroll;
						this.set_state(state, callback);
						return false;
					}
					if(state.core.selected) {
						_this = this;
						if (state.core.initial_selection === undefined ||
							state.core.initial_selection === this._data.core.selected.concat([]).sort().join(',')
						) {
							this.deselect_all();
							langx.each(state.core.selected, function (i, v) {
								_this.select_node(v, false, true);
							});
						}
						delete state.core.initial_selection;
						delete state.core.selected;
						this.set_state(state, callback);
						return false;
					}
					for(i in state) {
						if(state.hasOwnProperty(i) && i !== "core" && langx.inArray(i, this.settings.plugins) === -1) {
							delete state[i];
						}
					}
					if(langx.isEmptyObject(state.core)) {
						delete state.core;
						this.set_state(state, callback);
						return false;
					}
				}
				if(langx.isEmptyObject(state)) {
					state = null;
					if(callback) { callback.call(this); }
					/**
					 * triggered when a `set_state` call completes
					 * @event
					 * @name set_state.jstree
					 */
					this.trigger('set_state');
					return false;
				}
				return true;
			}
			return false;
		},
		/**
		 * refreshes the tree - all nodes are reloaded with calls to `load_node`.
		 * @name refresh()
		 * @param {Boolean} skip_loading an option to skip showing the loading indicator
		 * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
		 * @trigger refresh.jstree
		 */
		refresh : function (skip_loading, forget_state) {
			this._data.core.state = forget_state === true ? {} : this.get_state();
			if(forget_state && langx.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
			this._cnt = 0;
			this._model.data = {};
			this._model.data[$.jstree.root] = {
				id : $.jstree.root,
				parent : null,
				parents : [],
				children : [],
				children_d : [],
				state : { loaded : false }
			};
			this._data.core.selected = [];
			this._data.core.last_clicked = null;
			this._data.core.focused = null;

			var c = this.get_container_ul()[0].className;
			if(!skip_loading) {
				this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
				this.element.attr('aria-activedescendant','j'+this._id+'_loading');
			}
			this.load_node($.jstree.root, function (o, s) {
				if(s) {
					this.get_container_ul()[0].className = c;
					if(this._firstChild(this.get_container_ul()[0])) {
						this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
					}
					this.set_state(langx.extend(true, {}, this._data.core.state), function () {
						/**
						 * triggered when a `refresh` call completes
						 * @event
						 * @name refresh.jstree
						 */
						this.trigger('refresh');
					});
				}
				this._data.core.state = null;
			});
		},
		/**
		 * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
		 * @name refresh_node(obj)
		 * @param  {mixed} obj the node
		 * @trigger refresh_node.jstree
		 */
		refresh_node : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			var opened = [], to_load = [], s = this._data.core.selected.concat([]);
			to_load.push(obj.id);
			if(obj.state.opened === true) { opened.push(obj.id); }
			this.get_node(obj, true).find('.jstree-open').each(function() { to_load.push(this.id); opened.push(this.id); });
			this._load_nodes(to_load, langx.proxy(function (nodes) {
				this.open_node(opened, false, 0);
				this.select_node(s);
				/**
				 * triggered when a node is refreshed
				 * @event
				 * @name refresh_node.jstree
				 * @param {Object} node - the refreshed node
				 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
				 */
				this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
			}, this), false, true);
		},
		/**
		 * set (change) the ID of a node
		 * @name set_id(obj, id)
		 * @param  {mixed} obj the node
		 * @param  {String} id the new ID
		 * @return {Boolean}
		 * @trigger set_id.jstree
		 */
		set_id : function (obj, id) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			var i, j, m = this._model.data, old = obj.id;
			id = id.toString();
			// update parents (replace current ID with new one in children and children_d)
			m[obj.parent].children[langx.inArray(obj.id, m[obj.parent].children)] = id;
			for(i = 0, j = obj.parents.length; i < j; i++) {
				m[obj.parents[i]].children_d[langx.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
			}
			// update children (replace current ID with new one in parent and parents)
			for(i = 0, j = obj.children.length; i < j; i++) {
				m[obj.children[i]].parent = id;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				m[obj.children_d[i]].parents[langx.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
			}
			i = langx.inArray(obj.id, this._data.core.selected);
			if(i !== -1) { this._data.core.selected[i] = id; }
			// update model and obj itself (obj.id, this._model.data[KEY])
			i = this.get_node(obj.id, true);
			if(i) {
				i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
				if(this.element.attr('aria-activedescendant') === obj.id) {
					this.element.attr('aria-activedescendant', id);
				}
			}
			delete m[obj.id];
			obj.id = id;
			obj.li_attr.id = id;
			m[id] = obj;
			/**
			 * triggered when a node id value is changed
			 * @event
			 * @name set_id.jstree
			 * @param {Object} node
			 * @param {String} old the old id
			 */
			this.trigger('set_id',{ "node" : obj, "new" : obj.id, "old" : old });
			return true;
		},
		/**
		 * get the text value of a node
		 * @name get_text(obj)
		 * @param  {mixed} obj the node
		 * @return {String}
		 */
		get_text : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === $.jstree.root) ? false : obj.text;
		},
		/**
		 * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
		 * @private
		 * @name set_text(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger set_text.jstree
		 */
		set_text : function (obj, val) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_text(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			obj.text = val;
			if(this.get_node(obj, true).length) {
				this.redraw_node(obj.id);
			}
			/**
			 * triggered when a node text value is changed
			 * @event
			 * @name set_text.jstree
			 * @param {Object} obj
			 * @param {String} text the new value
			 */
			this.trigger('set_text',{ "obj" : obj, "text" : val });
			return true;
		},
		/**
		 * gets a JSON representation of a node (or the whole tree)
		 * @name get_json([obj, options])
		 * @param  {mixed} obj
		 * @param  {Object} options
		 * @param  {Boolean} options.no_state do not return state information
		 * @param  {Boolean} options.no_id do not return ID
		 * @param  {Boolean} options.no_children do not include children
		 * @param  {Boolean} options.no_data do not include node data
		 * @param  {Boolean} options.no_li_attr do not include LI attributes
		 * @param  {Boolean} options.no_a_attr do not include A attributes
		 * @param  {Boolean} options.flat return flat JSON instead of nested
		 * @return {Object}
		 */
		get_json : function (obj, options, flat) {
			obj = this.get_node(obj || $.jstree.root);
			if(!obj) { return false; }
			if(options && options.flat && !flat) { flat = []; }
			var tmp = {
				'id' : obj.id,
				'text' : obj.text,
				'icon' : this.get_icon(obj),
				'li_attr' : langx.extend(true, {}, obj.li_attr),
				'a_attr' : langx.extend(true, {}, obj.a_attr),
				'state' : {},
				'data' : options && options.no_data ? false : langx.extend(true, langx.isArray(obj.data)?[]:{}, obj.data)
				//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
			}, i, j;
			if(options && options.flat) {
				tmp.parent = obj.parent;
			}
			else {
				tmp.children = [];
			}
			if(!options || !options.no_state) {
				for(i in obj.state) {
					if(obj.state.hasOwnProperty(i)) {
						tmp.state[i] = obj.state[i];
					}
				}
			} else {
				delete tmp.state;
			}
			if(options && options.no_li_attr) {
				delete tmp.li_attr;
			}
			if(options && options.no_a_attr) {
				delete tmp.a_attr;
			}
			if(options && options.no_id) {
				delete tmp.id;
				if(tmp.li_attr && tmp.li_attr.id) {
					delete tmp.li_attr.id;
				}
				if(tmp.a_attr && tmp.a_attr.id) {
					delete tmp.a_attr.id;
				}
			}
			if(options && options.flat && obj.id !== $.jstree.root) {
				flat.push(tmp);
			}
			if(!options || !options.no_children) {
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(options && options.flat) {
						this.get_json(obj.children[i], options, flat);
					}
					else {
						tmp.children.push(this.get_json(obj.children[i], options));
					}
				}
			}
			return options && options.flat ? flat : (obj.id === $.jstree.root ? tmp.children : tmp);
		},
		/**
		 * create a new node (do not confuse with load_node)
		 * @name create_node([par, node, pos, callback, is_loaded])
		 * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
		 * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
		 * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
		 * @param  {Function} callback a function to be called once the node is created
		 * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
		 * @return {String}            the ID of the newly create node
		 * @trigger model.jstree, create_node.jstree
		 */
		create_node : function (par, node, pos, callback, is_loaded) {
			if(par === null) { par = $.jstree.root; }
			par = this.get_node(par);
			if(!par) { return false; }
			pos = pos === undefined ? "last" : pos;
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
			}
			if(!node) { node = { "text" : this.get_string('New node') }; }
			if(typeof node === "string") {
				node = { "text" : node };
			} else {
				node = langx.extend(true, {}, node);
			}
			if(node.text === undefined) { node.text = this.get_string('New node'); }
			var tmp, dpc, i, j;

			if(par.id === $.jstree.root) {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					tmp = this.get_node(par.parent);
					pos = langx.inArray(par.id, tmp.children);
					par = tmp;
					break;
				case "after" :
					tmp = this.get_node(par.parent);
					pos = langx.inArray(par.id, tmp.children) + 1;
					par = tmp;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > par.children.length) { pos = par.children.length; }
			if(!node.id) { node.id = true; }
			if(!this.check("create_node", node, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, par.id, par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : par.id });

			par.children_d = par.children_d.concat(dpc);
			for(i = 0, j = par.parents.length; i < j; i++) {
				this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
			}
			node = tmp;
			tmp = [];
			for(i = 0, j = par.children.length; i < j; i++) {
				tmp[i >= pos ? i+1 : i] = par.children[i];
			}
			tmp[pos] = node.id;
			par.children = tmp;

			this.redraw_node(par, true);
			/**
			 * triggered when a node is created
			 * @event
			 * @name create_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the new node among the parent's children
			 */
			this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
			if(callback) { callback.call(this, this.get_node(node)); }
			return node.id;
		},
		/**
		 * set the text value of a node
		 * @name rename_node(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger rename_node.jstree
		 */
		rename_node : function (obj, val) {
			var t1, t2, old;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.rename_node(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			old = obj.text;
			if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
			/**
			 * triggered when a node is renamed
			 * @event
			 * @name rename_node.jstree
			 * @param {Object} node
			 * @param {String} text the new value
			 * @param {String} old the old value
			 */
			this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
			return true;
		},
		/**
		 * remove a node
		 * @name delete_node(obj)
		 * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
		 * @return {Boolean}
		 * @trigger delete_node.jstree, changed.jstree
		 */
		delete_node : function (obj) {
			var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.delete_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			par = this.get_node(obj.parent);
			pos = langx.inArray(obj.id, par.children);
			c = false;
			if(!this.check("delete_node", obj, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(pos !== -1) {
				par.children = $.vakata.array_remove(par.children, pos);
			}
			tmp = obj.children_d.concat([]);
			tmp.push(obj.id);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
					return langx.inArray(v, tmp) === -1;
				});
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				if(this._model.data[tmp[k]].state.selected) {
					c = true;
					break;
				}
			}
			if (c) {
				this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
					return langx.inArray(v, tmp) === -1;
				});
			}
			/**
			 * triggered when a node is deleted
			 * @event
			 * @name delete_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 */
			this.trigger('delete_node', { "node" : obj, "parent" : par.id });
			if(c) {
				this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				delete this._model.data[tmp[k]];
			}
			if(langx.inArray(this._data.core.focused, tmp) !== -1) {
				this._data.core.focused = null;
				top = this.element[0].scrollTop;
				lft = this.element[0].scrollLeft;
				if(par.id === $.jstree.root) {
					if (this._model.data[$.jstree.root].children[0]) {
						this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();
					}
				}
				else {
					this.get_node(par, true).children('.jstree-anchor').focus();
				}
				this.element[0].scrollTop  = top;
				this.element[0].scrollLeft = lft;
			}
			this.redraw_node(par, true);
			return true;
		},
		/**
		 * check if an operation is premitted on the tree. Used internally.
		 * @private
		 * @name check(chk, obj, par, pos)
		 * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
		 * @param  {mixed} obj the node
		 * @param  {mixed} par the parent
		 * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
		 * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
		 * @return {Boolean}
		 */
		check : function (chk, obj, par, pos, more) {
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
			if(chk === "move_node" || chk === "copy_node") {
				if((!more || !more.is_multi) && (obj.id === par.id || (chk === "move_node" && langx.inArray(obj.id, par.children) === pos) || langx.inArray(par.id, obj.children_d) !== -1)) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					return false;
				}
			}
			if(tmp && tmp.data) { tmp = tmp.data; }
			if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
				if(tmp.functions[chk] === false) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				}
				return tmp.functions[chk];
			}
			if(chc === false || (langx.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				return false;
			}
			return true;
		},
		/**
		 * get the last error
		 * @name last_error()
		 * @return {Object}
		 */
		last_error : function () {
			return this._data.core.last_error;
		},
		/**
		 * move a node to a new parent
		 * @name move_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to move, pass an array to move multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger move_node.jstree
		 */
		move_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
			}

			if(langx.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);

			if(!obj || obj.id === $.jstree.root) { return false; }

			old_par = (obj.parent || $.jstree.root).toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
			old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? langx.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(is_multi) {
				if((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
					if(old_ins) { old_ins.delete_node(obj); }
					return tmp;
				}
				return false;
			}
			//var m = this._model.data;
			if(par.id === $.jstree.root) {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = langx.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = langx.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(obj.parent === new_par.id) {
				dpc = new_par.children.concat();
				tmp = langx.inArray(obj.id, dpc);
				if(tmp !== -1) {
					dpc = $.vakata.array_remove(dpc, tmp);
					if(pos > tmp) { pos--; }
				}
				tmp = [];
				for(i = 0, j = dpc.length; i < j; i++) {
					tmp[i >= pos ? i+1 : i] = dpc[i];
				}
				tmp[pos] = obj.id;
				new_par.children = tmp;
				this._node_changed(new_par.id);
				this.redraw(new_par.id === $.jstree.root);
			}
			else {
				// clean old parent and up
				tmp = obj.children_d.concat();
				tmp.push(obj.id);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					dpc = [];
					p = old_ins._model.data[obj.parents[i]].children_d;
					for(k = 0, l = p.length; k < l; k++) {
						if(langx.inArray(p[k], tmp) === -1) {
							dpc.push(p[k]);
						}
					}
					old_ins._model.data[obj.parents[i]].children_d = dpc;
				}
				old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);

				// insert into new parent and up
				for(i = 0, j = new_par.parents.length; i < j; i++) {
					this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
				}
				dpc = [];
				for(i = 0, j = new_par.children.length; i < j; i++) {
					dpc[i >= pos ? i+1 : i] = new_par.children[i];
				}
				dpc[pos] = obj.id;
				new_par.children = dpc;
				new_par.children_d.push(obj.id);
				new_par.children_d = new_par.children_d.concat(obj.children_d);

				// update object
				obj.parent = new_par.id;
				tmp = new_par.parents.concat();
				tmp.unshift(new_par.id);
				p = obj.parents.length;
				obj.parents = tmp;

				// update object children
				tmp = tmp.concat();
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
					Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
				}

				if(old_par === $.jstree.root || new_par.id === $.jstree.root) {
					this._model.force_full_redraw = true;
				}
				if(!this._model.force_full_redraw) {
					this._node_changed(old_par);
					this._node_changed(new_par.id);
				}
				if(!skip_redraw) {
					this.redraw();
				}
			}
			if(callback) { callback.call(this, obj, new_par, pos); }
			/**
			 * triggered when a node is moved
			 * @event
			 * @name move_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the old position of the node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return obj.id;
		},
		/**
		 * copy a node to a new parent
		 * @name copy_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger model.jstree copy_node.jstree
		 */
		copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
			}

			if(langx.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }

			old_par = (obj.parent || $.jstree.root).toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);

			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(par.id === $.jstree.root) {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = langx.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = langx.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
			if(!node) { return false; }
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });

			// insert into new parent and up
			for(i = 0, j = new_par.parents.length; i < j; i++) {
				this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
			}
			dpc = [];
			for(i = 0, j = new_par.children.length; i < j; i++) {
				dpc[i >= pos ? i+1 : i] = new_par.children[i];
			}
			dpc[pos] = tmp.id;
			new_par.children = dpc;
			new_par.children_d.push(tmp.id);
			new_par.children_d = new_par.children_d.concat(tmp.children_d);

			if(new_par.id === $.jstree.root) {
				this._model.force_full_redraw = true;
			}
			if(!this._model.force_full_redraw) {
				this._node_changed(new_par.id);
			}
			if(!skip_redraw) {
				this.redraw(new_par.id === $.jstree.root);
			}
			if(callback) { callback.call(this, tmp, new_par, pos); }
			/**
			 * triggered when a node is copied
			 * @event
			 * @name copy_node.jstree
			 * @param {Object} node the copied node
			 * @param {Object} original the original node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the position of the original node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? langx.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return tmp.id;
		},
		/**
		 * cut a node (a later call to `paste(obj)` would move the node)
		 * @name cut(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger cut.jstree
		 */
		cut : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!langx.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'move_node';
			/**
			 * triggered when nodes are added to the buffer for moving
			 * @event
			 * @name cut.jstree
			 * @param {Array} node
			 */
			this.trigger('cut', { "node" : obj });
		},
		/**
		 * copy a node (a later call to `paste(obj)` would copy the node)
		 * @name copy(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger copy.jstree
		 */
		copy : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!langx.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'copy_node';
			/**
			 * triggered when nodes are added to the buffer for copying
			 * @event
			 * @name copy.jstree
			 * @param {Array} node
			 */
			this.trigger('copy', { "node" : obj });
		},
		/**
		 * get the current buffer (any nodes that are waiting for a paste operation)
		 * @name get_buffer()
		 * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
		 */
		get_buffer : function () {
			return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
		},
		/**
		 * check if there is something in the buffer to paste
		 * @name can_paste()
		 * @return {Boolean}
		 */
		can_paste : function () {
			return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
		},
		/**
		 * copy or move the previously cut or copied nodes to a new parent
		 * @name paste(obj [, pos])
		 * @param  {mixed} obj the new parent
		 * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
		 * @trigger paste.jstree
		 */
		paste : function (obj, pos) {
			obj = this.get_node(obj);
			if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
			if(this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
				/**
				 * triggered when paste is invoked
				 * @event
				 * @name paste.jstree
				 * @param {String} parent the ID of the receiving node
				 * @param {Array} node the nodes in the buffer
				 * @param {String} mode the performed operation - "copy_node" or "move_node"
				 */
				this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
			}
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
		},
		/**
		 * clear the buffer of previously copied or cut nodes
		 * @name clear_buffer()
		 * @trigger clear_buffer.jstree
		 */
		clear_buffer : function () {
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
			/**
			 * triggered when the copy / cut buffer is cleared
			 * @event
			 * @name clear_buffer.jstree
			 */
			this.trigger('clear_buffer');
		},
		/**
		 * put a node in edit mode (input field to rename the node)
		 * @name edit(obj [, default_text, callback])
		 * @param  {mixed} obj
		 * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)
		 * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text
		 */
		edit : function (obj, default_text, callback) {
			var rtl, w, a, s, t, h1, h2, fn, tmp, cancel = false;
			obj = this.get_node(obj);
			if(!obj) { return false; }
			if(!this.check("edit", obj, this.get_parent(obj))) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			tmp = obj;
			default_text = typeof default_text === 'string' ? default_text : obj.text;
			this.set_text(obj, "");
			obj = this._open_to(obj);
			tmp.text = default_text;

			rtl = this._data.core.rtl;
			w  = this.element.width();
			this._data.core.focused = tmp.id;
			a  = obj.children('.jstree-anchor').focus();
			s  = $('<span>');
			/*!
			oi = obj.children("i:visible"),
			ai = a.children("i:visible"),
			w1 = oi.width() * oi.length,
			w2 = ai.width() * ai.length,
			*/
			t  = default_text;
			h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo(document.body);
			h2 = $("<"+"input />", {
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"box-sizing" : "border-box",
							"display" : "inline-block",
							"height" : (this._data.core.li_height) + "px",
							"lineHeight" : (this._data.core.li_height) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : langx.proxy(function (e) {
							e.stopImmediatePropagation();
							e.preventDefault();
							var i = s.children(".jstree-rename-input"),
								v = i.val(),
								f = this.settings.core.force_text,
								nv;
							if(v === "") { v = t; }
							h1.remove();
							s.replaceWith(a);
							s.remove();
							t = f ? t : $('<div></div>').append(langx.parseHTML(t)).html();
							this.set_text(obj, t);
							nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append(langx.parseHTML(v)).html());
							if(!nv) {
								this.set_text(obj, t); // move this up? and fix #483
							}
							this._data.core.focused = tmp.id;
							setTimeout(langx.proxy(function () {
								var node = this.get_node(tmp.id, true);
								if(node.length) {
									this._data.core.focused = tmp.id;
									node.children('.jstree-anchor').focus();
								}
							}, this), 0);
							if(callback) {
								callback.call(this, tmp, nv, cancel);
							}
							h2 = null;
						}, this),
						"keydown" : function (e) {
							var key = e.which;
							if(key === 27) {
								cancel = true;
								this.value = t;
							}
							if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
								e.stopImmediatePropagation();
							}
							if(key === 27 || key === 13) {
								e.preventDefault();
								this.blur();
							}
						},
						"click" : function (e) { e.stopImmediatePropagation(); },
						"mousedown" : function (e) { e.stopImmediatePropagation(); },
						"keyup" : function (e) {
							h2.width(Math.min(h1.text("pW" + this.value).width(),w));
						},
						"keypress" : function(e) {
							if(e.which === 13) { return false; }
						}
					});
				fn = {
						fontFamily		: a.css('fontFamily')		|| '',
						fontSize		: a.css('fontSize')			|| '',
						fontWeight		: a.css('fontWeight')		|| '',
						fontStyle		: a.css('fontStyle')		|| '',
						fontStretch		: a.css('fontStretch')		|| '',
						fontVariant		: a.css('fontVariant')		|| '',
						letterSpacing	: a.css('letterSpacing')	|| '',
						wordSpacing		: a.css('wordSpacing')		|| ''
				};
			s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
			a.replaceWith(s);
			h1.css(fn);
			h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			$(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {
				if (h2 && e.target !== h2) {
					$(h2).blur();
				}
			});
		},


		/**
		 * changes the theme
		 * @name set_theme(theme_name [, theme_url])
		 * @param {String} theme_name the name of the new theme to apply
		 * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
		 * @trigger set_theme.jstree
		 */
		set_theme : function (theme_name, theme_url) {
			if(!theme_name) { return false; }
			if(theme_url === true) {
				var dir = this.settings.core.themes.dir;
				if(!dir) { dir = $.jstree.path + '/themes'; }
				theme_url = dir + '/' + theme_name + '/style.css';
			}
			if(theme_url && langx.inArray(theme_url, themes_loaded) === -1) {
				$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
				themes_loaded.push(theme_url);
			}
			if(this._data.core.themes.name) {
				this.element.removeClass('jstree-' + this._data.core.themes.name);
			}
			this._data.core.themes.name = theme_name;
			this.element.addClass('jstree-' + theme_name);
			this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
			/**
			 * triggered when a theme is set
			 * @event
			 * @name set_theme.jstree
			 * @param {String} theme the new theme
			 */
			this.trigger('set_theme', { 'theme' : theme_name });
		},
		/**
		 * gets the name of the currently applied theme name
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme : function () { return this._data.core.themes.name; },
		/**
		 * changes the theme variant (if the theme has variants)
		 * @name set_theme_variant(variant_name)
		 * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
		 */
		set_theme_variant : function (variant_name) {
			if(this._data.core.themes.variant) {
				this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
			this._data.core.themes.variant = variant_name;
			if(variant_name) {
				this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
		},
		/**
		 * gets the name of the currently applied theme variant
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme_variant : function () { return this._data.core.themes.variant; },
		/**
		 * shows a striped background on the container (if the theme supports it)
		 * @name show_stripes()
		 */
		show_stripes : function () {
			this._data.core.themes.stripes = true;
			this.get_container_ul().addClass("jstree-striped");
			/**
			 * triggered when stripes are shown
			 * @event
			 * @name show_stripes.jstree
			 */
			this.trigger('show_stripes');
		},
		/**
		 * hides the striped background on the container
		 * @name hide_stripes()
		 */
		hide_stripes : function () {
			this._data.core.themes.stripes = false;
			this.get_container_ul().removeClass("jstree-striped");
			/**
			 * triggered when stripes are hidden
			 * @event
			 * @name hide_stripes.jstree
			 */
			this.trigger('hide_stripes');
		},
		/**
		 * toggles the striped background on the container
		 * @name toggle_stripes()
		 */
		toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
		/**
		 * shows the connecting dots (if the theme supports it)
		 * @name show_dots()
		 */
		show_dots : function () {
			this._data.core.themes.dots = true;
			this.get_container_ul().removeClass("jstree-no-dots");
			/**
			 * triggered when dots are shown
			 * @event
			 * @name show_dots.jstree
			 */
			this.trigger('show_dots');
		},
		/**
		 * hides the connecting dots
		 * @name hide_dots()
		 */
		hide_dots : function () {
			this._data.core.themes.dots = false;
			this.get_container_ul().addClass("jstree-no-dots");
			/**
			 * triggered when dots are hidden
			 * @event
			 * @name hide_dots.jstree
			 */
			this.trigger('hide_dots');
		},
		/**
		 * toggles the connecting dots
		 * @name toggle_dots()
		 */
		toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
		/**
		 * show the node icons
		 * @name show_icons()
		 */
		show_icons : function () {
			this._data.core.themes.icons = true;
			this.get_container_ul().removeClass("jstree-no-icons");
			/**
			 * triggered when icons are shown
			 * @event
			 * @name show_icons.jstree
			 */
			this.trigger('show_icons');
		},
		/**
		 * hide the node icons
		 * @name hide_icons()
		 */
		hide_icons : function () {
			this._data.core.themes.icons = false;
			this.get_container_ul().addClass("jstree-no-icons");
			/**
			 * triggered when icons are hidden
			 * @event
			 * @name hide_icons.jstree
			 */
			this.trigger('hide_icons');
		},
		/**
		 * toggle the node icons
		 * @name toggle_icons()
		 */
		toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
		/**
		 * show the node ellipsis
		 * @name show_icons()
		 */
		show_ellipsis : function () {
			this._data.core.themes.ellipsis = true;
			this.get_container_ul().addClass("jstree-ellipsis");
			/**
			 * triggered when ellisis is shown
			 * @event
			 * @name show_ellipsis.jstree
			 */
			this.trigger('show_ellipsis');
		},
		/**
		 * hide the node ellipsis
		 * @name hide_ellipsis()
		 */
		hide_ellipsis : function () {
			this._data.core.themes.ellipsis = false;
			this.get_container_ul().removeClass("jstree-ellipsis");
			/**
			 * triggered when ellisis is hidden
			 * @event
			 * @name hide_ellipsis.jstree
			 */
			this.trigger('hide_ellipsis');
		},
		/**
		 * toggle the node ellipsis
		 * @name toggle_icons()
		 */
		toggle_ellipsis : function () { if(this._data.core.themes.ellipsis) { this.hide_ellipsis(); } else { this.show_ellipsis(); } },
		/**
		 * set the node icon for a node
		 * @name set_icon(obj, icon)
		 * @param {mixed} obj
		 * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 */
		set_icon : function (obj, icon) {
			var t1, t2, dom, old;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_icon(obj[t1], icon);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			old = obj.icon;
			obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
			dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
			if(icon === false) {
				dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
				this.hide_icon(obj);
			}
			else if(icon === true || icon === null || icon === undefined || icon === '') {
				dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
				if(old === false) { this.show_icon(obj); }
			}
			else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
				dom.removeClass(old).css("background","");
				dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			else {
				dom.removeClass(old).css("background","");
				dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			return true;
		},
		/**
		 * get the node icon for a node
		 * @name get_icon(obj)
		 * @param {mixed} obj
		 * @return {String}
		 */
		get_icon : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === $.jstree.root) ? false : obj.icon;
		},
		/**
		 * hide the icon on an individual node
		 * @name hide_icon(obj)
		 * @param {mixed} obj
		 */
		hide_icon : function (obj) {
			var t1, t2;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === $.jstree.root) { return false; }
			obj.icon = false;
			this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
			return true;
		},
		/**
		 * show the icon on an individual node
		 * @name show_icon(obj)
		 * @param {mixed} obj
		 */
		show_icon : function (obj) {
			var t1, t2, dom;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === $.jstree.root) { return false; }
			dom = this.get_node(obj, true);
			obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
			if(!obj.icon) { obj.icon = true; }
			dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
			return true;
		}
	});

	// helpers
	$.vakata = {};

	$.vakata.search = function(pattern, txt, options) {
		options = options || {};
		if(options.fuzzy !== false) {
			options.fuzzy = true;
		}
		pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
		var MATCH_LOCATION	= options.location || 0,
			MATCH_DISTANCE	= options.distance || 100,
			MATCH_THRESHOLD	= options.threshold || 0.6,
			patternLen = pattern.length;
		if(patternLen > 32) {
			options.fuzzy = false;
		}
		if(options.fuzzy) {
			var matchmask = 1 << (patternLen - 1);
			var pattern_alphabet = (function () {
				var mask = {},
					i = 0;
				for (i = 0; i < patternLen; i++) {
					mask[pattern.charAt(i)] = 0;
				}
				for (i = 0; i < patternLen; i++) {
					mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
				}
				return mask;
			})();
			var match_bitapScore = function (e, x) {
				var accuracy = e / patternLen,
					proximity = Math.abs(MATCH_LOCATION - x);
				if(!MATCH_DISTANCE) {
					return proximity ? 1.0 : accuracy;
				}
				return accuracy + (proximity / MATCH_DISTANCE);
			};
		}
		var search = function (text) {
			text = options.caseSensitive ? text : text.toLowerCase();
			if(pattern === text || text.indexOf(pattern) !== -1) {
				return {
					isMatch: true,
					score: 0
				};
			}
			if(!options.fuzzy) {
				return {
					isMatch: false,
					score: 1
				};
			}
			var i, j,
				textLen = text.length,
				scoreThreshold = MATCH_THRESHOLD,
				bestLoc = text.indexOf(pattern, MATCH_LOCATION),
				binMin, binMid,
				binMax = patternLen + textLen,
				lastRd, start, finish, rd, charMatch,
				score = 1,
				locations = [];
			if (bestLoc != -1) {
				scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
				bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
				if (bestLoc != -1) {
					scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
				}
			}
			bestLoc = -1;
			for (i = 0; i < patternLen; i++) {
				binMin = 0;
				binMid = binMax;
				while (binMin < binMid) {
					if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
						binMin = binMid;
					} else {
						binMax = binMid;
					}
					binMid = Math.floor((binMax - binMin) / 2 + binMin);
				}
				binMax = binMid;
				start = Math.max(1, MATCH_LOCATION - binMid + 1);
				finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
				rd = Array(finish + 2);
				rd[finish + 1] = (1 << i) - 1;
				for (j = finish; j >= start; j--) {
					charMatch = pattern_alphabet[text.charAt(j - 1)];
					if (i === 0) {
						rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
					} else {
						rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
					}
					if (rd[j] & matchmask) {
						score = match_bitapScore(i, j - 1);
						if (score <= scoreThreshold) {
							scoreThreshold = score;
							bestLoc = j - 1;
							locations.push(bestLoc);
							if (bestLoc > MATCH_LOCATION) {
								start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
							} else {
								break;
							}
						}
					}
				}
				if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
					break;
				}
				lastRd = rd;
			}
			return {
				isMatch: bestLoc >= 0,
				score: score
			};
		};
		return txt === true ? { 'search' : search } : search(txt);
	};

	// collect attributes
	$.vakata.attributes = function(node, with_values) {
		node = $(node)[0];
		var attr = with_values ? {} : [];
		if(node && node.attributes) {
			langx.each(node.attributes, function (i, v) {
				if(langx.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
				if(v.value !== null && langx.trim(v.value) !== '') {
					if(with_values) { attr[v.name] = v.value; }
					else { attr.push(v.name); }
				}
			});
		}
		return attr;
	};
	$.vakata.array_unique = function(array) {
		var a = [], i, j, l, o = {};
		for(i = 0, l = array.length; i < l; i++) {
			if(o[array[i]] === undefined) {
				a.push(array[i]);
				o[array[i]] = true;
			}
		}
		return a;
	};
	// remove item from array
	$.vakata.array_remove = function(array, from) {
		array.splice(from, 1);
		return array;
		//var rest = array.slice((to || from) + 1 || array.length);
		//array.length = from < 0 ? array.length + from : from;
		//array.push.apply(array, rest);
		//return array;
	};
	// remove item from array
	$.vakata.array_remove_item = function(array, item) {
		var tmp = langx.inArray(item, array);
		return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
	};
	$.vakata.array_filter = function(c,a,b,d,e) {
		if (c.filter) {
			return c.filter(a, b);
		}
		d=[];
		for (e in c) {
			if (~~e+''===e+'' && e>=0 && a.call(b,c[e],+e,c)) {
				d.push(c[e]);
			}
		}
		return d;
	};


	return Tree;

});

define('skylark-widgets-hierarchy/addons/changed',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){
	"use strict";

	if($.jstree.plugins.changed) { return; }

	$.jstree.plugins.changed = function (options, parent) {
		var last = [];
		this.trigger = function (ev, data) {
			var i, j;
			if(!data) {
				data = {};
			}
			if(ev.replace('.jstree','') === 'changed') {
				data.changed = { selected : [], deselected : [] };
				var tmp = {};
				for(i = 0, j = last.length; i < j; i++) {
					tmp[last[i]] = 1;
				}
				for(i = 0, j = data.selected.length; i < j; i++) {
					if(!tmp[data.selected[i]]) {
						data.changed.selected.push(data.selected[i]);
					}
					else {
						tmp[data.selected[i]] = 2;
					}
				}
				for(i = 0, j = last.length; i < j; i++) {
					if(tmp[last[i]] === 1) {
						data.changed.deselected.push(last[i]);
					}
				}
				last = data.selected.slice();
			}
			/**
			 * triggered when selection changes (the "changed" plugin enhances the original event with more data)
			 * @event
			 * @name changed.jstree
			 * @param {Object} node
			 * @param {Object} action the action that caused the selection to change
			 * @param {Array} selected the current selection
			 * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event
			 * @param {Object} event the event (if any) that triggered this changed event
			 * @plugin changed
			 */
			parent.trigger.call(this, ev, data);
		};
		this.refresh = function (skip_loading, forget_state) {
			last = [];
			return parent.refresh.apply(this, arguments);
		};
	};

	return $;
});
define('skylark-widgets-hierarchy/addons/checkbox',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){
	"use strict";

	if($.jstree.plugins.checkbox) { return; }

	var _i = document.createElement('I');
	_i.className = 'jstree-icon jstree-checkbox';
	_i.setAttribute('role', 'presentation');
	/**
	 * stores all defaults for the checkbox plugin
	 * @name $.jstree.defaults.checkbox
	 * @plugin checkbox
	 */
	$.jstree.defaults.checkbox = {
		/**
		 * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.visible
		 * @plugin checkbox
		 */
		visible				: true,
		/**
		 * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.three_state
		 * @plugin checkbox
		 */
		three_state			: true,
		/**
		 * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.whole_node
		 * @plugin checkbox
		 */
		whole_node			: true,
		/**
		 * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.keep_selected_style
		 * @plugin checkbox
		 */
		keep_selected_style	: true,
		/**
		 * This setting controls how cascading and undetermined nodes are applied.
		 * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.
		 * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
		 * @name $.jstree.defaults.checkbox.cascade
		 * @plugin checkbox
		 */
		cascade				: '',
		/**
		 * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.
		 * @name $.jstree.defaults.checkbox.tie_selection
		 * @plugin checkbox
		 */
		tie_selection		: true,

		/**
		 * This setting controls if cascading down affects disabled checkboxes
		 * @name $.jstree.defaults.checkbox.cascade_to_disabled
		 * @plugin checkbox
		 */
		cascade_to_disabled : true,

		/**
		 * This setting controls if cascading down affects hidden checkboxes
		 * @name $.jstree.defaults.checkbox.cascade_to_hidden
		 * @plugin checkbox
		 */
		cascade_to_hidden : true
	};
	$.jstree.plugins.checkbox = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this._data.checkbox.uto = false;
			this._data.checkbox.selected = [];
			if(this.settings.checkbox.three_state) {
				this.settings.checkbox.cascade = 'up+down+undetermined';
			}
			this.element
				.on("init.jstree", langx.proxy(function () {
						this._data.checkbox.visible = this.settings.checkbox.visible;
						if(!this.settings.checkbox.keep_selected_style) {
							this.element.addClass('jstree-checkbox-no-clicked');
						}
						if(this.settings.checkbox.tie_selection) {
							this.element.addClass('jstree-checkbox-selection');
						}
					}, this))
				.on("loading.jstree", langx.proxy(function () {
						this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
					}, this));
			if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				this.element
					.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', langx.proxy(function () {
							// only if undetermined is in setting
							if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
							this._data.checkbox.uto = setTimeout(langx.proxy(this._undetermined, this), 50);
						}, this));
			}
			if(!this.settings.checkbox.tie_selection) {
				this.element
					.on('model.jstree', langx.proxy(function (e, data) {
						var m = this._model.data,
							p = m[data.parent],
							dpc = data.nodes,
							i, j;
						for(i = 0, j = dpc.length; i < j; i++) {
							m[dpc[i]].state.checked = m[dpc[i]].state.checked || (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
							if(m[dpc[i]].state.checked) {
								this._data.checkbox.selected.push(dpc[i]);
							}
						}
					}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
				this.element
					.on('model.jstree', langx.proxy(function (e, data) {
							var m = this._model.data,
								p = m[data.parent],
								dpc = data.nodes,
								chd = [],
								c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							if(s.indexOf('down') !== -1) {
								// apply down
								if(p.state[ t ? 'selected' : 'checked' ]) {
									for(i = 0, j = dpc.length; i < j; i++) {
										m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
									}

									this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
								}
								else {
									for(i = 0, j = dpc.length; i < j; i++) {
										if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
											for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
												m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
											}
											this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
										}
									}
								}
							}

							if(s.indexOf('up') !== -1) {
								// apply up
								for(i = 0, j = p.children_d.length; i < j; i++) {
									if(!m[p.children_d[i]].children.length) {
										chd.push(m[p.children_d[i]].parent);
									}
								}
								chd = $.vakata.array_unique(chd);
								for(k = 0, l = chd.length; k < l; k++) {
									p = m[chd[k]];
									while(p && p.id !== $.jstree.root) {
										c = 0;
										for(i = 0, j = p.children.length; i < j; i++) {
											c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(c === j) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										p = this.get_node(p.parent);
									}
								}
							}

							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', langx.proxy(function (e, data) {
							var self = this,
								obj = data.node,
								m = this._model.data,
								par = this.get_node(obj.parent),
								i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
								sel = {}, cur = this._data[ t ? 'core' : 'checkbox' ].selected;

							for (i = 0, j = cur.length; i < j; i++) {
								sel[cur[i]] = true;
							}

							// apply down
							if(s.indexOf('down') !== -1) {
								//this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
								var selectedIds = this._cascade_new_checked_state(obj.id, true);
								var temp = obj.children_d.concat(obj.id);
								for (i = 0, j = temp.length; i < j; i++) {
									if (selectedIds.indexOf(temp[i]) > -1) {
										sel[temp[i]] = true;
									}
									else {
										delete sel[temp[i]];
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								while(par && par.id !== $.jstree.root) {
									c = 0;
									for(i = 0, j = par.children.length; i < j; i++) {
										c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										par.state[ t ? 'selected' : 'checked' ] = true;
										sel[par.id] = true;
										//this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
										tmp = this.get_node(par, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									par = this.get_node(par.parent);
								}
							}

							cur = [];
							for (i in sel) {
								if (sel.hasOwnProperty(i)) {
									cur.push(i);
								}
							}
							this._data[ t ? 'core' : 'checkbox' ].selected = cur;
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', langx.proxy(function (e, data) {
							var obj = this.get_node($.jstree.root),
								m = this._model.data,
								i, j, tmp;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								tmp = m[obj.children_d[i]];
								if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
									tmp.original.state.undetermined = false;
								}
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', langx.proxy(function (e, data) {
							var self = this,
								obj = data.node,
								dom = this.get_node(obj, true),
								i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
								cur = this._data[ t ? 'core' : 'checkbox' ].selected, sel = {},
								stillSelectedIds = [],
								allIds = obj.children_d.concat(obj.id);

							// apply down
							if(s.indexOf('down') !== -1) {
								var selectedIds = this._cascade_new_checked_state(obj.id, false);

								cur = cur.filter(function(id) {
									return allIds.indexOf(id) === -1 || selectedIds.indexOf(id) > -1;
								});
							}

							// only apply up if cascade up is enabled and if this node is not selected
							// (if all child nodes are disabled and cascade_to_disabled === false then this node will till be selected).
							if(s.indexOf('up') !== -1 && cur.indexOf(obj.id) === -1) {
								for(i = 0, j = obj.parents.length; i < j; i++) {
									tmp = this._model.data[obj.parents[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
									tmp = this.get_node(obj.parents[i], true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}

								cur = cur.filter(function(id) {
									return obj.parents.indexOf(id) === -1;
								});
							}

							this._data[ t ? 'core' : 'checkbox' ].selected = cur;
						}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
				this.element
					.on('delete_node.jstree', langx.proxy(function (e, data) {
							// apply up (whole handler)
							var p = this.get_node(data.parent),
								m = this._model.data,
								i, j, c, tmp, t = this.settings.checkbox.tie_selection;
							while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(j > 0 && c === j) {
									p.state[ t ? 'selected' : 'checked' ] = true;
									this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
									tmp = this.get_node(p, true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
								else {
									break;
								}
								p = this.get_node(p.parent);
							}
						}, this))
					.on('move_node.jstree', langx.proxy(function (e, data) {
							// apply up (whole handler)
							var is_multi = data.is_multi,
								old_par = data.old_parent,
								new_par = this.get_node(data.parent),
								m = this._model.data,
								p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
							if(!is_multi) {
								p = this.get_node(old_par);
								while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(j > 0 && c === j) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									p = this.get_node(p.parent);
								}
							}
							p = new_par;
							while(p && p.id !== $.jstree.root) {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									if(!p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
								}
								else {
									if(p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = false;
										this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
								}
								p = this.get_node(p.parent);
							}
						}, this));
			}
		};
		/**
		 * get an array of all nodes whose state is "undetermined"
		 * @name get_undetermined([full])
		 * @param  {boolean} full: if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_undetermined = function (full) {
			if (this.settings.checkbox.cascade.indexOf('undetermined') === -1) {
				return [];
			}
			var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this, r = [];
			for(i = 0, j = s.length; i < j; i++) {
				if(m[s[i]] && m[s[i]].parents) {
					for(k = 0, l = m[s[i]].parents.length; k < l; k++) {
						if(o[m[s[i]].parents[k]] !== undefined) {
							break;
						}
						if(m[s[i]].parents[k] !== $.jstree.root) {
							o[m[s[i]].parents[k]] = true;
							p.push(m[s[i]].parents[k]);
						}
					}
				}
			}
			// attempt for server side undetermined state
			this.element.find('.jstree-closed').not(':has(.jstree-children)')
				.each(function () {
					var tmp = tt.get_node(this), tmp2;
					
					if(!tmp) { return; }
					
					if(!tmp.state.loaded) {
						if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
							if(o[tmp.id] === undefined && tmp.id !== $.jstree.root) {
								o[tmp.id] = true;
								p.push(tmp.id);
							}
							for(k = 0, l = tmp.parents.length; k < l; k++) {
								if(o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {
									o[tmp.parents[k]] = true;
									p.push(tmp.parents[k]);
								}
							}
						}
					}
					else {
						for(i = 0, j = tmp.children_d.length; i < j; i++) {
							tmp2 = m[tmp.children_d[i]];
							if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
								if(o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {
									o[tmp2.id] = true;
									p.push(tmp2.id);
								}
								for(k = 0, l = tmp2.parents.length; k < l; k++) {
									if(o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {
										o[tmp2.parents[k]] = true;
										p.push(tmp2.parents[k]);
									}
								}
							}
						}
					}
				});
			for (i = 0, j = p.length; i < j; i++) {
				if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
					r.push(full ? m[p[i]] : p[i]);
				}
			}
			return r;
		};
		/**
		 * set the undetermined state where and if necessary. Used internally.
		 * @private
		 * @name _undetermined()
		 * @plugin checkbox
		 */
		this._undetermined = function () {
			if(this.element === null) { return; }
			var p = this.get_undetermined(false), i, j, s;

			this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
			for (i = 0, j = p.length; i < j; i++) {
				s = this.get_node(p[i], true);
				if(s && s.length) {
					s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
				}
			}
		};
		this.redraw_node = function(obj, deep, is_callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var i, j, tmp = null, icon = null;
				for(i = 0, j = obj.childNodes.length; i < j; i++) {
					if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
						tmp = obj.childNodes[i];
						break;
					}
				}
				if(tmp) {
					if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
					icon = _i.cloneNode(false);
					if(this._model.data[obj.id].state.checkbox_disabled) { icon.className += ' jstree-checkbox-disabled'; }
					tmp.insertBefore(icon, tmp.childNodes[0]);
				}
			}
			if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
				this._data.checkbox.uto = setTimeout(langx.proxy(this._undetermined, this), 50);
			}
			return obj;
		};
		/**
		 * show the node checkbox icons
		 * @name show_checkboxes()
		 * @plugin checkbox
		 */
		this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
		/**
		 * hide the node checkbox icons
		 * @name hide_checkboxes()
		 * @plugin checkbox
		 */
		this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
		/**
		 * toggle the node icons
		 * @name toggle_checkboxes()
		 * @plugin checkbox
		 */
		this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
		/**
		 * checks if a node is in an undetermined state
		 * @name is_undetermined(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		this.is_undetermined = function (obj) {
			obj = this.get_node(obj);
			var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
			if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
				return false;
			}
			if(!obj.state.loaded && obj.original.state.undetermined === true) {
				return true;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				if(langx.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
					return true;
				}
			}
			return false;
		};
		/**
		 * disable a node's checkbox
		 * @name disable_checkbox(obj)
		 * @param {mixed} obj an array can be used too
		 * @trigger disable_checkbox.jstree
		 * @plugin checkbox
		 */
		this.disable_checkbox = function (obj) {
			var t1, t2, dom;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_checkbox(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checkbox_disabled) {
				obj.state.checkbox_disabled = true;
				if(dom && dom.length) {
					dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');
				}
				/**
				 * triggered when an node's checkbox is disabled
				 * @event
				 * @name disable_checkbox.jstree
				 * @param {Object} node
				 * @plugin checkbox
				 */
				this.trigger('disable_checkbox', { 'node' : obj });
			}
		};
		/**
		 * enable a node's checkbox
		 * @name disable_checkbox(obj)
		 * @param {mixed} obj an array can be used too
		 * @trigger enable_checkbox.jstree
		 * @plugin checkbox
		 */
		this.enable_checkbox = function (obj) {
			var t1, t2, dom;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_checkbox(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checkbox_disabled) {
				obj.state.checkbox_disabled = false;
				if(dom && dom.length) {
					dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');
				}
				/**
				 * triggered when an node's checkbox is enabled
				 * @event
				 * @name enable_checkbox.jstree
				 * @param {Object} node
				 * @plugin checkbox
				 */
				this.trigger('enable_checkbox', { 'node' : obj });
			}
		};

		this.activate_node = function (obj, e) {
			if($(e.target).hasClass('jstree-checkbox-disabled')) {
				return false;
			}
			if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
				e.ctrlKey = true;
			}
			if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
				return parent.activate_node.call(this, obj, e);
			}
			if(this.is_disabled(obj)) {
				return false;
			}
			if(this.is_checked(obj)) {
				this.uncheck_node(obj, e);
			}
			else {
				this.check_node(obj, e);
			}
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		};

		/**
		 * Cascades checked state to a node and all its descendants. This function does NOT affect hidden and disabled nodes (or their descendants).
		 * However if these unaffected nodes are already selected their ids will be included in the returned array.
		 * @private
		 * @param {string} id the node ID
		 * @param {bool} checkedState should the nodes be checked or not
		 * @returns {Array} Array of all node id's (in this tree branch) that are checked.
		 */
		this._cascade_new_checked_state = function (id, checkedState) {
			var self = this;
			var t = this.settings.checkbox.tie_selection;
			var node = this._model.data[id];
			var selectedNodeIds = [];
			var selectedChildrenIds = [], i, j, selectedChildIds;

			if (
				(this.settings.checkbox.cascade_to_disabled || !node.state.disabled) &&
				(this.settings.checkbox.cascade_to_hidden || !node.state.hidden)
			) {
				//First try and check/uncheck the children
				if (node.children) {
					for (i = 0, j = node.children.length; i < j; i++) {
						var childId = node.children[i];
						selectedChildIds = self._cascade_new_checked_state(childId, checkedState);
						selectedNodeIds = selectedNodeIds.concat(selectedChildIds);
						if (selectedChildIds.indexOf(childId) > -1) {
							selectedChildrenIds.push(childId);
						}
					}
				}

				var dom = self.get_node(node, true);

				//A node's state is undetermined if some but not all of it's children are checked/selected .
				var undetermined = selectedChildrenIds.length > 0 && selectedChildrenIds.length < node.children.length;

				if(node.original && node.original.state && node.original.state.undetermined) {
					node.original.state.undetermined = undetermined;
				}

				//If a node is undetermined then remove selected class
				if (undetermined) {
					node.state[ t ? 'selected' : 'checked' ] = false;
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
				}
				//Otherwise, if the checkedState === true (i.e. the node is being checked now) and all of the node's children are checked (if it has any children),
				//check the node and style it correctly.
				else if (checkedState && selectedChildrenIds.length === node.children.length) {
					node.state[ t ? 'selected' : 'checked' ] = checkedState;
					selectedNodeIds.push(node.id);

					dom.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
				}
				else {
					node.state[ t ? 'selected' : 'checked' ] = false;
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
				}
			}
			else {
				selectedChildIds = this.get_checked_descendants(id);

				if (node.state[ t ? 'selected' : 'checked' ]) {
					selectedChildIds.push(node.id);
				}

				selectedNodeIds = selectedNodeIds.concat(selectedChildIds);
			}

			return selectedNodeIds;
		};

		/**
		 * Gets ids of nodes selected in branch (of tree) specified by id (does not include the node specified by id)
		 * @name get_checked_descendants(obj)
		 * @param {string} id the node ID
		 * @return {Array} array of IDs
		 * @plugin checkbox
		 */
		this.get_checked_descendants = function (id) {
			var self = this;
			var t = self.settings.checkbox.tie_selection;
			var node = self._model.data[id];

			return node.children_d.filter(function(_id) {
				return self._model.data[_id].state[ t ? 'selected' : 'checked' ];
			});
		};

		/**
		 * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
		 * @name check_node(obj)
		 * @param {mixed} obj an array can be used to check multiple nodes
		 * @trigger check_node.jstree
		 * @plugin checkbox
		 */
		this.check_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
			var dom, t1, t2, th;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.check_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checked) {
				obj.state.checked = true;
				this._data.checkbox.selected.push(obj.id);
				if(dom && dom.length) {
					dom.children('.jstree-anchor').addClass('jstree-checked');
				}
				/**
				 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name check_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this check_node
				 * @plugin checkbox
				 */
				this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
		 * @name uncheck_node(obj)
		 * @param {mixed} obj an array can be used to uncheck multiple nodes
		 * @trigger uncheck_node.jstree
		 * @plugin checkbox
		 */
		this.uncheck_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
			var t1, t2, dom;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.uncheck_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checked) {
				obj.state.checked = false;
				this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
				if(dom.length) {
					dom.children('.jstree-anchor').removeClass('jstree-checked');
				}
				/**
				 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name uncheck_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this uncheck_node
				 * @plugin checkbox
				 */
				this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		
		/**
		 * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
		 * @name check_all()
		 * @trigger check_all.jstree, changed.jstree
		 * @plugin checkbox
		 */
		this.check_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.select_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name check_all.jstree
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
		};
		/**
		 * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
		 * @name uncheck_all()
		 * @trigger uncheck_all.jstree
		 * @plugin checkbox
		 */
		this.uncheck_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = false;
				}
			}
			this._data.checkbox.selected = [];
			this.element.find('.jstree-checked').removeClass('jstree-checked');
			/**
			 * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name uncheck_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
		};
		/**
		 * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
		 * @name is_checked(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 * @plugin checkbox
		 */
		this.is_checked = function (obj) {
			if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			return obj.state.checked;
		};
		/**
		 * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
		 * @name get_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
			return full ? langx.map(this._data.checkbox.selected, langx.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
		};
		/**
		 * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
		 * @name get_top_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_top_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
			var tmp = this.get_checked(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? langx.map(tmp, langx.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		};
		/**
		 * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
		 * @name get_bottom_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_bottom_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
			var tmp = this.get_checked(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? langx.map(obj, langx.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		};
		this.load_node = function (obj, callback) {
			var k, l, i, j, c, tmp;
			if(!langx.isArray(obj) && !this.settings.checkbox.tie_selection) {
				tmp = this.get_node(obj);
				if(tmp && tmp.state.loaded) {
					for(k = 0, l = tmp.children_d.length; k < l; k++) {
						if(this._model.data[tmp.children_d[k]].state.checked) {
							c = true;
							this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
						}
					}
				}
			}
			return parent.load_node.apply(this, arguments);
		};
		this.get_state = function () {
			var state = parent.get_state.apply(this, arguments);
			if(this.settings.checkbox.tie_selection) { return state; }
			state.checkbox = this._data.checkbox.selected.slice();
			return state;
		};
		this.set_state = function (state, callback) {
			var res = parent.set_state.apply(this, arguments);
			if(res && state.checkbox) {
				if(!this.settings.checkbox.tie_selection) {
					this.uncheck_all();
					var _this = this;
					langx.each(state.checkbox, function (i, v) {
						_this.check_node(v);
					});
				}
				delete state.checkbox;
				this.set_state(state, callback);
				return false;
			}
			return res;
		};
		this.refresh = function (skip_loading, forget_state) {
			if(!this.settings.checkbox.tie_selection) {
				this._data.checkbox.selected = [];
			}
			return parent.refresh.apply(this, arguments);
		};
	};

	// include the checkbox plugin by default
	// $.jstree.defaults.plugins.push("checkbox");

	return $;
});

define('skylark-widgets-hierarchy/addons/conditionalselect',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){
	"use strict";

	if($.jstree.plugins.conditionalselect) { return; }

	/**
	 * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.
	 * @name $.jstree.defaults.checkbox.visible
	 * @plugin checkbox
	 */
	$.jstree.defaults.conditionalselect = function () { return true; };
	$.jstree.plugins.conditionalselect = function (options, parent) {
		// own function
		this.activate_node = function (obj, e) {
			if(this.settings.conditionalselect.call(this, this.get_node(obj), e)) {
				return parent.activate_node.call(this, obj, e);
			}
		};
	};
	return $;
});
define('skylark-widgets-hierarchy/addons/menu',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query"
],function(langx,browser,eventer,noder,geom,$){

	var popup = null;
	var right_to_left ;

	var Menu = langx.Evented.inherit({
        klassName: "Menu",

        init : function(elm,options) {
        	if (!options) {
        		options = elm;
        		elm = null;
        	}
			var self = this,$el;

			this._options = langx.mixin({
					hide_onmouseleave	: 0,
					icons				: true

			},options);

			if (!elm) {
				$el = this.$el = $("<ul class='vakata-context'></ul>");
			} else {
				$el = this.$el = $(elm);
			}

			var to = false;
			$el.on("mouseenter", "li", function (e) {
					e.stopImmediatePropagation();

					if(noder.contains(this, e.relatedTarget)) {
						// премахнато заради delegate mouseleave по-долу
						// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
						return;
					}

					if(to) { clearTimeout(to); }
					$el.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

					$(this)
						.siblings().find("ul").hide().end().end()
						.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
					self._show_submenu(this);
				})
				// тестово - дали не натоварва?
				.on("mouseleave", "li", function (e) {
					if(noder.contains(this, e.relatedTarget)) { return; }
					$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
				})
				.on("mouseleave", function (e) {
					$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
					if(self._options.hide_onmouseleave) {
						to = setTimeout(
							(function (t) {
								return function () { self.hide(); };
							}(this)), self._options.hide_onmouseleave);
					}
				})
				.on("click", "a", function (e) {
					e.preventDefault();
				//})
				//.on("mouseup", "a", function (e) {
					if(!$(this).blur().parent().hasClass("vakata-context-disabled") && self._execute($(this).attr("rel")) !== false) {
						self.hide();
					}
				})
				.on('keydown', 'a', function (e) {
						var o = null;
						switch(e.which) {
							case 13:
							case 32:
								e.type = "click";
								e.preventDefault();
								$(e.currentTarget).trigger(e);
								break;
							case 37:
								self.$el.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
								e.stopImmediatePropagation();
								e.preventDefault();
								break;
							case 38:
								o = self.$el.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
								if(!o.length) { o = self.$el.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
								o.addClass("vakata-context-hover").children('a').focus();
								e.stopImmediatePropagation();
								e.preventDefault();
								break;
							case 39:
								self.$el.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
								e.stopImmediatePropagation();
								e.preventDefault();
								break;
							case 40:
								o = self.$el.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
								if(!o.length) { o = self.$el.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
								o.addClass("vakata-context-hover").children('a').focus();
								e.stopImmediatePropagation();
								e.preventDefault();
								break;
							case 27:
								self.hide();
								e.preventDefault();
								break;
							default:
								//console.log(e.which);
								break;
						}
					})
				.on('keydown', function (e) {
					e.preventDefault();
					var a = self.$el.find('.vakata-contextmenu-shortcut-' + e.which).parent();
					if(a.parent().not('.vakata-context-disabled')) {
						a.click();
					}
				});

			this.render();
        },

        render : function() {
        	var items = this._options.items;
			if(this._parse(items)) {
				this.$el.html(this.html);
			}
			this.$el.width('');
        },

		_trigger : function (event_name) {
			$(document).trigger("context_" + event_name + ".sbswt", {
				"reference"	: this.reference,
				"element"	: this.$el,
				"position"	: {
					"x" : this.position_x,
					"y" : this.position_y
				}
			});
		},        

		_execute : function (i) {
			i = this.items[i];
			return i && (!i._disabled || (langx.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : this.reference, "element" : this.$el }))) && i.action ? i.action.call(null, {
						"item"		: i,
						"reference"	: this.reference,
						"element"	: this.$el,
						"position"	: {
							"x" : this.position_x,
							"y" : this.position_y
						}
					}) : false;
		},
		_parse : function (o, is_callback) {
			var self = this,
				reference = self._options.reference;

			if(!o) { return false; }
			if(!is_callback) {
				self.html		= "";
				self.items	= [];
			}
			var str = "",
				sep = false,
				tmp;

			if(is_callback) { str += "<"+"ul>"; }
			langx.each(o, function (i, val) {
				if(!val) { return true; }
				self.items.push(val);
				if(!sep && val.separator_before) {
					str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + (self._options.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
				}
				sep = false;
				str += "<"+"li class='" + (val._class || "") + (val._disabled === true || (langx.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : reference, "element" : self.$el })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
				str += "<"+"a href='#' rel='" + (self.items.length - 1) + "' " + (val.title ? "title='" + val.title + "'" : "") + ">";
				if(self._options.icons) {
					str += "<"+"i ";
					if(val.icon) {
						if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
						else { str += " class='" + val.icon + "' "; }
					}
					str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
				}
				str += (langx.isFunction(val.label) ? val.label({ "item" : i, "reference" : reference, "element" : self.$el }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
				if(val.submenu) {
					tmp = self._parse(val.submenu, true);
					if(tmp) { str += tmp; }
				}
				str += "<"+"/li>";
				if(val.separator_after) {
					str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + (self._options.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
					sep = true;
				}
			});
			str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
			if(is_callback) { str += "</ul>"; }
			/**
			 * triggered on the document when the contextmenu is parsed (HTML is built)
			 * @event
			 * @plugin contextmenu
			 * @name context_parse.vakata
			 * @param {jQuery} reference the element that was right clicked
			 * @param {jQuery} element the DOM element of the menu itself
			 * @param {Object} position the x & y coordinates of the menu
			 */
			if(!is_callback) { self.html = str; self._trigger("parse"); }
			return str.length > 10 ? str : false;
		},
		_show_submenu : function (o) {
			o = $(o);
			if(!o.length || !o.children("ul").length) { return; }
			var e = o.children("ul"),
				xl = o.offset().left,
				x = xl + o.outerWidth(),
				y = o.offset().top,
				w = e.width(),
				h = e.height(),
				dw = $(window).width() + $(window).scrollLeft(),
				dh = $(window).height() + $(window).scrollTop();
			// може да се спести е една проверка - дали няма някой от класовете вече нагоре
			if(right_to_left) {
				o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
			}
			else {
				o[x + w > dw  && xl > dw - x ? "addClass" : "removeClass"]("vakata-context-right");
			}
			if(y + h + 10 > dh) {
				e.css("bottom","-1px");
			}

			//if does not fit - stick it to the side
			if (o.hasClass('vakata-context-right')) {
				if (xl < w) {
					e.css("margin-right", xl - w);
				}
			} else {
				if (dw - x < w) {
					e.css("margin-left", dw - x - w);
				}
			}

			e.show();
		},
		show : function (reference, position, data) {
			var o, e, x, y, w, h, dw, dh, cond = true;
			switch(cond) {
				case (!position && !reference):
					return false;
				case (!!position && !!reference):
					this.reference	= reference;
					this.position_x	= position.x;
					this.position_y	= position.y;
					break;
				case (!position && !!reference):
					this.reference	= reference;
					o = reference.offset();
					this.position_x	= o.left + reference.outerHeight();
					this.position_y	= o.top;
					break;
				case (!!position && !reference):
					this.position_x	= position.x;
					this.position_y	= position.y;
					break;
			}
			if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
				data = $(reference).data('vakata_contextmenu');
			}

			if(this.items.length) {
				this.$el.appendTo(document.body);
				e = this.$el;
				x = this.position_x;
				y = this.position_y;
				w = e.width();
				h = e.height();
				dw = $(window).width() + $(window).scrollLeft();
				dh = $(window).height() + $(window).scrollTop();
				if(right_to_left) {
					x -= (e.outerWidth() - $(reference).outerWidth());
					if(x < $(window).scrollLeft() + 20) {
						x = $(window).scrollLeft() + 20;
					}
				}
				if(x + w + 20 > dw) {
					x = dw - (w + 20);
				}
				if(y + h + 20 > dh) {
					y = dh - (h + 20);
				}

				this.$el
					.css({ "left" : x, "top" : y })
					.show()
					.find('a').first().focus().parent().addClass("vakata-context-hover");
				this.is_visible = true;

				popup = this;

				/**
				 * triggered on the document when the contextmenu is shown
				 * @event
				 * @plugin contextmenu
				 * @name context_show.vakata
				 * @param {jQuery} reference the element that was right clicked
				 * @param {jQuery} element the DOM element of the menu itself
				 * @param {Object} position the x & y coordinates of the menu
				 */
				this._trigger("show");
			}
		},
		hide : function () {
			if(this.is_visible) {
				this.$el.hide().find("ul").hide().end().find(':focus').blur().end().detach();
				this.is_visible = false;
				popup = null;
				/**
				 * triggered on the document when the contextmenu is hidden
				 * @event
				 * @plugin contextmenu
				 * @name context_hide.vakata
				 * @param {jQuery} reference the element that was right clicked
				 * @param {jQuery} element the DOM element of the menu itself
				 * @param {Object} position the x & y coordinates of the menu
				 */
				this._trigger("hide");
			}
		}

    });	

	$(function () {
		right_to_left = $(document.body).css("direction") === "rtl";

		$(document)
			.on("mousedown.sbswt.popup", function (e) {
				if(popup && popup.$el[0] !== e.target  && !noder.contains(popup.$el[0], e.target)) {
					popup.hide();
				}
			})
			.on("context_show.sbswt.popup", function (e, data) {
				popup.$el.find("li:has(ul)").children("a").addClass("vakata-context-parent");
				if(right_to_left) {
					popup.$el.addClass("vakata-context-rtl").css("direction", "rtl");
				}
				// also apply a RTL class?
				popup.$el.find("ul").hide().end();
			});
	});

	Menu.popup = function (reference, position, data) {
		var m = new Menu({
			reference : reference,
			items : data
		});
		m.show(reference,position);
	};

	Menu.hide = function() {
		if (popup) {
			popup.hide();
		}
	}

	return Menu;

});
define('skylark-widgets-hierarchy/addons/contextmenu',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./menu",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$, menu,jstree){

	"use strict";

	if($.jstree.plugins.contextmenu) { return; }

	/**
	 * stores all defaults for the contextmenu plugin
	 * @name $.jstree.defaults.contextmenu
	 * @plugin contextmenu
	 */
	$.jstree.defaults.contextmenu = {
		/**
		 * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
		 * @name $.jstree.defaults.contextmenu.select_node
		 * @plugin contextmenu
		 */
		select_node : true,
		/**
		 * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
		 * @name $.jstree.defaults.contextmenu.show_at_node
		 * @plugin contextmenu
		 */
		show_at_node : true,
		/**
		 * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
		 *
		 * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.
		 *
		 * * `separator_before` - a boolean indicating if there should be a separator before this item
		 * * `separator_after` - a boolean indicating if there should be a separator after this item
		 * * `_disabled` - a boolean indicating if this action should be disabled
		 * * `label` - a string - the name of the action (could be a function returning a string)
		 * * `title` - a string - an optional tooltip for the item
		 * * `action` - a function to be executed if this item is chosen, the function will receive 
		 * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
		 * * `shortcut_label` - shortcut label (like for example `F2` for rename)
		 * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered
		 *
		 * @name $.jstree.defaults.contextmenu.items
		 * @plugin contextmenu
		 */
		items : function (o, cb) { // Could be an object directly
			return {
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
					"label"				: "Create",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.create_node(obj, {}, "last", function (new_node) {
							try {
								inst.edit(new_node);
							} catch (ex) {
								setTimeout(function () { inst.edit(new_node); },0);
							}
						});
					}
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Rename",
					/*!
					"shortcut"			: 113,
					"shortcut_label"	: 'F2',
					"icon"				: "glyphicon glyphicon-leaf",
					*/
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.edit(obj);
					}
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Delete",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						if(inst.is_selected(obj)) {
							inst.delete_node(inst.get_selected());
						}
						else {
							inst.delete_node(obj);
						}
					}
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : {
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.cut(inst.get_top_selected());
								}
								else {
									inst.cut(obj);
								}
							}
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.copy(inst.get_top_selected());
								}
								else {
									inst.copy(obj);
								}
							}
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"_disabled"			: function (data) {
								return !$.jstree.reference(data.reference).can_paste();
							},
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								inst.paste(obj);
							}
						}
					}
				}
			};
		}
	};

	$.jstree.plugins.contextmenu = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			var last_ts = 0, cto = null, ex, ey;
			this.element
				.on("init.jstree loading.jstree ready.jstree", langx.proxy(function () {
						this.get_container_ul().addClass('jstree-contextmenu');
					}, this))
				.on("contextmenu.jstree", ".jstree-anchor", langx.proxy(function (e, data) {
						if (e.target.tagName.toLowerCase() === 'input') {
							return;
						}
						e.preventDefault();
						last_ts = e.ctrlKey ? +new Date() : 0;
						if(data || cto) {
							last_ts = (+new Date()) + 10000;
						}
						if(cto) {
							clearTimeout(cto);
						}
						if(!this.is_loading(e.currentTarget)) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", langx.proxy(function (e) {
						if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
							menu.hide();
						}
						last_ts = 0;
					}, this))
				.on("touchstart.jstree", ".jstree-anchor", function (e) {
						if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
							return;
						}
						ex = e.originalEvent.changedTouches[0].clientX;
						ey = e.originalEvent.changedTouches[0].clientY;
						cto = setTimeout(function () {
							$(e.currentTarget).trigger('contextmenu', true);
						}, 750);
					})
				.on('touchmove.vakata.jstree', function (e) {
						if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 10 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 10)) {
							clearTimeout(cto);
							menu.hide();
						}
					})
				.on('touchend.vakata.jstree', function (e) {
						if(cto) {
							clearTimeout(cto);
						}
					});

			/*!
			if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
				var el = null, tm = null;
				this.element
					.on("touchstart", ".jstree-anchor", function (e) {
						el = e.currentTarget;
						tm = +new Date();
						$(document).one("touchend", function (e) {
							e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
							e.currentTarget = e.target;
							tm = ((+(new Date())) - tm);
							if(e.target === el && tm > 600 && tm < 1000) {
								e.preventDefault();
								$(el).trigger('contextmenu', e);
							}
							el = null;
							tm = null;
						});
					});
			}
			*/
			$(document).on("context_hide.sbswt.popup", langx.proxy(function (e, data) {
				this._data.contextmenu.visible = false;
				$(data.reference).removeClass('jstree-context');
			}, this));
		};
		this.teardown = function () {
			if(this._data.contextmenu.visible) {
				menu.hide();
			}
			parent.teardown.call(this);
		};

		/**
		 * prepare and show the context menu for a node
		 * @name show_contextmenu(obj [, x, y])
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Object} e the event if available that triggered the contextmenu
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 */
		this.show_contextmenu = function (obj, x, y, e) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			var s = this.settings.contextmenu,
				d = this.get_node(obj, true),
				a = d.children(".jstree-anchor"),
				o = false,
				i = false;
			if(s.show_at_node || x === undefined || y === undefined) {
				o = a.offset();
				x = o.left;
				y = o.top + this._data.core.li_height;
			}
			if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
				this.activate_node(obj, e);
			}

			i = s.items;
			if(langx.isFunction(i)) {
				i = i.call(this, obj, langx.proxy(function (i) {
					this._show_contextmenu(obj, x, y, i);
				}, this));
			}
			if(langx.isPlainObject(i)) {
				this._show_contextmenu(obj, x, y, i);
			}
		};
		/**
		 * show the prepared context menu for a node
		 * @name _show_contextmenu(obj, x, y, i)
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Number} i the object of items to show
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 * @private
		 */
		this._show_contextmenu = function (obj, x, y, i) {
			var d = this.get_node(obj, true),
				a = d.children(".jstree-anchor");
			$(document).one("context_show.sbswt.popup", langx.proxy(function (e, data) {
				var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
				$(data.element).addClass(cls);
				a.addClass('jstree-context');
			}, this));
			this._data.contextmenu.visible = true;
			menu.popup(a, { 'x' : x, 'y' : y }, i);
			/**
			 * triggered when the contextmenu is shown for a node
			 * @event
			 * @name show_contextmenu.jstree
			 * @param {Object} node the node
			 * @param {Number} x the x-coordinate of the menu relative to the document
			 * @param {Number} y the y-coordinate of the menu relative to the document
			 * @plugin contextmenu
			 */
			this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
		};
	};

	// $.jstree.defaults.plugins.push("contextmenu");

	return $;
	
});

define('skylark-widgets-hierarchy/addons/dnd',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){

	"use strict";

	if($.jstree.plugins.dnd) { return; }

	/**
	 * stores all defaults for the drag'n'drop plugin
	 * @name $.jstree.defaults.dnd
	 * @plugin dnd
	 */
	$.jstree.defaults.dnd = {
		/**
		 * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
		 * @name $.jstree.defaults.dnd.copy
		 * @plugin dnd
		 */
		copy : true,
		/**
		 * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
		 * @name $.jstree.defaults.dnd.open_timeout
		 * @plugin dnd
		 */
		open_timeout : 500,
		/**
		 * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging
		 * @name $.jstree.defaults.dnd.is_draggable
		 * @plugin dnd
		 */
		is_draggable : true,
		/**
		 * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
		 * @name $.jstree.defaults.dnd.check_while_dragging
		 * @plugin dnd
		 */
		check_while_dragging : true,
		/**
		 * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
		 * @name $.jstree.defaults.dnd.always_copy
		 * @plugin dnd
		 */
		always_copy : false,
		/**
		 * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
		 * @name $.jstree.defaults.dnd.inside_pos
		 * @plugin dnd
		 */
		inside_pos : 0,
		/**
		 * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
		 * @name $.jstree.defaults.dnd.drag_selection
		 * @plugin dnd
		 */
		drag_selection : true,
		/**
		 * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
		 * @name $.jstree.defaults.dnd.touch
		 * @plugin dnd
		 */
		touch : true,
		/**
		 * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.
		 * @name $.jstree.defaults.dnd.large_drop_target
		 * @plugin dnd
		 */
		large_drop_target : false,
		/**
		 * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to "selected".
		 * @name $.jstree.defaults.dnd.large_drag_target
		 * @plugin dnd
		 */
		large_drag_target : false,
		/**
		 * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.
		 * @reference http://caniuse.com/#feat=dragndrop
		 * @name $.jstree.defaults.dnd.use_html5
		 * @plugin dnd
		 */
		use_html5: false
	};
	var drg, elm;
	// TODO: now check works by checking for each node individually, how about max_children, unique, etc?
	$.jstree.plugins.dnd = function (options, parent) {
		this.init = function (el, options) {
			parent.init.call(this, el, options);
			this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && ('draggable' in document.createElement('span'));
		};
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', langx.proxy(function (e) {
						if(this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
							return true;
						}
						if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
							return true;
						}
						var obj = this.get_node(e.target),
							mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
							txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
						if(this.settings.core.force_text) {
							txt = $.vakata.html.escape(txt);
						}
						if(obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === "touchstart" || e.type === "dragstart") &&
							(this.settings.dnd.is_draggable === true || (langx.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]), e)))
						) {
							drg = { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_top_selected() : [obj.id] };
							elm = e.currentTarget;
							if (this.settings.dnd.use_html5) {
								$.vakata.dnd._trigger('start', e, { 'helper': $(), 'element': elm, 'data': drg });
							} else {
								this.element.trigger('mousedown.jstree');
								return $.vakata.dnd.start(e, drg, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
							}
						}
					}, this));
			if (this.settings.dnd.use_html5) {
				this.element
					.on('dragover.jstree', function (e) {
							e.preventDefault();
							$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
							return false;
						})
					//.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
					//		e.preventDefault();
					//		$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
					//		return false;
					//	}, this))
					.on('drop.jstree', langx.proxy(function (e) {
							e.preventDefault();
							$.vakata.dnd._trigger('stop', e, { 'helper': $(), 'element': elm, 'data': drg });
							return false;
						}, this));
			}
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if (obj && this.settings.dnd.use_html5) {
				if (this.settings.dnd.large_drag_target) {
					obj.setAttribute('draggable', true);
				} else {
					var i, j, tmp = null;
					for(i = 0, j = obj.childNodes.length; i < j; i++) {
						if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
							tmp = obj.childNodes[i];
							break;
						}
					}
					if(tmp) {
						tmp.setAttribute('draggable', true);
					}
				}
			}
			return obj;
		};
	};

	$(function() {
		// bind only once for all instances
		var lastmv = false,
			laster = false,
			lastev = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');

		$(document)
			.on('dnd_start.vakata.jstree', function (e, data) {
				lastmv = false;
				lastev = false;
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.appendTo(document.body); //.show();
			})
			.on('dnd_move.vakata.jstree', function (e, data) {
				var isDifferentNode = data.event.target !== lastev.target;
				if(opento) {
					if (!data.event || data.event.type !== 'dragover' || isDifferentNode) {
						clearTimeout(opento);
					}
				}
				if(!data || !data.data || !data.data.jstree) { return; }

				// if we are hovering the marker image do nothing (can happen on "inside" drags)
				if(data.event.target.id && data.event.target.id === 'jstree-marker') {
					return;
				}
				lastev = data.event;

				var ins = $.jstree.reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm, is_copy, pn;
				// if we are over an instance
				if(ins && ins._data && ins._data.dnd) {
					marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
					is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)));
					data.helper
						.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
						.find('.jstree-copy').first()[ is_copy ? 'show' : 'hide' ]();

					// if are hovering the container itself add a new root node
					//console.log(data.event);
					if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
						ok = true;
						for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
							ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), $.jstree.root, 'last', { 'dnd' : true, 'ref' : ins.get_node($.jstree.root), 'pos' : 'i', 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
							if(!ok) { break; }
						}
						if(ok) {
							lastmv = { 'ins' : ins, 'par' : $.jstree.root, 'pos' : 'last' };
							marker.hide();
							data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
							if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
								data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
							}
							return;
						}
					}
					else {
						// if we are hovering a tree node
						ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
						if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
							off = ref.offset();
							rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;
							h = ref.outerHeight();
							if(rel < h / 3) {
								o = ['b', 'i', 'a'];
							}
							else if(rel > h - h / 3) {
								o = ['a', 'i', 'b'];
							}
							else {
								o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
							}
							langx.each(o, function (j, v) {
								switch(v) {
									case 'b':
										l = off.left - 6;
										t = off.top;
										p = ins.get_parent(ref);
										i = ref.parent().index();
										break;
									case 'i':
										ip = ins.settings.dnd.inside_pos;
										tm = ins.get_node(ref.parent());
										l = off.left - 2;
										t = off.top + h / 2 + 1;
										p = tm.id;
										i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
										break;
									case 'a':
										l = off.left - 6;
										t = off.top + h;
										p = ins.get_parent(ref);
										i = ref.parent().index() + 1;
										break;
								}
								ok = true;
								for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
									op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
									ps = i;
									if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
										pr = ins.get_node(p);
										if(ps > langx.inArray(data.data.nodes[t1], pr.children)) {
											ps -= 1;
										}
									}
									ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
									if(!ok) {
										if(ins && ins.last_error) { laster = ins.last_error(); }
										break;
									}
								}
								if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
									if (!data.event || data.event.type !== 'dragover' || isDifferentNode) {
										if (opento) { clearTimeout(opento); }
										opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
									}
								}
								if(ok) {
									pn = ins.get_node(p, true);
									if (!pn.hasClass('.jstree-dnd-parent')) {
										$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
										pn.addClass('jstree-dnd-parent');
									}
									lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
									marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
									data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
									if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
										data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
									}
									laster = {};
									o = true;
									return false;
								}
							});
							if(o === true) { return; }
						}
					}
				}
				$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
				lastmv = false;
				data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
				if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
					data.event.originalEvent.dataTransfer.dropEffect = 'none';
				}
				marker.hide();
			})
			.on('dnd_scroll.vakata.jstree', function (e, data) {
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide();
				lastmv = false;
				lastev = false;
				data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
			})
			.on('dnd_stop.vakata.jstree', function (e, data) {
				$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide().detach();
				var i, j, nodes = [];
				if(lastmv) {
					for(i = 0, j = data.data.nodes.length; i < j; i++) {
						nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
					}
					lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
				}
				else {
					i = $(data.event.target).closest('.jstree');
					if(i.length && laster && laster.error && laster.error === 'check') {
						i = i.jstree(true);
						if(i) {
							i.settings.core.error.call(this, laster);
						}
					}
				}
				lastev = false;
				lastmv = false;
			})
			.on('keyup.jstree keydown.jstree', function (e, data) {
				data = $.vakata.dnd._get();
				if(data && data.data && data.data.jstree) {
					if (e.type === "keyup" && e.which === 27) {
						if (opento) { clearTimeout(opento); }
						lastmv = false;
						laster = false;
						lastev = false;
						opento = false;
						marker.hide().detach();
						$.vakata.dnd._clean();
					} else {
						data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
						if(lastev) {
							lastev.metaKey = e.metaKey;
							lastev.ctrlKey = e.ctrlKey;
							$.vakata.dnd._trigger('move', lastev);
						}
					}
				}
			});
	});

	// helpers
	(function ($) {
		$.vakata.html = {
			div : $('<div />'),
			escape : function (str) {
				return $.vakata.html.div.text(str).html();
			},
			strip : function (str) {
				return $.vakata.html.div.empty().append(langx.parseHTML(str)).text();
			}
		};
		// private variable
		var vakata_dnd = {
			element	: false,
			target	: false,
			is_down	: false,
			is_drag	: false,
			helper	: false,
			helper_w: 0,
			data	: false,
			init_x	: 0,
			init_y	: 0,
			scroll_l: 0,
			scroll_t: 0,
			scroll_e: false,
			scroll_i: false,
			is_touch: false
		};
		$.vakata.dnd = {
			settings : {
				scroll_speed		: 10,
				scroll_proximity	: 20,
				helper_left			: 5,
				helper_top			: 10,
				threshold			: 5,
				threshold_touch		: 10
			},
			_trigger : function (event_name, e, data) {
				if (data === undefined) {
					data = $.vakata.dnd._get();
				}
				data.event = e;
				$(document).trigger("dnd_" + event_name + ".vakata", data);
			},
			_get : function () {
				return {
					"data"		: vakata_dnd.data,
					"element"	: vakata_dnd.element,
					"helper"	: vakata_dnd.helper
				};
			},
			_clean : function () {
				if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
				if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
				vakata_dnd = {
					element	: false,
					target	: false,
					is_down	: false,
					is_drag	: false,
					helper	: false,
					helper_w: 0,
					data	: false,
					init_x	: 0,
					init_y	: 0,
					scroll_l: 0,
					scroll_t: 0,
					scroll_e: false,
					scroll_i: false,
					is_touch: false
				};
				$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
			},
			_scroll : function (init_only) {
				if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
					if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
					return false;
				}
				if(!vakata_dnd.scroll_i) {
					vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
					return false;
				}
				if(init_only === true) { return false; }

				var i = vakata_dnd.scroll_e.scrollTop(),
					j = vakata_dnd.scroll_e.scrollLeft();
				vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
				vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
				if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
					/**
					 * triggered on the document when a drag causes an element to scroll
					 * @event
					 * @plugin dnd
					 * @name dnd_scroll.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {jQuery} event the element that is scrolling
					 */
					$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
				}
			},
			start : function (e, data, html) {
				if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
				try {
					e.currentTarget.unselectable = "on";
					e.currentTarget.onselectstart = function() { return false; };
					if(e.currentTarget.style) {
						e.currentTarget.style.touchAction = "none";
						e.currentTarget.style.msTouchAction = "none";
						e.currentTarget.style.MozUserSelect = "none";
					}
				} catch(ignore) { }
				vakata_dnd.init_x	= e.pageX;
				vakata_dnd.init_y	= e.pageY;
				vakata_dnd.data		= data;
				vakata_dnd.is_down	= true;
				vakata_dnd.element	= e.currentTarget;
				vakata_dnd.target	= e.target;
				vakata_dnd.is_touch	= e.type === "touchstart";
				if(html !== false) {
					vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
						"display"		: "block",
						"margin"		: "0",
						"padding"		: "0",
						"position"		: "absolute",
						"top"			: "-2000px",
						"lineHeight"	: "16px",
						"zIndex"		: "10000"
					});
				}
				$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
				return false;
			},
			drag : function (e) {
				if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(!vakata_dnd.is_down) { return; }
				if(!vakata_dnd.is_drag) {
					if(
						Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
						Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
					) {
						if(vakata_dnd.helper) {
							vakata_dnd.helper.appendTo(document.body);
							vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
						}
						vakata_dnd.is_drag = true;
						$(vakata_dnd.target).one('click.vakata', false);
						/**
						 * triggered on the document when a drag starts
						 * @event
						 * @plugin dnd
						 * @name dnd_start.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {Object} event the event that caused the start (probably mousemove)
						 */
						$.vakata.dnd._trigger("start", e);
					}
					else { return; }
				}

				var d  = false, w  = false,
					dh = false, wh = false,
					dw = false, ww = false,
					dt = false, dl = false,
					ht = false, hl = false;

				vakata_dnd.scroll_t = 0;
				vakata_dnd.scroll_l = 0;
				vakata_dnd.scroll_e = false;
				$($(e.target).parentsUntil("body").addBack().get().reverse())
					.filter(function () {
						return	(/^auto|scroll$/).test($(this).css("overflow")) &&
								(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
					})
					.each(function () {
						var t = $(this), o = t.offset();
						if(this.scrollHeight > this.offsetHeight) {
							if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
							if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
						}
						if(this.scrollWidth > this.offsetWidth) {
							if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
							if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
						}
						if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
							vakata_dnd.scroll_e = $(this);
							return false;
						}
					});

				if(!vakata_dnd.scroll_e) {
					d  = $(document); w = $(window);
					dh = d.height(); wh = w.height();
					dw = d.width(); ww = w.width();
					dt = d.scrollTop(); dl = d.scrollLeft();
					if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
					if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
					if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
					if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
					if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
						vakata_dnd.scroll_e = d;
					}
				}
				if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

				if(vakata_dnd.helper) {
					ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
					hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
					if(dh && ht + 25 > dh) { ht = dh - 50; }
					if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
					vakata_dnd.helper.css({
						left	: hl + "px",
						top		: ht + "px"
					});
				}
				/**
				 * triggered on the document when a drag is in progress
				 * @event
				 * @plugin dnd
				 * @name dnd_move.vakata
				 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
				 * @param {DOM} element the DOM element being dragged
				 * @param {jQuery} helper the helper shown next to the mouse
				 * @param {Object} event the event that caused this to trigger (most likely mousemove)
				 */
				$.vakata.dnd._trigger("move", e);
				return false;
			},
			stop : function (e) {
				if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) {
					/**
					 * triggered on the document when a drag stops (the dragged element is dropped)
					 * @event
					 * @plugin dnd
					 * @name dnd_stop.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {Object} event the event that caused the stop
					 */
					if (e.target !== vakata_dnd.target) {
						$(vakata_dnd.target).off('click.vakata');
					}
					$.vakata.dnd._trigger("stop", e);
				}
				else {
					if(e.type === "touchend" && e.target === vakata_dnd.target) {
						var to = setTimeout(function () { $(e.target).click(); }, 100);
						$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
					}
				}
				$.vakata.dnd._clean();
				return false;
			}
		};
	}($));

	// include the dnd plugin by default
	// $.jstree.defaults.plugins.push("dnd");

	return $;
	
});

define('skylark-widgets-hierarchy/addons/massload',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){

	"use strict";

	if($.jstree.plugins.massload) { return; }

	/**
	 * massload configuration
	 *
	 * It is possible to set this to a standard jQuery-like AJAX config.
	 * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.
	 *
	 * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.
	 *
	 * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.
	 *
	 *	{
	 *		"id1" : [{ "text" : "Child of ID1", "id" : "c1" }, { "text" : "Another child of ID1", "id" : "c2" }],
	 *		"id2" : [{ "text" : "Child of ID2", "id" : "c3" }]
	 *	}
	 * 
	 * @name $.jstree.defaults.massload
	 * @plugin massload
	 */
	$.jstree.defaults.massload = null;
	$.jstree.plugins.massload = function (options, parent) {
		this.init = function (el, options) {
			this._data.massload = {};
			parent.init.call(this, el, options);
		};
		this._load_nodes = function (nodes, callback, is_callback, force_reload) {
			var s = this.settings.massload,
				nodesString = JSON.stringify(nodes),
				toLoad = [],
				m = this._model.data,
				i, j, dom;
			if (!is_callback) {
				for(i = 0, j = nodes.length; i < j; i++) {
					if(!m[nodes[i]] || ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || force_reload) ) {
						toLoad.push(nodes[i]);
						dom = this.get_node(nodes[i], true);
						if (dom && dom.length) {
							dom.addClass("jstree-loading").attr('aria-busy',true);
						}
					}
				}
				this._data.massload = {};
				if (toLoad.length) {
					if(langx.isFunction(s)) {
						return s.call(this, toLoad, langx.proxy(function (data) {
							var i, j;
							if(data) {
								for(i in data) {
									if(data.hasOwnProperty(i)) {
										this._data.massload[i] = data[i];
									}
								}
							}
							for(i = 0, j = nodes.length; i < j; i++) {
								dom = this.get_node(nodes[i], true);
								if (dom && dom.length) {
									dom.removeClass("jstree-loading").attr('aria-busy',false);
								}
							}
							parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
						}, this));
					}
					if(typeof s === 'object' && s && s.url) {
						s = langx.extend(true, {}, s);
						if(langx.isFunction(s.url)) {
							s.url = s.url.call(this, toLoad);
						}
						if(langx.isFunction(s.data)) {
							s.data = s.data.call(this, toLoad);
						}
						return ajax(s)
							.done(langx.proxy(function (data,t,x) {
									var i, j;
									if(data) {
										for(i in data) {
											if(data.hasOwnProperty(i)) {
												this._data.massload[i] = data[i];
											}
										}
									}
									for(i = 0, j = nodes.length; i < j; i++) {
										dom = this.get_node(nodes[i], true);
										if (dom && dom.length) {
											dom.removeClass("jstree-loading").attr('aria-busy',false);
										}
									}
									parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
								}, this))
							.fail(langx.proxy(function (f) {
									parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
								}, this));
					}
				}
			}
			return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
		};
		this._load_node = function (obj, callback) {
			var data = this._data.massload[obj.id],
				rslt = null, dom;
			if(data) {
				rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](
					obj,
					typeof data === 'string' ? $(langx.parseHTML(data)).filter(function () { return this.nodeType !== 3; }) : data,
					function (status) { callback.call(this, status); }
				);
				dom = this.get_node(obj.id, true);
				if (dom && dom.length) {
					dom.removeClass("jstree-loading").attr('aria-busy',false);
				}
				delete this._data.massload[obj.id];
				return rslt;
			}
			return parent._load_node.call(this, obj, callback);
		};
	};

	return $;
	
});
define('skylark-widgets-hierarchy/addons/search',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){

	"use strict";

	if($.jstree.plugins.search) { return; }

	/**
	 * stores all defaults for the search plugin
	 * @name $.jstree.defaults.search
	 * @plugin search
	 */
	$.jstree.defaults.search = {
		/**
		 * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.
		 *
		 * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
		 * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to
		 * @name $.jstree.defaults.search.ajax
		 * @plugin search
		 */
		ajax : false,
		/**
		 * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
		 * @name $.jstree.defaults.search.fuzzy
		 * @plugin search
		 */
		fuzzy : false,
		/**
		 * Indicates if the search should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.search.case_sensitive
		 * @plugin search
		 */
		case_sensitive : false,
		/**
		 * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches
		 * @plugin search
		 */
		show_only_matches : false,
		/**
		 * Indicates if the children of matched element are shown (when show_only_matches is true)
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches_children
		 * @plugin search
		 */
		show_only_matches_children : false,
		/**
		 * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
		 * @name $.jstree.defaults.search.close_opened_onclear
		 * @plugin search
		 */
		close_opened_onclear : true,
		/**
		 * Indicates if only leaf nodes should be included in search results. Default is `false`.
		 * @name $.jstree.defaults.search.search_leaves_only
		 * @plugin search
		 */
		search_leaves_only : false,
		/**
		 * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
		 * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
		 * @name $.jstree.defaults.search.search_callback
		 * @plugin search
		 */
		search_callback : false
	};

	$.jstree.plugins.search = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this._data.search.str = "";
			this._data.search.dom = $();
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.som = false;
			this._data.search.smc = false;
			this._data.search.hdn = [];

			this.element
				.on("search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som && data.res.length) {
							var m = this._model.data, i, j, p = [], k, l;
							for(i = 0, j = data.res.length; i < j; i++) {
								if(m[data.res[i]] && !m[data.res[i]].state.hidden) {
									p.push(data.res[i]);
									p = p.concat(m[data.res[i]].parents);
									if(this._data.search.smc) {
										for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {
											if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {
												p.push(m[data.res[i]].children_d[k]);
											}
										}
									}
								}
							}
							p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);
							this._data.search.hdn = this.hide_all(true);
							this.show_node(p, true);
							this.redraw(true);
						}
					}, this))
				.on("clear_search.jstree", langx.proxy(function (e, data) {
						if(this._data.search.som && data.res.length) {
							this.show_node(this._data.search.hdn, true);
							this.redraw(true);
						}
					}, this));
		};
		/**
		 * used to search the tree nodes for a given string
		 * @name search(str [, skip_async])
		 * @param {String} str the search string
		 * @param {Boolean} skip_async if set to true server will not be queried even if configured
		 * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
		 * @param {mixed} inside an optional node to whose children to limit the search
		 * @param {Boolean} append if set to true the results of this search are appended to the previous search
		 * @plugin search
		 * @trigger search.jstree
		 */
		this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
			if(str === false || langx.trim(str.toString()) === "") {
				return this.clear_search();
			}
			inside = this.get_node(inside);
			inside = inside && inside.id ? inside.id : null;
			str = str.toString();
			var s = this.settings.search,
				a = s.ajax ? s.ajax : false,
				m = this._model.data,
				f = null,
				r = [],
				p = [], i, j;
			if(this._data.search.res.length && !append) {
				this.clear_search();
			}
			if(show_only_matches === undefined) {
				show_only_matches = s.show_only_matches;
			}
			if(show_only_matches_children === undefined) {
				show_only_matches_children = s.show_only_matches_children;
			}
			if(!skip_async && a !== false) {
				if(langx.isFunction(a)) {
					return a.call(this, str, langx.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!langx.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
							});
						}, this), inside);
				}
				else {
					a = langx.extend({}, a);
					if(!a.data) { a.data = {}; }
					a.data.str = str;
					if(inside) {
						a.data.inside = inside;
					}
					if (this._data.search.lastRequest) {
						this._data.search.lastRequest.abort();
					}
					this._data.search.lastRequest = ajax(a)
						.fail(langx.proxy(function () {
							this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
							this.settings.core.error.call(this, this._data.core.last_error);
						}, this))
						.done(langx.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!langx.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
							});
						}, this));
					return this._data.search.lastRequest;
				}
			}
			if(!append) {
				this._data.search.str = str;
				this._data.search.dom = $();
				this._data.search.res = [];
				this._data.search.opn = [];
				this._data.search.som = show_only_matches;
				this._data.search.smc = show_only_matches_children;
			}

			f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });
			langx.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {
				var v = m[i];
				if(v.text && !v.state.hidden && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) ) {
					r.push(i);
					p = p.concat(v.parents);
				}
			});
			if(r.length) {
				p = $.vakata.array_unique(p);
				for(i = 0, j = p.length; i < j; i++) {
					if(p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {
						this._data.search.opn.push(p[i]);
					}
				}
				if(!append) {
					this._data.search.dom = $(this.element[0].querySelectorAll('#' + langx.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
					this._data.search.res = r;
				}
				else {
					this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + langx.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))));
					this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
				}
				this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes
			 * @param {String} str the search string
			 * @param {Array} res a collection of objects represeing the matching nodes
			 * @plugin search
			 */
			this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
		};
		/**
		 * used to clear the last search (removes classes and shows all nodes if filtering is on)
		 * @name clear_search()
		 * @plugin search
		 * @trigger clear_search.jstree
		 */
		this.clear_search = function () {
			if(this.settings.search.close_opened_onclear) {
				this.close_node(this._data.search.opn, 0);
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name clear_search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
			 * @param {String} str the search string (the last search string)
			 * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
			 * @plugin search
			 */
			this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
			if(this._data.search.res.length) {
				this._data.search.dom = $(this.element[0].querySelectorAll('#' + langx.map(this._data.search.res, function (v) {
					return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&');
				}).join(', #')));
				this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
			}
			this._data.search.str = "";
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.dom = $();
		};

		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				if(langx.inArray(obj.id, this._data.search.res) !== -1) {
					var i, j, tmp = null;
					for(i = 0, j = obj.childNodes.length; i < j; i++) {
						if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
							tmp = obj.childNodes[i];
							break;
						}
					}
					if(tmp) {
						tmp.className += ' jstree-search';
					}
				}
			}
			return obj;
		};
	};

	// helpers
	(function ($) {
		// from http://kiro.me/projects/fuse.html
		$.vakata.search = function(pattern, txt, options) {
			options = options || {};
			options = langx.extend({}, $.vakata.search.defaults, options);
			if(options.fuzzy !== false) {
				options.fuzzy = true;
			}
			pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
			var MATCH_LOCATION	= options.location,
				MATCH_DISTANCE	= options.distance,
				MATCH_THRESHOLD	= options.threshold,
				patternLen = pattern.length,
				matchmask, pattern_alphabet, match_bitapScore, search;
			if(patternLen > 32) {
				options.fuzzy = false;
			}
			if(options.fuzzy) {
				matchmask = 1 << (patternLen - 1);
				pattern_alphabet = (function () {
					var mask = {},
						i = 0;
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] = 0;
					}
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
					}
					return mask;
				}());
				match_bitapScore = function (e, x) {
					var accuracy = e / patternLen,
						proximity = Math.abs(MATCH_LOCATION - x);
					if(!MATCH_DISTANCE) {
						return proximity ? 1.0 : accuracy;
					}
					return accuracy + (proximity / MATCH_DISTANCE);
				};
			}
			search = function (text) {
				text = options.caseSensitive ? text : text.toLowerCase();
				if(pattern === text || text.indexOf(pattern) !== -1) {
					return {
						isMatch: true,
						score: 0
					};
				}
				if(!options.fuzzy) {
					return {
						isMatch: false,
						score: 1
					};
				}
				var i, j,
					textLen = text.length,
					scoreThreshold = MATCH_THRESHOLD,
					bestLoc = text.indexOf(pattern, MATCH_LOCATION),
					binMin, binMid,
					binMax = patternLen + textLen,
					lastRd, start, finish, rd, charMatch,
					score = 1,
					locations = [];
				if (bestLoc !== -1) {
					scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
					if (bestLoc !== -1) {
						scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					}
				}
				bestLoc = -1;
				for (i = 0; i < patternLen; i++) {
					binMin = 0;
					binMid = binMax;
					while (binMin < binMid) {
						if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
							binMin = binMid;
						} else {
							binMax = binMid;
						}
						binMid = Math.floor((binMax - binMin) / 2 + binMin);
					}
					binMax = binMid;
					start = Math.max(1, MATCH_LOCATION - binMid + 1);
					finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
					rd = new Array(finish + 2);
					rd[finish + 1] = (1 << i) - 1;
					for (j = finish; j >= start; j--) {
						charMatch = pattern_alphabet[text.charAt(j - 1)];
						if (i === 0) {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
						} else {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
						}
						if (rd[j] & matchmask) {
							score = match_bitapScore(i, j - 1);
							if (score <= scoreThreshold) {
								scoreThreshold = score;
								bestLoc = j - 1;
								locations.push(bestLoc);
								if (bestLoc > MATCH_LOCATION) {
									start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
								} else {
									break;
								}
							}
						}
					}
					if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
						break;
					}
					lastRd = rd;
				}
				return {
					isMatch: bestLoc >= 0,
					score: score
				};
			};
			return txt === true ? { 'search' : search } : search(txt);
		};
		$.vakata.search.defaults = {
			location : 0,
			distance : 100,
			threshold : 0.6,
			fuzzy : false,
			caseSensitive : false
		};
	}($));

	// include the search plugin by default
	// $.jstree.defaults.plugins.push("search");

	return $;
	
});

define('skylark-widgets-hierarchy/addons/sort',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){

	"use strict";

	if($.jstree.plugins.sort) { return; }

	/**
	 * the settings function used to sort the nodes.
	 * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
	 * @name $.jstree.defaults.sort
	 * @plugin sort
	 */
	$.jstree.defaults.sort = function (a, b) {
		//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
		return this.get_text(a) > this.get_text(b) ? 1 : -1;
	};
	$.jstree.plugins.sort = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this.element
				.on("model.jstree", langx.proxy(function (e, data) {
						this.sort(data.parent, true);
					}, this))
				.on("rename_node.jstree create_node.jstree", langx.proxy(function (e, data) {
						this.sort(data.parent || data.node.parent, false);
						this.redraw_node(data.parent || data.node.parent, true);
					}, this))
				.on("move_node.jstree copy_node.jstree", langx.proxy(function (e, data) {
						this.sort(data.parent, false);
						this.redraw_node(data.parent, true);
					}, this));
		};
		/**
		 * used to sort a node's children
		 * @private
		 * @name sort(obj [, deep])
		 * @param  {mixed} obj the node
		 * @param {Boolean} deep if set to `true` nodes are sorted recursively.
		 * @plugin sort
		 * @trigger search.jstree
		 */
		this.sort = function (obj, deep) {
			var i, j;
			obj = this.get_node(obj);
			if(obj && obj.children && obj.children.length) {
				obj.children.sort(langx.proxy(this.settings.sort, this));
				if(deep) {
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						this.sort(obj.children_d[i], false);
					}
				}
			}
		};
	};

	// include the sort plugin by default
	// $.jstree.defaults.plugins.push("sort");

	return $;
	
});
define('skylark-widgets-hierarchy/addons/state',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){

	"use strict";

	if($.jstree.plugins.state) { return; }

	var to = false;
	/**
	 * stores all defaults for the state plugin
	 * @name $.jstree.defaults.state
	 * @plugin state
	 */
	$.jstree.defaults.state = {
		/**
		 * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
		 * @name $.jstree.defaults.state.key
		 * @plugin state
		 */
		key		: 'jstree',
		/**
		 * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
		 * @name $.jstree.defaults.state.events
		 * @plugin state
		 */
		events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
		/**
		 * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
		 * @name $.jstree.defaults.state.ttl
		 * @plugin state
		 */
		ttl		: false,
		/**
		 * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
		 * @name $.jstree.defaults.state.filter
		 * @plugin state
		 */
		filter	: false,
		/**
		 * Should loaded nodes be restored (setting this to true means that it is possible that the whole tree will be loaded for some users - use with caution). Defaults to `false`
		 * @name $.jstree.defaults.state.preserve_loaded
		 * @plugin state
		 */
		preserve_loaded : false
	};
	$.jstree.plugins.state = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			var bind = langx.proxy(function () {
				this.element.on(this.settings.state.events, langx.proxy(function () {
					if(to) { clearTimeout(to); }
					to = setTimeout(langx.proxy(function () { this.save_state(); }, this), 100);
				}, this));
				/**
				 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
				 * @event
				 * @name state_ready.jstree
				 * @plugin state
				 */
				this.trigger('state_ready');
			}, this);
			this.element
				.on("ready.jstree", langx.proxy(function (e, data) {
						this.element.one("restore_state.jstree", bind);
						if(!this.restore_state()) { bind(); }
					}, this));
		};
		/**
		 * save the state
		 * @name save_state()
		 * @plugin state
		 */
		this.save_state = function () {
			var tm = this.get_state();
			if (!this.settings.state.preserve_loaded) {
				delete tm.core.loaded;
			}
			var st = { 'state' : tm, 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
			$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
		};
		/**
		 * restore the state from the user's computer
		 * @name restore_state()
		 * @plugin state
		 */
		this.restore_state = function () {
			var k = $.vakata.storage.get(this.settings.state.key);
			if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
			if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
			if(!!k && k.state) { k = k.state; }
			if(!!k && langx.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
			if(!!k) {
				if (!this.settings.state.preserve_loaded) {
					delete k.core.loaded;
				}
				this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : langx.extend(true, {}, k) }); });
				this.set_state(k);
				return true;
			}
			return false;
		};
		/**
		 * clear the state on the user's computer
		 * @name clear_state()
		 * @plugin state
		 */
		this.clear_state = function () {
			return $.vakata.storage.del(this.settings.state.key);
		};
	};

	(function ($, undefined) {
		$.vakata.storage = {
			// simply specifying the functions in FF throws an error
			set : function (key, val) { return window.localStorage.setItem(key, val); },
			get : function (key) { return window.localStorage.getItem(key); },
			del : function (key) { return window.localStorage.removeItem(key); }
		};
	}($));

	// include the state plugin by default
	// $.jstree.defaults.plugins.push("state");

	return $;
	
});
define('skylark-widgets-hierarchy/addons/treegrid',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "./menu",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,menu,jstree){
    var BLANKRE = /^\s*$/g,
        IDREGEX = /[\\:&!^|()\[\]<>@*'+~#";,= \/${}%]/g,
        escapeId = function(id) {
            return (id || "").replace(IDREGEX, '\\$&');
        },
        NODE_DATA_ATTR = "data-jstreegrid",
        COL_DATA_ATTR = "data-jstreegrid-column",
        SEARCHCLASS = "jstree-search",
        SPECIAL_TITLE = "_DATA_",
        LEVELINDENT = 24,
        styled = false,
        MINCOLWIDTH = 10,
        generateCellId = function(tree, id) {
            return ("jstree_" + tree + "_grid_" + escapeId(id) + "_col");
        },
        getIds = function(nodes) {
            return langx.makeArray(nodes.map(function() {
                return this.id;
            }));
        },
        findDataCell = function(uniq, ids, col, scope) {
            if (scope == undefined) {
                scope = $();
            };
            if (ids === null || ids === undefined || ids.length === 0) {
                return scope;
            }
            var ret = $(),
                columns = [].concat(col),
                cellId;
            if (typeof(ids) === "string") {
                cellId = generateCellId(uniq, ids);
                ret = columns.map(function(col) {
                    return "#" + cellId + col;
                }).join(", ");
            } else {
                ret = []
                ids.forEach(function(elm, i) {
                    var cellId = generateCellId(uniq, elm);
                    ret = ret.concat(columns.map(function(col) {
                        return "#" + cellId + col;
                    }));
                });
                ret = ret.join(", ");
            }
            return columns.length == 1 ? scope.find(ret) : $(ret);
        },
        isClickedSep = false,
        toResize = null,
        oldMouseX = 0,
        newMouseX = 0,

        /*jslint regexp:true */
        htmlstripre = /<\/?[^>]+>/gi,
        /*jslint regexp:false */

        getIndent = function(node, tree) {
            var div, i, li, width;

            // did we already save it for this tree?
            tree._gridSettings = tree._gridSettings || {};
            if (tree._gridSettings.indent > 0) {
                width = tree._gridSettings.indent;
            } else {
                // create a new div on the DOM but not visible on the page
                div = $("<div></div>");
                i = node.prev("i");
                li = i.parent();
                // add to that div all of the classes on the tree root
                div.addClass(tree.get_node("#", true).attr("class"));

                // move the li to the temporary div root
                li.appendTo(div);

                // attach to the body quickly
                div.appendTo($("body"));

                // get the width
                width = i.width() || LEVELINDENT;

                // detach the li from the new div and destroy the new div
                li.detach();
                div.remove();

                // save it for the future
                tree._gridSettings.indent = width;
            }


            return (width);

        },

        copyData = function(fromtree, from, totree, to, recurse) {
            var i, j;
            to.data = langx.extend(true, {}, from.data);
            if (from && from.children_d && recurse) {
                for (i = 0, j = from.children_d.length; i < j; i++) {
                    copyData(fromtree, fromtree.get_node(from.children_d[i]), totree, totree.get_node(to.children_d[i]), recurse);
                }
            }
        },

        findLastClosedNode = function(tree, id) {
            // first get our node
            var ret, node = tree.get_node(id),
                children = node.children;
            // is it closed?
            if (!children || children.length <= 0 || !node.state.opened) {
                ret = id;
            } else {
                ret = findLastClosedNode(tree, children[children.length - 1]);
            }
            return (ret);
        },

        renderAWidth = function(node, tree) {
            var depth, width,
                fullWidth = parseInt(tree.settings.grid.columns[0].width, 10) + parseInt(tree._gridSettings.treeWidthDiff, 10);
            // need to use a selector in jquery 1.4.4+
            depth = tree.get_node(node).parents.length;
            width = fullWidth - depth * getIndent(node, tree);
            // the following line is no longer needed, since we are doing this inside a <td>
            //a.css({"vertical-align": "top", "overflow":"hidden"});
            return (fullWidth);
        },
        renderATitle = function(node, t, tree) {
            var a = node.hasClass("jstree-anchor") ? node : node.children("[class~='jstree-anchor']"),
                title, col = tree.settings.grid.columns[0];
            // get the title
            title = "";
            if (col.title) {
                if (col.title === SPECIAL_TITLE) {
                    title = tree.get_text(t);
                } else if (t.attr(col.title)) {
                    title = t.attr(col.title);
                }
            }
            // strip out HTML
            title = title.replace(htmlstripre, '');
            if (title) {
                a.attr("title", title);
            }
        },
        getCellData = function(value, data) {
            var val;
            // get the contents of the cell - value could be a string or a function
            if (value !== undefined && value !== null) {
                if (typeof(value) === "function") {
                    val = value(data);
                } else if (data.data !== null && data.data !== undefined && data.data[value] !== undefined) {
                    val = data.data[value];
                } else {
                    val = "";
                }
            } else {
                val = "";
            }
            return val;
        };

    $.jstree.defaults.grid = {
        width: 'auto'
    };

    $.jstree.plugins.grid = function(options, parent) {
        this._initialize = function() {
            if (!this._initialized) {
                var s = this.settings.grid || {},
                    styles, container = this.element,
                    i,
                    gs = this._gridSettings = {
                        columns: s.columns || [],
                        treeClass: "jstree-grid-col-0",
                        context: s.contextmenu || false,
                        columnWidth: s.columnWidth,
                        defaultConf: {
                            "*display": "inline",
                            "*+display": "inline"
                        },
                        isThemeroller: !!this._data.themeroller,
                        treeWidthDiff: 0,
                        resizable: s.resizable,
                        draggable: s.draggable,
                        stateful: s.stateful,
                        indent: 0,
                        sortOrder: 'text',
                        sortAsc: true,
                        caseInsensitive: s.caseInsensitive,
                        fixedHeader: s.fixedHeader !== false,
                        width: s.width,
                        height: s.height,
                        gridcontextmenu: s.gridcontextmenu,
                        treecol: 0,
                        gridcols: []
                    },
                    cols = gs.columns,
                    treecol = 0,
                    columnSearch = false;
                if (gs.gridcontextmenu === true) {
                    gs.gridcontextmenu = function(grid, tree, node, val, col, t, target) {
                        return {
                            "edit": {
                                label: "Edit",
                                "action": function(data) {
                                    var obj = t.get_node(node);
                                    grid._edit(obj, col, target);
                                }
                            }
                        }
                    }
                } else if (gs.gridcontextmenu === false) {
                    gs.gridcontextmenu = false;
                }
                // find which column our tree shuld go in
                for (var i = 0, len = s.columns.length; i < len; i++) {
                    if (s.columns[i].tree) {
                        // save which column it was
                        treecol = i;
                        gs.treecol = treecol;
                    } else {
                        gs.gridcols.push(i);
                    }
                }
                // set a unique ID for this table
                this.uniq = Math.ceil(Math.random() * 1000);
                this.rootid = container.attr("id");

                var msie = /msie/.test(navigator.userAgent.toLowerCase());
                if (msie) {
                    var version = parseFloat(navigator.appVersion.split("MSIE")[1]);
                    if (version < 8) {
                        gs.defaultConf.display = "inline";
                        gs.defaultConf.zoom = "1";
                    }
                }

                // set up the classes we need
                if (!styled) {
                    styled = true;
                    styles = [
                        '.jstree-grid-cell {vertical-align: top; overflow:hidden;margin-left:0;position:relative;width: 100%;padding-left:7px;white-space: nowrap;}',
                        '.jstree-grid-cell span {margin-right:0px;margin-right:0px;*display:inline;*+display:inline;white-space: nowrap;}',
                        '.jstree-grid-separator {position:absolute; top:0; right:0; height:24px; margin-left: -2px; border-width: 0 2px 0 0; *display:inline; *+display:inline; margin-right:0px;width:0px;}',
                        '.jstree-grid-header-cell {overflow: hidden; white-space: nowrap;padding: 1px 3px 2px 5px; cursor: default;}',
                        '.jstree-grid-header-themeroller {border: 0; padding: 1px 3px;}',
                        '.jstree-grid-header-regular {position:relative; background-color: #EBF3FD; z-index: 1;}',
                        '.jstree-grid-hidden {display: none;}',
                        '.jstree-grid-resizable-separator {cursor: col-resize; width: 2px;}',
                        '.jstree-grid-separator-regular {border-color: #d0d0d0; border-style: solid;}',
                        '.jstree-grid-cell-themeroller {border: none !important; background: transparent !important;}',
                        '.jstree-grid-wrapper {table-layout: fixed; width: 100%; overflow: auto; position: relative;}',
                        '.jstree-grid-midwrapper {display: table-row;}',
                        '.jstree-grid-width-auto {width:auto;display:block;}',
                        '.jstree-grid-column {display: table-cell; overflow: hidden;}',
                        '.jstree-grid-ellipsis {text-overflow: ellipsis;}',
                        '.jstree-grid-col-0 {width: 100%;}'
                    ];
                    $('<style type="text/css">' + styles.join("\n") + '</style>').appendTo("head");
                }
                this.gridWrapper = $("<div></div>").addClass("jstree-grid-wrapper").insertAfter(container);
                this.midWrapper = $("<div></div>").addClass("jstree-grid-midwrapper").appendTo(this.gridWrapper);
                // set the wrapper width
                if (s.width) {
                    this.gridWrapper.width(s.width);
                }
                if (s.height) {
                    this.gridWrapper.height(s.height);
                }
                // create the data columns
                for (var i = 0, len = cols.length; i < len; i++) {
                    // create the column
                    $("<div></div>").addClass("jstree-default jstree-grid-column jstree-grid-column-" + i + " jstree-grid-column-root-" + this.rootid).appendTo(this.midWrapper);
                }
                this.midWrapper.children("div:eq(" + treecol + ")").append(container);
                container.addClass("jstree-grid-cell");

                //move header with scroll
                if (gs.fixedHeader) {
                    this.gridWrapper.scroll(function() {
                        $(this).find('.jstree-grid-header').css('top', $(this).scrollTop());
                    });
                }

                // copy original sort function
                var defaultSort = langx.proxy(this.settings.sort, this);

                // override sort function
                this.settings.sort = function(a, b) {
                    var bigger, colrefs = this.colrefs;

                    if (gs.sortOrder === 'text') {
                        var caseInsensitiveSort = this.get_text(a).toLowerCase().localeCompare(this.get_text(b).toLowerCase());
                        bigger = gs.caseInsensitive ? (caseInsensitiveSort === 1) : (defaultSort(a, b) === 1);
                    } else {
                        // gs.sortOrder just refers to the unique random name for this column
                        // we need to get the correct value
                        var nodeA = this.get_node(a),
                            nodeB = this.get_node(b),
                            value = colrefs[gs.sortOrder].value,
                            valueA = typeof(value) === 'function' ? value(nodeA) : nodeA.data[value],
                            valueB = typeof(value) === 'function' ? value(nodeB) : nodeB.data[value];
                        if (typeof(valueA) && typeof(valueB) !== 'undefined') {
                            bigger = gs.caseInsensitive ? valueA.toLowerCase() > valueB.toLowerCase() : valueA > valueB;
                        }
                    }

                    if (!gs.sortAsc)
                        bigger = !bigger;

                    return bigger ? 1 : -1;
                };

                // sortable columns when jQuery UI is available
                if (gs.draggable) {
                    if (!$.ui || !$.ui.sortable) {
                        console.warn('[jstree-grid] draggable option requires jQuery UI');
                    } else {
                        var from, to;

                        $(this.midWrapper).sortable({
                            axis: "x",
                            handle: ".jstree-grid-header",
                            cancel: ".jstree-grid-separator",
                            start: function(event, ui) {
                                from = ui.item.index();
                            },
                            stop: function(event, ui) {
                                to = ui.item.index();
                                gs.columns.splice(to, 0, gs.columns.splice(from, 1)[0]);
                            }
                        });
                    }
                }

                //public function. validate searchObject keys, set columnSearch flag, calls jstree search and reset columnSearch flag
                this.searchColumn = function(searchObj) {
                    var validatedSearchObj = {};

                    if (typeof searchObj == 'object') {
                        for (var columnIndex in searchObj) {
                            if (searchObj.hasOwnProperty(columnIndex)) {
                                // keys should be the index of a column. This means the following:
                                // only integers and smaller than the number of columns and bigger or equal to 0
                                // (possilbe idea for in the future: ability to set key as a more human readable term like the column header and then map it here to an index)
                                if (columnIndex % 1 === 0 && columnIndex < cols.length && columnIndex >= 0) {
                                    validatedSearchObj[columnIndex] = searchObj[columnIndex];
                                }
                            }
                        }
                    }
                    columnSearch = validatedSearchObj;

                    if (Object.keys(validatedSearchObj).length !== 0) {
                        //the search string doesn't matter. we'll use the search string in the columnSearch object!
                        this.search('someValue');
                    } else { // nothing to search so reset jstree's search by passing an empty string
                        this.search('');
                    }
                    columnSearch = false;
                }


                // set default search for each column with no user defined search function (used when doing a columnSearch)
                for (var i = 0, len = cols.length; i < len; i++) {
                    var column = cols[i];
                    if (typeof(column.search_callback) !== "function") {
                        // no search callback so set default function
                        column.search_callback = function(str, columnValue, node, column) {
                            var f = new $.vakata.search(str, true, {
                                caseSensitive: searchSettings.case_sensitive,
                                fuzzy: searchSettings.fuzzy
                            });

                            return f.search(columnValue).isMatch;

                        };
                    }
                }

                // if there was no overridden search_callback, we will provide it
                // it will use the default per-node search algorithm, augmented by searching our data nodes
                var searchSettings = this.settings.search;
                var omniSearchCallback = searchSettings.search_callback;

                if (!omniSearchCallback) {
                    omniSearchCallback = function(str, node) {
                        var i, f = new $.vakata.search(str, true, {
                                caseSensitive: searchSettings.case_sensitive,
                                fuzzy: searchSettings.fuzzy
                            }),
                            matched = f.search(node.text).isMatch,
                            col;

                        // only bother looking in each cell if it was not yet matched
                        if (!matched) {
                            for (var i = 0, len = cols.length; i < len; i++) {
                                if (treecol === i) {
                                    continue;
                                }
                                col = cols[i];
                                matched = f.search(getCellData(col.value, node)).isMatch;
                                if (matched) {
                                    break;
                                }
                            }
                        }
                        return matched;
                    }
                }

                searchSettings.search_callback = function(str, node) {
                    var matched = false;
                    if (columnSearch) {
                        //using logical AND for column searches (more options in the future)
                        for (var columnIndex in columnSearch) {
                            if (columnSearch.hasOwnProperty(columnIndex)) {
                                var searchValue = columnSearch[columnIndex];
                                if (searchValue == '') {
                                    continue;
                                }
                                var col = cols[columnIndex];
                                if (treecol == columnIndex) {
                                    matched = col.search_callback(searchValue, node.text, node, col)
                                } else {
                                    matched = col.search_callback(searchValue, getCellData(col.value, node), node, col)
                                }

                                if (!matched) {
                                    break; //found one that didn't match
                                }
                            }
                        }

                        container.trigger("columnSearch_grid.jstree");
                    } else {
                        matched = omniSearchCallback(str, node);
                        container.trigger("omniSearch_grid.jstree");
                    }
                    return matched;
                };
                this._initialized = true;
            }
        };
        this.init = function(el, options) {
            parent.init.call(this, el, options);
            this._initialize();
        };
        this.bind = function() {
            parent.bind.call(this);
            this._initialize();
            this.element
                .on("move_node.jstree create_node.jstree clean_node.jstree change_node.jstree", langx.proxy(function(e, data) {
                    var target = this.get_node(data || "#", true);
                    var id = _guid();
                    this._detachColumns(id);
                    this._prepare_grid(target);
                    this._reattachColumns(id);
                }, this))
                .on("delete_node.jstree", langx.proxy(function(e, data) {
                    if (data.node.id !== undefined) {
                        var grid = this.gridWrapper,
                            removeNodes = [data.node.id],
                            i;
                        // add children to remove list
                        if (data.node && data.node.children_d) {
                            removeNodes = removeNodes.concat(data.node.children_d);
                        }
                        findDataCell(this.uniq, removeNodes, this._gridSettings.gridcols).remove();
                    }
                }, this))
                .on("show_node.jstree", langx.proxy(function(e, data) {
                    this._hideOrShowTree(data.node, false);
                }, this))
                .on("hide_node.jstree", langx.proxy(function(e, data) {
                    this._hideOrShowTree(data.node, true);
                }, this))
                .on("close_node.jstree", langx.proxy(function(e, data) {
                    this._hide_grid(data.node);
                }, this))
                .on("open_node.jstree", langx.proxy(function(e, data) {}, this))
                .on("load_node.jstree", langx.proxy(function(e, data) {}, this))
                .on("loaded.jstree", langx.proxy(function(e) {
                    this._prepare_headers();
                    this.element.trigger("loaded_grid.jstree");
                }, this))
                .on("ready.jstree", langx.proxy(function(e, data) {
                    // find the line-height of the first known node
                    var anchorHeight = this.element.find("[class~='jstree-anchor']:first").outerHeight(),
                        q,
                        cls = this.element.attr("class") || "";
                    $('<style type="text/css">div.jstree-grid-cell-root-' + this.rootid + ' {line-height: ' + anchorHeight + 'px; height: ' + anchorHeight + 'px;}</style>').appendTo("head");

                    // add container classes to the wrapper - EXCEPT those that are added by jstree, i.e. "jstree" and "jstree-*"
                    q = cls.split(/\s+/).map(function(i) {
                        var match = i.match(/^jstree(-|$)/);
                        return (match ? "" : i);
                    });
                    this.gridWrapper.addClass(q.join(" "));

                }, this))
                .on("move_node.jstree", langx.proxy(function(e, data) {
                    var node = data.new_instance.element;
                    //renderAWidth(node,this);
                    // check all the children, because we could drag a tree over
                    node.find("li > a").each(langx.proxy(function(i, elm) {
                        //renderAWidth($(elm),this);
                    }, this));

                }, this))
                .on("hover_node.jstree", langx.proxy(function(node, selected, event) {
                    var id = selected.node.id;
                    if (this._hover_node !== null && this._hover_node !== undefined) {
                        findDataCell(this.uniq, this._hover_node, this._gridSettings.gridcols).removeClass("jstree-hovered");
                    }
                    this._hover_node = id;
                    findDataCell(this.uniq, id, this._gridSettings.gridcols).addClass("jstree-hovered");
                }, this))
                .on("dehover_node.jstree", langx.proxy(function(node, selected, event) {
                    var id = selected.node.id;
                    this._hover_node = null;
                    findDataCell(this.uniq, id, this._gridSettings.gridcols).removeClass("jstree-hovered");
                }, this))
                .on("select_node.jstree", langx.proxy(function(node, selected, event) {
                    var id = selected.node.id;
                    findDataCell(this.uniq, id, this._gridSettings.gridcols).addClass("jstree-clicked");
                    this.get_node(selected.node.id, true).children("div.jstree-grid-cell").addClass("jstree-clicked");
                }, this))
                .on("deselect_node.jstree", langx.proxy(function(node, selected, event) {
                    var id = selected.node.id;
                    findDataCell(this.uniq, id, this._gridSettings.gridcols).removeClass("jstree-clicked");
                }, this))
                .on("deselect_all.jstree", langx.proxy(function(node, selected, event) {
                    // get all of the ids that were unselected
                    var ids = selected.node || [],
                        i;
                    findDataCell(this.uniq, ids, this._gridSettings.gridcols).removeClass("jstree-clicked");
                }, this))
                .on("search.jstree", langx.proxy(function(e, data) {
                    // search sometimes filters, so we need to hide all of the appropriate grid cells as well, and show only the matches
                    var grid = this.gridWrapper,
                        that = this,
                        nodesToShow, startTime = new Date().getTime(),
                        ids = getIds(data.nodes.filter(".jstree-node")),
                        endTime;
                    this.holdingCells = {};
                    if (data.nodes.length) {
                        var id = _guid();
                        // save the cells we will hide
                        var cells = grid.find('div.jstree-grid-cell-regular');
                        this._detachColumns(id);
                        if (this._data.search.som) {
                            // create the list of nodes we want to look at
                            if (this._data.search.smc) {
                                nodesToShow = data.nodes.add(data.nodes.find('.jstree-node'));
                            }
                            nodesToShow = (nodesToShow || data.nodes).add(data.nodes.parentsUntil(".jstree"));

                            // hide all of the grid cells
                            cells.hide();
                            // show only those that match
                            nodesToShow.filter(".jstree-node").each(function(i, node) {
                                var id = node.id;
                                if (id) {
                                    that._prepare_grid(node);
                                    for (var i = 0, len = that._gridSettings.gridcols.length; i < len; i++) {
                                        if (i === that._gridSettings.treecol) {
                                            continue;
                                        }
                                        findDataCell(that.uniq, id, that._gridSettings.gridcols[i], $(that._domManipulation.columns[i])).show();
                                    }
                                }
                            });
                        }

                        for (var i = 0, len = this._gridSettings.gridcols.length; i < len; i++) {
                            if (i === this._gridSettings.treecol) {
                                continue;
                            }
                            findDataCell(that.uniq, ids, this._gridSettings.gridcols[i], $(this._domManipulation.columns[i])).addClass(SEARCHCLASS);
                        }
                        this._reattachColumns(id);
                        endTime = new Date().getTime();
                        this.element.trigger("search-complete.jstree-grid", [{
                            time: endTime - startTime
                        }]);
                    }
                    return true;
                }, this))
                .on("clear_search.jstree", langx.proxy(function(e, data) {
                    // search has been cleared, so we need to show all rows
                    var grid = this.gridWrapper,
                        ids = getIds(data.nodes.filter(".jstree-node"));
                    grid.find('div.jstree-grid-cell').show();
                    findDataCell(this.uniq, ids, this._gridSettings.gridcols).removeClass(SEARCHCLASS);
                    return true;
                }, this))
                .on("copy_node.jstree", function(e, data) {
                    var newtree = data.new_instance,
                        oldtree = data.old_instance,
                        obj = newtree.get_node(data.node, true);
                    copyData(oldtree, data.original, newtree, data.node, true);
                    newtree._detachColumns(obj.id);
                    newtree._prepare_grid(obj);
                    newtree._reattachColumns(obj.id);
                    return true;
                })
                .on("show_ellipsis.jstree", langx.proxy(function(e, data) {
                    this.gridWrapper.find(".jstree-grid-cell").add(".jstree-grid-header", this.gridWrapper).addClass("jstree-grid-ellipsis");
                    return true;
                }, this))
                .on("hide_ellipsis.jstree", langx.proxy(function(e, data) {
                    this.gridWrapper.find(".jstree-grid-cell").add(".jstree-grid-header", this.gridWrapper).removeClass("jstree-grid-ellipsis");
                    return true;
                }, this));
            if (this._gridSettings.isThemeroller) {
                this.element
                    .on("select_node.jstree", langx.proxy(function(e, data) {
                        data.rslt.obj.children("[class~='jstree-anchor']").nextAll("div").addClass("ui-state-active");
                    }, this))
                    .on("deselect_node.jstree deselect_all.jstree", langx.proxy(function(e, data) {
                        data.rslt.obj.children("[class~='jstree-anchor']").nextAll("div").removeClass("ui-state-active");
                    }, this))
                    .on("hover_node.jstree", langx.proxy(function(e, data) {
                        data.rslt.obj.children("[class~='jstree-anchor']").nextAll("div").addClass("ui-state-hover");
                    }, this))
                    .on("dehover_node.jstree", langx.proxy(function(e, data) {
                        data.rslt.obj.children("[class~='jstree-anchor']").nextAll("div").removeClass("ui-state-hover");
                    }, this));
            }

            if (this._gridSettings.stateful) {
                this.element
                    .on("resize_column.jstree-grid", langx.proxy(function(e, col, width) {
                        localStorage['jstree-root-' + this.rootid + '-column-' + col] = width;
                    }, this));
            }
        };

        // tear down the tree entirely
        this.teardown = function() {
            var gw = this.gridWrapper,
                container = this.element,
                gridparent = gw.parent();
            container.detach();
            gw.remove();
            gridparent.append(container);
            parent.teardown.call(this);
        };
        // clean the grid in case of redraw or refresh entire tree
        this._clean_grid = function(target, id) {
            var grid = this.gridWrapper;
            if (target) {
                findDataCell(this.uniq, id, this._gridSettings.gridcols).remove();
            } else {
                // get all of the `div` children in all of the `td` in dataRow except for :first (that is the tree itself) and remove
                grid.find("div.jstree-grid-cell-regular").remove();
            }
        };
        // prepare the headers
        this._prepare_headers = function() {
            var header, i, col, _this = this,
                gs = this._gridSettings,
                cols = gs.columns || [],
                width, defaultWidth = gs.columnWidth,
                resizable = gs.resizable || false,
                cl, ccl, val, name, last, tr = gs.isThemeroller,
                classAdd = (tr ? "themeroller" : "regular"),
                puller,
                hasHeaders = false,
                gridparent = this.gridparent,
                rootid = this.rootid,
                conf = gs.defaultConf,
                coluuid,
                borPadWidth = 0,
                totalWidth = 0;

            // save the original parent so we can reparent on destroy
            this.parent = gridparent;

            // save the references to columns by unique ID
            this.colrefs = {};


            // create the headers
            for (var i = 0, len = cols.length; i < len; i++) {
                //col = $("<col/>");
                //col.appendTo(colgroup);
                cl = cols[i].headerClass || "";
                ccl = cols[i].columnClass || "";
                val = cols[i].header || "";
                do {
                    coluuid = String(Math.floor(Math.random() * 10000));
                } while (this.colrefs[coluuid] !== undefined);
                // create a unique name for this column
                name = cols[i].value ? coluuid : "text";
                this.colrefs[name] = cols[i];

                if (val) {
                    hasHeaders = true;
                }
                if (gs.stateful && localStorage['jstree-root-' + rootid + '-column-' + i])
                    width = localStorage['jstree-root-' + rootid + '-column-' + i];
                else
                    width = cols[i].width || defaultWidth;

                var minWidth = cols[i].minWidth || width;
                var maxWidth = cols[i].maxWidth || width;

                // we only deal with borders if width is not auto and not percentages
                borPadWidth = tr ? 1 + 6 : 2 + 8; // account for the borders and padding
                if (width !== 'auto' && typeof(width) !== "string") {
                    width -= borPadWidth;
                }
                col = this.midWrapper.children("div.jstree-grid-column-" + i);
                last = $("<div></div>").css(conf).addClass("jstree-grid-div-" + this.uniq + "-" + i + " " + (tr ? "ui-widget-header " : "") + " jstree-grid-header jstree-grid-header-cell jstree-grid-header-" + classAdd + " " + cl + " " + ccl).html(val);
                last.addClass((tr ? "ui-widget-header " : "") + "jstree-grid-header jstree-grid-header-" + classAdd);
                if (this.settings.core.themes.ellipsis === true) {
                    last.addClass('jstree-grid-ellipsis');
                }
                last.prependTo(col);
                last.attr(COL_DATA_ATTR, name);
                totalWidth += last.outerWidth();
                puller = $("<div class='jstree-grid-separator jstree-grid-separator-" + classAdd + (tr ? " ui-widget-header" : "") + (resizable ? " jstree-grid-resizable-separator" : "") + "'>&nbsp;</div>").appendTo(last);
                col.width(width);
                col.css("min-width", minWidth);
                col.css("max-width", maxWidth);
            }

            last.addClass((tr ? "ui-widget-header " : "") + "jstree-grid-header jstree-grid-header-last jstree-grid-header-" + classAdd);
            // if there is no width given for the last column, do it via automatic
            if (cols[cols.length - 1].width === undefined) {
                totalWidth -= width;
                col.css({
                    width: "auto"
                });
                last.addClass("jstree-grid-width-auto").next(".jstree-grid-separator").remove();
            }
            if (hasHeaders) {
                // save the offset of the div from the body
                //gs.divOffset = header.parent().offset().left;
                gs.header = header;
            } else {
                $("div.jstree-grid-header").hide();
            }

            if (!this.bound && resizable) {
                this.bound = true;
                $(document).mouseup(function() {
                    var ref, cols, width, headers, currentTree, colNum;
                    if (isClickedSep) {
                        colNum = toResize.prevAll(".jstree-grid-column").length;
                        currentTree = toResize.closest(".jstree-grid-wrapper").find(".jstree");
                        ref = $.jstree.reference(currentTree);
                        cols = ref.settings.grid.columns;
                        headers = toResize.parent().children("div.jstree-grid-column");
                        if (isNaN(colNum) || colNum < 0) {
                            ref._gridSettings.treeWidthDiff = currentTree.find("ins:eq(0)").width() + currentTree.find("[class~='jstree-anchor']:eq(0)").width() - ref._gridSettings.columns[0].width;
                        }
                        width = ref._gridSettings.columns[colNum].width = parseFloat(toResize.css("width"));
                        isClickedSep = false;
                        toResize = null;

                        currentTree.trigger("resize_column.jstree-grid", [colNum, width]);
                    }
                }).mousemove(function(e) {
                    if (isClickedSep) {
                        newMouseX = e.pageX;
                        var diff = newMouseX - oldMouseX,
                            oldPrevHeaderInner,
                            oldPrevColWidth, newPrevColWidth;

                        if (diff !== 0) {
                            oldPrevHeaderInner = toResize.width();
                            oldPrevColWidth = parseFloat(toResize.css("width"));

                            // handle a Chrome issue with columns set to auto
                            // thanks to Brabus https://github.com/side-by-side
                            if (!oldPrevColWidth) {
                                oldPrevColWidth = toResize.innerWidth();
                            }

                            // make sure that diff cannot be beyond the left/right limits
                            diff = diff < 0 ? Math.max(diff, -oldPrevHeaderInner) : diff;
                            newPrevColWidth = oldPrevColWidth + diff;

                            // only do this if we are not shrinking past 0 on left - and limit it to that amount
                            if ((diff > 0 || oldPrevHeaderInner > 0) && newPrevColWidth > MINCOLWIDTH) {
                                toResize.width(newPrevColWidth + "px");
                                toResize.css("min-width", newPrevColWidth + "px");
                                toResize.css("max-width", newPrevColWidth + "px");
                                oldMouseX = newMouseX;
                            }
                        }
                    }
                });
                this.gridWrapper.on("selectstart", ".jstree-grid-resizable-separator", function() {
                        return false;
                    }).on("mousedown", ".jstree-grid-resizable-separator", function(e) {
                        isClickedSep = true;
                        oldMouseX = e.pageX;
                        toResize = $(this).closest("div.jstree-grid-column");
                        // the max rightmost position we will allow is the right-most of the wrapper minus a buffer (10)
                        return false;
                    })
                    .on("dblclick", ".jstree-grid-resizable-separator", function(e) {
                        var clickedSep = $(this),
                            col = clickedSep.closest("div.jstree-grid-column"),
                            oldPrevColWidth = parseFloat(col.css("width")),
                            newWidth = 0,
                            diff,
                            colNum = col.prevAll(".jstree-grid-column").length,
                            oldPrevHeaderInner = col.width(),
                            newPrevColWidth;


                        //find largest width
                        col.find(".jstree-grid-cell").each(function() {
                            var item = $(this),
                                width;
                            item.css("position", "absolute");
                            item.css("width", "auto");
                            width = item.outerWidth();
                            item.css("position", "relative");

                            if (width > newWidth) {
                                newWidth = width;
                            }
                        });

                        diff = newWidth - oldPrevColWidth;

                        // make sure that diff cannot be beyond the left limits
                        diff = diff < 0 ? Math.max(diff, -oldPrevHeaderInner) : diff;
                        newPrevColWidth = (oldPrevColWidth + diff) + "px";

                        col.width(newPrevColWidth);
                        col.css("min-width", newPrevColWidth);
                        col.css("max-width", newPrevColWidth);

                        $(this).closest(".jstree-grid-wrapper").find(".jstree").trigger("resize_column.jstree-grid", [colNum, newPrevColWidth]);
                    })
                    .on("click", ".jstree-grid-separator", function(e) {
                        // don't sort after resize
                        e.stopPropagation();
                    });
            }
            this.gridWrapper.on("click", ".jstree-grid-header-cell", function(e) {
                if (!_this.sort) {
                    return;
                }

                // get column
                var name = $(this).attr(COL_DATA_ATTR);

                // sort order
                var symbol;
                if (gs.sortOrder === name && gs.sortAsc === true) {
                    gs.sortAsc = false;
                    symbol = "&darr;";
                } else {
                    gs.sortOrder = name;
                    gs.sortAsc = true;
                    symbol = "&uarr;";
                }

                // add sort arrow
                $(this.closest('.jstree-grid-wrapper')).find(".jstree-grid-sort-icon").remove();
                $("<span></span>").addClass("jstree-grid-sort-icon").appendTo($(this)).html(symbol);

                // sort by column
                var rootNode = _this.get_node('#');
                _this.sort(rootNode, true);
                _this.redraw_node(rootNode, true);
            });

        };

        this._domManipulation = null; // We'll store the column nodes in this object and an id for the grid-node that started the manipulation { id: "id of the node that started the manipulation", columns: { Key-Value-Pair col-No: Column }}

        function _guid() {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                s4() + '-' + s4() + s4() + s4();
        }
        /*
         * Trys to detach the tree columns on massive dom manipulations
         */
        this._detachColumns = function(id) {
            // if the columns are not detached, then detach them
            if (this._domManipulation == null) {
                var cols = this._gridSettings.columns || [],
                    treecol = this._gridSettings.treecol,
                    mw = this.midWrapper;
                this._domManipulation = {
                    id: id,
                    columns: {}
                };
                for (var i = 0, len = cols.length; i < len; i++) {
                    //if (treecol === i) {
                    //  continue;
                    //}
                    this._domManipulation.columns[i] = mw.children(".jstree-grid-column-" + i)[0];
                    this._domManipulation.columns[i].parentNode.removeChild(this._domManipulation.columns[i]);
                }
            }
            return this._domManipulation;
        }

        this._reattachColumns = function(id) {
            if (this._domManipulation == null) {
                return false;
            }
            if (this._domManipulation.id === id) {
                var cols = this._gridSettings.columns || [],
                    treecol = this._gridSettings.treecol,
                    mw = this.midWrapper;
                for (var i = 0, len = cols.length; i < len; i++) {
                    //if (treecol === i) {
                    //  continue;
                    //}
                    mw[0].appendChild(this._domManipulation.columns[i]);
                }
                this._domManipulation = null;
            }
            return true;
        }

        /*
         * Override open_node to detach the columns before redrawing child-nodes, and do reattach them afterwarts
         */
        this.open_node = function(obj, callback, animation) {
            var isArray = langx.isArray(obj);
            var node = null;
            if (!isArray) {
                node = this.get_node(obj);
                if (node.id === "#") {
                    return;
                } // wtf??? we ar in the root and do not need a open!
            }
            var id = isArray ? _guid() : node.id;
            this._detachColumns(id);
            var ret = parent.open_node.call(this, obj, callback, animation);
            this._reattachColumns(id);
            return ret;
        }

        /*
         * Override redraw_node to correctly insert the grid
         */
        this.redraw_node = function(obj, deep, is_callback, force_render) {
            var id = langx.isArray(obj) ? _guid() : this.get_node(obj).id;
            // we detach the columns once
            this._detachColumns(id);
            // first allow the parent to redraw the node
            obj = parent.redraw_node.call(this, obj, deep, is_callback, force_render);
            // next prepare the grid for a redrawn node - but only if ths node is not hidden (search does that)
            if (obj) {
                this._prepare_grid(obj);
            }
            // don't forget to reattach
            this._reattachColumns(id);
            return obj;
        };
        this.refresh = function() {
            this._clean_grid();
            return parent.refresh.apply(this, arguments);
        };
        /*
         * Override set_id to update cell attributes
         */
        this.set_id = function(obj, id) {
            var old, uniq = this.uniq;
            if (obj) {
                old = obj.id;
            }
            var result = parent.set_id.apply(this, arguments);
            if (result) {
                if (old !== undefined) {
                    var grid = this.gridWrapper,
                        oldNodes = [old],
                        i;
                    // get children
                    if (obj && obj.children_d) {
                        oldNodes = oldNodes.concat(obj.children_d);
                    }
                    // update id in children
                    findDataCell(uniq, oldNodes, this._gridSettings.gridcols)
                        .attr(NODE_DATA_ATTR, obj.id)
                        .removeClass(generateCellId(uniq, old))
                        .addClass(generateCellId(uniq, obj.id))
                        .each(function(i, node) {
                            $(node).attr('id', generateCellId(uniq, obj.id) + (i + 1));
                        });
                }
            }
            return result;
        };

        this._hideOrShowTree = function(node, hide) {
            //Hides or shows a tree
            this._detachColumns(node.id);
            // show cells in each detachted column
            this._hideOrShowNode(node, hide, this._gridSettings.columns || [], this._gridSettings.treecol);
            this._reattachColumns(node.id);
        }
        this._hideOrShowNode = function(node, hide, cols, treecol) {
            //Hides or shows a node with recursive calls to all open child-nodes
            for (var i = 0, len = cols.length; i < len; i++) {
                if (i === treecol) {
                    continue;
                }
                var cells = findDataCell(this.uniq, node.id, i, $(this._domManipulation.columns[i]));
                if (hide) {
                    cells.addClass("jstree-grid-hidden");
                } else {
                    cells.removeClass("jstree-grid-hidden");
                }
            }
            if (node.state.opened && node.children) {
                for (var i = 0, len = node.children.length; i < len; i++) {
                    this._hideOrShowNode(this.get_node(node.children[i]), hide, cols, treecol);
                }
            }
        }
        this._hide_grid = function(node) {
            if (!node) {
                return true;
            }
            this._detachColumns(node.id);
            var children = node.children ? node.children : [],
                cols = this._gridSettings.columns || [],
                treecol = this._gridSettings.treecol;
            // try to remove all children
            for (var i = 0, len = children.length; i < len; i++) {
                var child = this.get_node(children[i]);
                // go through each column, remove all children with the correct ID name
                for (var j = 0, lenj = cols.length; j < lenj; j++) {
                    if (j === treecol) {
                        continue;
                    }
                    findDataCell(this.uniq, child.id, j, $(this._domManipulation.columns[j])).remove();
                }
                if (child.state.opened) {
                    this._hide_grid(child);
                }
            }


            this._reattachColumns(node.id);
        };
        this.holdingCells = {};
        this.getHoldingCells = function(obj, col, hc) {
            if (obj.state.hidden || !obj.state.opened) {
                return $();
            }
            var ret = $(),
                children = obj.children || [],
                child, i, uniq = this.uniq;
            // run through each child, render it, and then render its children recursively
            for (i = 0; i < children.length; i++) {
                child = generateCellId(uniq, children[i]) + col;
                if (hc[child]) {
                    ret = ret.add(hc[child]).add(this.getHoldingCells(this.get_node(children[i]), col, hc));
                    //delete hc[child];
                }
            }
            return (ret);
        };

        /**
         * put a grid cell in edit mode (input field to edit the data)
         * @name edit(obj, col)
         * @param  {mixed} obj
         * @param  {obj} col definition
         * @param  {element} cell element, either span or wrapping div
         */
        this._edit = function(obj, col, element) {
            if (!obj) {
                return false;
            }
            if (!obj.data) {
                obj.data = {};
            }
            if (element) {
                element = $(element);
                if (element.prop("tagName").toLowerCase() === "div") {
                    element = element.children("span:first");
                }
            } else {
                // need to find the element - later
                return false;
            }
            var rtl = this._data.core.rtl,
                w = this.element.width(),
                t = obj.data[col.value],
                h1 = $("<" + "div />", {
                    css: {
                        "position": "absolute",
                        "top": "-200px",
                        "left": (rtl ? "0px" : "-1000px"),
                        "visibility": "hidden"
                    }
                }).appendTo("body"),
                h2 = $("<" + "input />", {
                    "value": t,
                    "class": "jstree-rename-input",
                    "css": {
                        "padding": "0",
                        "border": "1px solid silver",
                        "box-sizing": "border-box",
                        "display": "inline-block",
                        "height": (this._data.core.li_height) + "px",
                        "lineHeight": (this._data.core.li_height) + "px",
                        "width": "150px" // will be set a bit further down
                    },
                    "blur": langx.proxy(function() {
                        var v = h2.val();
                        // save the value if changed
                        if (v === "" || v === t) {
                            v = t;
                        } else {
                            obj.data[col.value] = v;
                            this.element.trigger('update_cell.jstree-grid', {
                                node: obj,
                                col: col.value,
                                value: v,
                                old: t
                            });
                            var id = _guid();
                            this._detachColumns(id);
                            this._prepare_grid(this.get_node(obj, true));
                            this._reattachColumns(id);
                        }
                        h2.remove();
                        element.show();
                    }, this),
                    "keydown": function(event) {
                        var key = event.which;
                        if (key === 27) {
                            this.value = t;
                        }
                        if (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
                            event.stopImmediatePropagation();
                        }
                        if (key === 27 || key === 13) {
                            event.preventDefault();
                            this.blur();
                        }
                    },
                    "click": function(e) {
                        e.stopImmediatePropagation();
                    },
                    "mousedown": function(e) {
                        e.stopImmediatePropagation();
                    },
                    "keyup": function(event) {
                        h2.width(Math.min(h1.text("pW" + this.value).width(), w));
                    },
                    "keypress": function(event) {
                        if (event.which === 13) {
                            return false;
                        }
                    }
                }),
                fn = {
                    fontFamily: element.css('fontFamily') || '',
                    fontSize: element.css('fontSize') || '',
                    fontWeight: element.css('fontWeight') || '',
                    fontStyle: element.css('fontStyle') || '',
                    fontStretch: element.css('fontStretch') || '',
                    fontVariant: element.css('fontVariant') || '',
                    letterSpacing: element.css('letterSpacing') || '',
                    wordSpacing: element.css('wordSpacing') || ''
                };
            element.hide();
            element.parent().append(h2);
            h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(), w))[0].select();
        };

        this.grid_hide_column = function(col) {
            this.midWrapper.find(".jstree-grid-column-" + col).hide();
        };
        this.grid_show_column = function(col) {
            this.midWrapper.find(".jstree-grid-column-" + col).show();
        };

        this._prepare_grid = function(obj) {
            var gs = this._gridSettings,
                c = gs.treeClass,
                _this = this,
                t,
                cols = gs.columns || [],
                width, tr = gs.isThemeroller,
                uniq = this.uniq,
                treecol = gs.treecol,
                tree = this.element,
                rootid = this.rootid,
                classAdd = (tr ? "themeroller" : "regular"),
                img, objData = this.get_node(obj),
                defaultWidth = gs.columnWidth,
                conf = gs.defaultConf,
                cellClickHandler = function(tree, node, val, col, t) {
                    return function(e) {
                        //node = tree.find("#"+node.attr("id"));
                        var event = eventer.create("select_cell.jstree-grid");
                        tree.trigger(event, [{
                            value: val,
                            column: col.header,
                            node: node,
                            grid: $(this),
                            sourceName: col.value
                        }]);
                        if (!event.isDefaultPrevented()) {
                            node.children(".jstree-anchor").trigger("click.jstree", e);
                        }
                    };
                },
                cellRightClickHandler = function(tree, node, val, col, t) {
                    return function(e) {
                        if (gs.gridcontextmenu) {
                            e.preventDefault();
                            menu.popup(this, {
                                'x': e.pageX,
                                'y': e.pageY
                            }, gs.gridcontextmenu(_this, tree, node, val, col, t, e.target));
                        }
                    };
                },
                hoverInHandler = function(node, jsTreeInstance) {
                    return function() {
                        jsTreeInstance.hover_node(node);
                    };
                },
                hoverOutHandler = function(node, jsTreeInstance) {
                    return function() {
                        jsTreeInstance.dehover_node(node);
                    };
                },
                i, val, cl, wcl, ccl, a, last, valClass, wideValClass, span, paddingleft, title, gridCellName, gridCellParentId, gridCellParent,
                gridCellPrev, gridCellPrevId, gridCellNext, gridCellNextId, gridCellChild, gridCellChildId,
                col, content, tmpWidth, mw = this.midWrapper,
                column, lid = objData.id,
                highlightSearch, isClicked,
                peers = this.get_node(objData.parent).children,
                // find my position in the list of peers. "peers" is the list of everyone at my level under my parent, in order
                pos = langx.inArray(lid, peers),
                hc = this.holdingCells,
                rendered = false,
                closed;
            // get our column definition
            t = $(obj);

            // find the a children
            a = t.children("[class~='jstree-anchor']");
            highlightSearch = a.hasClass(SEARCHCLASS);
            isClicked = a.hasClass("jstree-clicked");

            if (a.length === 1) {
                closed = !objData.state.opened;
                gridCellName = generateCellId(uniq, lid);
                gridCellParentId = objData.parent === "#" ? null : objData.parent;
                a.addClass(c);
                //renderAWidth(a,_this);
                renderATitle(a, t, _this);
                last = a;

                // calculate position ids once
                gridCellPrevId = pos <= 0 ? objData.parent : findLastClosedNode(this, peers[pos - 1]);
                gridCellNextId = pos >= peers.length - 1 ? "NULL" : peers[pos + 1];
                gridCellChildId = objData.children && objData.children.length > 0 ? objData.children[0] : "NULL";

                // find which column our tree shuld go in
                var s = this.settings.grid;
                for (var i = 0, len = cols.length; i < len; i++) {
                    if (treecol === i) {
                        continue;
                    }
                    col = cols[i];
                    column = this._domManipulation == null ? mw.children("div:eq(" + i + ")") : $(this._domManipulation.columns[i]); //Geht the detached column not mw.children("div:eq("+i+")");
                    // get the cellClass, the wideCellClass, and the columnClass
                    cl = col.cellClass || "";
                    wcl = col.wideCellClass || "";
                    ccl = col.columnClass || "";

                    // add a column class to the Column
                    column.addClass(ccl);


                    // get the contents of the cell - value could be a string or a function
                    val = getCellData(col.value, objData);

                    if (typeof(col.format) === "function") {
                        val = col.format(val);
                    }

                    // put images instead of text if needed
                    if (col.images) {
                        img = col.images[val] || col.images["default"];
                        if (img) {
                            content = img[0] === "*" ? '<span class="' + img.substr(1) + '"></span>' : '<img src="' + img + '">';
                        }
                    } else {
                        content = val;
                    }

                    // content cannot be blank, or it messes up heights
                    if (content === undefined || content === null || BLANKRE.test(content)) {
                        content = "&nbsp;";
                    }

                    // get the valueClass
                    valClass = col.valueClass && objData.data !== null && objData.data !== undefined ? objData.data[col.valueClass] || "" : "";
                    if (valClass && col.valueClassPrefix && col.valueClassPrefix !== "") {
                        valClass = col.valueClassPrefix + valClass;
                    }
                    // get the wideValueClass
                    wideValClass = col.wideValueClass && objData.data !== null && objData.data !== undefined ? objData.data[col.wideValueClass] || "" : "";
                    if (wideValClass && col.wideValueClassPrefix && col.wideValueClassPrefix !== "") {
                        wideValClass = col.wideValueClassPrefix + wideValClass;
                    }
                    // get the title
                    title = col.title && objData.data !== null && objData.data !== undefined ? objData.data[col.title] || "" : "";
                    // strip out HTML
                    title = title.replace(htmlstripre, '');

                    // get the width
                    paddingleft = 7;
                    width = col.width || defaultWidth;
                    if (width !== 'auto') {
                        width = tmpWidth || (width - paddingleft);
                    }

                    last = findDataCell(uniq, lid, i, column);
                    if (!last || last.length < 1) {
                        last = $("<div></div>");
                        $("<span></span>").appendTo(last);
                        last.attr("id", gridCellName + i);
                        last.addClass(gridCellName);
                        last.attr(NODE_DATA_ATTR, lid);
                        if (highlightSearch) {
                            last.addClass(SEARCHCLASS);
                        } else {
                            last.removeClass(SEARCHCLASS);
                        }
                        if (isClicked) {
                            last.addClass("jstree-clicked");
                        } else {
                            last.removeClass("jstree-clicked");
                        }
                        if (this.settings.core.themes.ellipsis === true && i !== treecol) {
                            last.addClass('jstree-grid-ellipsis');
                        }

                    }

                    // we need to check the hidden-state and see if we need to hide the node
                    if (objData.state.hidden) {
                        last.addClass("jstree-grid-hidden");
                    } else {
                        last.removeClass("jstree-grid-hidden");
                    }

                    // we need to put it in the dataCell - after the parent, but the position matters
                    // if we have no parent, then we are one of the root nodes, but still need to look at peers


                    // if we are first, i.e. pos === 0, we go right after the parent;
                    // if we are not first, and our previous peer (one before us) is closed, we go right after the previous peer cell
                    // if we are not first, and our previous peer is opened, then we have to find its youngest & lowest closed child (incl. leaf)
                    //
                    // probably be much easier to go *before* our next one
                    // but that one might not be drawn yet
                    // here is the logic for jstree drawing:
                    //   it draws peers from first to last or from last to first
                    //   it draws children before a parent
                    //
                    // so I can rely on my *parent* not being drawn, but I cannot rely on my previous peer or my next peer being drawn

                    // so we do the following:
                    //   1- We are the first child: install after the parent
                    //   2- Our previous peer is already drawn: install after the previous peer
                    //   3- Our previous peer is not drawn, we have a child that is drawn: install right before our first child
                    //   4- Our previous peer is not drawn, we have no child that is drawn, our next peer is drawn: install right before our next peer
                    //   5- Our previous peer is not drawn, we have no child that is drawn, our next peer is not drawn: install right after parent
                    gridCellPrev = findDataCell(uniq, gridCellPrevId, i, column);
                    gridCellNext = findDataCell(uniq, gridCellNextId, i, column);
                    gridCellChild = findDataCell(uniq, gridCellChildId, i, column);
                    gridCellParent = findDataCell(uniq, gridCellParentId, i, column);


                    // if our parent is already drawn, then we put this in the right order under our parent
                    if (gridCellParentId) {
                        if (gridCellParent && gridCellParent.length > 0) {
                            if (gridCellPrev && gridCellPrev.length > 0) {
                                last.insertAfter(gridCellPrev);
                            } else if (gridCellChild && gridCellChild.length > 0) {
                                last.insertBefore(gridCellChild);
                            } else if (gridCellNext && gridCellNext.length > 0) {
                                last.insertBefore(gridCellNext);
                            } else {
                                last.insertAfter(gridCellParent);
                            }
                            rendered = true;
                        } else {
                            rendered = false;
                        }
                        // always put it in the holding cells, and then sort when the parent comes in, in case parent is (re)drawn later
                        hc[gridCellName + i] = last;
                    } else {
                        if (gridCellPrev && gridCellPrev.length > 0) {
                            last.insertAfter(gridCellPrev);
                        } else if (gridCellChild && gridCellChild.length > 0) {
                            last.insertBefore(gridCellChild);
                        } else if (gridCellNext && gridCellNext.length > 0) {
                            last.insertBefore(gridCellNext);
                        } else {
                            last.appendTo(column);
                        }
                        rendered = true;
                    }
                    // do we have any children waiting for this cell? walk down through the children/grandchildren/etc tree
                    if (rendered) {
                        var toRen = this.getHoldingCells(objData, i, hc);
                        last.after(toRen);
                    }
                    // need to make the height of this match the line height of the tree. How?
                    span = last.children("span");

                    // create a span inside the div, so we can control what happens in the whole div versus inside just the text/background
                    span.addClass(cl + " " + valClass).html(content);
                    last = last.css(conf).addClass("jstree-grid-cell jstree-grid-cell-regular jstree-grid-cell-root-" + rootid + " jstree-grid-cell-" + classAdd + " " + wcl + " " + wideValClass + (tr ? " ui-state-default" : "")).addClass("jstree-grid-col-" + i).addClass("jstree-animated");
                    // add click handler for clicking inside a grid cell
                    last.click(cellClickHandler(tree, t, val, col, this));
                    last.on("contextmenu", cellRightClickHandler(tree, t, val, col, this));
                    last.hover(hoverInHandler(t, this), hoverOutHandler(t, this));

                    if (title) {
                        span.attr("title", title);
                    }

                    tree.trigger("render_cell.jstree-grid", [{
                        value: val,
                        column: col.header,
                        node: t,
                        sourceName: col.value
                    }]);
                }
                last.addClass("jstree-grid-cell-last" + (tr ? " ui-state-default" : ""));
                // if there is no width given for the last column, do it via automatic
                if (cols[cols.length - 1].width === undefined) {
                    last.addClass("jstree-grid-width-auto").next(".jstree-grid-separator").remove();
                }
            }
            this.element.css({
                'overflow-y': 'auto !important'
            });
        };
        // clean up holding cells
        this.holdingCells = {};

        // need to do alternating background colors or borders
    };

    return $;
});
define('skylark-widgets-hierarchy/addons/types',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){
	"use strict";

	if($.jstree.plugins.types) { return; }

	/**
	 * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
	 *
	 * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
	 * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
	 * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
	 * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
	 * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)
	 * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)
	 *
	 * There are two predefined types:
	 *
	 * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
	 * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
	 *
	 * @name $.jstree.defaults.types
	 * @plugin types
	 */
	$.jstree.defaults.types = {
		'default' : {}
	};
	$.jstree.defaults.types[$.jstree.root] = {};

	$.jstree.plugins.types = function (options, parent) {
		this.init = function (el, options) {
			var i, j;
			if(options && options.types && options.types['default']) {
				for(i in options.types) {
					if(i !== "default" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {
						for(j in options.types['default']) {
							if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
								options.types[i][j] = options.types['default'][j];
							}
						}
					}
				}
			}
			parent.init.call(this, el, options);
			this._model.data[$.jstree.root].type = $.jstree.root;
		};
		this.refresh = function (skip_loading, forget_state) {
			parent.refresh.call(this, skip_loading, forget_state);
			this._model.data[$.jstree.root].type = $.jstree.root;
		};
		this.bind = function () {
			this.element
				.on('model.jstree', langx.proxy(function (e, data) {
						var m = this._model.data,
							dpc = data.nodes,
							t = this.settings.types,
							i, j, c = 'default', k;
						for(i = 0, j = dpc.length; i < j; i++) {
							c = 'default';
							if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
								c = m[dpc[i]].original.type;
							}
							if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
								c = m[dpc[i]].data.jstree.type;
							}
							m[dpc[i]].type = c;
							if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
								m[dpc[i]].icon = t[c].icon;
							}
							if(t[c].li_attr !== undefined && typeof t[c].li_attr === 'object') {
								for (k in t[c].li_attr) {
									if (t[c].li_attr.hasOwnProperty(k)) {
										if (k === 'id') {
											continue;
										}
										else if (m[dpc[i]].li_attr[k] === undefined) {
											m[dpc[i]].li_attr[k] = t[c].li_attr[k];
										}
										else if (k === 'class') {
											m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];
										}
									}
								}
							}
							if(t[c].a_attr !== undefined && typeof t[c].a_attr === 'object') {
								for (k in t[c].a_attr) {
									if (t[c].a_attr.hasOwnProperty(k)) {
										if (k === 'id') {
											continue;
										}
										else if (m[dpc[i]].a_attr[k] === undefined) {
											m[dpc[i]].a_attr[k] = t[c].a_attr[k];
										}
										else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {
											m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];
										}
										else if (k === 'class') {
											m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];
										}
									}
								}
							}
						}
						m[$.jstree.root].type = $.jstree.root;
					}, this));
			parent.bind.call(this);
		};
		this.get_json = function (obj, options, flat) {
			var i, j,
				m = this._model.data,
				opt = options ? langx.extend(true, {}, options, {no_id:false}) : {},
				tmp = parent.get_json.call(this, obj, opt, flat);
			if(tmp === false) { return false; }
			if(langx.isArray(tmp)) {
				for(i = 0, j = tmp.length; i < j; i++) {
					tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
					if(options && options.no_id) {
						delete tmp[i].id;
						if(tmp[i].li_attr && tmp[i].li_attr.id) {
							delete tmp[i].li_attr.id;
						}
						if(tmp[i].a_attr && tmp[i].a_attr.id) {
							delete tmp[i].a_attr.id;
						}
					}
				}
			}
			else {
				tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
				if(options && options.no_id) {
					tmp = this._delete_ids(tmp);
				}
			}
			return tmp;
		};
		this._delete_ids = function (tmp) {
			if(langx.isArray(tmp)) {
				for(var i = 0, j = tmp.length; i < j; i++) {
					tmp[i] = this._delete_ids(tmp[i]);
				}
				return tmp;
			}
			delete tmp.id;
			if(tmp.li_attr && tmp.li_attr.id) {
				delete tmp.li_attr.id;
			}
			if(tmp.a_attr && tmp.a_attr.id) {
				delete tmp.a_attr.id;
			}
			if(tmp.children && langx.isArray(tmp.children)) {
				tmp.children = this._delete_ids(tmp.children);
			}
			return tmp;
		};
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
			m = m && m._model && m._model.data ? m._model.data : null;
			switch(chk) {
				case "create_node":
				case "move_node":
				case "copy_node":
					if(chk !== 'move_node' || langx.inArray(obj.id, par.children) === -1) {
						tmp = this.get_rules(par);
						if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && langx.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(m && obj.children_d && obj.parents) {
							d = 0;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								d = Math.max(d, m[obj.children_d[i]].parents.length);
							}
							d = d - obj.parents.length + 1;
						}
						if(d <= 0 || d === undefined) { d = 1; }
						do {
							if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							par = this.get_node(par.parent);
							tmp = this.get_rules(par);
							d++;
						} while(par);
					}
					break;
			}
			return true;
		};
		/**
		 * used to retrieve the type settings object for a node
		 * @name get_rules(obj)
		 * @param {mixed} obj the node to find the rules for
		 * @return {Object}
		 * @plugin types
		 */
		this.get_rules = function (obj) {
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var tmp = this.get_type(obj, true);
			if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
			if(tmp.max_children === undefined) { tmp.max_children = -1; }
			if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
			return tmp;
		};
		/**
		 * used to retrieve the type string or settings object for a node
		 * @name get_type(obj [, rules])
		 * @param {mixed} obj the node to find the rules for
		 * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
		 * @return {String|Object}
		 * @plugin types
		 */
		this.get_type = function (obj, rules) {
			obj = this.get_node(obj);
			return (!obj) ? false : ( rules ? langx.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
		};
		/**
		 * used to change a node's type
		 * @name set_type(obj, type)
		 * @param {mixed} obj the node to change
		 * @param {String} type the new type
		 * @plugin types
		 */
		this.set_type = function (obj, type) {
			var m = this._model.data, t, t1, t2, old_type, old_icon, k, d, a;
			if(langx.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_type(obj[t1], type);
				}
				return true;
			}
			t = this.settings.types;
			obj = this.get_node(obj);
			if(!t[type] || !obj) { return false; }
			d = this.get_node(obj, true);
			if (d && d.length) {
				a = d.children('.jstree-anchor');
			}
			old_type = obj.type;
			old_icon = this.get_icon(obj);
			obj.type = type;
			if(old_icon === true || !t[old_type] || (t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
				this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
			}

			// remove old type props
			if(t[old_type] && t[old_type].li_attr !== undefined && typeof t[old_type].li_attr === 'object') {
				for (k in t[old_type].li_attr) {
					if (t[old_type].li_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (k === 'class') {
							m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');
							if (d) { d.removeClass(t[old_type].li_attr[k]); }
						}
						else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {
							m[obj.id].li_attr[k] = null;
							if (d) { d.removeAttr(k); }
						}
					}
				}
			}
			if(t[old_type] && t[old_type].a_attr !== undefined && typeof t[old_type].a_attr === 'object') {
				for (k in t[old_type].a_attr) {
					if (t[old_type].a_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (k === 'class') {
							m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');
							if (a) { a.removeClass(t[old_type].a_attr[k]); }
						}
						else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {
							if (k === 'href') {
								m[obj.id].a_attr[k] = '#';
								if (a) { a.attr('href', '#'); }
							}
							else {
								delete m[obj.id].a_attr[k];
								if (a) { a.removeAttr(k); }
							}
						}
					}
				}
			}

			// add new props
			if(t[type].li_attr !== undefined && typeof t[type].li_attr === 'object') {
				for (k in t[type].li_attr) {
					if (t[type].li_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (m[obj.id].li_attr[k] === undefined) {
							m[obj.id].li_attr[k] = t[type].li_attr[k];
							if (d) {
								if (k === 'class') {
									d.addClass(t[type].li_attr[k]);
								}
								else {
									d.attr(k, t[type].li_attr[k]);
								}
							}
						}
						else if (k === 'class') {
							m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];
							if (d) { d.addClass(t[type].li_attr[k]); }
						}
					}
				}
			}
			if(t[type].a_attr !== undefined && typeof t[type].a_attr === 'object') {
				for (k in t[type].a_attr) {
					if (t[type].a_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (m[obj.id].a_attr[k] === undefined) {
							m[obj.id].a_attr[k] = t[type].a_attr[k];
							if (a) {
								if (k === 'class') {
									a.addClass(t[type].a_attr[k]);
								}
								else {
									a.attr(k, t[type].a_attr[k]);
								}
							}
						}
						else if (k === 'href' && m[obj.id].a_attr[k] === '#') {
							m[obj.id].a_attr['href'] = t[type].a_attr['href'];
							if (a) { a.attr('href', t[type].a_attr['href']); }
						}
						else if (k === 'class') {
							m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];
							if (a) { a.addClass(t[type].a_attr[k]); }
						}
					}
				}
			}

			return true;
		};
	};
	// include the types plugin by default
	// $.jstree.defaults.plugins.push("types");
	return $;
	
});

define('skylark-widgets-hierarchy/addons/unique',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){
	"use strict";

	if($.jstree.plugins.unique) { return; }

	/**
	 * stores all defaults for the unique plugin
	 * @name $.jstree.defaults.unique
	 * @plugin unique
	 */
	$.jstree.defaults.unique = {
		/**
		 * Indicates if the comparison should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.unique.case_sensitive
		 * @plugin unique
		 */
		case_sensitive : false,
		/**
		 * Indicates if white space should be trimmed before the comparison. Default is `false`.
		 * @name $.jstree.defaults.unique.trim_whitespace
		 * @plugin unique
		 */
		trim_whitespace : false,
		/**
		 * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
		 * @name $.jstree.defaults.unique.duplicate
		 * @plugin unique
		 */
		duplicate : function (name, counter) {
			return name + ' (' + counter + ')';
		}
	};

	$.jstree.plugins.unique = function (options, parent) {
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			if(!par || !par.children) { return true; }
			var n = chk === "rename_node" ? pos : obj.text,
				c = [],
				s = this.settings.unique.case_sensitive,
				w = this.settings.unique.trim_whitespace,
				m = this._model.data, i, j, t;
			for(i = 0, j = par.children.length; i < j; i++) {
				t = m[par.children[i]].text;
				if (!s) {
					t = t.toLowerCase();
				}
				if (w) {
					t = t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
				}
				c.push(t);
			}
			if(!s) { n = n.toLowerCase(); }
			if (w) { n = n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); }
			switch(chk) {
				case "delete_node":
					return true;
				case "rename_node":
					t = obj.text || '';
					if (!s) {
						t = t.toLowerCase();
					}
					if (w) {
						t = t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
					}
					i = (langx.inArray(n, c) === -1 || (obj.text && t === n));
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "create_node":
					i = (langx.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "copy_node":
					i = (langx.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "move_node":
					i = ( (obj.parent === par.id && (!more || !more.is_multi)) || langx.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
			}
			return true;
		};
		this.create_node = function (par, node, pos, callback, is_loaded) {
			if(!node || node.text === undefined) {
				if(par === null) {
					par = $.jstree.root;
				}
				par = this.get_node(par);
				if(!par) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				pos = pos === undefined ? "last" : pos;
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				if(!node) { node = {}; }
				var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, w = this.settings.unique.trim_whitespace, cb = this.settings.unique.duplicate, t;
				n = tmp = this.get_string('New node');
				dpc = [];
				for(i = 0, j = par.children.length; i < j; i++) {
					t = m[par.children[i]].text;
					if (!s) {
						t = t.toLowerCase();
					}
					if (w) {
						t = t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
					}
					dpc.push(t);
				}
				i = 1;
				t = n;
				if (!s) {
					t = t.toLowerCase();
				}
				if (w) {
					t = t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
				}
				while(langx.inArray(t, dpc) !== -1) {
					n = cb.call(this, tmp, (++i)).toString();
					t = n;
					if (!s) {
						t = t.toLowerCase();
					}
					if (w) {
						t = t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
					}
				}
				node.text = n;
			}
			return parent.create_node.call(this, par, node, pos, callback, is_loaded);
		};
	};

	// include the unique plugin by default
	// $.jstree.defaults.plugins.push("unique");
	return $;
	
});

define('skylark-widgets-hierarchy/addons/wholerow',[
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-query",
  "../Hierarchy"
],function(langx,browser,eventer,noder,geom,$,jstree){
	"use strict";

	if($.jstree.plugins.wholerow) { return; }

	var div = document.createElement('DIV');
	div.setAttribute('unselectable','on');
	div.setAttribute('role','presentation');
	div.className = 'jstree-wholerow';
	div.innerHTML = '&#160;';
	$.jstree.plugins.wholerow = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('ready.jstree set_state.jstree', langx.proxy(function () {
						this.hide_dots();
					}, this))
				.on("init.jstree loading.jstree ready.jstree", langx.proxy(function () {
						//div.style.height = this._data.core.li_height + 'px';
						this.get_container_ul().addClass('jstree-wholerow-ul');
					}, this))
				.on("deselect_all.jstree", langx.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
					}, this))
				.on("changed.jstree", langx.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
						var tmp = false, i, j;
						for(i = 0, j = data.selected.length; i < j; i++) {
							tmp = this.get_node(data.selected[i], true);
							if(tmp && tmp.length) {
								tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
							}
						}
					}, this))
				.on("open_node.jstree", langx.proxy(function (e, data) {
						this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
					}, this))
				.on("hover_node.jstree dehover_node.jstree", langx.proxy(function (e, data) {
						if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
						this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
					}, this))
				.on("contextmenu.jstree", ".jstree-wholerow", langx.proxy(function (e) {
						if (this._data.contextmenu) {
							e.preventDefault();
							var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
							$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
						}
					}, this))
				/*!
				.on("mousedown.jstree touchstart.jstree", ".jstree-wholerow", function (e) {
						if(e.target === e.currentTarget) {
							var a = $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor");
							e.target = a[0];
							a.trigger(e);
						}
					})
				*/
				.on("click.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("dblclick.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('dblclick', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("click.jstree", ".jstree-leaf > .jstree-ocl", langx.proxy(function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					}, this))
				.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", langx.proxy(function (e) {
						e.stopImmediatePropagation();
						if(!this.is_disabled(e.currentTarget)) {
							this.hover_node(e.currentTarget);
						}
						return false;
					}, this))
				.on("mouseleave.jstree", ".jstree-node", langx.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		};
		this.teardown = function () {
			if(this.settings.wholerow) {
				this.element.find(".jstree-wholerow").remove();
			}
			parent.teardown.call(this);
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var tmp = div.cloneNode(true);
				//tmp.style.height = this._data.core.li_height + 'px';
				if(langx.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
				if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
				obj.insertBefore(tmp, obj.childNodes[0]);
			}
			return obj;
		};
	};
	// include the wholerow plugin by default
	// $.jstree.defaults.plugins.push("wholerow");

	return $;

});

define('skylark-widgets-hierarchy/main',[
    "skylark-domx-query",
    "./Hierarchy",
    "./addons/changed",
    "./addons/checkbox",
    "./addons/conditionalselect",
    "./addons/contextmenu",
    "./addons/dnd",
    "./addons/massload",
    "./addons/search",
    "./addons/sort",
    "./addons/state",
    "./addons/treegrid",
    "./addons/types",
    "./addons/unique",
    "./addons/wholerow"
], function($) {
    return $;
});
define('skylark-widgets-hierarchy', ['skylark-widgets-hierarchy/main'], function (main) { return main; });

define('skylark-widgets-iconpicker/allIcons',[],function(){
	var icons = [ {
            title: "fab fa-500px",
            searchTerms: []
        }, {
            title: "fab fa-accessible-icon",
            searchTerms: [ "accessibility", "handicap", "person", "wheelchair", "wheelchair-alt" ]
        }, {
            title: "fab fa-accusoft",
            searchTerms: []
        }, {
            title: "fab fa-acquisitions-incorporated",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "game", "gaming", "tabletop" ]
        }, {
            title: "fas fa-ad",
            searchTerms: []
        }, {
            title: "fas fa-address-book",
            searchTerms: []
        }, {
            title: "far fa-address-book",
            searchTerms: []
        }, {
            title: "fas fa-address-card",
            searchTerms: []
        }, {
            title: "far fa-address-card",
            searchTerms: []
        }, {
            title: "fas fa-adjust",
            searchTerms: [ "contrast" ]
        }, {
            title: "fab fa-adn",
            searchTerms: []
        }, {
            title: "fab fa-adversal",
            searchTerms: []
        }, {
            title: "fab fa-affiliatetheme",
            searchTerms: []
        }, {
            title: "fas fa-air-freshener",
            searchTerms: []
        }, {
            title: "fab fa-algolia",
            searchTerms: []
        }, {
            title: "fas fa-align-center",
            searchTerms: [ "middle", "text" ]
        }, {
            title: "fas fa-align-justify",
            searchTerms: [ "text" ]
        }, {
            title: "fas fa-align-left",
            searchTerms: [ "text" ]
        }, {
            title: "fas fa-align-right",
            searchTerms: [ "text" ]
        }, {
            title: "fab fa-alipay",
            searchTerms: []
        }, {
            title: "fas fa-allergies",
            searchTerms: [ "freckles", "hand", "intolerances", "pox", "spots" ]
        }, {
            title: "fab fa-amazon",
            searchTerms: []
        }, {
            title: "fab fa-amazon-pay",
            searchTerms: []
        }, {
            title: "fas fa-ambulance",
            searchTerms: [ "help", "machine", "support", "vehicle" ]
        }, {
            title: "fas fa-american-sign-language-interpreting",
            searchTerms: []
        }, {
            title: "fab fa-amilia",
            searchTerms: []
        }, {
            title: "fas fa-anchor",
            searchTerms: [ "link" ]
        }, {
            title: "fab fa-android",
            searchTerms: [ "robot" ]
        }, {
            title: "fab fa-angellist",
            searchTerms: []
        }, {
            title: "fas fa-angle-double-down",
            searchTerms: [ "arrows" ]
        }, {
            title: "fas fa-angle-double-left",
            searchTerms: [ "arrows", "back", "laquo", "previous", "quote" ]
        }, {
            title: "fas fa-angle-double-right",
            searchTerms: [ "arrows", "forward", "next", "quote", "raquo" ]
        }, {
            title: "fas fa-angle-double-up",
            searchTerms: [ "arrows" ]
        }, {
            title: "fas fa-angle-down",
            searchTerms: [ "arrow" ]
        }, {
            title: "fas fa-angle-left",
            searchTerms: [ "arrow", "back", "previous" ]
        }, {
            title: "fas fa-angle-right",
            searchTerms: [ "arrow", "forward", "next" ]
        }, {
            title: "fas fa-angle-up",
            searchTerms: [ "arrow" ]
        }, {
            title: "fas fa-angry",
            searchTerms: [ "disapprove", "emoticon", "face", "mad", "upset" ]
        }, {
            title: "far fa-angry",
            searchTerms: [ "disapprove", "emoticon", "face", "mad", "upset" ]
        }, {
            title: "fab fa-angrycreative",
            searchTerms: []
        }, {
            title: "fab fa-angular",
            searchTerms: []
        }, {
            title: "fas fa-ankh",
            searchTerms: [ "amulet", "copper", "coptic christianity", "copts", "crux ansata", "egyptian", "venus" ]
        }, {
            title: "fab fa-app-store",
            searchTerms: []
        }, {
            title: "fab fa-app-store-ios",
            searchTerms: []
        }, {
            title: "fab fa-apper",
            searchTerms: []
        }, {
            title: "fab fa-apple",
            searchTerms: [ "food", "fruit", "mac", "osx" ]
        }, {
            title: "fas fa-apple-alt",
            searchTerms: [ "fall", "food", "fruit", "fuji", "macintosh", "seasonal" ]
        }, {
            title: "fab fa-apple-pay",
            searchTerms: []
        }, {
            title: "fas fa-archive",
            searchTerms: [ "box", "package", "storage" ]
        }, {
            title: "fas fa-archway",
            searchTerms: [ "arc", "monument", "road", "street" ]
        }, {
            title: "fas fa-arrow-alt-circle-down",
            searchTerms: [ "arrow-circle-o-down", "download" ]
        }, {
            title: "far fa-arrow-alt-circle-down",
            searchTerms: [ "arrow-circle-o-down", "download" ]
        }, {
            title: "fas fa-arrow-alt-circle-left",
            searchTerms: [ "arrow-circle-o-left", "back", "previous" ]
        }, {
            title: "far fa-arrow-alt-circle-left",
            searchTerms: [ "arrow-circle-o-left", "back", "previous" ]
        }, {
            title: "fas fa-arrow-alt-circle-right",
            searchTerms: [ "arrow-circle-o-right", "forward", "next" ]
        }, {
            title: "far fa-arrow-alt-circle-right",
            searchTerms: [ "arrow-circle-o-right", "forward", "next" ]
        }, {
            title: "fas fa-arrow-alt-circle-up",
            searchTerms: [ "arrow-circle-o-up" ]
        }, {
            title: "far fa-arrow-alt-circle-up",
            searchTerms: [ "arrow-circle-o-up" ]
        }, {
            title: "fas fa-arrow-circle-down",
            searchTerms: [ "download" ]
        }, {
            title: "fas fa-arrow-circle-left",
            searchTerms: [ "back", "previous" ]
        }, {
            title: "fas fa-arrow-circle-right",
            searchTerms: [ "forward", "next" ]
        }, {
            title: "fas fa-arrow-circle-up",
            searchTerms: []
        }, {
            title: "fas fa-arrow-down",
            searchTerms: [ "download" ]
        }, {
            title: "fas fa-arrow-left",
            searchTerms: [ "back", "previous" ]
        }, {
            title: "fas fa-arrow-right",
            searchTerms: [ "forward", "next" ]
        }, {
            title: "fas fa-arrow-up",
            searchTerms: []
        }, {
            title: "fas fa-arrows-alt",
            searchTerms: [ "arrow", "arrows", "bigger", "enlarge", "expand", "fullscreen", "move", "position", "reorder", "resize" ]
        }, {
            title: "fas fa-arrows-alt-h",
            searchTerms: [ "arrows-h", "resize" ]
        }, {
            title: "fas fa-arrows-alt-v",
            searchTerms: [ "arrows-v", "resize" ]
        }, {
            title: "fas fa-assistive-listening-systems",
            searchTerms: []
        }, {
            title: "fas fa-asterisk",
            searchTerms: [ "details" ]
        }, {
            title: "fab fa-asymmetrik",
            searchTerms: []
        }, {
            title: "fas fa-at",
            searchTerms: [ "e-mail", "email" ]
        }, {
            title: "fas fa-atlas",
            searchTerms: [ "book", "directions", "geography", "map", "wayfinding" ]
        }, {
            title: "fas fa-atom",
            searchTerms: [ "atheism", "chemistry", "science" ]
        }, {
            title: "fab fa-audible",
            searchTerms: []
        }, {
            title: "fas fa-audio-description",
            searchTerms: []
        }, {
            title: "fab fa-autoprefixer",
            searchTerms: []
        }, {
            title: "fab fa-avianex",
            searchTerms: []
        }, {
            title: "fab fa-aviato",
            searchTerms: []
        }, {
            title: "fas fa-award",
            searchTerms: [ "honor", "praise", "prize", "recognition", "ribbon" ]
        }, {
            title: "fab fa-aws",
            searchTerms: []
        }, {
            title: "fas fa-backspace",
            searchTerms: [ "command", "delete", "keyboard", "undo" ]
        }, {
            title: "fas fa-backward",
            searchTerms: [ "previous", "rewind" ]
        }, {
            title: "fas fa-balance-scale",
            searchTerms: [ "balanced", "justice", "legal", "measure", "weight" ]
        }, {
            title: "fas fa-ban",
            searchTerms: [ "abort", "ban", "block", "cancel", "delete", "hide", "prohibit", "remove", "stop", "trash" ]
        }, {
            title: "fas fa-band-aid",
            searchTerms: [ "bandage", "boo boo", "ouch" ]
        }, {
            title: "fab fa-bandcamp",
            searchTerms: []
        }, {
            title: "fas fa-barcode",
            searchTerms: [ "scan" ]
        }, {
            title: "fas fa-bars",
            searchTerms: [ "checklist", "drag", "hamburger", "list", "menu", "nav", "navigation", "ol", "reorder", "settings", "todo", "ul" ]
        }, {
            title: "fas fa-baseball-ball",
            searchTerms: []
        }, {
            title: "fas fa-basketball-ball",
            searchTerms: []
        }, {
            title: "fas fa-bath",
            searchTerms: []
        }, {
            title: "fas fa-battery-empty",
            searchTerms: [ "power", "status" ]
        }, {
            title: "fas fa-battery-full",
            searchTerms: [ "power", "status" ]
        }, {
            title: "fas fa-battery-half",
            searchTerms: [ "power", "status" ]
        }, {
            title: "fas fa-battery-quarter",
            searchTerms: [ "power", "status" ]
        }, {
            title: "fas fa-battery-three-quarters",
            searchTerms: [ "power", "status" ]
        }, {
            title: "fas fa-bed",
            searchTerms: [ "lodging", "sleep", "travel" ]
        }, {
            title: "fas fa-beer",
            searchTerms: [ "alcohol", "bar", "beverage", "drink", "liquor", "mug", "stein" ]
        }, {
            title: "fab fa-behance",
            searchTerms: []
        }, {
            title: "fab fa-behance-square",
            searchTerms: []
        }, {
            title: "fas fa-bell",
            searchTerms: [ "alert", "notification", "reminder" ]
        }, {
            title: "far fa-bell",
            searchTerms: [ "alert", "notification", "reminder" ]
        }, {
            title: "fas fa-bell-slash",
            searchTerms: []
        }, {
            title: "far fa-bell-slash",
            searchTerms: []
        }, {
            title: "fas fa-bezier-curve",
            searchTerms: [ "curves", "illustrator", "lines", "path", "vector" ]
        }, {
            title: "fas fa-bible",
            searchTerms: [ "book", "catholicism", "christianity" ]
        }, {
            title: "fas fa-bicycle",
            searchTerms: [ "bike", "gears", "transportation", "vehicle" ]
        }, {
            title: "fab fa-bimobject",
            searchTerms: []
        }, {
            title: "fas fa-binoculars",
            searchTerms: []
        }, {
            title: "fas fa-birthday-cake",
            searchTerms: []
        }, {
            title: "fab fa-bitbucket",
            searchTerms: [ "bitbucket-square", "git" ]
        }, {
            title: "fab fa-bitcoin",
            searchTerms: []
        }, {
            title: "fab fa-bity",
            searchTerms: []
        }, {
            title: "fab fa-black-tie",
            searchTerms: []
        }, {
            title: "fab fa-blackberry",
            searchTerms: []
        }, {
            title: "fas fa-blender",
            searchTerms: []
        }, {
            title: "fas fa-blender-phone",
            searchTerms: [ "appliance", "fantasy", "silly" ]
        }, {
            title: "fas fa-blind",
            searchTerms: []
        }, {
            title: "fab fa-blogger",
            searchTerms: []
        }, {
            title: "fab fa-blogger-b",
            searchTerms: []
        }, {
            title: "fab fa-bluetooth",
            searchTerms: []
        }, {
            title: "fab fa-bluetooth-b",
            searchTerms: []
        }, {
            title: "fas fa-bold",
            searchTerms: []
        }, {
            title: "fas fa-bolt",
            searchTerms: [ "electricity", "lightning", "weather", "zap" ]
        }, {
            title: "fas fa-bomb",
            searchTerms: []
        }, {
            title: "fas fa-bone",
            searchTerms: []
        }, {
            title: "fas fa-bong",
            searchTerms: [ "aparatus", "cannabis", "marijuana", "pipe", "smoke", "smoking" ]
        }, {
            title: "fas fa-book",
            searchTerms: [ "documentation", "read" ]
        }, {
            title: "fas fa-book-dead",
            searchTerms: [ "Dungeons & Dragons", "crossbones", "d&d", "dark arts", "death", "dnd", "documentation", "evil", "fantasy", "halloween", "holiday", "read", "skull", "spell" ]
        }, {
            title: "fas fa-book-open",
            searchTerms: [ "flyer", "notebook", "open book", "pamphlet", "reading" ]
        }, {
            title: "fas fa-book-reader",
            searchTerms: [ "library" ]
        }, {
            title: "fas fa-bookmark",
            searchTerms: [ "save" ]
        }, {
            title: "far fa-bookmark",
            searchTerms: [ "save" ]
        }, {
            title: "fas fa-bowling-ball",
            searchTerms: []
        }, {
            title: "fas fa-box",
            searchTerms: [ "package" ]
        }, {
            title: "fas fa-box-open",
            searchTerms: []
        }, {
            title: "fas fa-boxes",
            searchTerms: []
        }, {
            title: "fas fa-braille",
            searchTerms: []
        }, {
            title: "fas fa-brain",
            searchTerms: [ "cerebellum", "gray matter", "intellect", "medulla oblongata", "mind", "noodle", "wit" ]
        }, {
            title: "fas fa-briefcase",
            searchTerms: [ "bag", "business", "luggage", "office", "work" ]
        }, {
            title: "fas fa-briefcase-medical",
            searchTerms: [ "health briefcase" ]
        }, {
            title: "fas fa-broadcast-tower",
            searchTerms: [ "airwaves", "radio", "waves" ]
        }, {
            title: "fas fa-broom",
            searchTerms: [ "clean", "firebolt", "fly", "halloween", "holiday", "nimbus 2000", "quidditch", "sweep", "witch" ]
        }, {
            title: "fas fa-brush",
            searchTerms: [ "bristles", "color", "handle", "painting" ]
        }, {
            title: "fab fa-btc",
            searchTerms: []
        }, {
            title: "fas fa-bug",
            searchTerms: [ "insect", "report" ]
        }, {
            title: "fas fa-building",
            searchTerms: [ "apartment", "business", "company", "office", "work" ]
        }, {
            title: "far fa-building",
            searchTerms: [ "apartment", "business", "company", "office", "work" ]
        }, {
            title: "fas fa-bullhorn",
            searchTerms: [ "announcement", "broadcast", "louder", "megaphone", "share" ]
        }, {
            title: "fas fa-bullseye",
            searchTerms: [ "target" ]
        }, {
            title: "fas fa-burn",
            searchTerms: [ "energy" ]
        }, {
            title: "fab fa-buromobelexperte",
            searchTerms: []
        }, {
            title: "fas fa-bus",
            searchTerms: [ "machine", "public transportation", "transportation", "vehicle" ]
        }, {
            title: "fas fa-bus-alt",
            searchTerms: [ "machine", "public transportation", "transportation", "vehicle" ]
        }, {
            title: "fas fa-business-time",
            searchTerms: [ "briefcase", "business socks", "clock", "flight of the conchords", "wednesday" ]
        }, {
            title: "fab fa-buysellads",
            searchTerms: []
        }, {
            title: "fas fa-calculator",
            searchTerms: []
        }, {
            title: "fas fa-calendar",
            searchTerms: [ "calendar-o", "date", "event", "schedule", "time", "when" ]
        }, {
            title: "far fa-calendar",
            searchTerms: [ "calendar-o", "date", "event", "schedule", "time", "when" ]
        }, {
            title: "fas fa-calendar-alt",
            searchTerms: [ "calendar", "date", "event", "schedule", "time", "when" ]
        }, {
            title: "far fa-calendar-alt",
            searchTerms: [ "calendar", "date", "event", "schedule", "time", "when" ]
        }, {
            title: "fas fa-calendar-check",
            searchTerms: [ "accept", "agree", "appointment", "confirm", "correct", "done", "ok", "select", "success", "todo" ]
        }, {
            title: "far fa-calendar-check",
            searchTerms: [ "accept", "agree", "appointment", "confirm", "correct", "done", "ok", "select", "success", "todo" ]
        }, {
            title: "fas fa-calendar-minus",
            searchTerms: [ "delete", "negative", "remove" ]
        }, {
            title: "far fa-calendar-minus",
            searchTerms: [ "delete", "negative", "remove" ]
        }, {
            title: "fas fa-calendar-plus",
            searchTerms: [ "add", "create", "new", "positive" ]
        }, {
            title: "far fa-calendar-plus",
            searchTerms: [ "add", "create", "new", "positive" ]
        }, {
            title: "fas fa-calendar-times",
            searchTerms: [ "archive", "delete", "remove", "x" ]
        }, {
            title: "far fa-calendar-times",
            searchTerms: [ "archive", "delete", "remove", "x" ]
        }, {
            title: "fas fa-camera",
            searchTerms: [ "photo", "picture", "record" ]
        }, {
            title: "fas fa-camera-retro",
            searchTerms: [ "photo", "picture", "record" ]
        }, {
            title: "fas fa-campground",
            searchTerms: [ "camping", "fall", "outdoors", "seasonal", "tent" ]
        }, {
            title: "fas fa-cannabis",
            searchTerms: [ "bud", "chronic", "drugs", "endica", "endo", "ganja", "marijuana", "mary jane", "pot", "reefer", "sativa", "spliff", "weed", "whacky-tabacky" ]
        }, {
            title: "fas fa-capsules",
            searchTerms: [ "drugs", "medicine" ]
        }, {
            title: "fas fa-car",
            searchTerms: [ "machine", "transportation", "vehicle" ]
        }, {
            title: "fas fa-car-alt",
            searchTerms: []
        }, {
            title: "fas fa-car-battery",
            searchTerms: []
        }, {
            title: "fas fa-car-crash",
            searchTerms: []
        }, {
            title: "fas fa-car-side",
            searchTerms: []
        }, {
            title: "fas fa-caret-down",
            searchTerms: [ "arrow", "dropdown", "menu", "more", "triangle down" ]
        }, {
            title: "fas fa-caret-left",
            searchTerms: [ "arrow", "back", "previous", "triangle left" ]
        }, {
            title: "fas fa-caret-right",
            searchTerms: [ "arrow", "forward", "next", "triangle right" ]
        }, {
            title: "fas fa-caret-square-down",
            searchTerms: [ "caret-square-o-down", "dropdown", "menu", "more" ]
        }, {
            title: "far fa-caret-square-down",
            searchTerms: [ "caret-square-o-down", "dropdown", "menu", "more" ]
        }, {
            title: "fas fa-caret-square-left",
            searchTerms: [ "back", "caret-square-o-left", "previous" ]
        }, {
            title: "far fa-caret-square-left",
            searchTerms: [ "back", "caret-square-o-left", "previous" ]
        }, {
            title: "fas fa-caret-square-right",
            searchTerms: [ "caret-square-o-right", "forward", "next" ]
        }, {
            title: "far fa-caret-square-right",
            searchTerms: [ "caret-square-o-right", "forward", "next" ]
        }, {
            title: "fas fa-caret-square-up",
            searchTerms: [ "caret-square-o-up" ]
        }, {
            title: "far fa-caret-square-up",
            searchTerms: [ "caret-square-o-up" ]
        }, {
            title: "fas fa-caret-up",
            searchTerms: [ "arrow", "triangle up" ]
        }, {
            title: "fas fa-cart-arrow-down",
            searchTerms: [ "shopping" ]
        }, {
            title: "fas fa-cart-plus",
            searchTerms: [ "add", "create", "new", "positive", "shopping" ]
        }, {
            title: "fas fa-cat",
            searchTerms: [ "feline", "halloween", "holiday", "kitten", "kitty", "meow", "pet" ]
        }, {
            title: "fab fa-cc-amazon-pay",
            searchTerms: []
        }, {
            title: "fab fa-cc-amex",
            searchTerms: [ "amex" ]
        }, {
            title: "fab fa-cc-apple-pay",
            searchTerms: []
        }, {
            title: "fab fa-cc-diners-club",
            searchTerms: []
        }, {
            title: "fab fa-cc-discover",
            searchTerms: []
        }, {
            title: "fab fa-cc-jcb",
            searchTerms: []
        }, {
            title: "fab fa-cc-mastercard",
            searchTerms: []
        }, {
            title: "fab fa-cc-paypal",
            searchTerms: []
        }, {
            title: "fab fa-cc-stripe",
            searchTerms: []
        }, {
            title: "fab fa-cc-visa",
            searchTerms: []
        }, {
            title: "fab fa-centercode",
            searchTerms: []
        }, {
            title: "fas fa-certificate",
            searchTerms: [ "badge", "star" ]
        }, {
            title: "fas fa-chair",
            searchTerms: [ "furniture", "seat" ]
        }, {
            title: "fas fa-chalkboard",
            searchTerms: [ "blackboard", "learning", "school", "teaching", "whiteboard", "writing" ]
        }, {
            title: "fas fa-chalkboard-teacher",
            searchTerms: [ "blackboard", "instructor", "learning", "professor", "school", "whiteboard", "writing" ]
        }, {
            title: "fas fa-charging-station",
            searchTerms: []
        }, {
            title: "fas fa-chart-area",
            searchTerms: [ "analytics", "area-chart", "graph" ]
        }, {
            title: "fas fa-chart-bar",
            searchTerms: [ "analytics", "bar-chart", "graph" ]
        }, {
            title: "far fa-chart-bar",
            searchTerms: [ "analytics", "bar-chart", "graph" ]
        }, {
            title: "fas fa-chart-line",
            searchTerms: [ "activity", "analytics", "dashboard", "graph", "line-chart" ]
        }, {
            title: "fas fa-chart-pie",
            searchTerms: [ "analytics", "graph", "pie-chart" ]
        }, {
            title: "fas fa-check",
            searchTerms: [ "accept", "agree", "checkmark", "confirm", "correct", "done", "notice", "notification", "notify", "ok", "select", "success", "tick", "todo", "yes" ]
        }, {
            title: "fas fa-check-circle",
            searchTerms: [ "accept", "agree", "confirm", "correct", "done", "ok", "select", "success", "todo", "yes" ]
        }, {
            title: "far fa-check-circle",
            searchTerms: [ "accept", "agree", "confirm", "correct", "done", "ok", "select", "success", "todo", "yes" ]
        }, {
            title: "fas fa-check-double",
            searchTerms: [ "accept", "agree", "checkmark", "confirm", "correct", "done", "notice", "notification", "notify", "ok", "select", "success", "tick", "todo" ]
        }, {
            title: "fas fa-check-square",
            searchTerms: [ "accept", "agree", "checkmark", "confirm", "correct", "done", "ok", "select", "success", "todo", "yes" ]
        }, {
            title: "far fa-check-square",
            searchTerms: [ "accept", "agree", "checkmark", "confirm", "correct", "done", "ok", "select", "success", "todo", "yes" ]
        }, {
            title: "fas fa-chess",
            searchTerms: []
        }, {
            title: "fas fa-chess-bishop",
            searchTerms: []
        }, {
            title: "fas fa-chess-board",
            searchTerms: []
        }, {
            title: "fas fa-chess-king",
            searchTerms: []
        }, {
            title: "fas fa-chess-knight",
            searchTerms: []
        }, {
            title: "fas fa-chess-pawn",
            searchTerms: []
        }, {
            title: "fas fa-chess-queen",
            searchTerms: []
        }, {
            title: "fas fa-chess-rook",
            searchTerms: []
        }, {
            title: "fas fa-chevron-circle-down",
            searchTerms: [ "arrow", "dropdown", "menu", "more" ]
        }, {
            title: "fas fa-chevron-circle-left",
            searchTerms: [ "arrow", "back", "previous" ]
        }, {
            title: "fas fa-chevron-circle-right",
            searchTerms: [ "arrow", "forward", "next" ]
        }, {
            title: "fas fa-chevron-circle-up",
            searchTerms: [ "arrow" ]
        }, {
            title: "fas fa-chevron-down",
            searchTerms: []
        }, {
            title: "fas fa-chevron-left",
            searchTerms: [ "back", "bracket", "previous" ]
        }, {
            title: "fas fa-chevron-right",
            searchTerms: [ "bracket", "forward", "next" ]
        }, {
            title: "fas fa-chevron-up",
            searchTerms: []
        }, {
            title: "fas fa-child",
            searchTerms: []
        }, {
            title: "fab fa-chrome",
            searchTerms: [ "browser" ]
        }, {
            title: "fas fa-church",
            searchTerms: [ "building", "community", "religion" ]
        }, {
            title: "fas fa-circle",
            searchTerms: [ "circle-thin", "dot", "notification" ]
        }, {
            title: "far fa-circle",
            searchTerms: [ "circle-thin", "dot", "notification" ]
        }, {
            title: "fas fa-circle-notch",
            searchTerms: [ "circle-o-notch" ]
        }, {
            title: "fas fa-city",
            searchTerms: [ "buildings", "busy", "skyscrapers", "urban", "windows" ]
        }, {
            title: "fas fa-clipboard",
            searchTerms: [ "paste" ]
        }, {
            title: "far fa-clipboard",
            searchTerms: [ "paste" ]
        }, {
            title: "fas fa-clipboard-check",
            searchTerms: [ "accept", "agree", "confirm", "done", "ok", "select", "success", "todo", "yes" ]
        }, {
            title: "fas fa-clipboard-list",
            searchTerms: [ "checklist", "completed", "done", "finished", "intinerary", "ol", "schedule", "todo", "ul" ]
        }, {
            title: "fas fa-clock",
            searchTerms: [ "date", "late", "schedule", "timer", "timestamp", "watch" ]
        }, {
            title: "far fa-clock",
            searchTerms: [ "date", "late", "schedule", "timer", "timestamp", "watch" ]
        }, {
            title: "fas fa-clone",
            searchTerms: [ "copy", "duplicate" ]
        }, {
            title: "far fa-clone",
            searchTerms: [ "copy", "duplicate" ]
        }, {
            title: "fas fa-closed-captioning",
            searchTerms: [ "cc" ]
        }, {
            title: "far fa-closed-captioning",
            searchTerms: [ "cc" ]
        }, {
            title: "fas fa-cloud",
            searchTerms: [ "save" ]
        }, {
            title: "fas fa-cloud-download-alt",
            searchTerms: [ "import" ]
        }, {
            title: "fas fa-cloud-meatball",
            searchTerms: []
        }, {
            title: "fas fa-cloud-moon",
            searchTerms: [ "crescent", "evening", "halloween", "holiday", "lunar", "night", "sky" ]
        }, {
            title: "fas fa-cloud-moon-rain",
            searchTerms: []
        }, {
            title: "fas fa-cloud-rain",
            searchTerms: [ "precipitation" ]
        }, {
            title: "fas fa-cloud-showers-heavy",
            searchTerms: [ "precipitation", "rain", "storm" ]
        }, {
            title: "fas fa-cloud-sun",
            searchTerms: [ "day", "daytime", "fall", "outdoors", "seasonal" ]
        }, {
            title: "fas fa-cloud-sun-rain",
            searchTerms: []
        }, {
            title: "fas fa-cloud-upload-alt",
            searchTerms: [ "cloud-upload" ]
        }, {
            title: "fab fa-cloudscale",
            searchTerms: []
        }, {
            title: "fab fa-cloudsmith",
            searchTerms: []
        }, {
            title: "fab fa-cloudversify",
            searchTerms: []
        }, {
            title: "fas fa-cocktail",
            searchTerms: [ "alcohol", "beverage", "drink" ]
        }, {
            title: "fas fa-code",
            searchTerms: [ "brackets", "html" ]
        }, {
            title: "fas fa-code-branch",
            searchTerms: [ "branch", "code-fork", "fork", "git", "github", "rebase", "svn", "vcs", "version" ]
        }, {
            title: "fab fa-codepen",
            searchTerms: []
        }, {
            title: "fab fa-codiepie",
            searchTerms: []
        }, {
            title: "fas fa-coffee",
            searchTerms: [ "beverage", "breakfast", "cafe", "drink", "fall", "morning", "mug", "seasonal", "tea" ]
        }, {
            title: "fas fa-cog",
            searchTerms: [ "settings" ]
        }, {
            title: "fas fa-cogs",
            searchTerms: [ "gears", "settings" ]
        }, {
            title: "fas fa-coins",
            searchTerms: []
        }, {
            title: "fas fa-columns",
            searchTerms: [ "dashboard", "panes", "split" ]
        }, {
            title: "fas fa-comment",
            searchTerms: [ "bubble", "chat", "conversation", "feedback", "message", "note", "notification", "sms", "speech", "texting" ]
        }, {
            title: "far fa-comment",
            searchTerms: [ "bubble", "chat", "conversation", "feedback", "message", "note", "notification", "sms", "speech", "texting" ]
        }, {
            title: "fas fa-comment-alt",
            searchTerms: [ "bubble", "chat", "commenting", "conversation", "feedback", "message", "note", "notification", "sms", "speech", "texting" ]
        }, {
            title: "far fa-comment-alt",
            searchTerms: [ "bubble", "chat", "commenting", "conversation", "feedback", "message", "note", "notification", "sms", "speech", "texting" ]
        }, {
            title: "fas fa-comment-dollar",
            searchTerms: []
        }, {
            title: "fas fa-comment-dots",
            searchTerms: []
        }, {
            title: "far fa-comment-dots",
            searchTerms: []
        }, {
            title: "fas fa-comment-slash",
            searchTerms: []
        }, {
            title: "fas fa-comments",
            searchTerms: [ "bubble", "chat", "conversation", "feedback", "message", "note", "notification", "sms", "speech", "texting" ]
        }, {
            title: "far fa-comments",
            searchTerms: [ "bubble", "chat", "conversation", "feedback", "message", "note", "notification", "sms", "speech", "texting" ]
        }, {
            title: "fas fa-comments-dollar",
            searchTerms: []
        }, {
            title: "fas fa-compact-disc",
            searchTerms: [ "bluray", "cd", "disc", "media" ]
        }, {
            title: "fas fa-compass",
            searchTerms: [ "directory", "location", "menu", "safari" ]
        }, {
            title: "far fa-compass",
            searchTerms: [ "directory", "location", "menu", "safari" ]
        }, {
            title: "fas fa-compress",
            searchTerms: [ "collapse", "combine", "contract", "merge", "smaller" ]
        }, {
            title: "fas fa-concierge-bell",
            searchTerms: [ "attention", "hotel", "service", "support" ]
        }, {
            title: "fab fa-connectdevelop",
            searchTerms: []
        }, {
            title: "fab fa-contao",
            searchTerms: []
        }, {
            title: "fas fa-cookie",
            searchTerms: [ "baked good", "chips", "food", "snack", "sweet", "treat" ]
        }, {
            title: "fas fa-cookie-bite",
            searchTerms: [ "baked good", "bitten", "chips", "eating", "food", "snack", "sweet", "treat" ]
        }, {
            title: "fas fa-copy",
            searchTerms: [ "clone", "duplicate", "file", "files-o" ]
        }, {
            title: "far fa-copy",
            searchTerms: [ "clone", "duplicate", "file", "files-o" ]
        }, {
            title: "fas fa-copyright",
            searchTerms: []
        }, {
            title: "far fa-copyright",
            searchTerms: []
        }, {
            title: "fas fa-couch",
            searchTerms: [ "furniture", "sofa" ]
        }, {
            title: "fab fa-cpanel",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-by",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-nc",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-nc-eu",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-nc-jp",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-nd",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-pd",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-pd-alt",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-remix",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-sa",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-sampling",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-sampling-plus",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-share",
            searchTerms: []
        }, {
            title: "fab fa-creative-commons-zero",
            searchTerms: []
        }, {
            title: "fas fa-credit-card",
            searchTerms: [ "buy", "checkout", "credit-card-alt", "debit", "money", "payment", "purchase" ]
        }, {
            title: "far fa-credit-card",
            searchTerms: [ "buy", "checkout", "credit-card-alt", "debit", "money", "payment", "purchase" ]
        }, {
            title: "fab fa-critical-role",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "game", "gaming", "tabletop" ]
        }, {
            title: "fas fa-crop",
            searchTerms: [ "design" ]
        }, {
            title: "fas fa-crop-alt",
            searchTerms: []
        }, {
            title: "fas fa-cross",
            searchTerms: [ "catholicism", "christianity" ]
        }, {
            title: "fas fa-crosshairs",
            searchTerms: [ "gpd", "picker", "position" ]
        }, {
            title: "fas fa-crow",
            searchTerms: [ "bird", "bullfrog", "fauna", "halloween", "holiday", "toad" ]
        }, {
            title: "fas fa-crown",
            searchTerms: []
        }, {
            title: "fab fa-css3",
            searchTerms: [ "code" ]
        }, {
            title: "fab fa-css3-alt",
            searchTerms: []
        }, {
            title: "fas fa-cube",
            searchTerms: [ "package" ]
        }, {
            title: "fas fa-cubes",
            searchTerms: [ "packages" ]
        }, {
            title: "fas fa-cut",
            searchTerms: [ "scissors" ]
        }, {
            title: "fab fa-cuttlefish",
            searchTerms: []
        }, {
            title: "fab fa-d-and-d",
            searchTerms: []
        }, {
            title: "fab fa-d-and-d-beyond",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "gaming", "tabletop" ]
        }, {
            title: "fab fa-dashcube",
            searchTerms: []
        }, {
            title: "fas fa-database",
            searchTerms: []
        }, {
            title: "fas fa-deaf",
            searchTerms: []
        }, {
            title: "fab fa-delicious",
            searchTerms: []
        }, {
            title: "fas fa-democrat",
            searchTerms: [ "american", "democratic party", "donkey", "election", "left", "left-wing", "liberal", "politics", "usa" ]
        }, {
            title: "fab fa-deploydog",
            searchTerms: []
        }, {
            title: "fab fa-deskpro",
            searchTerms: []
        }, {
            title: "fas fa-desktop",
            searchTerms: [ "computer", "cpu", "demo", "desktop", "device", "machine", "monitor", "pc", "screen" ]
        }, {
            title: "fab fa-dev",
            searchTerms: []
        }, {
            title: "fab fa-deviantart",
            searchTerms: []
        }, {
            title: "fas fa-dharmachakra",
            searchTerms: [ "buddhism", "buddhist", "wheel of dharma" ]
        }, {
            title: "fas fa-diagnoses",
            searchTerms: []
        }, {
            title: "fas fa-dice",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-d20",
            searchTerms: [ "Dungeons & Dragons", "chance", "d&d", "dnd", "fantasy", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-d6",
            searchTerms: [ "Dungeons & Dragons", "chance", "d&d", "dnd", "fantasy", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-five",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-four",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-one",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-six",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-three",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fas fa-dice-two",
            searchTerms: [ "chance", "gambling", "game", "roll" ]
        }, {
            title: "fab fa-digg",
            searchTerms: []
        }, {
            title: "fab fa-digital-ocean",
            searchTerms: []
        }, {
            title: "fas fa-digital-tachograph",
            searchTerms: []
        }, {
            title: "fas fa-directions",
            searchTerms: []
        }, {
            title: "fab fa-discord",
            searchTerms: []
        }, {
            title: "fab fa-discourse",
            searchTerms: []
        }, {
            title: "fas fa-divide",
            searchTerms: []
        }, {
            title: "fas fa-dizzy",
            searchTerms: [ "dazed", "disapprove", "emoticon", "face" ]
        }, {
            title: "far fa-dizzy",
            searchTerms: [ "dazed", "disapprove", "emoticon", "face" ]
        }, {
            title: "fas fa-dna",
            searchTerms: [ "double helix", "helix" ]
        }, {
            title: "fab fa-dochub",
            searchTerms: []
        }, {
            title: "fab fa-docker",
            searchTerms: []
        }, {
            title: "fas fa-dog",
            searchTerms: [ "canine", "fauna", "mammmal", "pet", "pooch", "puppy", "woof" ]
        }, {
            title: "fas fa-dollar-sign",
            searchTerms: [ "$", "dollar-sign", "money", "price", "usd" ]
        }, {
            title: "fas fa-dolly",
            searchTerms: []
        }, {
            title: "fas fa-dolly-flatbed",
            searchTerms: []
        }, {
            title: "fas fa-donate",
            searchTerms: [ "generosity", "give" ]
        }, {
            title: "fas fa-door-closed",
            searchTerms: []
        }, {
            title: "fas fa-door-open",
            searchTerms: []
        }, {
            title: "fas fa-dot-circle",
            searchTerms: [ "bullseye", "notification", "target" ]
        }, {
            title: "far fa-dot-circle",
            searchTerms: [ "bullseye", "notification", "target" ]
        }, {
            title: "fas fa-dove",
            searchTerms: [ "bird", "fauna", "flying", "peace" ]
        }, {
            title: "fas fa-download",
            searchTerms: [ "import" ]
        }, {
            title: "fab fa-draft2digital",
            searchTerms: []
        }, {
            title: "fas fa-drafting-compass",
            searchTerms: [ "mechanical drawing", "plot", "plotting" ]
        }, {
            title: "fas fa-dragon",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy" ]
        }, {
            title: "fas fa-draw-polygon",
            searchTerms: []
        }, {
            title: "fab fa-dribbble",
            searchTerms: []
        }, {
            title: "fab fa-dribbble-square",
            searchTerms: []
        }, {
            title: "fab fa-dropbox",
            searchTerms: []
        }, {
            title: "fas fa-drum",
            searchTerms: [ "instrument", "music", "percussion", "snare", "sound" ]
        }, {
            title: "fas fa-drum-steelpan",
            searchTerms: [ "calypso", "instrument", "music", "percussion", "reggae", "snare", "sound", "steel", "tropical" ]
        }, {
            title: "fas fa-drumstick-bite",
            searchTerms: []
        }, {
            title: "fab fa-drupal",
            searchTerms: []
        }, {
            title: "fas fa-dumbbell",
            searchTerms: [ "exercise", "gym", "strength", "weight", "weight-lifting" ]
        }, {
            title: "fas fa-dungeon",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "door", "entrance", "fantasy", "gate" ]
        }, {
            title: "fab fa-dyalog",
            searchTerms: []
        }, {
            title: "fab fa-earlybirds",
            searchTerms: []
        }, {
            title: "fab fa-ebay",
            searchTerms: []
        }, {
            title: "fab fa-edge",
            searchTerms: [ "browser", "ie" ]
        }, {
            title: "fas fa-edit",
            searchTerms: [ "edit", "pen", "pencil", "update", "write" ]
        }, {
            title: "far fa-edit",
            searchTerms: [ "edit", "pen", "pencil", "update", "write" ]
        }, {
            title: "fas fa-eject",
            searchTerms: []
        }, {
            title: "fab fa-elementor",
            searchTerms: []
        }, {
            title: "fas fa-ellipsis-h",
            searchTerms: [ "dots", "drag", "kebab", "list", "menu", "nav", "navigation", "ol", "reorder", "settings", "ul" ]
        }, {
            title: "fas fa-ellipsis-v",
            searchTerms: [ "dots", "drag", "kebab", "list", "menu", "nav", "navigation", "ol", "reorder", "settings", "ul" ]
        }, {
            title: "fab fa-ello",
            searchTerms: []
        }, {
            title: "fab fa-ember",
            searchTerms: []
        }, {
            title: "fab fa-empire",
            searchTerms: []
        }, {
            title: "fas fa-envelope",
            searchTerms: [ "e-mail", "email", "letter", "mail", "message", "notification", "support" ]
        }, {
            title: "far fa-envelope",
            searchTerms: [ "e-mail", "email", "letter", "mail", "message", "notification", "support" ]
        }, {
            title: "fas fa-envelope-open",
            searchTerms: [ "e-mail", "email", "letter", "mail", "message", "notification", "support" ]
        }, {
            title: "far fa-envelope-open",
            searchTerms: [ "e-mail", "email", "letter", "mail", "message", "notification", "support" ]
        }, {
            title: "fas fa-envelope-open-text",
            searchTerms: []
        }, {
            title: "fas fa-envelope-square",
            searchTerms: [ "e-mail", "email", "letter", "mail", "message", "notification", "support" ]
        }, {
            title: "fab fa-envira",
            searchTerms: [ "leaf" ]
        }, {
            title: "fas fa-equals",
            searchTerms: []
        }, {
            title: "fas fa-eraser",
            searchTerms: [ "delete", "remove" ]
        }, {
            title: "fab fa-erlang",
            searchTerms: []
        }, {
            title: "fab fa-ethereum",
            searchTerms: []
        }, {
            title: "fab fa-etsy",
            searchTerms: []
        }, {
            title: "fas fa-euro-sign",
            searchTerms: [ "eur" ]
        }, {
            title: "fas fa-exchange-alt",
            searchTerms: [ "arrow", "arrows", "exchange", "reciprocate", "return", "swap", "transfer" ]
        }, {
            title: "fas fa-exclamation",
            searchTerms: [ "alert", "danger", "error", "important", "notice", "notification", "notify", "problem", "warning" ]
        }, {
            title: "fas fa-exclamation-circle",
            searchTerms: [ "alert", "danger", "error", "important", "notice", "notification", "notify", "problem", "warning" ]
        }, {
            title: "fas fa-exclamation-triangle",
            searchTerms: [ "alert", "danger", "error", "important", "notice", "notification", "notify", "problem", "warning" ]
        }, {
            title: "fas fa-expand",
            searchTerms: [ "bigger", "enlarge", "resize" ]
        }, {
            title: "fas fa-expand-arrows-alt",
            searchTerms: [ "arrows-alt", "bigger", "enlarge", "move", "resize" ]
        }, {
            title: "fab fa-expeditedssl",
            searchTerms: []
        }, {
            title: "fas fa-external-link-alt",
            searchTerms: [ "external-link", "new", "open" ]
        }, {
            title: "fas fa-external-link-square-alt",
            searchTerms: [ "external-link-square", "new", "open" ]
        }, {
            title: "fas fa-eye",
            searchTerms: [ "optic", "see", "seen", "show", "sight", "views", "visible" ]
        }, {
            title: "far fa-eye",
            searchTerms: [ "optic", "see", "seen", "show", "sight", "views", "visible" ]
        }, {
            title: "fas fa-eye-dropper",
            searchTerms: [ "eyedropper" ]
        }, {
            title: "fas fa-eye-slash",
            searchTerms: [ "blind", "hide", "show", "toggle", "unseen", "views", "visible", "visiblity" ]
        }, {
            title: "far fa-eye-slash",
            searchTerms: [ "blind", "hide", "show", "toggle", "unseen", "views", "visible", "visiblity" ]
        }, {
            title: "fab fa-facebook",
            searchTerms: [ "facebook-official", "social network" ]
        }, {
            title: "fab fa-facebook-f",
            searchTerms: [ "facebook" ]
        }, {
            title: "fab fa-facebook-messenger",
            searchTerms: []
        }, {
            title: "fab fa-facebook-square",
            searchTerms: [ "social network" ]
        }, {
            title: "fab fa-fantasy-flight-games",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "game", "gaming", "tabletop" ]
        }, {
            title: "fas fa-fast-backward",
            searchTerms: [ "beginning", "first", "previous", "rewind", "start" ]
        }, {
            title: "fas fa-fast-forward",
            searchTerms: [ "end", "last", "next" ]
        }, {
            title: "fas fa-fax",
            searchTerms: []
        }, {
            title: "fas fa-feather",
            searchTerms: [ "bird", "light", "plucked", "quill" ]
        }, {
            title: "fas fa-feather-alt",
            searchTerms: [ "bird", "light", "plucked", "quill" ]
        }, {
            title: "fas fa-female",
            searchTerms: [ "human", "person", "profile", "user", "woman" ]
        }, {
            title: "fas fa-fighter-jet",
            searchTerms: [ "airplane", "fast", "fly", "goose", "maverick", "plane", "quick", "top gun", "transportation", "travel" ]
        }, {
            title: "fas fa-file",
            searchTerms: [ "document", "new", "page", "pdf", "resume" ]
        }, {
            title: "far fa-file",
            searchTerms: [ "document", "new", "page", "pdf", "resume" ]
        }, {
            title: "fas fa-file-alt",
            searchTerms: [ "document", "file-text", "invoice", "new", "page", "pdf" ]
        }, {
            title: "far fa-file-alt",
            searchTerms: [ "document", "file-text", "invoice", "new", "page", "pdf" ]
        }, {
            title: "fas fa-file-archive",
            searchTerms: [ ".zip", "bundle", "compress", "compression", "download", "zip" ]
        }, {
            title: "far fa-file-archive",
            searchTerms: [ ".zip", "bundle", "compress", "compression", "download", "zip" ]
        }, {
            title: "fas fa-file-audio",
            searchTerms: []
        }, {
            title: "far fa-file-audio",
            searchTerms: []
        }, {
            title: "fas fa-file-code",
            searchTerms: []
        }, {
            title: "far fa-file-code",
            searchTerms: []
        }, {
            title: "fas fa-file-contract",
            searchTerms: [ "agreement", "binding", "document", "legal", "signature" ]
        }, {
            title: "fas fa-file-csv",
            searchTerms: [ "spreadsheets" ]
        }, {
            title: "fas fa-file-download",
            searchTerms: []
        }, {
            title: "fas fa-file-excel",
            searchTerms: []
        }, {
            title: "far fa-file-excel",
            searchTerms: []
        }, {
            title: "fas fa-file-export",
            searchTerms: []
        }, {
            title: "fas fa-file-image",
            searchTerms: []
        }, {
            title: "far fa-file-image",
            searchTerms: []
        }, {
            title: "fas fa-file-import",
            searchTerms: []
        }, {
            title: "fas fa-file-invoice",
            searchTerms: [ "bill", "document", "receipt" ]
        }, {
            title: "fas fa-file-invoice-dollar",
            searchTerms: [ "$", "bill", "document", "dollar-sign", "money", "receipt", "usd" ]
        }, {
            title: "fas fa-file-medical",
            searchTerms: []
        }, {
            title: "fas fa-file-medical-alt",
            searchTerms: []
        }, {
            title: "fas fa-file-pdf",
            searchTerms: []
        }, {
            title: "far fa-file-pdf",
            searchTerms: []
        }, {
            title: "fas fa-file-powerpoint",
            searchTerms: []
        }, {
            title: "far fa-file-powerpoint",
            searchTerms: []
        }, {
            title: "fas fa-file-prescription",
            searchTerms: [ "drugs", "medical", "medicine", "rx" ]
        }, {
            title: "fas fa-file-signature",
            searchTerms: [ "John Hancock", "contract", "document", "name" ]
        }, {
            title: "fas fa-file-upload",
            searchTerms: []
        }, {
            title: "fas fa-file-video",
            searchTerms: []
        }, {
            title: "far fa-file-video",
            searchTerms: []
        }, {
            title: "fas fa-file-word",
            searchTerms: []
        }, {
            title: "far fa-file-word",
            searchTerms: []
        }, {
            title: "fas fa-fill",
            searchTerms: [ "bucket", "color", "paint", "paint bucket" ]
        }, {
            title: "fas fa-fill-drip",
            searchTerms: [ "bucket", "color", "drop", "paint", "paint bucket", "spill" ]
        }, {
            title: "fas fa-film",
            searchTerms: [ "movie" ]
        }, {
            title: "fas fa-filter",
            searchTerms: [ "funnel", "options" ]
        }, {
            title: "fas fa-fingerprint",
            searchTerms: [ "human", "id", "identification", "lock", "smudge", "touch", "unique", "unlock" ]
        }, {
            title: "fas fa-fire",
            searchTerms: [ "caliente", "flame", "heat", "hot", "popular" ]
        }, {
            title: "fas fa-fire-extinguisher",
            searchTerms: []
        }, {
            title: "fab fa-firefox",
            searchTerms: [ "browser" ]
        }, {
            title: "fas fa-first-aid",
            searchTerms: []
        }, {
            title: "fab fa-first-order",
            searchTerms: []
        }, {
            title: "fab fa-first-order-alt",
            searchTerms: []
        }, {
            title: "fab fa-firstdraft",
            searchTerms: []
        }, {
            title: "fas fa-fish",
            searchTerms: [ "fauna", "gold", "swimming" ]
        }, {
            title: "fas fa-fist-raised",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "hand", "ki", "monk", "resist", "strength", "unarmed combat" ]
        }, {
            title: "fas fa-flag",
            searchTerms: [ "country", "notice", "notification", "notify", "pole", "report", "symbol" ]
        }, {
            title: "far fa-flag",
            searchTerms: [ "country", "notice", "notification", "notify", "pole", "report", "symbol" ]
        }, {
            title: "fas fa-flag-checkered",
            searchTerms: [ "notice", "notification", "notify", "pole", "racing", "report", "symbol" ]
        }, {
            title: "fas fa-flag-usa",
            searchTerms: [ "betsy ross", "country", "old glory", "stars", "stripes", "symbol" ]
        }, {
            title: "fas fa-flask",
            searchTerms: [ "beaker", "experimental", "labs", "science" ]
        }, {
            title: "fab fa-flickr",
            searchTerms: []
        }, {
            title: "fab fa-flipboard",
            searchTerms: []
        }, {
            title: "fas fa-flushed",
            searchTerms: [ "embarrassed", "emoticon", "face" ]
        }, {
            title: "far fa-flushed",
            searchTerms: [ "embarrassed", "emoticon", "face" ]
        }, {
            title: "fab fa-fly",
            searchTerms: []
        }, {
            title: "fas fa-folder",
            searchTerms: []
        }, {
            title: "far fa-folder",
            searchTerms: []
        }, {
            title: "fas fa-folder-minus",
            searchTerms: [ "archive", "delete", "negative", "remove" ]
        }, {
            title: "fas fa-folder-open",
            searchTerms: []
        }, {
            title: "far fa-folder-open",
            searchTerms: []
        }, {
            title: "fas fa-folder-plus",
            searchTerms: [ "add", "create", "new", "positive" ]
        }, {
            title: "fas fa-font",
            searchTerms: [ "text" ]
        }, {
            title: "fab fa-font-awesome",
            searchTerms: [ "meanpath" ]
        }, {
            title: "fab fa-font-awesome-alt",
            searchTerms: []
        }, {
            title: "fab fa-font-awesome-flag",
            searchTerms: []
        }, {
            title: "far fa-font-awesome-logo-full",
            searchTerms: []
        }, {
            title: "fas fa-font-awesome-logo-full",
            searchTerms: []
        }, {
            title: "fab fa-font-awesome-logo-full",
            searchTerms: []
        }, {
            title: "fab fa-fonticons",
            searchTerms: []
        }, {
            title: "fab fa-fonticons-fi",
            searchTerms: []
        }, {
            title: "fas fa-football-ball",
            searchTerms: [ "fall", "pigskin", "seasonal" ]
        }, {
            title: "fab fa-fort-awesome",
            searchTerms: [ "castle" ]
        }, {
            title: "fab fa-fort-awesome-alt",
            searchTerms: [ "castle" ]
        }, {
            title: "fab fa-forumbee",
            searchTerms: []
        }, {
            title: "fas fa-forward",
            searchTerms: [ "forward", "next" ]
        }, {
            title: "fab fa-foursquare",
            searchTerms: []
        }, {
            title: "fab fa-free-code-camp",
            searchTerms: []
        }, {
            title: "fab fa-freebsd",
            searchTerms: []
        }, {
            title: "fas fa-frog",
            searchTerms: [ "amphibian", "bullfrog", "fauna", "hop", "kermit", "kiss", "prince", "ribbit", "toad", "wart" ]
        }, {
            title: "fas fa-frown",
            searchTerms: [ "disapprove", "emoticon", "face", "rating", "sad" ]
        }, {
            title: "far fa-frown",
            searchTerms: [ "disapprove", "emoticon", "face", "rating", "sad" ]
        }, {
            title: "fas fa-frown-open",
            searchTerms: [ "disapprove", "emoticon", "face", "rating", "sad" ]
        }, {
            title: "far fa-frown-open",
            searchTerms: [ "disapprove", "emoticon", "face", "rating", "sad" ]
        }, {
            title: "fab fa-fulcrum",
            searchTerms: []
        }, {
            title: "fas fa-funnel-dollar",
            searchTerms: []
        }, {
            title: "fas fa-futbol",
            searchTerms: [ "ball", "football", "soccer" ]
        }, {
            title: "far fa-futbol",
            searchTerms: [ "ball", "football", "soccer" ]
        }, {
            title: "fab fa-galactic-republic",
            searchTerms: [ "politics", "star wars" ]
        }, {
            title: "fab fa-galactic-senate",
            searchTerms: [ "star wars" ]
        }, {
            title: "fas fa-gamepad",
            searchTerms: [ "controller" ]
        }, {
            title: "fas fa-gas-pump",
            searchTerms: []
        }, {
            title: "fas fa-gavel",
            searchTerms: [ "hammer", "judge", "lawyer", "opinion" ]
        }, {
            title: "fas fa-gem",
            searchTerms: [ "diamond" ]
        }, {
            title: "far fa-gem",
            searchTerms: [ "diamond" ]
        }, {
            title: "fas fa-genderless",
            searchTerms: []
        }, {
            title: "fab fa-get-pocket",
            searchTerms: []
        }, {
            title: "fab fa-gg",
            searchTerms: []
        }, {
            title: "fab fa-gg-circle",
            searchTerms: []
        }, {
            title: "fas fa-ghost",
            searchTerms: [ "apparition", "blinky", "clyde", "floating", "halloween", "holiday", "inky", "pinky", "spirit" ]
        }, {
            title: "fas fa-gift",
            searchTerms: [ "generosity", "giving", "party", "present", "wrapped" ]
        }, {
            title: "fab fa-git",
            searchTerms: []
        }, {
            title: "fab fa-git-square",
            searchTerms: []
        }, {
            title: "fab fa-github",
            searchTerms: [ "octocat" ]
        }, {
            title: "fab fa-github-alt",
            searchTerms: [ "octocat" ]
        }, {
            title: "fab fa-github-square",
            searchTerms: [ "octocat" ]
        }, {
            title: "fab fa-gitkraken",
            searchTerms: []
        }, {
            title: "fab fa-gitlab",
            searchTerms: [ "Axosoft" ]
        }, {
            title: "fab fa-gitter",
            searchTerms: []
        }, {
            title: "fas fa-glass-martini",
            searchTerms: [ "alcohol", "bar", "beverage", "drink", "glass", "liquor", "martini" ]
        }, {
            title: "fas fa-glass-martini-alt",
            searchTerms: []
        }, {
            title: "fas fa-glasses",
            searchTerms: [ "foureyes", "hipster", "nerd", "reading", "sight", "spectacles" ]
        }, {
            title: "fab fa-glide",
            searchTerms: []
        }, {
            title: "fab fa-glide-g",
            searchTerms: []
        }, {
            title: "fas fa-globe",
            searchTerms: [ "all", "coordinates", "country", "earth", "global", "gps", "language", "localize", "location", "map", "online", "place", "planet", "translate", "travel", "world" ]
        }, {
            title: "fas fa-globe-africa",
            searchTerms: [ "all", "country", "earth", "global", "gps", "language", "localize", "location", "map", "online", "place", "planet", "translate", "travel", "world" ]
        }, {
            title: "fas fa-globe-americas",
            searchTerms: [ "all", "country", "earth", "global", "gps", "language", "localize", "location", "map", "online", "place", "planet", "translate", "travel", "world" ]
        }, {
            title: "fas fa-globe-asia",
            searchTerms: [ "all", "country", "earth", "global", "gps", "language", "localize", "location", "map", "online", "place", "planet", "translate", "travel", "world" ]
        }, {
            title: "fab fa-gofore",
            searchTerms: []
        }, {
            title: "fas fa-golf-ball",
            searchTerms: []
        }, {
            title: "fab fa-goodreads",
            searchTerms: []
        }, {
            title: "fab fa-goodreads-g",
            searchTerms: []
        }, {
            title: "fab fa-google",
            searchTerms: []
        }, {
            title: "fab fa-google-drive",
            searchTerms: []
        }, {
            title: "fab fa-google-play",
            searchTerms: []
        }, {
            title: "fab fa-google-plus",
            searchTerms: [ "google-plus-circle", "google-plus-official" ]
        }, {
            title: "fab fa-google-plus-g",
            searchTerms: [ "google-plus", "social network" ]
        }, {
            title: "fab fa-google-plus-square",
            searchTerms: [ "social network" ]
        }, {
            title: "fab fa-google-wallet",
            searchTerms: []
        }, {
            title: "fas fa-gopuram",
            searchTerms: [ "building", "entrance", "hinduism", "temple", "tower" ]
        }, {
            title: "fas fa-graduation-cap",
            searchTerms: [ "learning", "school", "student" ]
        }, {
            title: "fab fa-gratipay",
            searchTerms: [ "favorite", "heart", "like", "love" ]
        }, {
            title: "fab fa-grav",
            searchTerms: []
        }, {
            title: "fas fa-greater-than",
            searchTerms: []
        }, {
            title: "fas fa-greater-than-equal",
            searchTerms: []
        }, {
            title: "fas fa-grimace",
            searchTerms: [ "cringe", "emoticon", "face" ]
        }, {
            title: "far fa-grimace",
            searchTerms: [ "cringe", "emoticon", "face" ]
        }, {
            title: "fas fa-grin",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "far fa-grin",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "fas fa-grin-alt",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "far fa-grin-alt",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "fas fa-grin-beam",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "far fa-grin-beam",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "fas fa-grin-beam-sweat",
            searchTerms: [ "emoticon", "face", "smile" ]
        }, {
            title: "far fa-grin-beam-sweat",
            searchTerms: [ "emoticon", "face", "smile" ]
        }, {
            title: "fas fa-grin-hearts",
            searchTerms: [ "emoticon", "face", "love", "smile" ]
        }, {
            title: "far fa-grin-hearts",
            searchTerms: [ "emoticon", "face", "love", "smile" ]
        }, {
            title: "fas fa-grin-squint",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "far fa-grin-squint",
            searchTerms: [ "emoticon", "face", "laugh", "smile" ]
        }, {
            title: "fas fa-grin-squint-tears",
            searchTerms: [ "emoticon", "face", "happy", "smile" ]
        }, {
            title: "far fa-grin-squint-tears",
            searchTerms: [ "emoticon", "face", "happy", "smile" ]
        }, {
            title: "fas fa-grin-stars",
            searchTerms: [ "emoticon", "face", "star-struck" ]
        }, {
            title: "far fa-grin-stars",
            searchTerms: [ "emoticon", "face", "star-struck" ]
        }, {
            title: "fas fa-grin-tears",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-grin-tears",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-grin-tongue",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-grin-tongue",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-grin-tongue-squint",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-grin-tongue-squint",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-grin-tongue-wink",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-grin-tongue-wink",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-grin-wink",
            searchTerms: [ "emoticon", "face", "flirt", "laugh", "smile" ]
        }, {
            title: "far fa-grin-wink",
            searchTerms: [ "emoticon", "face", "flirt", "laugh", "smile" ]
        }, {
            title: "fas fa-grip-horizontal",
            searchTerms: [ "affordance", "drag", "drop", "grab", "handle" ]
        }, {
            title: "fas fa-grip-vertical",
            searchTerms: [ "affordance", "drag", "drop", "grab", "handle" ]
        }, {
            title: "fab fa-gripfire",
            searchTerms: []
        }, {
            title: "fab fa-grunt",
            searchTerms: []
        }, {
            title: "fab fa-gulp",
            searchTerms: []
        }, {
            title: "fas fa-h-square",
            searchTerms: [ "hospital", "hotel" ]
        }, {
            title: "fab fa-hacker-news",
            searchTerms: []
        }, {
            title: "fab fa-hacker-news-square",
            searchTerms: []
        }, {
            title: "fab fa-hackerrank",
            searchTerms: []
        }, {
            title: "fas fa-hammer",
            searchTerms: [ "admin", "fix", "repair", "settings", "tool" ]
        }, {
            title: "fas fa-hamsa",
            searchTerms: [ "amulet", "christianity", "islam", "jewish", "judaism", "muslim", "protection" ]
        }, {
            title: "fas fa-hand-holding",
            searchTerms: []
        }, {
            title: "fas fa-hand-holding-heart",
            searchTerms: []
        }, {
            title: "fas fa-hand-holding-usd",
            searchTerms: [ "$", "dollar sign", "donation", "giving", "money", "price" ]
        }, {
            title: "fas fa-hand-lizard",
            searchTerms: []
        }, {
            title: "far fa-hand-lizard",
            searchTerms: []
        }, {
            title: "fas fa-hand-paper",
            searchTerms: [ "stop" ]
        }, {
            title: "far fa-hand-paper",
            searchTerms: [ "stop" ]
        }, {
            title: "fas fa-hand-peace",
            searchTerms: []
        }, {
            title: "far fa-hand-peace",
            searchTerms: []
        }, {
            title: "fas fa-hand-point-down",
            searchTerms: [ "finger", "hand-o-down", "point" ]
        }, {
            title: "far fa-hand-point-down",
            searchTerms: [ "finger", "hand-o-down", "point" ]
        }, {
            title: "fas fa-hand-point-left",
            searchTerms: [ "back", "finger", "hand-o-left", "left", "point", "previous" ]
        }, {
            title: "far fa-hand-point-left",
            searchTerms: [ "back", "finger", "hand-o-left", "left", "point", "previous" ]
        }, {
            title: "fas fa-hand-point-right",
            searchTerms: [ "finger", "forward", "hand-o-right", "next", "point", "right" ]
        }, {
            title: "far fa-hand-point-right",
            searchTerms: [ "finger", "forward", "hand-o-right", "next", "point", "right" ]
        }, {
            title: "fas fa-hand-point-up",
            searchTerms: [ "finger", "hand-o-up", "point" ]
        }, {
            title: "far fa-hand-point-up",
            searchTerms: [ "finger", "hand-o-up", "point" ]
        }, {
            title: "fas fa-hand-pointer",
            searchTerms: [ "select" ]
        }, {
            title: "far fa-hand-pointer",
            searchTerms: [ "select" ]
        }, {
            title: "fas fa-hand-rock",
            searchTerms: []
        }, {
            title: "far fa-hand-rock",
            searchTerms: []
        }, {
            title: "fas fa-hand-scissors",
            searchTerms: []
        }, {
            title: "far fa-hand-scissors",
            searchTerms: []
        }, {
            title: "fas fa-hand-spock",
            searchTerms: []
        }, {
            title: "far fa-hand-spock",
            searchTerms: []
        }, {
            title: "fas fa-hands",
            searchTerms: []
        }, {
            title: "fas fa-hands-helping",
            searchTerms: [ "aid", "assistance", "partnership", "volunteering" ]
        }, {
            title: "fas fa-handshake",
            searchTerms: [ "greeting", "partnership" ]
        }, {
            title: "far fa-handshake",
            searchTerms: [ "greeting", "partnership" ]
        }, {
            title: "fas fa-hanukiah",
            searchTerms: [ "candle", "hanukkah", "jewish", "judaism", "light" ]
        }, {
            title: "fas fa-hashtag",
            searchTerms: []
        }, {
            title: "fas fa-hat-wizard",
            searchTerms: [ "Dungeons & Dragons", "buckle", "cloth", "clothing", "d&d", "dnd", "fantasy", "halloween", "holiday", "mage", "magic", "pointy", "witch" ]
        }, {
            title: "fas fa-haykal",
            searchTerms: [ "bahai", "bahá'í", "star" ]
        }, {
            title: "fas fa-hdd",
            searchTerms: [ "cpu", "hard drive", "harddrive", "machine", "save", "storage" ]
        }, {
            title: "far fa-hdd",
            searchTerms: [ "cpu", "hard drive", "harddrive", "machine", "save", "storage" ]
        }, {
            title: "fas fa-heading",
            searchTerms: [ "header" ]
        }, {
            title: "fas fa-headphones",
            searchTerms: [ "audio", "listen", "music", "sound", "speaker" ]
        }, {
            title: "fas fa-headphones-alt",
            searchTerms: [ "audio", "listen", "music", "sound", "speaker" ]
        }, {
            title: "fas fa-headset",
            searchTerms: [ "audio", "gamer", "gaming", "listen", "live chat", "microphone", "shot caller", "sound", "support", "telemarketer" ]
        }, {
            title: "fas fa-heart",
            searchTerms: [ "favorite", "like", "love" ]
        }, {
            title: "far fa-heart",
            searchTerms: [ "favorite", "like", "love" ]
        }, {
            title: "fas fa-heartbeat",
            searchTerms: [ "ekg", "lifeline", "vital signs" ]
        }, {
            title: "fas fa-helicopter",
            searchTerms: [ "airwolf", "apache", "chopper", "flight", "fly" ]
        }, {
            title: "fas fa-highlighter",
            searchTerms: [ "edit", "marker", "sharpie", "update", "write" ]
        }, {
            title: "fas fa-hiking",
            searchTerms: [ "activity", "backpack", "fall", "fitness", "outdoors", "seasonal", "walking" ]
        }, {
            title: "fas fa-hippo",
            searchTerms: [ "fauna", "hungry", "mammmal" ]
        }, {
            title: "fab fa-hips",
            searchTerms: []
        }, {
            title: "fab fa-hire-a-helper",
            searchTerms: []
        }, {
            title: "fas fa-history",
            searchTerms: []
        }, {
            title: "fas fa-hockey-puck",
            searchTerms: []
        }, {
            title: "fas fa-home",
            searchTerms: [ "house", "main" ]
        }, {
            title: "fab fa-hooli",
            searchTerms: []
        }, {
            title: "fab fa-hornbill",
            searchTerms: []
        }, {
            title: "fas fa-horse",
            searchTerms: [ "equus", "fauna", "mammmal", "neigh" ]
        }, {
            title: "fas fa-hospital",
            searchTerms: [ "building", "emergency room", "medical center" ]
        }, {
            title: "far fa-hospital",
            searchTerms: [ "building", "emergency room", "medical center" ]
        }, {
            title: "fas fa-hospital-alt",
            searchTerms: [ "building", "emergency room", "medical center" ]
        }, {
            title: "fas fa-hospital-symbol",
            searchTerms: []
        }, {
            title: "fas fa-hot-tub",
            searchTerms: []
        }, {
            title: "fas fa-hotel",
            searchTerms: [ "building", "lodging" ]
        }, {
            title: "fab fa-hotjar",
            searchTerms: []
        }, {
            title: "fas fa-hourglass",
            searchTerms: []
        }, {
            title: "far fa-hourglass",
            searchTerms: []
        }, {
            title: "fas fa-hourglass-end",
            searchTerms: []
        }, {
            title: "fas fa-hourglass-half",
            searchTerms: []
        }, {
            title: "fas fa-hourglass-start",
            searchTerms: []
        }, {
            title: "fas fa-house-damage",
            searchTerms: [ "devastation", "home" ]
        }, {
            title: "fab fa-houzz",
            searchTerms: []
        }, {
            title: "fas fa-hryvnia",
            searchTerms: [ "money" ]
        }, {
            title: "fab fa-html5",
            searchTerms: []
        }, {
            title: "fab fa-hubspot",
            searchTerms: []
        }, {
            title: "fas fa-i-cursor",
            searchTerms: []
        }, {
            title: "fas fa-id-badge",
            searchTerms: []
        }, {
            title: "far fa-id-badge",
            searchTerms: []
        }, {
            title: "fas fa-id-card",
            searchTerms: [ "document", "identification", "issued" ]
        }, {
            title: "far fa-id-card",
            searchTerms: [ "document", "identification", "issued" ]
        }, {
            title: "fas fa-id-card-alt",
            searchTerms: [ "demographics" ]
        }, {
            title: "fas fa-image",
            searchTerms: [ "album", "photo", "picture" ]
        }, {
            title: "far fa-image",
            searchTerms: [ "album", "photo", "picture" ]
        }, {
            title: "fas fa-images",
            searchTerms: [ "album", "photo", "picture" ]
        }, {
            title: "far fa-images",
            searchTerms: [ "album", "photo", "picture" ]
        }, {
            title: "fab fa-imdb",
            searchTerms: []
        }, {
            title: "fas fa-inbox",
            searchTerms: []
        }, {
            title: "fas fa-indent",
            searchTerms: []
        }, {
            title: "fas fa-industry",
            searchTerms: [ "factory", "manufacturing" ]
        }, {
            title: "fas fa-infinity",
            searchTerms: []
        }, {
            title: "fas fa-info",
            searchTerms: [ "details", "help", "information", "more" ]
        }, {
            title: "fas fa-info-circle",
            searchTerms: [ "details", "help", "information", "more" ]
        }, {
            title: "fab fa-instagram",
            searchTerms: []
        }, {
            title: "fab fa-internet-explorer",
            searchTerms: [ "browser", "ie" ]
        }, {
            title: "fab fa-ioxhost",
            searchTerms: []
        }, {
            title: "fas fa-italic",
            searchTerms: [ "italics" ]
        }, {
            title: "fab fa-itunes",
            searchTerms: []
        }, {
            title: "fab fa-itunes-note",
            searchTerms: []
        }, {
            title: "fab fa-java",
            searchTerms: []
        }, {
            title: "fas fa-jedi",
            searchTerms: [ "star wars" ]
        }, {
            title: "fab fa-jedi-order",
            searchTerms: [ "star wars" ]
        }, {
            title: "fab fa-jenkins",
            searchTerms: []
        }, {
            title: "fab fa-joget",
            searchTerms: []
        }, {
            title: "fas fa-joint",
            searchTerms: [ "blunt", "cannabis", "doobie", "drugs", "marijuana", "roach", "smoke", "smoking", "spliff" ]
        }, {
            title: "fab fa-joomla",
            searchTerms: []
        }, {
            title: "fas fa-journal-whills",
            searchTerms: [ "book", "jedi", "star wars", "the force" ]
        }, {
            title: "fab fa-js",
            searchTerms: []
        }, {
            title: "fab fa-js-square",
            searchTerms: []
        }, {
            title: "fab fa-jsfiddle",
            searchTerms: []
        }, {
            title: "fas fa-kaaba",
            searchTerms: [ "building", "cube", "islam", "muslim" ]
        }, {
            title: "fab fa-kaggle",
            searchTerms: []
        }, {
            title: "fas fa-key",
            searchTerms: [ "password", "unlock" ]
        }, {
            title: "fab fa-keybase",
            searchTerms: []
        }, {
            title: "fas fa-keyboard",
            searchTerms: [ "input", "type" ]
        }, {
            title: "far fa-keyboard",
            searchTerms: [ "input", "type" ]
        }, {
            title: "fab fa-keycdn",
            searchTerms: []
        }, {
            title: "fas fa-khanda",
            searchTerms: [ "chakkar", "sikh", "sikhism", "sword" ]
        }, {
            title: "fab fa-kickstarter",
            searchTerms: []
        }, {
            title: "fab fa-kickstarter-k",
            searchTerms: []
        }, {
            title: "fas fa-kiss",
            searchTerms: [ "beso", "emoticon", "face", "love", "smooch" ]
        }, {
            title: "far fa-kiss",
            searchTerms: [ "beso", "emoticon", "face", "love", "smooch" ]
        }, {
            title: "fas fa-kiss-beam",
            searchTerms: [ "beso", "emoticon", "face", "love", "smooch" ]
        }, {
            title: "far fa-kiss-beam",
            searchTerms: [ "beso", "emoticon", "face", "love", "smooch" ]
        }, {
            title: "fas fa-kiss-wink-heart",
            searchTerms: [ "beso", "emoticon", "face", "love", "smooch" ]
        }, {
            title: "far fa-kiss-wink-heart",
            searchTerms: [ "beso", "emoticon", "face", "love", "smooch" ]
        }, {
            title: "fas fa-kiwi-bird",
            searchTerms: [ "bird", "fauna" ]
        }, {
            title: "fab fa-korvue",
            searchTerms: []
        }, {
            title: "fas fa-landmark",
            searchTerms: [ "building", "historic", "memoroable", "politics" ]
        }, {
            title: "fas fa-language",
            searchTerms: [ "dialect", "idiom", "localize", "speech", "translate", "vernacular" ]
        }, {
            title: "fas fa-laptop",
            searchTerms: [ "computer", "cpu", "dell", "demo", "device", "dude you're getting", "mac", "macbook", "machine", "pc" ]
        }, {
            title: "fas fa-laptop-code",
            searchTerms: []
        }, {
            title: "fab fa-laravel",
            searchTerms: []
        }, {
            title: "fab fa-lastfm",
            searchTerms: []
        }, {
            title: "fab fa-lastfm-square",
            searchTerms: []
        }, {
            title: "fas fa-laugh",
            searchTerms: [ "LOL", "emoticon", "face", "laugh" ]
        }, {
            title: "far fa-laugh",
            searchTerms: [ "LOL", "emoticon", "face", "laugh" ]
        }, {
            title: "fas fa-laugh-beam",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-laugh-beam",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-laugh-squint",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-laugh-squint",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-laugh-wink",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "far fa-laugh-wink",
            searchTerms: [ "LOL", "emoticon", "face" ]
        }, {
            title: "fas fa-layer-group",
            searchTerms: [ "layers" ]
        }, {
            title: "fas fa-leaf",
            searchTerms: [ "eco", "flora", "nature", "plant" ]
        }, {
            title: "fab fa-leanpub",
            searchTerms: []
        }, {
            title: "fas fa-lemon",
            searchTerms: [ "food" ]
        }, {
            title: "far fa-lemon",
            searchTerms: [ "food" ]
        }, {
            title: "fab fa-less",
            searchTerms: []
        }, {
            title: "fas fa-less-than",
            searchTerms: []
        }, {
            title: "fas fa-less-than-equal",
            searchTerms: []
        }, {
            title: "fas fa-level-down-alt",
            searchTerms: [ "level-down" ]
        }, {
            title: "fas fa-level-up-alt",
            searchTerms: [ "level-up" ]
        }, {
            title: "fas fa-life-ring",
            searchTerms: [ "support" ]
        }, {
            title: "far fa-life-ring",
            searchTerms: [ "support" ]
        }, {
            title: "fas fa-lightbulb",
            searchTerms: [ "idea", "inspiration" ]
        }, {
            title: "far fa-lightbulb",
            searchTerms: [ "idea", "inspiration" ]
        }, {
            title: "fab fa-line",
            searchTerms: []
        }, {
            title: "fas fa-link",
            searchTerms: [ "chain" ]
        }, {
            title: "fab fa-linkedin",
            searchTerms: [ "linkedin-square" ]
        }, {
            title: "fab fa-linkedin-in",
            searchTerms: [ "linkedin" ]
        }, {
            title: "fab fa-linode",
            searchTerms: []
        }, {
            title: "fab fa-linux",
            searchTerms: [ "tux" ]
        }, {
            title: "fas fa-lira-sign",
            searchTerms: [ "try", "turkish" ]
        }, {
            title: "fas fa-list",
            searchTerms: [ "checklist", "completed", "done", "finished", "ol", "todo", "ul" ]
        }, {
            title: "fas fa-list-alt",
            searchTerms: [ "checklist", "completed", "done", "finished", "ol", "todo", "ul" ]
        }, {
            title: "far fa-list-alt",
            searchTerms: [ "checklist", "completed", "done", "finished", "ol", "todo", "ul" ]
        }, {
            title: "fas fa-list-ol",
            searchTerms: [ "checklist", "list", "numbers", "ol", "todo", "ul" ]
        }, {
            title: "fas fa-list-ul",
            searchTerms: [ "checklist", "list", "ol", "todo", "ul" ]
        }, {
            title: "fas fa-location-arrow",
            searchTerms: [ "address", "coordinates", "gps", "location", "map", "place", "where" ]
        }, {
            title: "fas fa-lock",
            searchTerms: [ "admin", "protect", "security" ]
        }, {
            title: "fas fa-lock-open",
            searchTerms: [ "admin", "lock", "open", "password", "protect" ]
        }, {
            title: "fas fa-long-arrow-alt-down",
            searchTerms: [ "long-arrow-down" ]
        }, {
            title: "fas fa-long-arrow-alt-left",
            searchTerms: [ "back", "long-arrow-left", "previous" ]
        }, {
            title: "fas fa-long-arrow-alt-right",
            searchTerms: [ "long-arrow-right" ]
        }, {
            title: "fas fa-long-arrow-alt-up",
            searchTerms: [ "long-arrow-up" ]
        }, {
            title: "fas fa-low-vision",
            searchTerms: []
        }, {
            title: "fas fa-luggage-cart",
            searchTerms: []
        }, {
            title: "fab fa-lyft",
            searchTerms: []
        }, {
            title: "fab fa-magento",
            searchTerms: []
        }, {
            title: "fas fa-magic",
            searchTerms: [ "autocomplete", "automatic", "mage", "magic", "spell", "witch", "wizard" ]
        }, {
            title: "fas fa-magnet",
            searchTerms: []
        }, {
            title: "fas fa-mail-bulk",
            searchTerms: []
        }, {
            title: "fab fa-mailchimp",
            searchTerms: []
        }, {
            title: "fas fa-male",
            searchTerms: [ "human", "man", "person", "profile", "user" ]
        }, {
            title: "fab fa-mandalorian",
            searchTerms: []
        }, {
            title: "fas fa-map",
            searchTerms: [ "coordinates", "location", "paper", "place", "travel" ]
        }, {
            title: "far fa-map",
            searchTerms: [ "coordinates", "location", "paper", "place", "travel" ]
        }, {
            title: "fas fa-map-marked",
            searchTerms: [ "address", "coordinates", "destination", "gps", "localize", "location", "map", "paper", "pin", "place", "point of interest", "position", "route", "travel", "where" ]
        }, {
            title: "fas fa-map-marked-alt",
            searchTerms: [ "address", "coordinates", "destination", "gps", "localize", "location", "map", "paper", "pin", "place", "point of interest", "position", "route", "travel", "where" ]
        }, {
            title: "fas fa-map-marker",
            searchTerms: [ "address", "coordinates", "gps", "localize", "location", "map", "pin", "place", "position", "travel", "where" ]
        }, {
            title: "fas fa-map-marker-alt",
            searchTerms: [ "address", "coordinates", "gps", "localize", "location", "map", "pin", "place", "position", "travel", "where" ]
        }, {
            title: "fas fa-map-pin",
            searchTerms: [ "address", "coordinates", "gps", "localize", "location", "map", "marker", "place", "position", "travel", "where" ]
        }, {
            title: "fas fa-map-signs",
            searchTerms: []
        }, {
            title: "fab fa-markdown",
            searchTerms: []
        }, {
            title: "fas fa-marker",
            searchTerms: [ "edit", "sharpie", "update", "write" ]
        }, {
            title: "fas fa-mars",
            searchTerms: [ "male" ]
        }, {
            title: "fas fa-mars-double",
            searchTerms: []
        }, {
            title: "fas fa-mars-stroke",
            searchTerms: []
        }, {
            title: "fas fa-mars-stroke-h",
            searchTerms: []
        }, {
            title: "fas fa-mars-stroke-v",
            searchTerms: []
        }, {
            title: "fas fa-mask",
            searchTerms: [ "costume", "disguise", "halloween", "holiday", "secret", "super hero" ]
        }, {
            title: "fab fa-mastodon",
            searchTerms: []
        }, {
            title: "fab fa-maxcdn",
            searchTerms: []
        }, {
            title: "fas fa-medal",
            searchTerms: []
        }, {
            title: "fab fa-medapps",
            searchTerms: []
        }, {
            title: "fab fa-medium",
            searchTerms: []
        }, {
            title: "fab fa-medium-m",
            searchTerms: []
        }, {
            title: "fas fa-medkit",
            searchTerms: [ "first aid", "firstaid", "health", "help", "support" ]
        }, {
            title: "fab fa-medrt",
            searchTerms: []
        }, {
            title: "fab fa-meetup",
            searchTerms: []
        }, {
            title: "fab fa-megaport",
            searchTerms: []
        }, {
            title: "fas fa-meh",
            searchTerms: [ "emoticon", "face", "neutral", "rating" ]
        }, {
            title: "far fa-meh",
            searchTerms: [ "emoticon", "face", "neutral", "rating" ]
        }, {
            title: "fas fa-meh-blank",
            searchTerms: [ "emoticon", "face", "neutral", "rating" ]
        }, {
            title: "far fa-meh-blank",
            searchTerms: [ "emoticon", "face", "neutral", "rating" ]
        }, {
            title: "fas fa-meh-rolling-eyes",
            searchTerms: [ "emoticon", "face", "neutral", "rating" ]
        }, {
            title: "far fa-meh-rolling-eyes",
            searchTerms: [ "emoticon", "face", "neutral", "rating" ]
        }, {
            title: "fas fa-memory",
            searchTerms: [ "DIMM", "RAM" ]
        }, {
            title: "fas fa-menorah",
            searchTerms: [ "candle", "hanukkah", "jewish", "judaism", "light" ]
        }, {
            title: "fas fa-mercury",
            searchTerms: [ "transgender" ]
        }, {
            title: "fas fa-meteor",
            searchTerms: []
        }, {
            title: "fas fa-microchip",
            searchTerms: [ "cpu", "processor" ]
        }, {
            title: "fas fa-microphone",
            searchTerms: [ "record", "sound", "voice" ]
        }, {
            title: "fas fa-microphone-alt",
            searchTerms: [ "record", "sound", "voice" ]
        }, {
            title: "fas fa-microphone-alt-slash",
            searchTerms: [ "disable", "mute", "record", "sound", "voice" ]
        }, {
            title: "fas fa-microphone-slash",
            searchTerms: [ "disable", "mute", "record", "sound", "voice" ]
        }, {
            title: "fas fa-microscope",
            searchTerms: []
        }, {
            title: "fab fa-microsoft",
            searchTerms: []
        }, {
            title: "fas fa-minus",
            searchTerms: [ "collapse", "delete", "hide", "minify", "negative", "remove", "trash" ]
        }, {
            title: "fas fa-minus-circle",
            searchTerms: [ "delete", "hide", "negative", "remove", "trash" ]
        }, {
            title: "fas fa-minus-square",
            searchTerms: [ "collapse", "delete", "hide", "minify", "negative", "remove", "trash" ]
        }, {
            title: "far fa-minus-square",
            searchTerms: [ "collapse", "delete", "hide", "minify", "negative", "remove", "trash" ]
        }, {
            title: "fab fa-mix",
            searchTerms: []
        }, {
            title: "fab fa-mixcloud",
            searchTerms: []
        }, {
            title: "fab fa-mizuni",
            searchTerms: []
        }, {
            title: "fas fa-mobile",
            searchTerms: [ "apple", "call", "cell phone", "cellphone", "device", "iphone", "number", "screen", "telephone", "text" ]
        }, {
            title: "fas fa-mobile-alt",
            searchTerms: [ "apple", "call", "cell phone", "cellphone", "device", "iphone", "number", "screen", "telephone", "text" ]
        }, {
            title: "fab fa-modx",
            searchTerms: []
        }, {
            title: "fab fa-monero",
            searchTerms: []
        }, {
            title: "fas fa-money-bill",
            searchTerms: [ "buy", "cash", "checkout", "money", "payment", "price", "purchase" ]
        }, {
            title: "fas fa-money-bill-alt",
            searchTerms: [ "buy", "cash", "checkout", "money", "payment", "price", "purchase" ]
        }, {
            title: "far fa-money-bill-alt",
            searchTerms: [ "buy", "cash", "checkout", "money", "payment", "price", "purchase" ]
        }, {
            title: "fas fa-money-bill-wave",
            searchTerms: []
        }, {
            title: "fas fa-money-bill-wave-alt",
            searchTerms: []
        }, {
            title: "fas fa-money-check",
            searchTerms: [ "bank check", "cheque" ]
        }, {
            title: "fas fa-money-check-alt",
            searchTerms: [ "bank check", "cheque" ]
        }, {
            title: "fas fa-monument",
            searchTerms: [ "building", "historic", "memoroable" ]
        }, {
            title: "fas fa-moon",
            searchTerms: [ "contrast", "crescent", "darker", "lunar", "night" ]
        }, {
            title: "far fa-moon",
            searchTerms: [ "contrast", "crescent", "darker", "lunar", "night" ]
        }, {
            title: "fas fa-mortar-pestle",
            searchTerms: [ "crush", "culinary", "grind", "medical", "mix", "spices" ]
        }, {
            title: "fas fa-mosque",
            searchTerms: [ "building", "islam", "muslim" ]
        }, {
            title: "fas fa-motorcycle",
            searchTerms: [ "bike", "machine", "transportation", "vehicle" ]
        }, {
            title: "fas fa-mountain",
            searchTerms: []
        }, {
            title: "fas fa-mouse-pointer",
            searchTerms: [ "select" ]
        }, {
            title: "fas fa-music",
            searchTerms: [ "note", "sound" ]
        }, {
            title: "fab fa-napster",
            searchTerms: []
        }, {
            title: "fab fa-neos",
            searchTerms: []
        }, {
            title: "fas fa-network-wired",
            searchTerms: []
        }, {
            title: "fas fa-neuter",
            searchTerms: []
        }, {
            title: "fas fa-newspaper",
            searchTerms: [ "article", "press" ]
        }, {
            title: "far fa-newspaper",
            searchTerms: [ "article", "press" ]
        }, {
            title: "fab fa-nimblr",
            searchTerms: []
        }, {
            title: "fab fa-nintendo-switch",
            searchTerms: []
        }, {
            title: "fab fa-node",
            searchTerms: []
        }, {
            title: "fab fa-node-js",
            searchTerms: []
        }, {
            title: "fas fa-not-equal",
            searchTerms: []
        }, {
            title: "fas fa-notes-medical",
            searchTerms: []
        }, {
            title: "fab fa-npm",
            searchTerms: []
        }, {
            title: "fab fa-ns8",
            searchTerms: []
        }, {
            title: "fab fa-nutritionix",
            searchTerms: []
        }, {
            title: "fas fa-object-group",
            searchTerms: [ "design" ]
        }, {
            title: "far fa-object-group",
            searchTerms: [ "design" ]
        }, {
            title: "fas fa-object-ungroup",
            searchTerms: [ "design" ]
        }, {
            title: "far fa-object-ungroup",
            searchTerms: [ "design" ]
        }, {
            title: "fab fa-odnoklassniki",
            searchTerms: []
        }, {
            title: "fab fa-odnoklassniki-square",
            searchTerms: []
        }, {
            title: "fas fa-oil-can",
            searchTerms: []
        }, {
            title: "fab fa-old-republic",
            searchTerms: [ "politics", "star wars" ]
        }, {
            title: "fas fa-om",
            searchTerms: [ "buddhism", "hinduism", "jainism", "mantra" ]
        }, {
            title: "fab fa-opencart",
            searchTerms: []
        }, {
            title: "fab fa-openid",
            searchTerms: []
        }, {
            title: "fab fa-opera",
            searchTerms: []
        }, {
            title: "fab fa-optin-monster",
            searchTerms: []
        }, {
            title: "fab fa-osi",
            searchTerms: []
        }, {
            title: "fas fa-otter",
            searchTerms: [ "fauna", "mammmal" ]
        }, {
            title: "fas fa-outdent",
            searchTerms: []
        }, {
            title: "fab fa-page4",
            searchTerms: []
        }, {
            title: "fab fa-pagelines",
            searchTerms: [ "eco", "flora", "leaf", "leaves", "nature", "plant", "tree" ]
        }, {
            title: "fas fa-paint-brush",
            searchTerms: []
        }, {
            title: "fas fa-paint-roller",
            searchTerms: [ "brush", "painting", "tool" ]
        }, {
            title: "fas fa-palette",
            searchTerms: [ "colors", "painting" ]
        }, {
            title: "fab fa-palfed",
            searchTerms: []
        }, {
            title: "fas fa-pallet",
            searchTerms: []
        }, {
            title: "fas fa-paper-plane",
            searchTerms: []
        }, {
            title: "far fa-paper-plane",
            searchTerms: []
        }, {
            title: "fas fa-paperclip",
            searchTerms: [ "attachment" ]
        }, {
            title: "fas fa-parachute-box",
            searchTerms: [ "aid", "assistance", "rescue", "supplies" ]
        }, {
            title: "fas fa-paragraph",
            searchTerms: []
        }, {
            title: "fas fa-parking",
            searchTerms: []
        }, {
            title: "fas fa-passport",
            searchTerms: [ "document", "identification", "issued" ]
        }, {
            title: "fas fa-pastafarianism",
            searchTerms: [ "agnosticism", "atheism", "flying spaghetti monster", "fsm" ]
        }, {
            title: "fas fa-paste",
            searchTerms: [ "clipboard", "copy" ]
        }, {
            title: "fab fa-patreon",
            searchTerms: []
        }, {
            title: "fas fa-pause",
            searchTerms: [ "wait" ]
        }, {
            title: "fas fa-pause-circle",
            searchTerms: []
        }, {
            title: "far fa-pause-circle",
            searchTerms: []
        }, {
            title: "fas fa-paw",
            searchTerms: [ "animal", "pet" ]
        }, {
            title: "fab fa-paypal",
            searchTerms: []
        }, {
            title: "fas fa-peace",
            searchTerms: []
        }, {
            title: "fas fa-pen",
            searchTerms: [ "design", "edit", "update", "write" ]
        }, {
            title: "fas fa-pen-alt",
            searchTerms: [ "design", "edit", "update", "write" ]
        }, {
            title: "fas fa-pen-fancy",
            searchTerms: [ "design", "edit", "fountain pen", "update", "write" ]
        }, {
            title: "fas fa-pen-nib",
            searchTerms: [ "design", "edit", "fountain pen", "update", "write" ]
        }, {
            title: "fas fa-pen-square",
            searchTerms: [ "edit", "pencil-square", "update", "write" ]
        }, {
            title: "fas fa-pencil-alt",
            searchTerms: [ "design", "edit", "pencil", "update", "write" ]
        }, {
            title: "fas fa-pencil-ruler",
            searchTerms: []
        }, {
            title: "fab fa-penny-arcade",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "game", "gaming", "pax", "tabletop" ]
        }, {
            title: "fas fa-people-carry",
            searchTerms: [ "movers" ]
        }, {
            title: "fas fa-percent",
            searchTerms: []
        }, {
            title: "fas fa-percentage",
            searchTerms: []
        }, {
            title: "fab fa-periscope",
            searchTerms: []
        }, {
            title: "fas fa-person-booth",
            searchTerms: [ "changing", "changing room", "election", "human", "person", "vote", "voting" ]
        }, {
            title: "fab fa-phabricator",
            searchTerms: []
        }, {
            title: "fab fa-phoenix-framework",
            searchTerms: []
        }, {
            title: "fab fa-phoenix-squadron",
            searchTerms: []
        }, {
            title: "fas fa-phone",
            searchTerms: [ "call", "earphone", "number", "support", "telephone", "voice" ]
        }, {
            title: "fas fa-phone-slash",
            searchTerms: []
        }, {
            title: "fas fa-phone-square",
            searchTerms: [ "call", "number", "support", "telephone", "voice" ]
        }, {
            title: "fas fa-phone-volume",
            searchTerms: [ "telephone", "volume-control-phone" ]
        }, {
            title: "fab fa-php",
            searchTerms: []
        }, {
            title: "fab fa-pied-piper",
            searchTerms: []
        }, {
            title: "fab fa-pied-piper-alt",
            searchTerms: []
        }, {
            title: "fab fa-pied-piper-hat",
            searchTerms: [ "clothing" ]
        }, {
            title: "fab fa-pied-piper-pp",
            searchTerms: []
        }, {
            title: "fas fa-piggy-bank",
            searchTerms: [ "save", "savings" ]
        }, {
            title: "fas fa-pills",
            searchTerms: [ "drugs", "medicine" ]
        }, {
            title: "fab fa-pinterest",
            searchTerms: []
        }, {
            title: "fab fa-pinterest-p",
            searchTerms: []
        }, {
            title: "fab fa-pinterest-square",
            searchTerms: []
        }, {
            title: "fas fa-place-of-worship",
            searchTerms: []
        }, {
            title: "fas fa-plane",
            searchTerms: [ "airplane", "destination", "fly", "location", "mode", "travel", "trip" ]
        }, {
            title: "fas fa-plane-arrival",
            searchTerms: [ "airplane", "arriving", "destination", "fly", "land", "landing", "location", "mode", "travel", "trip" ]
        }, {
            title: "fas fa-plane-departure",
            searchTerms: [ "airplane", "departing", "destination", "fly", "location", "mode", "take off", "taking off", "travel", "trip" ]
        }, {
            title: "fas fa-play",
            searchTerms: [ "music", "playing", "sound", "start" ]
        }, {
            title: "fas fa-play-circle",
            searchTerms: [ "playing", "start" ]
        }, {
            title: "far fa-play-circle",
            searchTerms: [ "playing", "start" ]
        }, {
            title: "fab fa-playstation",
            searchTerms: []
        }, {
            title: "fas fa-plug",
            searchTerms: [ "connect", "online", "power" ]
        }, {
            title: "fas fa-plus",
            searchTerms: [ "add", "create", "expand", "new", "positive" ]
        }, {
            title: "fas fa-plus-circle",
            searchTerms: [ "add", "create", "expand", "new", "positive" ]
        }, {
            title: "fas fa-plus-square",
            searchTerms: [ "add", "create", "expand", "new", "positive" ]
        }, {
            title: "far fa-plus-square",
            searchTerms: [ "add", "create", "expand", "new", "positive" ]
        }, {
            title: "fas fa-podcast",
            searchTerms: []
        }, {
            title: "fas fa-poll",
            searchTerms: [ "results", "survey", "vote", "voting" ]
        }, {
            title: "fas fa-poll-h",
            searchTerms: [ "results", "survey", "vote", "voting" ]
        }, {
            title: "fas fa-poo",
            searchTerms: []
        }, {
            title: "fas fa-poo-storm",
            searchTerms: [ "mess", "poop", "shit" ]
        }, {
            title: "fas fa-poop",
            searchTerms: []
        }, {
            title: "fas fa-portrait",
            searchTerms: []
        }, {
            title: "fas fa-pound-sign",
            searchTerms: [ "gbp" ]
        }, {
            title: "fas fa-power-off",
            searchTerms: [ "on", "reboot", "restart" ]
        }, {
            title: "fas fa-pray",
            searchTerms: []
        }, {
            title: "fas fa-praying-hands",
            searchTerms: []
        }, {
            title: "fas fa-prescription",
            searchTerms: [ "drugs", "medical", "medicine", "rx" ]
        }, {
            title: "fas fa-prescription-bottle",
            searchTerms: [ "drugs", "medical", "medicine", "rx" ]
        }, {
            title: "fas fa-prescription-bottle-alt",
            searchTerms: [ "drugs", "medical", "medicine", "rx" ]
        }, {
            title: "fas fa-print",
            searchTerms: []
        }, {
            title: "fas fa-procedures",
            searchTerms: []
        }, {
            title: "fab fa-product-hunt",
            searchTerms: []
        }, {
            title: "fas fa-project-diagram",
            searchTerms: []
        }, {
            title: "fab fa-pushed",
            searchTerms: []
        }, {
            title: "fas fa-puzzle-piece",
            searchTerms: [ "add-on", "addon", "section" ]
        }, {
            title: "fab fa-python",
            searchTerms: []
        }, {
            title: "fab fa-qq",
            searchTerms: []
        }, {
            title: "fas fa-qrcode",
            searchTerms: [ "scan" ]
        }, {
            title: "fas fa-question",
            searchTerms: [ "help", "information", "support", "unknown" ]
        }, {
            title: "fas fa-question-circle",
            searchTerms: [ "help", "information", "support", "unknown" ]
        }, {
            title: "far fa-question-circle",
            searchTerms: [ "help", "information", "support", "unknown" ]
        }, {
            title: "fas fa-quidditch",
            searchTerms: []
        }, {
            title: "fab fa-quinscape",
            searchTerms: []
        }, {
            title: "fab fa-quora",
            searchTerms: []
        }, {
            title: "fas fa-quote-left",
            searchTerms: []
        }, {
            title: "fas fa-quote-right",
            searchTerms: []
        }, {
            title: "fas fa-quran",
            searchTerms: [ "book", "islam", "muslim" ]
        }, {
            title: "fab fa-r-project",
            searchTerms: []
        }, {
            title: "fas fa-rainbow",
            searchTerms: []
        }, {
            title: "fas fa-random",
            searchTerms: [ "shuffle", "sort" ]
        }, {
            title: "fab fa-ravelry",
            searchTerms: []
        }, {
            title: "fab fa-react",
            searchTerms: []
        }, {
            title: "fab fa-reacteurope",
            searchTerms: []
        }, {
            title: "fab fa-readme",
            searchTerms: []
        }, {
            title: "fab fa-rebel",
            searchTerms: []
        }, {
            title: "fas fa-receipt",
            searchTerms: [ "check", "invoice", "table" ]
        }, {
            title: "fas fa-recycle",
            searchTerms: []
        }, {
            title: "fab fa-red-river",
            searchTerms: []
        }, {
            title: "fab fa-reddit",
            searchTerms: []
        }, {
            title: "fab fa-reddit-alien",
            searchTerms: []
        }, {
            title: "fab fa-reddit-square",
            searchTerms: []
        }, {
            title: "fas fa-redo",
            searchTerms: [ "forward", "refresh", "reload", "repeat" ]
        }, {
            title: "fas fa-redo-alt",
            searchTerms: [ "forward", "refresh", "reload", "repeat" ]
        }, {
            title: "fas fa-registered",
            searchTerms: []
        }, {
            title: "far fa-registered",
            searchTerms: []
        }, {
            title: "fab fa-renren",
            searchTerms: []
        }, {
            title: "fas fa-reply",
            searchTerms: []
        }, {
            title: "fas fa-reply-all",
            searchTerms: []
        }, {
            title: "fab fa-replyd",
            searchTerms: []
        }, {
            title: "fas fa-republican",
            searchTerms: [ "american", "conservative", "election", "elephant", "politics", "republican party", "right", "right-wing", "usa" ]
        }, {
            title: "fab fa-researchgate",
            searchTerms: []
        }, {
            title: "fab fa-resolving",
            searchTerms: []
        }, {
            title: "fas fa-retweet",
            searchTerms: [ "refresh", "reload", "share", "swap" ]
        }, {
            title: "fab fa-rev",
            searchTerms: []
        }, {
            title: "fas fa-ribbon",
            searchTerms: [ "badge", "cause", "lapel", "pin" ]
        }, {
            title: "fas fa-ring",
            searchTerms: [ "Dungeons & Dragons", "Gollum", "band", "binding", "d&d", "dnd", "fantasy", "jewelry", "precious" ]
        }, {
            title: "fas fa-road",
            searchTerms: [ "street" ]
        }, {
            title: "fas fa-robot",
            searchTerms: []
        }, {
            title: "fas fa-rocket",
            searchTerms: [ "app" ]
        }, {
            title: "fab fa-rocketchat",
            searchTerms: []
        }, {
            title: "fab fa-rockrms",
            searchTerms: []
        }, {
            title: "fas fa-route",
            searchTerms: []
        }, {
            title: "fas fa-rss",
            searchTerms: [ "blog" ]
        }, {
            title: "fas fa-rss-square",
            searchTerms: [ "blog", "feed" ]
        }, {
            title: "fas fa-ruble-sign",
            searchTerms: [ "rub" ]
        }, {
            title: "fas fa-ruler",
            searchTerms: []
        }, {
            title: "fas fa-ruler-combined",
            searchTerms: []
        }, {
            title: "fas fa-ruler-horizontal",
            searchTerms: []
        }, {
            title: "fas fa-ruler-vertical",
            searchTerms: []
        }, {
            title: "fas fa-running",
            searchTerms: [ "jog", "sprint" ]
        }, {
            title: "fas fa-rupee-sign",
            searchTerms: [ "indian", "inr" ]
        }, {
            title: "fas fa-sad-cry",
            searchTerms: [ "emoticon", "face", "tear", "tears" ]
        }, {
            title: "far fa-sad-cry",
            searchTerms: [ "emoticon", "face", "tear", "tears" ]
        }, {
            title: "fas fa-sad-tear",
            searchTerms: [ "emoticon", "face", "tear", "tears" ]
        }, {
            title: "far fa-sad-tear",
            searchTerms: [ "emoticon", "face", "tear", "tears" ]
        }, {
            title: "fab fa-safari",
            searchTerms: [ "browser" ]
        }, {
            title: "fab fa-sass",
            searchTerms: []
        }, {
            title: "fas fa-save",
            searchTerms: [ "floppy", "floppy-o" ]
        }, {
            title: "far fa-save",
            searchTerms: [ "floppy", "floppy-o" ]
        }, {
            title: "fab fa-schlix",
            searchTerms: []
        }, {
            title: "fas fa-school",
            searchTerms: []
        }, {
            title: "fas fa-screwdriver",
            searchTerms: [ "admin", "fix", "repair", "settings", "tool" ]
        }, {
            title: "fab fa-scribd",
            searchTerms: []
        }, {
            title: "fas fa-scroll",
            searchTerms: [ "Dungeons & Dragons", "announcement", "d&d", "dnd", "fantasy", "paper" ]
        }, {
            title: "fas fa-search",
            searchTerms: [ "bigger", "enlarge", "magnify", "preview", "zoom" ]
        }, {
            title: "fas fa-search-dollar",
            searchTerms: []
        }, {
            title: "fas fa-search-location",
            searchTerms: []
        }, {
            title: "fas fa-search-minus",
            searchTerms: [ "minify", "negative", "smaller", "zoom", "zoom out" ]
        }, {
            title: "fas fa-search-plus",
            searchTerms: [ "bigger", "enlarge", "magnify", "positive", "zoom", "zoom in" ]
        }, {
            title: "fab fa-searchengin",
            searchTerms: []
        }, {
            title: "fas fa-seedling",
            searchTerms: []
        }, {
            title: "fab fa-sellcast",
            searchTerms: [ "eercast" ]
        }, {
            title: "fab fa-sellsy",
            searchTerms: []
        }, {
            title: "fas fa-server",
            searchTerms: [ "cpu" ]
        }, {
            title: "fab fa-servicestack",
            searchTerms: []
        }, {
            title: "fas fa-shapes",
            searchTerms: [ "circle", "square", "triangle" ]
        }, {
            title: "fas fa-share",
            searchTerms: []
        }, {
            title: "fas fa-share-alt",
            searchTerms: []
        }, {
            title: "fas fa-share-alt-square",
            searchTerms: []
        }, {
            title: "fas fa-share-square",
            searchTerms: [ "send", "social" ]
        }, {
            title: "far fa-share-square",
            searchTerms: [ "send", "social" ]
        }, {
            title: "fas fa-shekel-sign",
            searchTerms: [ "ils" ]
        }, {
            title: "fas fa-shield-alt",
            searchTerms: [ "achievement", "award", "block", "defend", "security", "winner" ]
        }, {
            title: "fas fa-ship",
            searchTerms: [ "boat", "sea" ]
        }, {
            title: "fas fa-shipping-fast",
            searchTerms: []
        }, {
            title: "fab fa-shirtsinbulk",
            searchTerms: []
        }, {
            title: "fas fa-shoe-prints",
            searchTerms: [ "feet", "footprints", "steps" ]
        }, {
            title: "fas fa-shopping-bag",
            searchTerms: []
        }, {
            title: "fas fa-shopping-basket",
            searchTerms: []
        }, {
            title: "fas fa-shopping-cart",
            searchTerms: [ "buy", "checkout", "payment", "purchase" ]
        }, {
            title: "fab fa-shopware",
            searchTerms: []
        }, {
            title: "fas fa-shower",
            searchTerms: []
        }, {
            title: "fas fa-shuttle-van",
            searchTerms: [ "machine", "public-transportation", "transportation", "vehicle" ]
        }, {
            title: "fas fa-sign",
            searchTerms: []
        }, {
            title: "fas fa-sign-in-alt",
            searchTerms: [ "arrow", "enter", "join", "log in", "login", "sign in", "sign up", "sign-in", "signin", "signup" ]
        }, {
            title: "fas fa-sign-language",
            searchTerms: []
        }, {
            title: "fas fa-sign-out-alt",
            searchTerms: [ "arrow", "exit", "leave", "log out", "logout", "sign-out" ]
        }, {
            title: "fas fa-signal",
            searchTerms: [ "bars", "graph", "online", "status" ]
        }, {
            title: "fas fa-signature",
            searchTerms: [ "John Hancock", "cursive", "name", "writing" ]
        }, {
            title: "fab fa-simplybuilt",
            searchTerms: []
        }, {
            title: "fab fa-sistrix",
            searchTerms: []
        }, {
            title: "fas fa-sitemap",
            searchTerms: [ "directory", "hierarchy", "ia", "information architecture", "organization" ]
        }, {
            title: "fab fa-sith",
            searchTerms: []
        }, {
            title: "fas fa-skull",
            searchTerms: [ "bones", "skeleton", "yorick" ]
        }, {
            title: "fas fa-skull-crossbones",
            searchTerms: [ "Dungeons & Dragons", "alert", "bones", "d&d", "danger", "dead", "deadly", "death", "dnd", "fantasy", "halloween", "holiday", "jolly-roger", "pirate", "poison", "skeleton", "warning" ]
        }, {
            title: "fab fa-skyatlas",
            searchTerms: []
        }, {
            title: "fab fa-skype",
            searchTerms: []
        }, {
            title: "fab fa-slack",
            searchTerms: [ "anchor", "hash", "hashtag" ]
        }, {
            title: "fab fa-slack-hash",
            searchTerms: [ "anchor", "hash", "hashtag" ]
        }, {
            title: "fas fa-slash",
            searchTerms: []
        }, {
            title: "fas fa-sliders-h",
            searchTerms: [ "settings", "sliders" ]
        }, {
            title: "fab fa-slideshare",
            searchTerms: []
        }, {
            title: "fas fa-smile",
            searchTerms: [ "approve", "emoticon", "face", "happy", "rating", "satisfied" ]
        }, {
            title: "far fa-smile",
            searchTerms: [ "approve", "emoticon", "face", "happy", "rating", "satisfied" ]
        }, {
            title: "fas fa-smile-beam",
            searchTerms: [ "emoticon", "face", "happy", "positive" ]
        }, {
            title: "far fa-smile-beam",
            searchTerms: [ "emoticon", "face", "happy", "positive" ]
        }, {
            title: "fas fa-smile-wink",
            searchTerms: [ "emoticon", "face", "happy" ]
        }, {
            title: "far fa-smile-wink",
            searchTerms: [ "emoticon", "face", "happy" ]
        }, {
            title: "fas fa-smog",
            searchTerms: [ "dragon" ]
        }, {
            title: "fas fa-smoking",
            searchTerms: [ "cigarette", "nicotine", "smoking status" ]
        }, {
            title: "fas fa-smoking-ban",
            searchTerms: [ "no smoking", "non-smoking" ]
        }, {
            title: "fab fa-snapchat",
            searchTerms: []
        }, {
            title: "fab fa-snapchat-ghost",
            searchTerms: []
        }, {
            title: "fab fa-snapchat-square",
            searchTerms: []
        }, {
            title: "fas fa-snowflake",
            searchTerms: [ "precipitation", "seasonal", "winter" ]
        }, {
            title: "far fa-snowflake",
            searchTerms: [ "precipitation", "seasonal", "winter" ]
        }, {
            title: "fas fa-socks",
            searchTerms: [ "business socks", "business time", "flight of the conchords", "wednesday" ]
        }, {
            title: "fas fa-solar-panel",
            searchTerms: [ "clean", "eco-friendly", "energy", "green", "sun" ]
        }, {
            title: "fas fa-sort",
            searchTerms: [ "order" ]
        }, {
            title: "fas fa-sort-alpha-down",
            searchTerms: [ "sort-alpha-asc" ]
        }, {
            title: "fas fa-sort-alpha-up",
            searchTerms: [ "sort-alpha-desc" ]
        }, {
            title: "fas fa-sort-amount-down",
            searchTerms: [ "sort-amount-asc" ]
        }, {
            title: "fas fa-sort-amount-up",
            searchTerms: [ "sort-amount-desc" ]
        }, {
            title: "fas fa-sort-down",
            searchTerms: [ "arrow", "descending", "sort-desc" ]
        }, {
            title: "fas fa-sort-numeric-down",
            searchTerms: [ "numbers", "sort-numeric-asc" ]
        }, {
            title: "fas fa-sort-numeric-up",
            searchTerms: [ "numbers", "sort-numeric-desc" ]
        }, {
            title: "fas fa-sort-up",
            searchTerms: [ "arrow", "ascending", "sort-asc" ]
        }, {
            title: "fab fa-soundcloud",
            searchTerms: []
        }, {
            title: "fas fa-spa",
            searchTerms: [ "flora", "mindfullness", "plant", "wellness" ]
        }, {
            title: "fas fa-space-shuttle",
            searchTerms: [ "astronaut", "machine", "nasa", "rocket", "transportation" ]
        }, {
            title: "fab fa-speakap",
            searchTerms: []
        }, {
            title: "fas fa-spider",
            searchTerms: [ "arachnid", "bug", "charlotte", "crawl", "eight", "halloween", "holiday" ]
        }, {
            title: "fas fa-spinner",
            searchTerms: [ "loading", "progress" ]
        }, {
            title: "fas fa-splotch",
            searchTerms: []
        }, {
            title: "fab fa-spotify",
            searchTerms: []
        }, {
            title: "fas fa-spray-can",
            searchTerms: []
        }, {
            title: "fas fa-square",
            searchTerms: [ "block", "box" ]
        }, {
            title: "far fa-square",
            searchTerms: [ "block", "box" ]
        }, {
            title: "fas fa-square-full",
            searchTerms: []
        }, {
            title: "fas fa-square-root-alt",
            searchTerms: []
        }, {
            title: "fab fa-squarespace",
            searchTerms: []
        }, {
            title: "fab fa-stack-exchange",
            searchTerms: []
        }, {
            title: "fab fa-stack-overflow",
            searchTerms: []
        }, {
            title: "fas fa-stamp",
            searchTerms: []
        }, {
            title: "fas fa-star",
            searchTerms: [ "achievement", "award", "favorite", "important", "night", "rating", "score" ]
        }, {
            title: "far fa-star",
            searchTerms: [ "achievement", "award", "favorite", "important", "night", "rating", "score" ]
        }, {
            title: "fas fa-star-and-crescent",
            searchTerms: [ "islam", "muslim" ]
        }, {
            title: "fas fa-star-half",
            searchTerms: [ "achievement", "award", "rating", "score", "star-half-empty", "star-half-full" ]
        }, {
            title: "far fa-star-half",
            searchTerms: [ "achievement", "award", "rating", "score", "star-half-empty", "star-half-full" ]
        }, {
            title: "fas fa-star-half-alt",
            searchTerms: [ "achievement", "award", "rating", "score", "star-half-empty", "star-half-full" ]
        }, {
            title: "fas fa-star-of-david",
            searchTerms: [ "jewish", "judaism" ]
        }, {
            title: "fas fa-star-of-life",
            searchTerms: []
        }, {
            title: "fab fa-staylinked",
            searchTerms: []
        }, {
            title: "fab fa-steam",
            searchTerms: []
        }, {
            title: "fab fa-steam-square",
            searchTerms: []
        }, {
            title: "fab fa-steam-symbol",
            searchTerms: []
        }, {
            title: "fas fa-step-backward",
            searchTerms: [ "beginning", "first", "previous", "rewind", "start" ]
        }, {
            title: "fas fa-step-forward",
            searchTerms: [ "end", "last", "next" ]
        }, {
            title: "fas fa-stethoscope",
            searchTerms: []
        }, {
            title: "fab fa-sticker-mule",
            searchTerms: []
        }, {
            title: "fas fa-sticky-note",
            searchTerms: []
        }, {
            title: "far fa-sticky-note",
            searchTerms: []
        }, {
            title: "fas fa-stop",
            searchTerms: [ "block", "box", "square" ]
        }, {
            title: "fas fa-stop-circle",
            searchTerms: []
        }, {
            title: "far fa-stop-circle",
            searchTerms: []
        }, {
            title: "fas fa-stopwatch",
            searchTerms: [ "time" ]
        }, {
            title: "fas fa-store",
            searchTerms: []
        }, {
            title: "fas fa-store-alt",
            searchTerms: []
        }, {
            title: "fab fa-strava",
            searchTerms: []
        }, {
            title: "fas fa-stream",
            searchTerms: []
        }, {
            title: "fas fa-street-view",
            searchTerms: [ "map" ]
        }, {
            title: "fas fa-strikethrough",
            searchTerms: []
        }, {
            title: "fab fa-stripe",
            searchTerms: []
        }, {
            title: "fab fa-stripe-s",
            searchTerms: []
        }, {
            title: "fas fa-stroopwafel",
            searchTerms: [ "dessert", "food", "sweets", "waffle" ]
        }, {
            title: "fab fa-studiovinari",
            searchTerms: []
        }, {
            title: "fab fa-stumbleupon",
            searchTerms: []
        }, {
            title: "fab fa-stumbleupon-circle",
            searchTerms: []
        }, {
            title: "fas fa-subscript",
            searchTerms: []
        }, {
            title: "fas fa-subway",
            searchTerms: [ "machine", "railway", "train", "transportation", "vehicle" ]
        }, {
            title: "fas fa-suitcase",
            searchTerms: [ "baggage", "luggage", "move", "suitcase", "travel", "trip" ]
        }, {
            title: "fas fa-suitcase-rolling",
            searchTerms: []
        }, {
            title: "fas fa-sun",
            searchTerms: [ "brighten", "contrast", "day", "lighter", "sol", "solar", "star", "weather" ]
        }, {
            title: "far fa-sun",
            searchTerms: [ "brighten", "contrast", "day", "lighter", "sol", "solar", "star", "weather" ]
        }, {
            title: "fab fa-superpowers",
            searchTerms: []
        }, {
            title: "fas fa-superscript",
            searchTerms: [ "exponential" ]
        }, {
            title: "fab fa-supple",
            searchTerms: []
        }, {
            title: "fas fa-surprise",
            searchTerms: [ "emoticon", "face", "shocked" ]
        }, {
            title: "far fa-surprise",
            searchTerms: [ "emoticon", "face", "shocked" ]
        }, {
            title: "fas fa-swatchbook",
            searchTerms: []
        }, {
            title: "fas fa-swimmer",
            searchTerms: [ "athlete", "head", "man", "person", "water" ]
        }, {
            title: "fas fa-swimming-pool",
            searchTerms: [ "ladder", "recreation", "water" ]
        }, {
            title: "fas fa-synagogue",
            searchTerms: [ "building", "jewish", "judaism", "star of david", "temple" ]
        }, {
            title: "fas fa-sync",
            searchTerms: [ "exchange", "refresh", "reload", "rotate", "swap" ]
        }, {
            title: "fas fa-sync-alt",
            searchTerms: [ "refresh", "reload", "rotate" ]
        }, {
            title: "fas fa-syringe",
            searchTerms: [ "immunizations", "needle" ]
        }, {
            title: "fas fa-table",
            searchTerms: [ "data", "excel", "spreadsheet" ]
        }, {
            title: "fas fa-table-tennis",
            searchTerms: []
        }, {
            title: "fas fa-tablet",
            searchTerms: [ "apple", "device", "ipad", "kindle", "screen" ]
        }, {
            title: "fas fa-tablet-alt",
            searchTerms: [ "apple", "device", "ipad", "kindle", "screen" ]
        }, {
            title: "fas fa-tablets",
            searchTerms: [ "drugs", "medicine" ]
        }, {
            title: "fas fa-tachometer-alt",
            searchTerms: [ "dashboard", "tachometer" ]
        }, {
            title: "fas fa-tag",
            searchTerms: [ "label" ]
        }, {
            title: "fas fa-tags",
            searchTerms: [ "labels" ]
        }, {
            title: "fas fa-tape",
            searchTerms: []
        }, {
            title: "fas fa-tasks",
            searchTerms: [ "downloading", "downloads", "loading", "progress", "settings" ]
        }, {
            title: "fas fa-taxi",
            searchTerms: [ "cab", "cabbie", "car", "car service", "lyft", "machine", "transportation", "uber", "vehicle" ]
        }, {
            title: "fab fa-teamspeak",
            searchTerms: []
        }, {
            title: "fas fa-teeth",
            searchTerms: []
        }, {
            title: "fas fa-teeth-open",
            searchTerms: []
        }, {
            title: "fab fa-telegram",
            searchTerms: []
        }, {
            title: "fab fa-telegram-plane",
            searchTerms: []
        }, {
            title: "fas fa-temperature-high",
            searchTerms: [ "mercury", "thermometer", "warm" ]
        }, {
            title: "fas fa-temperature-low",
            searchTerms: [ "cool", "mercury", "thermometer" ]
        }, {
            title: "fab fa-tencent-weibo",
            searchTerms: []
        }, {
            title: "fas fa-terminal",
            searchTerms: [ "code", "command", "console", "prompt" ]
        }, {
            title: "fas fa-text-height",
            searchTerms: []
        }, {
            title: "fas fa-text-width",
            searchTerms: []
        }, {
            title: "fas fa-th",
            searchTerms: [ "blocks", "boxes", "grid", "squares" ]
        }, {
            title: "fas fa-th-large",
            searchTerms: [ "blocks", "boxes", "grid", "squares" ]
        }, {
            title: "fas fa-th-list",
            searchTerms: [ "checklist", "completed", "done", "finished", "ol", "todo", "ul" ]
        }, {
            title: "fab fa-the-red-yeti",
            searchTerms: []
        }, {
            title: "fas fa-theater-masks",
            searchTerms: []
        }, {
            title: "fab fa-themeco",
            searchTerms: []
        }, {
            title: "fab fa-themeisle",
            searchTerms: []
        }, {
            title: "fas fa-thermometer",
            searchTerms: [ "mercury", "status", "temperature" ]
        }, {
            title: "fas fa-thermometer-empty",
            searchTerms: [ "mercury", "status", "temperature" ]
        }, {
            title: "fas fa-thermometer-full",
            searchTerms: [ "fever", "mercury", "status", "temperature" ]
        }, {
            title: "fas fa-thermometer-half",
            searchTerms: [ "mercury", "status", "temperature" ]
        }, {
            title: "fas fa-thermometer-quarter",
            searchTerms: [ "mercury", "status", "temperature" ]
        }, {
            title: "fas fa-thermometer-three-quarters",
            searchTerms: [ "mercury", "status", "temperature" ]
        }, {
            title: "fab fa-think-peaks",
            searchTerms: []
        }, {
            title: "fas fa-thumbs-down",
            searchTerms: [ "disagree", "disapprove", "dislike", "hand", "thumbs-o-down" ]
        }, {
            title: "far fa-thumbs-down",
            searchTerms: [ "disagree", "disapprove", "dislike", "hand", "thumbs-o-down" ]
        }, {
            title: "fas fa-thumbs-up",
            searchTerms: [ "agree", "approve", "favorite", "hand", "like", "ok", "okay", "success", "thumbs-o-up", "yes", "you got it dude" ]
        }, {
            title: "far fa-thumbs-up",
            searchTerms: [ "agree", "approve", "favorite", "hand", "like", "ok", "okay", "success", "thumbs-o-up", "yes", "you got it dude" ]
        }, {
            title: "fas fa-thumbtack",
            searchTerms: [ "coordinates", "location", "marker", "pin", "thumb-tack" ]
        }, {
            title: "fas fa-ticket-alt",
            searchTerms: [ "ticket" ]
        }, {
            title: "fas fa-times",
            searchTerms: [ "close", "cross", "error", "exit", "incorrect", "notice", "notification", "notify", "problem", "wrong", "x" ]
        }, {
            title: "fas fa-times-circle",
            searchTerms: [ "close", "cross", "exit", "incorrect", "notice", "notification", "notify", "problem", "wrong", "x" ]
        }, {
            title: "far fa-times-circle",
            searchTerms: [ "close", "cross", "exit", "incorrect", "notice", "notification", "notify", "problem", "wrong", "x" ]
        }, {
            title: "fas fa-tint",
            searchTerms: [ "drop", "droplet", "raindrop", "waterdrop" ]
        }, {
            title: "fas fa-tint-slash",
            searchTerms: []
        }, {
            title: "fas fa-tired",
            searchTerms: [ "emoticon", "face", "grumpy" ]
        }, {
            title: "far fa-tired",
            searchTerms: [ "emoticon", "face", "grumpy" ]
        }, {
            title: "fas fa-toggle-off",
            searchTerms: [ "switch" ]
        }, {
            title: "fas fa-toggle-on",
            searchTerms: [ "switch" ]
        }, {
            title: "fas fa-toilet-paper",
            searchTerms: [ "bathroom", "halloween", "holiday", "lavatory", "prank", "restroom", "roll" ]
        }, {
            title: "fas fa-toolbox",
            searchTerms: [ "admin", "container", "fix", "repair", "settings", "tools" ]
        }, {
            title: "fas fa-tooth",
            searchTerms: [ "bicuspid", "dental", "molar", "mouth", "teeth" ]
        }, {
            title: "fas fa-torah",
            searchTerms: [ "book", "jewish", "judaism" ]
        }, {
            title: "fas fa-torii-gate",
            searchTerms: [ "building", "shintoism" ]
        }, {
            title: "fas fa-tractor",
            searchTerms: []
        }, {
            title: "fab fa-trade-federation",
            searchTerms: []
        }, {
            title: "fas fa-trademark",
            searchTerms: []
        }, {
            title: "fas fa-traffic-light",
            searchTerms: []
        }, {
            title: "fas fa-train",
            searchTerms: [ "bullet", "locomotive", "railway" ]
        }, {
            title: "fas fa-transgender",
            searchTerms: [ "intersex" ]
        }, {
            title: "fas fa-transgender-alt",
            searchTerms: []
        }, {
            title: "fas fa-trash",
            searchTerms: [ "delete", "garbage", "hide", "remove" ]
        }, {
            title: "fas fa-trash-alt",
            searchTerms: [ "delete", "garbage", "hide", "remove", "trash", "trash-o" ]
        }, {
            title: "far fa-trash-alt",
            searchTerms: [ "delete", "garbage", "hide", "remove", "trash", "trash-o" ]
        }, {
            title: "fas fa-tree",
            searchTerms: [ "bark", "fall", "flora", "forest", "nature", "plant", "seasonal" ]
        }, {
            title: "fab fa-trello",
            searchTerms: []
        }, {
            title: "fab fa-tripadvisor",
            searchTerms: []
        }, {
            title: "fas fa-trophy",
            searchTerms: [ "achievement", "award", "cup", "game", "winner" ]
        }, {
            title: "fas fa-truck",
            searchTerms: [ "delivery", "shipping" ]
        }, {
            title: "fas fa-truck-loading",
            searchTerms: []
        }, {
            title: "fas fa-truck-monster",
            searchTerms: []
        }, {
            title: "fas fa-truck-moving",
            searchTerms: []
        }, {
            title: "fas fa-truck-pickup",
            searchTerms: []
        }, {
            title: "fas fa-tshirt",
            searchTerms: [ "cloth", "clothing" ]
        }, {
            title: "fas fa-tty",
            searchTerms: []
        }, {
            title: "fab fa-tumblr",
            searchTerms: []
        }, {
            title: "fab fa-tumblr-square",
            searchTerms: []
        }, {
            title: "fas fa-tv",
            searchTerms: [ "computer", "display", "monitor", "television" ]
        }, {
            title: "fab fa-twitch",
            searchTerms: []
        }, {
            title: "fab fa-twitter",
            searchTerms: [ "social network", "tweet" ]
        }, {
            title: "fab fa-twitter-square",
            searchTerms: [ "social network", "tweet" ]
        }, {
            title: "fab fa-typo3",
            searchTerms: []
        }, {
            title: "fab fa-uber",
            searchTerms: []
        }, {
            title: "fab fa-uikit",
            searchTerms: []
        }, {
            title: "fas fa-umbrella",
            searchTerms: [ "protection", "rain" ]
        }, {
            title: "fas fa-umbrella-beach",
            searchTerms: [ "protection", "recreation", "sun" ]
        }, {
            title: "fas fa-underline",
            searchTerms: []
        }, {
            title: "fas fa-undo",
            searchTerms: [ "back", "control z", "exchange", "oops", "return", "rotate", "swap" ]
        }, {
            title: "fas fa-undo-alt",
            searchTerms: [ "back", "control z", "exchange", "oops", "return", "swap" ]
        }, {
            title: "fab fa-uniregistry",
            searchTerms: []
        }, {
            title: "fas fa-universal-access",
            searchTerms: []
        }, {
            title: "fas fa-university",
            searchTerms: [ "bank", "institution" ]
        }, {
            title: "fas fa-unlink",
            searchTerms: [ "chain", "chain-broken", "remove" ]
        }, {
            title: "fas fa-unlock",
            searchTerms: [ "admin", "lock", "password", "protect" ]
        }, {
            title: "fas fa-unlock-alt",
            searchTerms: [ "admin", "lock", "password", "protect" ]
        }, {
            title: "fab fa-untappd",
            searchTerms: []
        }, {
            title: "fas fa-upload",
            searchTerms: [ "export", "publish" ]
        }, {
            title: "fab fa-usb",
            searchTerms: []
        }, {
            title: "fas fa-user",
            searchTerms: [ "account", "avatar", "head", "human", "man", "person", "profile" ]
        }, {
            title: "far fa-user",
            searchTerms: [ "account", "avatar", "head", "human", "man", "person", "profile" ]
        }, {
            title: "fas fa-user-alt",
            searchTerms: [ "account", "avatar", "head", "human", "man", "person", "profile" ]
        }, {
            title: "fas fa-user-alt-slash",
            searchTerms: []
        }, {
            title: "fas fa-user-astronaut",
            searchTerms: [ "avatar", "clothing", "cosmonaut", "space", "suit" ]
        }, {
            title: "fas fa-user-check",
            searchTerms: []
        }, {
            title: "fas fa-user-circle",
            searchTerms: [ "account", "avatar", "head", "human", "man", "person", "profile" ]
        }, {
            title: "far fa-user-circle",
            searchTerms: [ "account", "avatar", "head", "human", "man", "person", "profile" ]
        }, {
            title: "fas fa-user-clock",
            searchTerms: []
        }, {
            title: "fas fa-user-cog",
            searchTerms: []
        }, {
            title: "fas fa-user-edit",
            searchTerms: []
        }, {
            title: "fas fa-user-friends",
            searchTerms: []
        }, {
            title: "fas fa-user-graduate",
            searchTerms: [ "cap", "clothing", "commencement", "gown", "graduation", "student" ]
        }, {
            title: "fas fa-user-injured",
            searchTerms: [ "cast", "ouch", "sling" ]
        }, {
            title: "fas fa-user-lock",
            searchTerms: []
        }, {
            title: "fas fa-user-md",
            searchTerms: [ "doctor", "job", "medical", "nurse", "occupation", "profile" ]
        }, {
            title: "fas fa-user-minus",
            searchTerms: [ "delete", "negative", "remove" ]
        }, {
            title: "fas fa-user-ninja",
            searchTerms: [ "assassin", "avatar", "dangerous", "deadly", "sneaky" ]
        }, {
            title: "fas fa-user-plus",
            searchTerms: [ "positive", "sign up", "signup" ]
        }, {
            title: "fas fa-user-secret",
            searchTerms: [ "clothing", "coat", "hat", "incognito", "privacy", "spy", "whisper" ]
        }, {
            title: "fas fa-user-shield",
            searchTerms: []
        }, {
            title: "fas fa-user-slash",
            searchTerms: [ "ban", "remove" ]
        }, {
            title: "fas fa-user-tag",
            searchTerms: []
        }, {
            title: "fas fa-user-tie",
            searchTerms: [ "avatar", "business", "clothing", "formal" ]
        }, {
            title: "fas fa-user-times",
            searchTerms: [ "archive", "delete", "remove", "x" ]
        }, {
            title: "fas fa-users",
            searchTerms: [ "people", "persons", "profiles" ]
        }, {
            title: "fas fa-users-cog",
            searchTerms: []
        }, {
            title: "fab fa-ussunnah",
            searchTerms: []
        }, {
            title: "fas fa-utensil-spoon",
            searchTerms: [ "spoon" ]
        }, {
            title: "fas fa-utensils",
            searchTerms: [ "cutlery", "dinner", "eat", "food", "knife", "restaurant", "spoon" ]
        }, {
            title: "fab fa-vaadin",
            searchTerms: []
        }, {
            title: "fas fa-vector-square",
            searchTerms: [ "anchors", "lines", "object" ]
        }, {
            title: "fas fa-venus",
            searchTerms: [ "female" ]
        }, {
            title: "fas fa-venus-double",
            searchTerms: []
        }, {
            title: "fas fa-venus-mars",
            searchTerms: []
        }, {
            title: "fab fa-viacoin",
            searchTerms: []
        }, {
            title: "fab fa-viadeo",
            searchTerms: []
        }, {
            title: "fab fa-viadeo-square",
            searchTerms: []
        }, {
            title: "fas fa-vial",
            searchTerms: [ "test tube" ]
        }, {
            title: "fas fa-vials",
            searchTerms: [ "lab results", "test tubes" ]
        }, {
            title: "fab fa-viber",
            searchTerms: []
        }, {
            title: "fas fa-video",
            searchTerms: [ "camera", "film", "movie", "record", "video-camera" ]
        }, {
            title: "fas fa-video-slash",
            searchTerms: []
        }, {
            title: "fas fa-vihara",
            searchTerms: [ "buddhism", "buddhist", "building", "monastery" ]
        }, {
            title: "fab fa-vimeo",
            searchTerms: []
        }, {
            title: "fab fa-vimeo-square",
            searchTerms: []
        }, {
            title: "fab fa-vimeo-v",
            searchTerms: [ "vimeo" ]
        }, {
            title: "fab fa-vine",
            searchTerms: []
        }, {
            title: "fab fa-vk",
            searchTerms: []
        }, {
            title: "fab fa-vnv",
            searchTerms: []
        }, {
            title: "fas fa-volleyball-ball",
            searchTerms: []
        }, {
            title: "fas fa-volume-down",
            searchTerms: [ "audio", "lower", "music", "quieter", "sound", "speaker" ]
        }, {
            title: "fas fa-volume-mute",
            searchTerms: []
        }, {
            title: "fas fa-volume-off",
            searchTerms: [ "audio", "music", "mute", "sound" ]
        }, {
            title: "fas fa-volume-up",
            searchTerms: [ "audio", "higher", "louder", "music", "sound", "speaker" ]
        }, {
            title: "fas fa-vote-yea",
            searchTerms: [ "accept", "cast", "election", "politics", "positive", "yes" ]
        }, {
            title: "fas fa-vr-cardboard",
            searchTerms: [ "google", "reality", "virtual" ]
        }, {
            title: "fab fa-vuejs",
            searchTerms: []
        }, {
            title: "fas fa-walking",
            searchTerms: []
        }, {
            title: "fas fa-wallet",
            searchTerms: []
        }, {
            title: "fas fa-warehouse",
            searchTerms: []
        }, {
            title: "fas fa-water",
            searchTerms: []
        }, {
            title: "fab fa-weebly",
            searchTerms: []
        }, {
            title: "fab fa-weibo",
            searchTerms: []
        }, {
            title: "fas fa-weight",
            searchTerms: [ "measurement", "scale", "weight" ]
        }, {
            title: "fas fa-weight-hanging",
            searchTerms: [ "anvil", "heavy", "measurement" ]
        }, {
            title: "fab fa-weixin",
            searchTerms: []
        }, {
            title: "fab fa-whatsapp",
            searchTerms: []
        }, {
            title: "fab fa-whatsapp-square",
            searchTerms: []
        }, {
            title: "fas fa-wheelchair",
            searchTerms: [ "handicap", "person" ]
        }, {
            title: "fab fa-whmcs",
            searchTerms: []
        }, {
            title: "fas fa-wifi",
            searchTerms: []
        }, {
            title: "fab fa-wikipedia-w",
            searchTerms: []
        }, {
            title: "fas fa-wind",
            searchTerms: [ "air", "blow", "breeze", "fall", "seasonal" ]
        }, {
            title: "fas fa-window-close",
            searchTerms: []
        }, {
            title: "far fa-window-close",
            searchTerms: []
        }, {
            title: "fas fa-window-maximize",
            searchTerms: []
        }, {
            title: "far fa-window-maximize",
            searchTerms: []
        }, {
            title: "fas fa-window-minimize",
            searchTerms: []
        }, {
            title: "far fa-window-minimize",
            searchTerms: []
        }, {
            title: "fas fa-window-restore",
            searchTerms: []
        }, {
            title: "far fa-window-restore",
            searchTerms: []
        }, {
            title: "fab fa-windows",
            searchTerms: [ "microsoft" ]
        }, {
            title: "fas fa-wine-bottle",
            searchTerms: [ "alcohol", "beverage", "drink", "glass", "grapes" ]
        }, {
            title: "fas fa-wine-glass",
            searchTerms: [ "alcohol", "beverage", "drink", "grapes" ]
        }, {
            title: "fas fa-wine-glass-alt",
            searchTerms: [ "alcohol", "beverage", "drink", "grapes" ]
        }, {
            title: "fab fa-wix",
            searchTerms: []
        }, {
            title: "fab fa-wizards-of-the-coast",
            searchTerms: [ "Dungeons & Dragons", "d&d", "dnd", "fantasy", "game", "gaming", "tabletop" ]
        }, {
            title: "fab fa-wolf-pack-battalion",
            searchTerms: []
        }, {
            title: "fas fa-won-sign",
            searchTerms: [ "krw" ]
        }, {
            title: "fab fa-wordpress",
            searchTerms: []
        }, {
            title: "fab fa-wordpress-simple",
            searchTerms: []
        }, {
            title: "fab fa-wpbeginner",
            searchTerms: []
        }, {
            title: "fab fa-wpexplorer",
            searchTerms: []
        }, {
            title: "fab fa-wpforms",
            searchTerms: []
        }, {
            title: "fab fa-wpressr",
            searchTerms: [ "rendact" ]
        }, {
            title: "fas fa-wrench",
            searchTerms: [ "fix", "settings", "spanner", "tool", "update" ]
        }, {
            title: "fas fa-x-ray",
            searchTerms: [ "radiological images", "radiology" ]
        }, {
            title: "fab fa-xbox",
            searchTerms: []
        }, {
            title: "fab fa-xing",
            searchTerms: []
        }, {
            title: "fab fa-xing-square",
            searchTerms: []
        }, {
            title: "fab fa-y-combinator",
            searchTerms: []
        }, {
            title: "fab fa-yahoo",
            searchTerms: []
        }, {
            title: "fab fa-yandex",
            searchTerms: []
        }, {
            title: "fab fa-yandex-international",
            searchTerms: []
        }, {
            title: "fab fa-yelp",
            searchTerms: []
        }, {
            title: "fas fa-yen-sign",
            searchTerms: [ "jpy", "money" ]
        }, {
            title: "fas fa-yin-yang",
            searchTerms: [ "daoism", "opposites", "taoism" ]
        }, {
            title: "fab fa-yoast",
            searchTerms: []
        }, {
            title: "fab fa-youtube",
            searchTerms: [ "film", "video", "youtube-play", "youtube-square" ]
        }, {
            title: "fab fa-youtube-square",
            searchTerms: []
        }, {
            title: "fab fa-zhihu",
            searchTerms: []
        } ];
    return icons;
});
define('skylark-widgets-iconpicker/IconPicker',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-query",
    "skylark-widgets-base/Widget",
    "./allIcons"
],function(skylark,langx, $, Widget,allIcons) {
    'use strict';

    var _helpers = {

        isElement: function(selector) {
            return ($(selector).length > 0);
        },

    };

    var IconPicker = Widget.inherit({
        klassName : "IconPicker",

        pluginName : "lark.iconpicker",

        options : {
            title: false, // Popover title (optional) only if specified in the template
            selected: false, // use this value as the current item and ignore the original
            defaultValue: false, // use this value as the current item if input or element value is empty
            placement: 'bottom', // (has some issues with auto and CSS). auto, top, bottom, left, right
            collision: 'none', // If true, the popover will be repositioned to another position when collapses with the window borders
            animation: true, // fade in/out on show/hide ?
            //hide iconpicker automatically when a value is picked. it is ignored if mustAccept is not false and the accept button is visible
            hideOnSelect: false,
            showFooter: false,
            searchInFooter: false, // If true, the search will be added to the footer instead of the title
            mustAccept: false, // only applicable when there's an iconpicker-btn-accept button in the popover footer
            selectedCustomClass: 'bg-primary', // Appends this class when to the selected item
            icons: allIcons, // list of icon classes 
            fullClassFormatter: function(val) {
                return val;
            },
            input: 'input,.iconpicker-input', // children input selector
            inputSearch: false, // use the input as a search box too?
            container: false, //  Appends the popover to a specific element. If not set, the selected element or element parent is used
            component: '.input-group-addon,.iconpicker-component', // children component jQuery selector or object, relative to the container element
            // Plugin templates:
            templates: {
                popover: '<div class="iconpicker-popover popover"><div class="arrow"></div>' +
                    '<div class="popover-title"></div><div class="popover-content"></div></div>',
                footer: '<div class="popover-footer"></div>',
                buttons: '<button class="iconpicker-btn iconpicker-btn-cancel btn btn-default btn-sm">Cancel</button>' +
                    ' <button class="iconpicker-btn iconpicker-btn-accept btn btn-primary btn-sm">Accept</button>',
                search: '<input type="search" class="form-control iconpicker-search" placeholder="Type to filter" />',
                iconpicker: '<div class="iconpicker"><div class="iconpicker-items"></div></div>',
                iconpickerItem: '<a role="button" href="javascript:;" class="iconpicker-item"><i></i></a>',
            }
        },

        //_construct : function(element, options) {
        _init : function() {
            this.$element = $(this._elm).addClass('iconpicker-element');

            //this.options = langx.extend(true,{}, this.options, this.element.data(), options);
            this.options.originalPlacement = this.options.placement;

            // Iconpicker container element
            this.container = (_helpers.isElement(this.options.container) ? $(this.options.container) : false);
            if (this.container === false) {
                if (this.$element.is('.dropdown-toggle')) {
                    this.container = $('~ .dropdown-menu:first', this.$element);
                } else {
                    this.container = (this.$element.is('input,textarea,button,.btn') ? this.$element.parent() : this.$element);
                }
            }
            this.container.addClass('iconpicker-container');

            if (this.isDropdownMenu()) {
                this.options.placement = 'inline';
            }

            // Is the element an input? Should we search inside for any input?
            this.input = (this.$element.is('input,textarea') ? this.$element.addClass('iconpicker-input') : false);
            if (this.input === false) {
                this.input = (this.container.find(this.options.input));
                if (!this.input.is('input,textarea')) {
                    this.input = false;
                }
            }

            // Plugin as component ?
            this.component = this.isDropdownMenu() ? this.container.parent().find(this.options.component) : this.container.find(this.options.component);
            if (this.component.length === 0) {
                this.component = false;
            } else {
                this.component.find('i').addClass('iconpicker-component');
            }

            // Create popover and iconpicker HTML
            this._createPopover();
            this._createIconpicker();

            if (this.getAcceptButton().length === 0) {
                // disable this because we don't have accept buttons
                this.options.mustAccept = false;
            }

            // Avoid CSS issues with input-group-addon(s)
            if (this.isInputGroup()) {
                this.container.parent().append(this.popover);
            } else {
                this.container.append(this.popover);
            }

            this._id = this.getUID();
            
            // Bind events
            this._bindElementEvents();
            this._bindWindowEvents();

            // Refresh everything
            this.update(this.options.selected);

            if (this.isInline()) {
                this.show();
            }
        },


        _createPopover: function() {
            this.popover = $(this.options.templates.popover);

            // title (header)
            var _title = this.popover.find('.popover-title');
            if (!!this.options.title) {
                _title.append($('<div class="popover-title-text">' + this.options.title + '</div>'));
            }
            if (this.hasSeparatedSearchInput() && !this.options.searchInFooter) {
                _title.append(this.options.templates.search);
            } else if (!this.options.title) {
                _title.remove();
            }

            // footer
            if (this.options.showFooter && this.options.templates.footer) {
                var _footer = $(this.options.templates.footer);
                if (this.hasSeparatedSearchInput() && this.options.searchInFooter) {
                    _footer.append($(this.options.templates.search));
                }
                if (this.options.templates.buttons) {
                    _footer.append($(this.options.templates.buttons));
                }
                this.popover.append(_footer);
            }

            if (this.options.animation === true) {
                this.popover.addClass('fade');
            }

            return this.popover;
        },
        _createIconpicker: function() {
            var _self = this;
            this.iconpicker = $(this.options.templates.iconpicker);

            var itemClickFn = function(e) {
                var $this = $(this);
                if ($this.is('i')) {
                    $this = $this.parent();
                }

                if (_self.options.mustAccept === false) {
                    _self.update($this.data('iconpickerValue'));
                    _self.emit('picked', {
                        data: _self.iconpickerValue
                    });

                } else {
                    _self.update($this.data('iconpickerValue'), true);
                }

                if (_self.options.hideOnSelect && (_self.options.mustAccept === false)) {
                    // only hide when the accept button is not present
                    _self.hide();
                }
            };

            var $itemElementTemplate = $(this.options.templates.iconpickerItem);
            var $elementsToAppend = [];
            for (var i in this.options.icons) {
                if (typeof this.options.icons[i].title === 'string') {
                    var itemElement = $itemElementTemplate.clone();
                    itemElement.find('i')
                        .addClass(this.options.fullClassFormatter(this.options.icons[i].title));
                    itemElement.data('iconpickerValue', this.options.icons[i].title)
                        .on('click.iconpicker', itemClickFn);

                    itemElement.attr('title', '.' + this.options.icons[i].title);
                    if (this.options.icons[i].searchTerms.length > 0) {
                        var searchTerms = '';
                        for (var j = 0; j < this.options.icons[i].searchTerms.length; j++) {
                            searchTerms = searchTerms + this.options.icons[i].searchTerms[j] + ' ';
                        }
                        itemElement.attr('data-search-terms', searchTerms);
                    }
                    $elementsToAppend.push(itemElement);
                }
            }
            this.iconpicker.find('.iconpicker-items').append($elementsToAppend);
            this.popover.find('.popover-content').append(this.iconpicker);

            return this.iconpicker;
        },
        _isEventInsideIconpicker: function(e) {
            var _t = $(e.target);
            if ((!_t.hasClass('iconpicker-element') ||
                    (_t.hasClass('iconpicker-element') && !_t.is(this.$element))) &&
                (_t.parents('.iconpicker-popover').length === 0)) {
                return false;
            }
            return true;
        },
        _bindElementEvents: function() {
            var _self = this;

            this.getSearchInput().on('keyup.iconpicker', function() {
                _self.filter($(this).val().toLowerCase());
            });

            this.getAcceptButton().on('click.iconpicker', function() {
                var _picked = _self.iconpicker.find('.iconpicker-selected').get(0);

                _self.update(_self.iconpickerValue);

                _self.emit('picked', {
                    data: _self.iconpickerValue
                });

                if (!_self.isInline()) {
                    _self.hide();
                }
            });
            this.getCancelButton().on('click.iconpicker', function() {
                if (!_self.isInline()) {
                    _self.hide();
                }
            });

            this.$element.on('focus.iconpicker', function(e) {
                _self.show();
                e.stopPropagation();
            });

            if (this.hasComponent()) {
                this.component.on('click.iconpicker', function() {
                    _self.toggle();
                });
            }

            if (this.hasInput()) {
                // Bind input keyup event
                this.input.on('keyup.iconpicker', function(e) {
                    if (!_helpers.inArray(e.keyCode, [38, 40, 37, 39, 16, 17, 18, 9, 8, 91, 93, 20, 46, 186, 190, 46, 78, 188, 44, 86])) {
                        _self.update();
                    } else {
                        _self._updateFormGroupStatus(_self.getValid(this.value) !== false);
                    }
                    if (_self.options.inputSearch === true) {
                        _self.filter($(this).val().toLowerCase());
                    }
                    //_self.hide();
                });
            }

        },
        _bindWindowEvents: function() {
            var $doc = $(window.document);
            var _self = this;

            // Add a namespace to the document events so they can be identified
            // later for every instance separately
            var _eventNs = '.iconpicker.inst' + this._id;

            $(window).on('resize.iconpicker' + _eventNs + ' orientationchange.iconpicker' + _eventNs, function(e) {
                // reposition popover
                if (_self.popover.hasClass('in')) {
                    _self.updatePlacement();
                }
            });

            if (!_self.isInline()) {
                $doc.on('mouseup' + _eventNs, function(e) {
                    if (!_self._isEventInsideIconpicker(e) && !_self.isInline()) {
                        _self.hide();
                    }
                });
            }
        },

        
        _unbindElementEvents: function() {
            this.popover.off('.iconpicker');
            this.$element.off('.iconpicker');

            if (this.hasInput()) {
                this.input.off('.iconpicker');
            }

            if (this.hasComponent()) {
                this.component.off('.iconpicker');
            }

            if (this.hasContainer()) {
                this.container.off('.iconpicker');
            }
        },
        _unbindWindowEvents: function() {
            // destroy window and window.document bound events
            $(window).off('.iconpicker.inst' + this._id);
            $(window.document).off('.iconpicker.inst' + this._id);
        },

        updatePlacement: function(placement, collision) {
            placement = placement || this.options.placement;
            this.options.placement = placement; // set new placement
            collision = collision || this.options.collision;
            collision = (collision === true ? 'flip' : collision);

            var _pos = {
                // at: Defines which position (or side) on container element to align the
                // popover element against: "horizontal vertical" alignment.
                at: "right bottom",
                // my: Defines which position (or side) on the popover being positioned to align
                // with the container element: "horizontal vertical" alignment
                my: "right top",
                // of: Which element to position against.
                of: (this.hasInput() && !this.isInputGroup()) ? this.input : this.container,
                // collision: When the positioned element overflows the window (or within element)
                // in some direction, move it to an alternative position.
                collision: (collision === true ? 'flip' : collision),
                // within: Element to position within, affecting collision detection.
                within: window
            };

            // remove previous classes
            this.popover.removeClass('inline topLeftCorner topLeft top topRight topRightCorner ' +
                'rightTop right rightBottom bottomRight bottomRightCorner ' +
                'bottom bottomLeft bottomLeftCorner leftBottom left leftTop');

            if (typeof placement === 'object') {
                // custom position ?
                return this.popover.position(langx.extend({}, _pos, placement));
            }

            switch (placement) {
                case 'inline':
                    {
                        _pos = false;
                    }
                    break;
                case 'topLeftCorner':
                    {
                        _pos.my = 'right bottom';
                        _pos.at = 'left top';
                    }
                    break;

                case 'topLeft':
                    {
                        _pos.my = 'left bottom';
                        _pos.at = 'left top';
                    }
                    break;

                case 'top':
                    {
                        _pos.my = 'center bottom';
                        _pos.at = 'center top';
                    }
                    break;

                case 'topRight':
                    {
                        _pos.my = 'right bottom';
                        _pos.at = 'right top';
                    }
                    break;

                case 'topRightCorner':
                    {
                        _pos.my = 'left bottom';
                        _pos.at = 'right top';
                    }
                    break;

                case 'rightTop':
                    {
                        _pos.my = 'left bottom';
                        _pos.at = 'right center';
                    }
                    break;

                case 'right':
                    {
                        _pos.my = 'left center';
                        _pos.at = 'right center';
                    }
                    break;

                case 'rightBottom':
                    {
                        _pos.my = 'left top';
                        _pos.at = 'right center';
                    }
                    break;

                case 'bottomRightCorner':
                    {
                        _pos.my = 'left top';
                        _pos.at = 'right bottom';
                    }
                    break;

                case 'bottomRight':
                    {
                        _pos.my = 'right top';
                        _pos.at = 'right bottom';
                    }
                    break;
                case 'bottom':
                    {
                        _pos.my = 'center top';
                        _pos.at = 'center bottom';
                    }
                    break;

                case 'bottomLeft':
                    {
                        _pos.my = 'left top';
                        _pos.at = 'left bottom';
                    }
                    break;

                case 'bottomLeftCorner':
                    {
                        _pos.my = 'right top';
                        _pos.at = 'left bottom';
                    }
                    break;

                case 'leftBottom':
                    {
                        _pos.my = 'right top';
                        _pos.at = 'left center';
                    }
                    break;

                case 'left':
                    {
                        _pos.my = 'right center';
                        _pos.at = 'left center';
                    }
                    break;

                case 'leftTop':
                    {
                        _pos.my = 'right bottom';
                        _pos.at = 'left center';
                    }
                    break;

                default:
                    {
                        return false;
                    }
                    break;

            }

            this.popover.css({
                'display': (this.options.placement === 'inline') ? '' : 'block'
            });

            if (_pos !== false) {
                this.popover.position(_pos).css('maxWidth', $(window).width() - this.container.offset().left - 5);
            } else {
                //reset position
                this.popover.css({
                    'top': 'auto',
                    'right': 'auto',
                    'bottom': 'auto',
                    'left': 'auto',
                    'maxWidth': 'none'
                });
            }
            this.popover.addClass(this.options.placement);

            return true;
        },
        _updateComponents: function() {
            // Update selected item
            this.iconpicker.find('.iconpicker-item.iconpicker-selected')
                .removeClass('iconpicker-selected ' + this.options.selectedCustomClass);

            if (this.iconpickerValue) {
                this.iconpicker.find('.' + this.options.fullClassFormatter(this.iconpickerValue).replace(/ /g, '.')).parent()
                    .addClass('iconpicker-selected ' + this.options.selectedCustomClass);
            }

            // Update component item
            if (this.hasComponent()) {
                var icn = this.component.find('i');
                if (icn.length > 0) {
                    icn.attr('class', this.options.fullClassFormatter(this.iconpickerValue));
                } else {
                    this.component.html(this.getHtml());
                }
            }

        },
        _updateFormGroupStatus: function(isValid) {
            if (this.hasInput()) {
                if (isValid !== false) {
                    // Remove form-group error class if any
                    this.input.parents('.form-group:first').removeClass('has-error');
                } else {
                    this.input.parents('.form-group:first').addClass('has-error');
                }
                return true;
            }
            return false;
        },
        getValid: function(val) {
            // here we must validate the value (you may change this validation
            // to suit your needs
            if (!langx.isString(val)) {
                val = '';
            }

            var isEmpty = (val === '');

            // trim string
            val = langx.trim(val);
            var e = false;
            for (var i = 0; i < this.options.icons.length; i++) {
                if (this.options.icons[i].title === val) {
                    e = true;
                    break;
                };
            }

            if (e || isEmpty) {
                return val;
            }
            return false;
        },
        /**
         * Sets the internal item value and updates everything, excepting the input or element.
         * For doing so, call setSourceValue() or update() instead
         */
        setValue: function(val) {
            // sanitize first
            var _val = this.getValid(val);
            if (_val !== false) {
                this.iconpickerValue = _val;

                return this.iconpickerValue;
            } else {

                return false;
            }
        },
        getHtml: function() {
            return '<i class="' + this.options.fullClassFormatter(this.iconpickerValue) + '"></i>';
        },
        /**
         * Calls setValue and if it's a valid item value, sets the input or element value
         */
        setSourceValue: function(val) {
            val = this.setValue(val);
            if ((val !== false) && (val !== '')) {
                if (this.hasInput()) {
                    this.input.val(this.iconpickerValue);
                } else {
                    this.$element.data('iconpickerValue', this.iconpickerValue);
                }

            }
            return val;
        },
        /**
         * Returns the input or element item value, without formatting, or defaultValue
         * if it's empty string, undefined, false or null
         * @param {type} defaultValue
         * @returns string|mixed
         */
        getSourceValue: function(defaultValue) {
            // returns the input or element value, as string
            defaultValue = defaultValue || this.options.defaultValue;
            var val = defaultValue;

            if (this.hasInput()) {
                val = this.input.val();
            } else {
                val = this.$element.data('iconpickerValue');
            }
            if ((val === undefined) || (val === '') || (val === null) || (val === false)) {
                // if not defined or empty, return default
                val = defaultValue;
            }
            return val;
        },
        hasInput: function() {
            return (this.input !== false);
        },
        isInputSearch: function() {
            return (this.hasInput() && (this.options.inputSearch === true));
        },
        isInputGroup: function() {
            return this.container.is('.input-group');
        },
        isDropdownMenu: function() {
            return this.container.is('.dropdown-menu');
        },
        hasSeparatedSearchInput: function() {
            return (this.options.templates.search !== false) && (!this.isInputSearch());
        },
        hasComponent: function() {
            return (this.component !== false);
        },
        hasContainer: function() {
            return (this.container !== false);
        },
        getAcceptButton: function() {
            return this.popover.find('.iconpicker-btn-accept');
        },
        getCancelButton: function() {
            return this.popover.find('.iconpicker-btn-cancel');
        },
        getSearchInput: function() {
            return this.popover.find('.iconpicker-search');
        },
        filter: function(filterText) {
            if (!filterText) {
                this.iconpicker.find('.iconpicker-item').show();
                return $(false);
            } else {
                var found = [];
                this.iconpicker.find('.iconpicker-item').each(function() {
                    var $this = $(this);
                    var text = $this.attr('title').toLowerCase();
                    var searchTerms = $this.attr('data-search-terms') ? $this.attr('data-search-terms').toLowerCase() : '';
                    text = text + ' ' + searchTerms;
                    var regex = false;
                    try {
                        regex = new RegExp('(^|\\W)' + filterText, 'g');
                    } catch (e) {
                        regex = false;
                    }
                    if ((regex !== false) && text.match(regex)) {
                        found.push($this);
                        $this.show();
                    } else {
                        $this.hide();
                    }
                });
                return found;
            }
        },
        show: function() {
            if (this.popover.hasClass('in')) {
                return false;
            }
            // hide other non-inline pickers
            IconPicker.batch($('.iconpicker-popover.in:not(.inline)').not(this.popover), 'hide');

            this.updatePlacement();
            this.popover.addClass('in');
            setTimeout(langx.proxy(function() {
                this.popover.css('display', this.isInline() ? '' : 'block');

            }, this), this.options.animation ? 300 : 1); // animation duration
        },
        hide: function() {
            if (!this.popover.hasClass('in')) {
                return false;
            }

            this.popover.removeClass('in');
            setTimeout(langx.proxy(function() {
                this.popover.css('display', 'none');
                this.getSearchInput().val('');
                this.filter(''); // clear filter

            }, this), this.options.animation ? 300 : 1);
        },
        toggle: function() {
            if (this.popover.is(":visible")) {
                this.hide();
            } else {
                this.show(true);
            }
        },
        update: function(val, updateOnlyInternal) {
            val = (val ? val : this.getSourceValue(this.iconpickerValue));
            // reads the input or element value again and tries to update the plugin
            // fallback to the current selected item value

            if (updateOnlyInternal === true) {
                val = this.setValue(val);
            } else {
                val = this.setSourceValue(val);
                this._updateFormGroupStatus(val !== false);
            }

            if (val !== false) {
                this._updateComponents();
            }

            return val;
        },
        destroy: function() {

            // unbinds events and resets everything to the initial state,
            // including component mode
            this.$element.removeData('iconpicker').removeData('iconpickerValue').removeClass('iconpicker-element');

            this._unbindElementEvents();
            this._unbindWindowEvents();

            $(this.popover).remove();

        },
        disable: function() {
            if (this.hasInput()) {
                this.input.prop('disabled', true);
                return true;
            }
            return false;
        },
        enable: function() {
            if (this.hasInput()) {
                this.input.prop('disabled', false);
                return true;
            }
            return false;
        },
        isDisabled: function() {
            if (this.hasInput()) {
                return (this.input.prop('disabled') === true);
            }
            return false;
        },
        isInline: function() {
            return (this.options.placement === 'inline') || (this.popover.hasClass('inline'));
        }

    });
  

    IconPicker.batch = function(selector, method) {
        var args = Array.prototype.slice.call(arguments, 2);
        return $(selector).each(function() {
            var $inst = $(this).plugin('lark.iconpicker');
            if (!!$inst) {
                $inst[method].apply($inst, args);
            }
        });
    };


    return skylark.attach("widgets.IconPicker",IconPicker);
});

define('skylark-widgets-iconpicker/main',[
	"./IconPicker"
],function(IconPicker){
	return IconPicker;
});
define('skylark-widgets-iconpicker', ['skylark-widgets-iconpicker/main'], function (main) { return main; });

define('skylark-widgets-repeater/Repeater',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-browser",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-velm",
  "skylark-domx-query",
  "skylark-widgets-swt/Widget",
  "skylark-widgets-swt/SelectList",
  "skylark-widgets-swt/ComboBox",
  "skylark-widgets-swt/SearchBox"  
],function(skylark,langx,browser,eventer,noder,geom,elmx,$,Widget){

	// REPEATER CONSTRUCTOR AND PROTOTYPE

	var Repeater = Widget.inherit({
		klassName: "Repeater",

		pluginName: "lark.repeater",

		options : {
			dataSource: function dataSource (options, callback) {
				callback({ count: 0, end: 0, items: [], page: 0, pages: 1, start: 0 });
			},
			defaultView: -1, // should be a string value. -1 means it will grab the active view from the view controls
			dropPagingCap: 10,
			staticHeight: -1, // normally true or false. -1 means it will look for data-staticheight on the element
			views: null, // can be set to an object to configure multiple views of the same type,
			searchOnKeyPress: false,
			allowCancel: true,

			addons : {
				views : ["table","tile"]
			}
		},

//		_init : function(element,options) {
		_init : function() {
			var self = this;
			var $btn;
			var currentView;

			this.$element = $(this._elm); //$(element);

			this.$canvas = this.$element.find('.repeater-canvas');
			this.$count = this.$element.find('.repeater-count');
			this.$end = this.$element.find('.repeater-end');
			this.$filters = this.$element.find('.repeater-filters');
			this.$loader = this.$element.find('.repeater-loader');
			this.$pageSize = this.$element.find('.repeater-itemization .selectlist');
			this.$nextBtn = this.$element.find('.repeater-next');
			this.$pages = this.$element.find('.repeater-pages');
			this.$prevBtn = this.$element.find('.repeater-prev');
			this.$primaryPaging = this.$element.find('.repeater-primaryPaging');
			this.$search = this.$element.find('.repeater-search').find('.search');
			this.$secondaryPaging = this.$element.find('.repeater-secondaryPaging');
			this.$start = this.$element.find('.repeater-start');
			this.$viewport = this.$element.find('.repeater-viewport');
			this.$views = this.$element.find('.repeater-views');

			this.$element.on('mousedown.bs.dropdown.data-api', '[data-toggle="dropdown"]',function(e) {
				$(this).dropdown();
			}); 

			this.currentPage = 0;
			this.currentView = null;
			this.isDisabled = false;
			this.infiniteScrollingCallback = function noop () {};
			this.infiniteScrollingCont = null;
			this.infiniteScrollingEnabled = false;
			this.infiniteScrollingEnd = null;
			this.infiniteScrollingOptions = {};
			this.lastPageInput = 0;
			//this.options = langx.mixin({}, $.fn.repeater.defaults, options);
			this.pageIncrement = 0;// store direction navigated
			this.resizeTimeout = {};
			this.stamp = new Date().getTime() + (Math.floor(Math.random() * 100) + 1);
			this.storedDataSourceOpts = null;
			this.syncingViewButtonState = false;
//			this.viewOptions = {};
			this.viewType = null;

			this.$filters.plugin("lark.selectlist");
			this.$pageSize.plugin("lark.selectlist");
			this.$primaryPaging.find('.combobox').plugin("lark.combobox");
			this.$search.plugin("lark.searchbox",{
				searchOnKeyPress: this.options.searchOnKeyPress,
				allowCancel: this.options.allowCancel
			});

			this.$filters.on('changed.fu.selectlist', function onFiltersChanged (e, value) {
				self.$element.trigger('filtered.lark.repeater', value);
				self.render({
					clearInfinite: true,
					pageIncrement: null
				});
			});
			this.$nextBtn.on('click.lark.repeater', langx.proxy(this.next, this));
			this.$pageSize.on('changed.fu.selectlist', function onPageSizeChanged (e, value) {
				self.$element.trigger('pageSizeChanged.lark.repeater', value);
				self.render({
					pageIncrement: null
				});
			});
			this.$prevBtn.on('click.lark.repeater', langx.proxy(this.previous, this));
			this.$primaryPaging.find('.combobox').on('changed.fu.combobox', function onPrimaryPagingChanged (evt, data) {
				self.pageInputChange(data.text, data);
			});
			this.$search.on('searched.fu.search cleared.fu.search', function onSearched (e, value) {
				self.$element.trigger('searchChanged.lark.repeater', value);
				self.render({
					clearInfinite: true,
					pageIncrement: null
				});
			});
			this.$search.on('canceled.fu.search', function onSearchCanceled (e, value) {
				self.$element.trigger('canceled.lark.repeater', value);
				self.render({
					clearInfinite: true,
					pageIncrement: null
				});
			});

			this.$secondaryPaging.on('blur.lark.repeater', function onSecondaryPagingBlur () {
				self.pageInputChange(self.$secondaryPaging.val());
			});
			this.$secondaryPaging.on('keyup', function onSecondaryPagingKeyup (e) {
				if (e.keyCode === 13) {
					self.pageInputChange(self.$secondaryPaging.val());
				}
			});
			this.$views.find('input').on('change.lark.repeater', langx.proxy(this.viewChanged, this));

			$(window).on('resize.lark.repeater.' + this.stamp, function onResizeRepeater () {
				clearTimeout(self.resizeTimeout);
				self.resizeTimeout = setTimeout(function resizeTimeout () {
					self.resize();
					self.$element.trigger('resized.lark.repeater');
				}, 75);
			});

			//this.$loader.loader();
			//this.$loader.loader('pause');
			if (this.options.defaultView !== -1) {
				currentView = this.options.defaultView;
			} else {
				$btn = this.$views.find('label.active input');
				currentView = ($btn.length > 0) ? $btn.val() : 'table';
			}

			//this.setViewOptions(currentView); // by lwf

			this.initViewTypes(function initViewTypes () {
				self.resize();
				self.$element.trigger('resized.lark.repeater');
				self.render({
					changeView: currentView
				});
			});
		},

		clear: function clear (opts) {
			var options = opts || {};

			if (!options.preserve) {
				// Just trash everything because preserve is false
				this.$canvas.empty();
			} else if (!this.infiniteScrollingEnabled || options.clearInfinite) {
				// Preserve clear only if infiniteScrolling is disabled or if specifically told to do so
				scan(this.$canvas);
			} // Otherwise don't clear because infiniteScrolling is enabled

			// If viewChanged and current viewTypeObj has a cleared function, call it
			var viewChanged = (options.viewChanged !== undefined) ? options.viewChanged : false;
			/* lwf
			var viewTypeObj = $.fn.repeater.viewTypes[this.viewType] || {};
			if (!viewChanged && viewTypeObj.cleared) {
				viewTypeObj.cleared.call(this, {
					options: options
				});
			}
			*/
			if (this._view) {
				this._view.cleared({
					options: options
				});
			}
		},

		clearPreservedDataSourceOptions: function clearPreservedDataSourceOptions () {
			this.storedDataSourceOpts = null;
		},

		destroy: function destroy () {
			var markup;
			// set input value attrbute in markup
			this.$element.find('input').each(function eachInput () {
				$(this).attr('value', $(this).val());
			});

			// empty elements to return to original markup
			this.$canvas.empty();
			markup = this.$element[0].outerHTML;

			// destroy components and remove leftover
			this.$element.find('.combobox').plugin("lark.combobox").destroy();
			this.$element.find('.selectlist').plugin("lark.selectlist").destroy();
			this.$element.find('.search').plugin("lark.searchbox").destroy();
			if (this.infiniteScrollingEnabled) {
				$(this.infiniteScrollingCont).infinitescroll('destroy');
			}

			this.$element.remove();

			// any external events
			$(window).off('resize.lark.repeater.' + this.stamp);

			return markup;
		},

		disable: function disable () {
			//var viewTypeObj = $.fn.repeater.viewTypes[this.viewType] || {};

			this.$search.plugin("lark.searchbox").disable();
			this.$filters.plugin("lark.selectlist").disable();
			this.$views.find('label, input').addClass('disabled').attr('disabled', 'disabled');
			this.$pageSize.plugin("lark.selectlist").disable();
			this.$primaryPaging.find('.combobox').plugin("lark.combobox").disable();
			this.$secondaryPaging.attr('disabled', 'disabled');
			this.$prevBtn.attr('disabled', 'disabled');
			this.$nextBtn.attr('disabled', 'disabled');

			/* lwf
			if (viewTypeObj.enabled) {
				viewTypeObj.enabled.call(this, {
					status: false
				});
			}
			*/
			if (this._view) {
				this._view.enabled({
					status: false
				});
			}

			this.isDisabled = true;
			this.$element.addClass('disabled');
			this.$element.trigger('disabled.lark.repeater');
		},

		enable: function enable () {
			//var viewTypeObj = $.fn.repeater.viewTypes[this.viewType] || {};

			this.$search.plugin("lark.searchbox").enable();
			this.$filters.plugin("lark.selectlist").enable()
			this.$views.find('label, input').removeClass('disabled').removeAttr('disabled');
			this.$pageSize.plugin("lark.selectlist").enable()
			this.$primaryPaging.find('.combobox').plugin("lark.combobox").enable();
			this.$secondaryPaging.removeAttr('disabled');

			if (!this.$prevBtn.hasClass('page-end')) {
				this.$prevBtn.removeAttr('disabled');
			}
			if (!this.$nextBtn.hasClass('page-end')) {
				this.$nextBtn.removeAttr('disabled');
			}

			// is 0 or 1 pages, if using $primaryPaging (combobox)
			// if using selectlist allow user to use selectlist to select 0 or 1
			if (this.$prevBtn.hasClass('page-end') && this.$nextBtn.hasClass('page-end')) {
				this.$primaryPaging.plugin("lark.combobox").disable();
			}

			// if there are no items
			if (parseInt(this.$count.html(), 10) !== 0) {
				this.$pageSize.plugin("lark.selectlist").enable();
			} else {
				this.$pageSize.plugin("lark.selectlist").disable();
			}

			/* lwf
			if (viewTypeObj.enabled) {
				viewTypeObj.enabled.call(this, {
					status: true
				});
			}
			*/
			if (this._view) {
				this._view.enabled({
					status: true
				});
			}

			this.isDisabled = false;
			this.$element.removeClass('disabled');
			this.$element.trigger('enabled.lark.repeater');
		},

		getDataOptions: function getDataOptions (opts) {
			var options = opts || {};
			if (options.pageIncrement !== undefined) {
				if (options.pageIncrement === null) {
					this.currentPage = 0;
				} else {
					this.currentPage += options.pageIncrement;
				}
			}

			var dataSourceOptions = {};
			if (options.dataSourceOptions) {
				dataSourceOptions = options.dataSourceOptions;

				if (options.preserveDataSourceOptions) {
					if (this.storedDataSourceOpts) {
						this.storedDataSourceOpts = langx.mixin(this.storedDataSourceOpts, dataSourceOptions);
					} else {
						this.storedDataSourceOpts = dataSourceOptions;
					}
				}
			}

			if (this.storedDataSourceOpts) {
				dataSourceOptions = langx.mixin(this.storedDataSourceOpts, dataSourceOptions);
			}

			var returnOptions = {
				view: this.currentView,
				pageIndex: this.currentPage,
				filter: {
					text: 'All',
					value: 'all'
				}
			};
			if (this.$filters.length > 0) {
				returnOptions.filter = this.$filters.plugin("lark.selectlist").selectedItem();
			}

			if (!this.infiniteScrollingEnabled) {
				returnOptions.pageSize = 25;

				if (this.$pageSize.length > 0) {
					returnOptions.pageSize = parseInt(this.$pageSize.plugin("lark.selectlist").selectedItem().value, 10);
				}
			}

			var searchValue = this.$search && this.$search.find('input') && this.$search.find('input').val();
			if (searchValue !== '') {
				returnOptions.search = searchValue;
			}

			/* lwf
			var viewType = $.fn.repeater.viewTypes[this.viewType] || {};
			var addViewTypeData = viewType.dataOptions;
			if (addViewTypeData) {
				returnOptions = addViewTypeData.call(this, returnOptions);
			}
			*/
			if (this._view) {
				returnOptions = this._view.dataOptions(returnOptions);
			}


			returnOptions = langx.mixin(returnOptions, dataSourceOptions);

			return returnOptions;
		},

		infiniteScrolling: function infiniteScrolling (enable, opts) {
			var footer = this.$element.find('.repeater-footer');
			var viewport = this.$element.find('.repeater-viewport');
			var options = opts || {};

			if (enable) {
				this.infiniteScrollingEnabled = true;
				this.infiniteScrollingEnd = options.end;
				delete options.dataSource;
				delete options.end;
				this.infiniteScrollingOptions = options;
				viewport.css({
					height: viewport.height() + footer.outerHeight()
				});
				footer.hide();
			} else {
				var cont = this.infiniteScrollingCont;
				var data = cont.data();
				delete data.infinitescroll;
				cont.off('scroll');
				cont.removeClass('infinitescroll');

				this.infiniteScrollingCont = null;
				this.infiniteScrollingEnabled = false;
				this.infiniteScrollingEnd = null;
				this.infiniteScrollingOptions = {};
				viewport.css({
					height: viewport.height() - footer.outerHeight()
				});
				footer.show();
			}
		},

		infiniteScrollPaging: function infiniteScrollPaging (data) {
			var end = (this.infiniteScrollingEnd !== true) ? this.infiniteScrollingEnd : undefined;
			var page = data.page;
			var pages = data.pages;

			this.currentPage = (page !== undefined) ? page : NaN;

			if (data.end === true || (this.currentPage + 1) >= pages) {
				this.infiniteScrollingCont.infinitescroll('end', end);
			}
		},

		initInfiniteScrolling: function initInfiniteScrolling () {
			var cont = this.$canvas.find('[data-infinite="true"]:first');

			cont = (cont.length < 1) ? this.$canvas : cont;
			if (cont.data('fu.infinitescroll')) {
				cont.infinitescroll('enable');
			} else {
				var self = this;
				var opts = langx.mixin({}, this.infiniteScrollingOptions);
				opts.dataSource = function dataSource (helpers, callback) {
					self.infiniteScrollingCallback = callback;
					self.render({
						pageIncrement: 1
					});
				};
				cont.infinitescroll(opts);
				this.infiniteScrollingCont = cont;
			}
		},

		initViewTypes: function initViewTypes (callback) {
			/*
			var viewTypes = [];

			for (var key in $.fn.repeater.viewTypes) {
				if ({}.hasOwnProperty.call($.fn.repeater.viewTypes, key)) {
					viewTypes.push($.fn.repeater.viewTypes[key]);
				}
			}
			*/

			var views = this._views = [];
			var viewTypes = this.options.addons.views;
			for (var i = 0; i< viewTypes.length; i++) {
				var setting = Repeater.addons.views[viewTypes[i]];
				if (!setting) {
					throw new Error("The view type " + viewTypes[i] + " is not defined!");
				} 
				var ctor = setting.ctor;
				this._views.push(this._views[viewTypes[i]] = new ctor(this));

			}

			if (views.length > 0) {
				initViewType.call(this, 0, viewTypes, callback);
			} else {
				callback();
			}
		},

		itemization: function itemization (data) {
			this.$count.html((data.count !== undefined) ? data.count : '?');
			this.$end.html((data.end !== undefined) ? data.end : '?');
			this.$start.html((data.start !== undefined) ? data.start : '?');
		},

		next: function next () {
			this.$nextBtn.attr('disabled', 'disabled');
			this.$prevBtn.attr('disabled', 'disabled');
			this.pageIncrement = 1;
			this.$element.trigger('nextClicked.lark.repeater');
			this.render({
				pageIncrement: this.pageIncrement
			});
		},

		pageInputChange: function pageInputChange (val, dataFromCombobox) {
			// dataFromCombobox is a proxy for data from combobox's changed event,
			// if no combobox is present data will be undefined
			var pageInc;
			if (val !== this.lastPageInput) {
				this.lastPageInput = val;
				var value = parseInt(val, 10) - 1;
				pageInc = value - this.currentPage;
				this.$element.trigger('pageChanged.lark.repeater', [value, dataFromCombobox]);
				this.render({
					pageIncrement: pageInc
				});
			}
		},

		pagination: function pagination (data) {
			this.$primaryPaging.removeClass('active');
			this.$secondaryPaging.removeClass('active');

			var totalPages = data.pages;
			this.currentPage = (data.page !== undefined) ? data.page : NaN;
			// set paging to 0 if total pages is 0, otherwise use one-based index
			var currenPageOutput = totalPages === 0 ? 0 : this.currentPage + 1;

			if (totalPages <= this.options.dropPagingCap) {
				this.$primaryPaging.addClass('active');
				var dropMenu = this.$primaryPaging.find('.dropdown-menu');
				dropMenu.empty();
				for (var i = 0; i < totalPages; i++) {
					var l = i + 1;
					dropMenu.append('<li data-value="' + l + '"><a href="#">' + l + '</a></li>');
				}

				this.$primaryPaging.find('input.form-control').val(currenPageOutput);
			} else {
				this.$secondaryPaging.addClass('active');
				this.$secondaryPaging.val(currenPageOutput);
			}

			this.lastPageInput = this.currentPage + 1 + '';

			this.$pages.html('' + totalPages);

			// this is not the last page
			if ((this.currentPage + 1) < totalPages) {
				this.$nextBtn.removeAttr('disabled');
				this.$nextBtn.removeClass('page-end');
			} else {
				this.$nextBtn.attr('disabled', 'disabled');
				this.$nextBtn.addClass('page-end');
			}

			// this is not the first page
			if ((this.currentPage - 1) >= 0) {
				this.$prevBtn.removeAttr('disabled');
				this.$prevBtn.removeClass('page-end');
			} else {
				this.$prevBtn.attr('disabled', 'disabled');
				this.$prevBtn.addClass('page-end');
			}

			// return focus to next/previous buttons after navigating
			if (this.pageIncrement !== 0) {
				if (this.pageIncrement > 0) {
					if (this.$nextBtn.is(':disabled')) {
						// if you can't focus, go the other way
						this.$prevBtn.focus();
					} else {
						this.$nextBtn.focus();
					}
				} else if (this.$prevBtn.is(':disabled')) {
					// if you can't focus, go the other way
					this.$nextBtn.focus();
				} else {
					this.$prevBtn.focus();
				}
			}
		},

		previous: function previous () {
			this.$nextBtn.attr('disabled', 'disabled');
			this.$prevBtn.attr('disabled', 'disabled');
			this.pageIncrement = -1;
			this.$element.trigger('previousClicked.lark.repeater');
			this.render({
				pageIncrement: this.pageIncrement
			});
		},

		// This functions more as a "pre-render" than a true "render"
		render: function render (opts) {
			this.disable();

			var viewChanged = false;
			//var viewTypeObj = $.fn.repeater.viewTypes[this.viewType] || {};
			var options = opts || {};

			if (options.changeView && (this.currentView !== options.changeView)) {
				var prevView = this.currentView;
				this.currentView = options.changeView;
				this.viewType = this.currentView.split('.')[0];

				this._view = this._views[this.viewType];

				//this.setViewOptions(this.currentView);

				this.$element.attr('data-currentview', this.currentView);
				this.$element.attr('data-viewtype', this.viewType);
				viewChanged = true;
				options.viewChanged = viewChanged;

				this.$element.trigger('viewChanged.lark.repeater', this.currentView);

				if (this.infiniteScrollingEnabled) {
					this.infiniteScrolling(false);
				}

				/* lwf
				viewTypeObj = $.fn.repeater.viewTypes[this.viewType] || {};
				if (viewTypeObj.selected) {
					viewTypeObj.selected.call(this, {
						prevView: prevView
					});
				}
				*/
				this._view.selected({
					prevView: prevView
				})
			}

			this.syncViewButtonState();

			options.preserve = (options.preserve !== undefined) ? options.preserve : !viewChanged;
			this.clear(options);

			if (!this.infiniteScrollingEnabled || (this.infiniteScrollingEnabled && viewChanged)) {
				//this.$loader.show().loader('play');
				this._throbber = this.throb({
					className : "loader"
				});
			}

			var dataOptions = this.getDataOptions(options);

			var beforeRender = this.options.dataSource;
			var repeaterPrototypeContext = this;
			var viewTypeObj = this._view;
			beforeRender(
				dataOptions,
				// this serves as a bridge function to pass all required data through to the actual function
				// that does the rendering for us.
				function callDoRender (dataSourceReturnedData) {
					doRender.call(
						repeaterPrototypeContext,
						{
							data: dataSourceReturnedData,
							dataOptions: dataOptions,
							options: options,
							viewChanged: viewChanged,
							viewTypeObj: viewTypeObj
						}
					);
				}
			);
		},

		resize: function resize () {
			var staticHeight = (this.options.staticHeight === -1) ? this.$element.attr('data-staticheight') : this.options.staticHeight;
			var viewTypeObj = {};
			var height;
			var viewportMargins;
			var scrubbedElements = [];
			var previousProperties = [];
			//var $hiddenElements = this.$element.parentsUntil(':visible').addBack(); // del addBack() not supported by skyalrk
			var $hiddenElements = this.$element.parentsUntil(':visible');
			var currentHiddenElement;
			var currentElementIndex = 0;

			// Set parents to 'display:block' until repeater is visible again
			while (currentElementIndex < $hiddenElements.length && this.$element.is(':hidden')) {
				currentHiddenElement = $hiddenElements[currentElementIndex];
				// Only set display property on elements that are explicitly hidden (i.e. do not inherit it from their parent)
				if ($(currentHiddenElement).is(':hidden')) {
					previousProperties.push(currentHiddenElement.style['display']);
					currentHiddenElement.style['display'] = 'block';
					scrubbedElements.push(currentHiddenElement);
				}
				currentElementIndex++;
			}

			//if (this.viewType) {
			//	viewTypeObj = $.fn.repeater.viewTypes[this.viewType] || {};
			//}

			if (staticHeight !== undefined && staticHeight !== false && staticHeight !== 'false') {
				this.$canvas.addClass('scrolling');
				viewportMargins = {
					bottom: this.$viewport.css('margin-bottom'),
					top: this.$viewport.css('margin-top')
				};

				var staticHeightValue = (staticHeight === 'true' || staticHeight === true) ? this.$element.height() : parseInt(staticHeight, 10);
				var headerHeight = this.$element.find('.repeater-header').outerHeight();
				var footerHeight = this.$element.find('.repeater-footer').outerHeight();
				var bottomMargin = (viewportMargins.bottom === 'auto') ? 0 : parseInt(viewportMargins.bottom, 10);
				var topMargin = (viewportMargins.top === 'auto') ? 0 : parseInt(viewportMargins.top, 10);

				height = staticHeightValue - headerHeight - footerHeight - bottomMargin - topMargin;
				this.$viewport.outerHeight(height);
			} else {
				this.$canvas.removeClass('scrolling');
			}



			/* lwf
			if (viewTypeObj.resize) {
				viewTypeObj.resize.call(this, {
					height: this.$element.outerHeight(),
					width: this.$element.outerWidth()
				});
			}
			*/
			if (this._view) {
				this._view.resize({
					height: this.$element.outerHeight(),
					width: this.$element.outerWidth()
				});
			}

			scrubbedElements.forEach(function (element, i) {
				element.style['display'] = previousProperties[i];
			});
		},

		// e.g. "Rows" or "Thumbnails"
		renderItems: function renderItems (viewTypeObj, data, callback) {
			if (!viewTypeObj.render) {
				if (viewTypeObj.before) {
					var addBefore = viewTypeObj.before({
						container: this.$canvas,
						data: data
					});
					addItem(this.$canvas, addBefore);
				}

				var $dataContainer = this.$canvas.find('[data-container="true"]:last');
				var $container = ($dataContainer.length > 0) ? $dataContainer : this.$canvas;

				// It appears that the following code would theoretically allow you to pass a deeply
				// nested value to "repeat on" to be added to the repeater.
				// eg. `data.foo.bar.items`
				if (viewTypeObj.renderItem) {
					var subset;
					var objectAndPropsToRepeatOnString = viewTypeObj.repeat || 'data.items';
					var objectAndPropsToRepeatOn = objectAndPropsToRepeatOnString.split('.');
					var objectToRepeatOn = objectAndPropsToRepeatOn[0];

					if (objectToRepeatOn === 'data' || objectToRepeatOn === 'this') {
						subset = (objectToRepeatOn === 'this') ? this : data;

						// Extracts subset from object chain (get `items` out of `foo.bar.items`). I think....
						var propsToRepeatOn = objectAndPropsToRepeatOn.slice(1);
						for (var prop = 0; prop < propsToRepeatOn.length; prop++) {
							if (subset[propsToRepeatOn[prop]] !== undefined) {
								subset = subset[propsToRepeatOn[prop]];
							} else {
								subset = [];
								logWarn('WARNING: Repeater unable to find property to iterate renderItem on.');
								break;
							}
						}

						for (var subItemIndex = 0; subItemIndex < subset.length; subItemIndex++) {
							var addSubItem = viewTypeObj.renderItem({
								container: $container,
								data: data,
								index: subItemIndex,
								subset: subset
							});
							addItem($container, addSubItem);
						}
					} else {
						logWarn('WARNING: Repeater plugin "repeat" value must start with either "data" or "this"');
					}
				}

				if (viewTypeObj.after) {
					var addAfter = viewTypeObj.after({
						container: this.$canvas,
						data: data
					});
					addItem(this.$canvas, addAfter);
				}

				callback(data);
			} else {
				viewTypeObj.render({
					container: this.$canvas,
					data: data
				}, callback);
				callback(data);
			}
		},

		/* // by lwf
		setViewOptions: function setViewOptions (curView) {
			var opts = {};
			var viewName = curView.split('.')[1];

			if (this.options.views) {
				opts = this.options.views[viewName] || this.options.views[curView] || {};
			} else {
				opts = {};
			}

			this.viewOptions = langx.mixin({}, this.options, opts);
		},
		*/
		viewChanged: function viewChanged (e) {
			var $selected = $(e.target);
			var val = $selected.val();

			if (!this.syncingViewButtonState) {
				if (this.isDisabled || $selected.parents('label:first').hasClass('disabled')) {
					this.syncViewButtonState();
				} else {
					this.render({
						changeView: val,
						pageIncrement: null
					});
				}
			}
		},

		syncViewButtonState: function syncViewButtonState () {
			var $itemToCheck = this.$views.find('input[value="' + this.currentView + '"]');

			this.syncingViewButtonState = true;
			this.$views.find('input').prop('checked', false);
			this.$views.find('label.active').removeClass('active');

			if ($itemToCheck.length > 0) {
				$itemToCheck.prop('checked', true);
				$itemToCheck.parents('label:first').addClass('active');
			}
			this.syncingViewButtonState = false;
		},

		getNestedProperty: function (obj, property) {
			property.replace(
				// Matches native JavaScript notation in a String,
				// e.g. '["doubleQuoteProp"].dotProp[2]'
				// eslint-disable-next-line no-useless-escape
				/\[(?:'([^']+)'|"([^"]+)"|(\d+))\]|(?:(?:^|\.)([^\.\[]+))/g,
				function (str, singleQuoteProp, doubleQuoteProp, arrayIndex, dotProp) {
					var prop =
						dotProp ||
						singleQuoteProp ||
						doubleQuoteProp ||
						(arrayIndex && parseInt(arrayIndex, 10))
					if (str && obj) {
						obj = obj[prop]
					}
				}
			)
			return obj
		},

		getDataProperty: function (obj, property) {
			var key
			var prop
			if (obj.dataset) {
				key = property.replace(/-([a-z])/g, function (_, b) {
					return b.toUpperCase()
				})
				prop = obj.dataset[key]
			} else if (obj.getAttribute) {
				prop = obj.getAttribute(
					'data-' + property.replace(/([A-Z])/g, '-$1').toLowerCase()
				)
			}
			if (typeof prop === 'string') {
				// eslint-disable-next-line no-useless-escape
				if (
					/^(true|false|null|-?\d+(\.\d+)?|\{[\s\S]*\}|\[[\s\S]*\])$/.test(prop)
				) {
					try {
						return $.parseJSON(prop)
					} catch (ignore) {}
				}
				return prop
			}
		},

		getItemProperty: function (obj, property) {
			var prop = this.getDataProperty(obj, property)
			if (prop === undefined) {
				prop = obj[property]
			}
			if (prop === undefined) {
				prop = this.getNestedProperty(obj, property)
			}
			return prop
		}

		
	});

	var logWarn = function logWarn (msg) {
		if (window.console && window.console.warn) {
			window.console.warn(msg);
		}
	};

	var scan = function scan (cont) {
		var keep = [];
		cont.children().each(function eachContainerChild () {
			var item = $(this);
			var pres = item.attr('data-preserve');
			if (pres === 'deep') {
				item.detach();
				keep.push(item);
			} else if (pres === 'shallow') {
				scan(item);
				item.detach();
				keep.push(item);
			}
		});
		cont.empty();
		cont.append(keep);
	};

	var addItem = function addItem ($parent, response) {
		var action;
		if (response) {
			action = (response.action) ? response.action : 'append';
			if (action !== 'none' && response.item !== undefined) {
				var $container = (response.container !== undefined) ? $(response.container) : $parent;
				$container[action](response.item);
			}
		}
	};

	var callNextInit = function callNextInit (currentViewType, viewTypes, callback) {
		var nextViewType = currentViewType + 1;
		if (nextViewType < viewTypes.length) {
			initViewType.call(this, nextViewType, viewTypes, callback);
		} else {
			callback();
		}
	};

	var initViewType = function initViewType (currentViewtype, viewTypes, callback) {
		if (viewTypes[currentViewtype].initialize) {
			viewTypes[currentViewtype].initialize.call(this, {}, function afterInitialize () {
				callNextInit.call(this, currentViewtype, viewTypes, callback);
			});
		} else {
			callNextInit.call(this, currentViewtype, viewTypes, callback);
		}
	};

	// Does all of our cleanup post-render
	var afterRender = function afterRender (state) {
		var data = state.data || {};

		if (this.infiniteScrollingEnabled) {
			if (state.viewChanged || state.options.clearInfinite) {
				this.initInfiniteScrolling();
			}

			this.infiniteScrollPaging(data, state.options);
		}

		//this.$loader.hide().loader('pause');
		if (this._throbber) {
			this._throbber.remove();
			this._throbber = null;
		}
		this.enable();

		this.$search.trigger('rendered.lark.repeater', {
			data: data,
			options: state.dataOptions,
			renderOptions: state.options
		});
		this.$element.trigger('rendered.lark.repeater', {
			data: data,
			options: state.dataOptions,
			renderOptions: state.options
		});

		// for maintaining support of 'loaded' event
		this.$element.trigger('loaded.lark.repeater', state.dataOptions);
	};

	// This does the actual rendering of the repeater
	var doRender = function doRender (state) {
		var data = state.data || {};

		if (this.infiniteScrollingEnabled) {
			// pass empty object because data handled in infiniteScrollPaging method
			this.infiniteScrollingCallback({});
		} else {
			this.itemization(data);
			this.pagination(data);
		}

		var self = this;
		this.renderItems(
			state.viewTypeObj,
			data,
			function callAfterRender (d) {
				state.data = d;
				afterRender.call(self, state);
			}
		);
	};

	Repeater.addons = {};


	return skylark.attach("widgets.Repeater",Repeater);

});

define('skylark-widgets-repeater/views',[
	"./Repeater"
],function(Repeater){
	return Repeater.addons.views = {};
});
define('skylark-widgets-repeater/views/ViewBase',[
	"skylark-langx/langx",
	"skylark-domx-noder",
	"skylark-domx-query",
	"../views",	
],function(langx,noder,$,views) {

	var ViewBase = langx.Evented.inherit({
	    klassName: "ViewBase",

	    options : {
	      // The class to add when the gallery controls are visible:
	      controlsClass: "skylarkui-repeater-controls",
		  // Defines if the gallery should open in fullscreen mode:
		  fullScreen: false

	    },


    	_create$Item : function (template,itemData) {
        	var invalid = false;

        	function replace() {
            	var end, start, val;

            	start = template.indexOf('{{');
            	end = template.indexOf('}}', start + 2);

            	if (start > -1 && end > -1) {
                	val = langx.trim(template.substring(start + 2, end));
                	val = (itemData[val] !== undefined) ? itemData[val] : '';
                	template = template.substring(0, start) + val + template.substring(end + 2);
            	} else {
                	invalid = true;
            	}
       		}

        	while (!invalid && template.search('{{') >= 0) {
            	replace(template);
        	}

        	return $(template);
    	},	    
	    
		init : function (repeater,options) {
			var that = this,
				hasControls;
			this.repeater = repeater;
			this.initOptions(options);
	        if (this.options.fullScreen) {
	          noder.fullScreen(this.container[0]);
	        }
	        this.repeater.on("item.running",function(e){
	            if (that.container.hasClass(that.options.controlsClass)) {
	              hasControls = true
	              that.container.removeClass(that.options.controlsClass);
	            } else {
	              hasControls = false
	            }
	        });

	        this.repeater.on("item.running",function(e){
	            if (hasControls) {
	              that.container.addClass(that.options.controlsClass);
	            }
	        });
		},

	    initOptions: function (options) {
	      // Create a copy of the prototype options:
	      this.options = langx.mixin({}, this.options,options);
	    },

	    close: function () {
      		if (noder.fullScreen() === this.container[0]) {
        		noder.fullScreen(false);
      		}
      	},

      	getValue : function() {
      		return this.getSelectedItems();
      	},

      	cleared : function() {

      	},

      	selected : function() {

      	},

	    dataOptions: function (options) {
	    	return options;
	    },

	    enabled : function(helpers){
	    	
	    }

	});

	return views.ViewBase = ViewBase;
});

define('skylark-widgets-repeater/views/ListView',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "../views",   
    "./ViewBase"
], function(langx, browser, eventer, noder, geom, $, views, ViewBase) {


  var ListView = ViewBase.inherit({
    klassName : "ListView",

    options: {
        alignment: 'left',
        infiniteScroll: false,
        itemRendered: null,
        noItemsHTML: 'no items found',
        selectable: false,

        template : '<ul class="clearfix repeater-list" data-container="true" data-infinite="true" data-preserve="shallow"></ul>',
        item : {
            template: '<li class="repeater-item"><img  src="{{ThumbnailImage}}" class="thumb"/><h4 class="title">{{name}}</h4></div>'
        },
    },

    //ADDITIONAL METHODS
    clearSelectedItems : function() {
        this.repeater.$canvas.find('.repeater-list .selectable.selected').removeClass('selected');
    },

    getSelectedItems : function() {
        var selected = [];
        this.repeater.$canvas.find('.repeater-list .selectable.selected').each(function() {
            selected.push($(this));
        });
        return selected;
    },

    setSelectedItems : function(items, force) {
        var selectable = this.options.selectable;
        var self = this;
        var i, $item, l, n;

        //this function is necessary because lint yells when a function is in a loop
        function compareItemIndex() {
            if (n === items[i].index) {
                $item = $(this);
                return false;
            } else {
                n++;
            }
        }

        //this function is necessary because lint yells when a function is in a loop
        function compareItemSelector() {
            $item = $(this);
            if ($item.is(items[i].selector)) {
                selectItem($item, items[i].selected);
            }
        }

        function selectItem($itm, select) {
            select = (select !== undefined) ? select : true;
            if (select) {
                if (!force && selectable !== 'multi') {
                    self.thumbnail_clearSelectedItems();
                }

                $itm.addClass('selected');
            } else {
                $itm.removeClass('selected');
            }
        }

        if (!langx.isArray(items)) {
            items = [items];
        }

        if (force === true || selectable === 'multi') {
            l = items.length;
        } else if (selectable) {
            l = (items.length > 0) ? 1 : 0;
        } else {
            l = 0;
        }

        for (i = 0; i < l; i++) {
            if (items[i].index !== undefined) {
                $item = $();
                n = 0;
                this.repeater.$canvas.find('.repeater-list .selectable').each(compareItemIndex);
                if ($item.length > 0) {
                    selectItem($item, items[i].selected);
                }

            } else if (items[i].selector) {
                this.repeater.$canvas.find('.repeater-list .selectable').each(compareItemSelector);
            }
        }
    },

    selected: function() {
        var infScroll = this.options.infiniteScroll;
        var opts;
        if (infScroll) {
            opts = (typeof infScroll === 'object') ? infScroll : {};
            this.infiniteScrolling(true, opts);
        }
    },
    before: function(helpers) {
        var alignment = this.options.alignment;
        var $cont = this.repeater.$canvas.find('.repeater-list');
        var data = helpers.data;
        var response = {};
        var $empty, validAlignments;

        if ($cont.length < 1) {
            $cont = $(this.options.template);

            response.item = $cont;
        } else {
            response.action = 'none';
        }

        return response;
    },

    renderItem: function(helpers) {
        var selectable = this.options.selectable;
        var selected = 'selected';
        var self = this;
        var $item = this._create$Item(this.options.item.template,helpers.subset[helpers.index]);

        $item.data('item_data', helpers.data.items[helpers.index]);

        if (selectable) {
            $item.addClass('selectable');
            $item.on('click', function() {
                if (self.isDisabled) return;

                if (!$item.hasClass(selected)) {
                    if (selectable !== 'multi') {
                        self.repeater.$canvas.find('.repeater-list .selectable.selected').each(function() {
                            var $itm = $(this);
                            $itm.removeClass(selected);
                            self.repeater.$element.trigger('deselected.lark.repeaterList', $itm);
                        });
                    }

                    $item.addClass(selected);
                    self.repeater.$element.trigger('selected.lark.repeaterList', $item);
                } else {
                    $item.removeClass(selected);
                    self.repeater.$element.trigger('deselected.lark.repeaterList', $item);
                }
            });
        }

        helpers.container.append($item);


        if (this.options.itemRendered) {
            this.options.itemRendered({
                container: helpers.container,
                item: $thumbnail,
                itemData: helpers.subset[helpers.index]
            }, function() {});
        }

        return false;
    }
    
  });


    views["list"] = {
        name : "list",
        ctor : ListView
    };

    return ListView;
    
});
/* global define, window, document, DocumentTouch */

define('skylark-widgets-repeater/views/SliderView',[
  "skylark-langx/langx",
  "skylark-domx-noder",
  "skylark-domx-query",
  "../views", 
  "./ViewBase"
],function (langx,noder,$,views,ViewBase) {
  'use strict'

  var SliderView = ViewBase.inherit({
    klassName : "SliderView",

    options: {
      // The Id, element or querySelector of the repeater view:
      container: null,
      // The tag name, Id, element or querySelector of the slides container:
      slidesContainer: 'div.slides',
      // The tag name, Id, element or querySelector of the title element:
      titleElement: 'h3',
      // The class to add when the gallery is visible:
      displayClass: 'slider-display',
      // The class to add when the gallery only displays one element:
      singleClass: 'slider-single',
      // The class to add when the left edge has been reached:
      leftEdgeClass: 'slider-left',
      // The class to add when the right edge has been reached:
      rightEdgeClass: 'slider-right',
      // The class to add when the automatic slideshow is active:
      playingClass: 'slider-playing',
      // The class for all slides:
      slideClass: 'slide',
      // The slide class for loading elements:
      slideLoadingClass: 'slide-loading',
      // The slide class for elements that failed to load:
      slideErrorClass: 'slide-error',
      // The class for the content element loaded into each slide:
      slideContentClass: 'slide-content',
      // The class for the "toggle" control:
      toggleClass: 'toggle',
      // The class for the "prev" control:
      prevClass: 'prev',
      // The class for the "next" control:
      nextClass: 'next',
      // The class for the "close" control:
      closeClass: 'close',

      // The class for the "play-pause" toggle control:
      playPauseClass: 'play-pause',
      // The list object property (or data attribute) with the object type:
      //--- typeProperty: 'type',
      // The list object property (or data attribute) with the object title:
      //--- titleProperty: 'title',
      // The list object property (or data attribute) with the object alt text:
      //--- altTextProperty: 'alt',
      // The list object property (or data attribute) with the object URL:
      //--- urlProperty: 'href',
      // The list object property (or data attribute) with the object srcset URL(s):
      //--- srcsetProperty: 'urlset',
      // The gallery listens for transitionend events before triggering the
      // opened and closed events, unless the following option is set to false:
      displayTransition: true,
      // Defines if the gallery slides are cleared from the gallery modal,
      // or reused for the next gallery initialization:
      clearSlides: true,
      // Defines if images should be stretched to fill the available space,
      // while maintaining their aspect ratio (will only be enabled for browsers
      // supporting background-size="contain", which excludes IE < 9).
      // Set to "cover", to make images cover all available space (requires
      // support for background-size="cover", which excludes IE < 9):
      //--- stretchImages: false,
      // Toggle the controls on pressing the Return key:
      toggleControlsOnReturn: true,
      // Toggle the controls on slide click:
      toggleControlsOnSlideClick: true,
      // Toggle the automatic slideshow interval on pressing the Space key:
      toggleSlideshowOnSpace: true,
      // Navigate the gallery by pressing left and right on the keyboard:
      enableKeyboardNavigation: true,
      // Close the gallery on pressing the Esc key:
      closeOnEscape: true,
      // Close the gallery when clicking on an empty slide area:
      closeOnSlideClick: true,
      // Close the gallery by swiping up or down:
      closeOnSwipeUpOrDown: true,
      // Emulate touch events on mouse-pointer devices such as desktop browsers:
      emulateTouchEvents: true,
      // Stop touch events from bubbling up to ancestor elements of the Gallery:
      stopTouchEventsPropagation: false,
      // Hide the page scrollbars:
      hidePageScrollbars: false,
      // Stops any touches on the container from scrolling the page:
      disableScroll: true,
      // Carousel mode (shortcut for carousel specific options):
      carousel: false,
      // Allow continuous navigation, moving from last to first
      // and from first to last slide:
      continuous: true,
      // Remove elements outside of the preload range from the DOM:
      unloadElements: true,
      // Start with the automatic slideshow:
      startSlideshow: true,
      // Delay in milliseconds between slides for the automatic slideshow:
      slideshowInterval: 5000,
      // The starting index as integer.
      // Can also be an object of the given list,
      // or an equal object with the same url property:
      index: 0,
      // The number of elements to load around the current index:
      preloadRange: 2,
      // The transition speed between slide changes in milliseconds:
      transitionSpeed: 400,
      // The transition speed for automatic slide changes, set to an integer
      // greater 0 to override the default transition speed:
      slideshowTransitionSpeed: undefined,
      // The event object for which the default action will be canceled
      // on Gallery initialization (e.g. the click event to open the Gallery):
      event: undefined,

      // Callback function executed on slide change.
      // Is called with the gallery instance as "this" object and the
      // current index and slide as arguments:
      onslide: undefined,
      // Callback function executed after the slide change transition.
      // Is called with the gallery instance as "this" object and the
      // current index and slide as arguments:
      onslideend: undefined,
      // Callback function executed on slide content load.
      // Is called with the gallery instance as "this" object and the
      // slide index and slide element as arguments:
      onslidecomplete: undefined,


      // The tag name, Id, element or querySelector of the indicator container:
      indicatorContainer: 'ol',
      // The class for the active indicator:
      activeIndicatorClass: 'active',
      // The list object property (or data attribute) with the thumbnail URL,
      // used as alternative to a thumbnail child element:
      thumbnailProperty: 'ThumbnailImage',
      // Defines if the gallery indicators should display a thumbnail:
      thumbnailIndicators: true,

      indicators : {
            // Hide the page scrollbars:
          hidePageScrollbars: false,

          // The tag name, Id, element or querySelector of the indicator container:
          indicatorContainer: 'ol',
          // The class for the active indicator:
          activeIndicatorClass: 'active',
          // The list object property (or data attribute) with the thumbnail URL,
          // used as alternative to a thumbnail child element:
          thumbnailProperty: 'thumbnail',
          // Defines if the gallery indicators should display a thumbnail:
          thumbnailIndicators: true
      },



      "template" :'<div class="repeater-slider">' + 
                  '<div class="slides"></div>' +
                  '<h3 class="title"></h3>' +
                  '<a class="prev">‹</a>' +
                  '<a class="next">›</a>' +
                  '<a class="play-pause"></a>' +
                  '<ol class="indicator"></ol>' +
                  "</div>",

      "item" : {
        template : '<img height="75" src="{{ThumbnailImage}}" width="65"/>' 
      }
    },

    /*---
    carouselOptions: {
      hidePageScrollbars: false,
      toggleControlsOnReturn: false,
      toggleSlideshowOnSpace: false,
      enableKeyboardNavigation: false,
      closeOnEscape: false,
      closeOnSlideClick: false,
      closeOnSwipeUpOrDown: false,
      disableScroll: false,
      startSlideshow: true
    },
    */
    
    // Detect touch, transition, transform and background-size support:
    support: (function (element) {
      var support = {
        touch:
          window.ontouchstart !== undefined ||
          (window.DocumentTouch && document instanceof DocumentTouch)
      }
      var transitions = {
        webkitTransition: {
          end: 'webkitTransitionEnd',
          prefix: '-webkit-'
        },
        MozTransition: {
          end: 'transitionend',
          prefix: '-moz-'
        },
        OTransition: {
          end: 'otransitionend',
          prefix: '-o-'
        },
        transition: {
          end: 'transitionend',
          prefix: ''
        }
      }
      var prop
      for (prop in transitions) {
        if (
          transitions.hasOwnProperty(prop) &&
          element.style[prop] !== undefined
        ) {
          support.transition = transitions[prop]
          support.transition.name = prop
          break
        }
      }
      function elementTests () {
        var transition = support.transition
        var prop
        var translateZ
        document.body.appendChild(element)
        if (transition) {
          prop = transition.name.slice(0, -9) + 'ransform'
          if (element.style[prop] !== undefined) {
            element.style[prop] = 'translateZ(0)'
            translateZ = window
              .getComputedStyle(element)
              .getPropertyValue(transition.prefix + 'transform')
            support.transform = {
              prefix: transition.prefix,
              name: prop,
              translate: true,
              translateZ: !!translateZ && translateZ !== 'none'
            }
          }
        }
        if (element.style.backgroundSize !== undefined) {
          support.backgroundSize = {}
          element.style.backgroundSize = 'contain'
          support.backgroundSize.contain =
            window
              .getComputedStyle(element)
              .getPropertyValue('background-size') === 'contain'
          element.style.backgroundSize = 'cover'
          support.backgroundSize.cover =
            window
              .getComputedStyle(element)
              .getPropertyValue('background-size') === 'cover'
        }
        document.body.removeChild(element)
      }
      if (document.body) {
        elementTests()
      } else {
        $(document).on('DOMContentLoaded', elementTests)
      }
      return support
      // Test element, has to be standard HTML and must not be hidden
      // for the CSS3 tests using window.getComputedStyle to be applicable:
    })(document.createElement('div')),

    requestAnimationFrame:
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame,

    cancelAnimationFrame:
      window.cancelAnimationFrame ||
      window.webkitCancelRequestAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame,

    render: function (helper){
      //this.overrided(repeater,options);

      this.container = this.repeater.$canvas.find('.repeater-slider');

      if (this.container.length < 1) {
        this.container = $(this.options.template);
        this.repeater.$canvas.append(this.container);
      } 
      this.list = helper.data.items;
      //this.options.container = helper.container;
      this.num = this.list.length;

      this.initStartIndex()
      this.initView();

      this.initEventListeners()
      // Load the slide at the given index:
      this.onslide(this.index)
      // Manually trigger the slideend event for the initial slide:
      this.ontransitionend()
      // Start the automatic slideshow if applicable:
      if (this.options.startSlideshow) {
        this.play()
      }

    },

    slide: function (to, speed) {
      window.clearTimeout(this.timeout)
      var index = this.index
      var direction
      var naturalDirection
      var diff
      if (index === to || this.num === 1) {
        return
      }
      if (!speed) {
        speed = this.options.transitionSpeed
      }
      if (this.support.transform) {
        if (!this.options.continuous) {
          to = this.circle(to)
        }
        // 1: backward, -1: forward:
        direction = Math.abs(index - to) / (index - to)
        // Get the actual position of the slide:
        if (this.options.continuous) {
          naturalDirection = direction
          direction = -this.positions[this.circle(to)] / this.slideWidth
          // If going forward but to < index, use to = slides.length + to
          // If going backward but to > index, use to = -slides.length + to
          if (direction !== naturalDirection) {
            to = -direction * this.num + to
          }
        }
        diff = Math.abs(index - to) - 1
        // Move all the slides between index and to in the right direction:
        while (diff) {
          diff -= 1
          this.move(
            this.circle((to > index ? to : index) - diff - 1),
            this.slideWidth * direction,
            0
          )
        }
        to = this.circle(to)
        this.move(index, this.slideWidth * direction, speed)
        this.move(to, 0, speed)
        if (this.options.continuous) {
          this.move(
            this.circle(to - direction),
            -(this.slideWidth * direction),
            0
          )
        }
      } else {
        to = this.circle(to)
        this.animate(index * -this.slideWidth, to * -this.slideWidth, speed)
      }
      this.onslide(to)
    },

    getIndex: function () {
      return this.index
    },

    getNumber: function () {
      return this.num
    },

    prev: function () {
      if (this.options.continuous || this.index) {
        this.slide(this.index - 1)
      }
    },

    next: function () {
      if (this.options.continuous || this.index < this.num - 1) {
        this.slide(this.index + 1)
      }
    },

    circle: function (index) {
      // Always return a number inside of the slides index range:
      return (this.num + index % this.num) % this.num
    },

    move: function (index, dist, speed) {
      this.translateX(index, dist, speed)
      this.positions[index] = dist
    },

    translate: function (index, x, y, speed) {
      var style = this.slides[index].style
      var transition = this.support.transition
      var transform = this.support.transform
      style[transition.name + 'Duration'] = speed + 'ms'
      style[transform.name] =
        'translate(' +
        x +
        'px, ' +
        y +
        'px)' +
        (transform.translateZ ? ' translateZ(0)' : '')
    },

    translateX: function (index, x, speed) {
      this.translate(index, x, 0, speed)
    },

    translateY: function (index, y, speed) {
      this.translate(index, 0, y, speed)
    },

    animate: function (from, to, speed) {
      if (!speed) {
        this.slidesContainer[0].style.left = to + 'px'
        return
      }
      var that = this
      var start = new Date().getTime()
      var timer = window.setInterval(function () {
        var timeElap = new Date().getTime() - start
        if (timeElap > speed) {
          that.slidesContainer[0].style.left = to + 'px'
          that.ontransitionend()
          window.clearInterval(timer)
          return
        }
        that.slidesContainer[0].style.left =
          (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + 'px'
      }, 4)
    },

    play: function (time) {
      var that = this
      window.clearTimeout(this.timeout)
      this.interval = time || this.options.slideshowInterval;
      this.timeout = this.setTimeout(
        (!this.requestAnimationFrame && this.slide) ||
          function (to, speed) {
            that.animationFrameId = that.requestAnimationFrame.call(
              window,
              function () {
                that.slide(to, speed)
              }
            )
          },
        [this.index + 1, this.options.slideshowTransitionSpeed],
        this.interval
      )

      this.container.addClass(this.options.playingClass)
    },

    pause: function () {
      window.clearTimeout(this.timeout)
      this.interval = null
      if (this.cancelAnimationFrame) {
        this.cancelAnimationFrame.call(window, this.animationFrameId)
        this.animationFrameId = null
      }
      this.container.removeClass(this.options.playingClass)
    },

    add: function (list) {
      var i
      if (!list.concat) {
        // Make a real array out of the list to add:
        list = Array.prototype.slice.call(list)
      }
      if (!this.list.concat) {
        // Make a real array out of the Gallery list:
        this.list = Array.prototype.slice.call(this.list)
      }
      this.list = this.list.concat(list)
      this.num = this.list.length
      if (this.num > 2 && this.options.continuous === null) {
        this.options.continuous = true
        this.container.removeClass(this.options.leftEdgeClass)
      }
      this.container
        .removeClass(this.options.rightEdgeClass)
        .removeClass(this.options.singleClass)
      for (i = this.num - list.length; i < this.num; i += 1) {
        this.addSlide(i)
        this.positionSlide(i)
      }
      this.positions.length = this.num
      this.initSlides(true)
    },

    resetSlides: function () {
      this.slidesContainer.empty()
      this.unloadAllSlides()
      this.slides = []

      this.indicatorContainer.empty();
      this.indicators = [];

    },

    preventDefault: function (event) {
      if (event.preventDefault) {
        event.preventDefault()
      } else {
        event.returnValue = false
      }
    },

    stopPropagation: function (event) {
      if (event.stopPropagation) {
        event.stopPropagation()
      } else {
        event.cancelBubble = true
      }
    },

    onresize: function () {
      this.initSlides(true)
    },

    onmousedown: function (event) {
      // Trigger on clicks of the left mouse button only
      // and exclude video & audio elements:
      if (
        event.which &&
        event.which === 1 &&
        event.target.nodeName !== 'VIDEO' &&
        event.target.nodeName !== 'AUDIO'
      ) {
        // Preventing the default mousedown action is required
        // to make touch emulation work with Firefox:
        event.preventDefault()
        ;(event.originalEvent || event).touches = [
          {
            pageX: event.pageX,
            pageY: event.pageY
          }
        ]
        this.ontouchstart(event)
      }
    },

    onmousemove: function (event) {
      if (this.touchStart) {
        ;(event.originalEvent || event).touches = [
          {
            pageX: event.pageX,
            pageY: event.pageY
          }
        ]
        this.ontouchmove(event)
      }
    },

    onmouseup: function (event) {
      if (this.touchStart) {
        this.ontouchend(event)
        delete this.touchStart
      }
    },

    onmouseout: function (event) {
      if (this.touchStart) {
        var target = event.target
        var related = event.relatedTarget
        if (!related || (related !== target && !noder.contains(target, related))) {
          this.onmouseup(event)
        }
      }
    },

    ontouchstart: function (event) {
      if (this.options.stopTouchEventsPropagation) {
        this.stopPropagation(event)
      }
      // jQuery doesn't copy touch event properties by default,
      // so we have to access the originalEvent object:
      var touches = (event.originalEvent || event).touches[0]
      this.touchStart = {
        // Remember the initial touch coordinates:
        x: touches.pageX,
        y: touches.pageY,
        // Store the time to determine touch duration:
        time: Date.now()
      }
      // Helper variable to detect scroll movement:
      this.isScrolling = undefined
      // Reset delta values:
      this.touchDelta = {}
    },

    ontouchmove: function (event) {
      if (this.options.stopTouchEventsPropagation) {
        this.stopPropagation(event)
      }
      // jQuery doesn't copy touch event properties by default,
      // so we have to access the originalEvent object:
      var touches = (event.originalEvent || event).touches[0]
      var scale = (event.originalEvent || event).scale
      var index = this.index
      var touchDeltaX
      var indices
      // Ensure this is a one touch swipe and not, e.g. a pinch:
      if (touches.length > 1 || (scale && scale !== 1)) {
        return
      }
      if (this.options.disableScroll) {
        event.preventDefault()
      }
      // Measure change in x and y coordinates:
      this.touchDelta = {
        x: touches.pageX - this.touchStart.x,
        y: touches.pageY - this.touchStart.y
      }
      touchDeltaX = this.touchDelta.x
      // Detect if this is a vertical scroll movement (run only once per touch):
      if (this.isScrolling === undefined) {
        this.isScrolling =
          this.isScrolling ||
          Math.abs(touchDeltaX) < Math.abs(this.touchDelta.y)
      }
      if (!this.isScrolling) {
        // Always prevent horizontal scroll:
        event.preventDefault()
        // Stop the slideshow:
        window.clearTimeout(this.timeout)
        if (this.options.continuous) {
          indices = [this.circle(index + 1), index, this.circle(index - 1)]
        } else {
          // Increase resistance if first slide and sliding left
          // or last slide and sliding right:
          this.touchDelta.x = touchDeltaX =
            touchDeltaX /
            ((!index && touchDeltaX > 0) ||
            (index === this.num - 1 && touchDeltaX < 0)
              ? Math.abs(touchDeltaX) / this.slideWidth + 1
              : 1)
          indices = [index]
          if (index) {
            indices.push(index - 1)
          }
          if (index < this.num - 1) {
            indices.unshift(index + 1)
          }
        }
        while (indices.length) {
          index = indices.pop()
          this.translateX(index, touchDeltaX + this.positions[index], 0)
        }
      } else {
        this.translateY(index, this.touchDelta.y + this.positions[index], 0)
      }
    },

    ontouchend: function (event) {
      if (this.options.stopTouchEventsPropagation) {
        this.stopPropagation(event)
      }
      var index = this.index
      var speed = this.options.transitionSpeed
      var slideWidth = this.slideWidth
      var isShortDuration = Number(Date.now() - this.touchStart.time) < 250
      // Determine if slide attempt triggers next/prev slide:
      var isValidSlide =
        (isShortDuration && Math.abs(this.touchDelta.x) > 20) ||
        Math.abs(this.touchDelta.x) > slideWidth / 2
      // Determine if slide attempt is past start or end:
      var isPastBounds =
        (!index && this.touchDelta.x > 0) ||
        (index === this.num - 1 && this.touchDelta.x < 0)
      var isValidClose =
        !isValidSlide &&
        this.options.closeOnSwipeUpOrDown &&
        ((isShortDuration && Math.abs(this.touchDelta.y) > 20) ||
          Math.abs(this.touchDelta.y) > this.slideHeight / 2)
      var direction
      var indexForward
      var indexBackward
      var distanceForward
      var distanceBackward
      if (this.options.continuous) {
        isPastBounds = false
      }
      // Determine direction of swipe (true: right, false: left):
      direction = this.touchDelta.x < 0 ? -1 : 1
      if (!this.isScrolling) {
        if (isValidSlide && !isPastBounds) {
          indexForward = index + direction
          indexBackward = index - direction
          distanceForward = slideWidth * direction
          distanceBackward = -slideWidth * direction
          if (this.options.continuous) {
            this.move(this.circle(indexForward), distanceForward, 0)
            this.move(this.circle(index - 2 * direction), distanceBackward, 0)
          } else if (indexForward >= 0 && indexForward < this.num) {
            this.move(indexForward, distanceForward, 0)
          }
          this.move(index, this.positions[index] + distanceForward, speed)
          this.move(
            this.circle(indexBackward),
            this.positions[this.circle(indexBackward)] + distanceForward,
            speed
          )
          index = this.circle(indexBackward)
          this.onslide(index)
        } else {
          // Move back into position
          if (this.options.continuous) {
            this.move(this.circle(index - 1), -slideWidth, speed)
            this.move(index, 0, speed)
            this.move(this.circle(index + 1), slideWidth, speed)
          } else {
            if (index) {
              this.move(index - 1, -slideWidth, speed)
            }
            this.move(index, 0, speed)
            if (index < this.num - 1) {
              this.move(index + 1, slideWidth, speed)
            }
          }
        }
      } else {
          // Move back into position
          this.translateY(index, 0, speed)
      }
    },

    ontouchcancel: function (event) {
      if (this.touchStart) {
        this.ontouchend(event)
        delete this.touchStart
      }
    },

    ontransitionend: function (event) {
      var slide = this.slides[this.index]
      if (!event || slide === event.target) {
        if (this.interval) {
          this.play()
        }
        this.setTimeout(this.options.onslideend, [this.index, slide])
      }
    },

    onkeydown: function (event) {
      switch (event.which || event.keyCode) {
        case 13: // Return
          if (this.options.toggleControlsOnReturn) {
            this.preventDefault(event)
            this.toggleControls()
          }
          break
        case 27: // Esc
          break
        case 32: // Space
          if (this.options.toggleSlideshowOnSpace) {
            this.preventDefault(event)
            this.toggleSlideshow()
          }
          break
        case 37: // Left
          if (this.options.enableKeyboardNavigation) {
            this.preventDefault(event)
            this.prev()
          }
          break
        case 39: // Right
          if (this.options.enableKeyboardNavigation) {
            this.preventDefault(event)
            this.next()
          }
          break
      }
    },

    handleClick: function (event) {
      var options = this.options
      var target = event.target || event.srcElement
      var parent = target.parentNode

      if (parent === this.indicatorContainer[0]) {
        // Click on indicator element
        this.preventDefault(event)
        this.slide(this.getNodeIndex(target))
      } else if (parent.parentNode === this.indicatorContainer[0]) {
        // Click on indicator child element
        this.preventDefault(event)
        this.slide(this.getNodeIndex(parent))
      } else {
        function isTarget (className) {
          return $(target).hasClass(className) || $(parent).hasClass(className)
        }


        if (isTarget(options.toggleClass)) {
          // Click on "toggle" control
          this.preventDefault(event)
          this.toggleControls()
        } else if (isTarget(options.prevClass)) {
          // Click on "prev" control
          this.preventDefault(event)
          this.prev()
        } else if (isTarget(options.nextClass)) {
          // Click on "next" control
          this.preventDefault(event)
          this.next()
        } else if (isTarget(options.playPauseClass)) {
          // Click on "play-pause" control
          this.preventDefault(event)
          this.toggleSlideshow()
        } else if (parent === this.slidesContainer[0]) {
          // Click on slide background
          if (options.toggleControlsOnSlideClick) {
            this.preventDefault(event)
            this.toggleControls()
          }
        } else if (
          parent.parentNode &&
          parent.parentNode === this.slidesContainer[0]
        ) {
          // Click on displayed element
          if (options.toggleControlsOnSlideClick) {
            this.preventDefault(event)
            this.toggleControls()
          }
        }
      }
    },

    onclick: function (event) {
      if (
        this.options.emulateTouchEvents &&
        this.touchDelta &&
        (Math.abs(this.touchDelta.x) > 20 || Math.abs(this.touchDelta.y) > 20)
      ) {
        delete this.touchDelta
        return
      }
      return this.handleClick(event)
    },

    updateEdgeClasses: function (index) {
      if (!index) {
        this.container.addClass(this.options.leftEdgeClass)
      } else {
        this.container.removeClass(this.options.leftEdgeClass)
      }
      if (index === this.num - 1) {
        this.container.addClass(this.options.rightEdgeClass)
      } else {
        this.container.removeClass(this.options.rightEdgeClass)
      }
    },

    handleSlide: function (index) {
      if (!this.options.continuous) {
        this.updateEdgeClasses(index)
      }
      this.loadElements(index)
      if (this.options.unloadElements) {
        this.unloadElements(index)
      }
      this.setTitle(index)

      this.setActiveIndicator(index)

    },

    onslide: function (index) {
      this.index = index
      this.handleSlide(index)
      this.setTimeout(this.options.onslide, [index, this.slides[index]])
    },

    setTitle: function (index) {
      var firstChild = this.slides[index].firstChild
      var text = firstChild.title || firstChild.alt
      var titleElement = this.titleElement
      if (titleElement.length) {
        this.titleElement.empty()
        if (text) {
          titleElement[0].appendChild(document.createTextNode(text))
        }
      }
    },

    setTimeout: function (func, args, wait) {
      var that = this
      return (
        func &&
        window.setTimeout(function () {
          func.apply(that, args || [])
        }, wait || 0)
      )
    },

    createElement: function (obj, callback) {
      var $item = this._create$Item(this.options.item.template,obj);
      $item.find("img").on('load error', callback);

      $item.addClass(this.options.slideContentClass);
      return $item;
    },

    loadElement: function (index) {
      if (!this.elements[index]) {
        if (this.slides[index].firstChild) {
          this.elements[index] = $(this.slides[index]).hasClass(
            this.options.slideErrorClass
          )
            ? 3
            : 2
        } else {
          this.elements[index] = 1 // Loading
          $(this.slides[index]).append(            
            this.createElement(this.list[index], this.proxyListener)
          );
          //$(this.slides[index]).addClass(this.options.slideLoadingClass).append(            
          //  this.createElement(this.list[index], this.proxyListener)
          //);
        }
      }
    },

    loadElements: function (index) {
      var limit = Math.min(this.num, this.options.preloadRange * 2 + 1)
      var j = index
      var i
      for (i = 0; i < limit; i += 1) {
        // First load the current slide element (0),
        // then the next one (+1),
        // then the previous one (-2),
        // then the next after next (+2), etc.:
        j += i * (i % 2 === 0 ? -1 : 1)
        // Connect the ends of the list to load slide elements for
        // continuous navigation:
        j = this.circle(j)
        this.loadElement(j)
      }
    },

    unloadElements: function (index) {
      var i, diff
      for (i in this.elements) {
        if (this.elements.hasOwnProperty(i)) {
          diff = Math.abs(index - i)
          if (
            diff > this.options.preloadRange &&
            diff + this.options.preloadRange < this.num
          ) {
            this.unloadSlide(i)
            delete this.elements[i]
          }
        }
      }
    },


    createIndicator: function (obj) {
      var repeater = this.repeater,
          indicator = this.indicatorPrototype.cloneNode(false)
      var title = repeater.getItemProperty(obj,"title")
      var thumbnailProperty = this.options.thumbnailProperty
      var thumbnailUrl
      var thumbnail
      if (this.options.thumbnailIndicators) {
        if (thumbnailProperty) {
          thumbnailUrl = repeater.getItemProperty(obj, thumbnailProperty)
        }
        if (thumbnailUrl === undefined) {
          thumbnail = obj.getElementsByTagName && $(obj).find('img')[0]
          if (thumbnail) {
            thumbnailUrl = thumbnail.src
          }
        }
        if (thumbnailUrl) {
          indicator.style.backgroundImage = 'url("' + thumbnailUrl + '")'
        }
      }
      if (title) {
        indicator.title = title;
      }
      return indicator;
    },

    addIndicator: function (index) {
      if (this.indicatorContainer.length) {
        var indicator = this.createIndicator(this.list[index])
        indicator.setAttribute('data-index', index)
        this.indicatorContainer[0].appendChild(indicator)
        this.indicators.push(indicator)
      }
    },

    setActiveIndicator: function (index) {
      if (this.indicators) {
        if (this.activeIndicator) {
          this.activeIndicator.removeClass(this.options.activeIndicatorClass)
        }
        this.activeIndicator = $(this.indicators[index])
        this.activeIndicator.addClass(this.options.activeIndicatorClass)
      }
    },


    addSlide: function (index) {
      var slide = this.slidePrototype.cloneNode(false)
      slide.setAttribute('data-index', index)
      this.slidesContainer[0].appendChild(slide)
      this.slides.push(slide)

      this.addIndicator(index)
    },

    positionSlide: function (index) {
      var slide = this.slides[index]
      slide.style.width = this.slideWidth + 'px'
      if (this.support.transform) {
        slide.style.left = index * -this.slideWidth + 'px'
        this.move(
          index,
          this.index > index
            ? -this.slideWidth
            : this.index < index ? this.slideWidth : 0,
          0
        )
      }
    },

    initSlides: function (reload) {
      var clearSlides, i
      if (!reload) {
        // indicator
        this.indicatorContainer = this.container.find(
          this.options.indicatorContainer
        )
        if (this.indicatorContainer.length) {
          this.indicatorPrototype = document.createElement('li')
          this.indicators = this.indicatorContainer[0].children
        }

        this.positions = []
        this.positions.length = this.num
        this.elements = {}
        this.imagePrototype = document.createElement('img')
        this.elementPrototype = document.createElement('div')
        this.slidePrototype = document.createElement('div')
        $(this.slidePrototype).addClass(this.options.slideClass)
        this.slides = this.slidesContainer[0].children
        clearSlides =
          this.options.clearSlides || this.slides.length !== this.num
      }
      this.slideWidth = this.container[0].clientWidth
      this.slideHeight = this.container[0].clientHeight
      this.slidesContainer[0].style.width = this.num * this.slideWidth + 'px'
      if (clearSlides) {
        this.resetSlides()
      }
      for (i = 0; i < this.num; i += 1) {
        if (clearSlides) {
          this.addSlide(i)
        }
        this.positionSlide(i)
      }
      // Reposition the slides before and after the given index:
      if (this.options.continuous && this.support.transform) {
        this.move(this.circle(this.index - 1), -this.slideWidth, 0)
        this.move(this.circle(this.index + 1), this.slideWidth, 0)
      }
      if (!this.support.transform) {
        this.slidesContainer[0].style.left =
          this.index * -this.slideWidth + 'px'
      }
    },

    unloadSlide: function (index) {
      var slide, firstChild
      slide = this.slides[index]
      firstChild = slide.firstChild
      if (firstChild !== null) {
        slide.removeChild(firstChild)
      }
    },

    unloadAllSlides: function () {
      var i, len
      for (i = 0, len = this.slides.length; i < len; i++) {
        this.unloadSlide(i)
      }
    },

    toggleControls: function () {

      var controlsClass = this.options.controlsClass
      if (this.container.hasClass(controlsClass)) {
        this.container.removeClass(controlsClass)
      } else {
        this.container.addClass(controlsClass)
      }
    },

    toggleSlideshow: function () {
      if (!this.interval) {
        this.play()
      } else {
        this.pause()
      }
    },

    getNodeIndex: function (element) {
      return parseInt(element.getAttribute('data-index'), 10)
    },

    initStartIndex: function () {
      var repeater = this.repeater,
          index = this.options.index;
      var i
      // Check if the index is given as a list object:
      if (index && typeof index !== 'number') {
        for (i = 0; i < this.num; i += 1) {
          if (
            this.list[i] === index || repeater.getItemUrl(this.list[i]) ===  repeater.getItemUrl(index) ) {
            index = i
            break
          }
        }
      }
      // Make sure the index is in the list range:
      this.index = this.circle(parseInt(index, 10) || 0)
    },

    initEventListeners: function () {
      var that = this
      var slidesContainer = this.slidesContainer
      function proxyListener (event) {
        var type =
          that.support.transition && that.support.transition.end === event.type
            ? 'transitionend'
            : event.type
        that['on' + type](event)
      }
      $(window).on('resize', proxyListener)
      $(document.body).on('keydown', proxyListener)
      this.container.on('click', proxyListener)
      if (this.support.touch) {
        slidesContainer.on(
          'touchstart touchmove touchend touchcancel',
          proxyListener
        )
      } else if (this.options.emulateTouchEvents && this.support.transition) {
        slidesContainer.on(
          'mousedown mousemove mouseup mouseout',
          proxyListener
        )
      }
      if (this.support.transition) {
        slidesContainer.on(this.support.transition.end, proxyListener)
      }
      this.proxyListener = proxyListener
    },

    destroyEventListeners: function () {
      var slidesContainer = this.slidesContainer
      var proxyListener = this.proxyListener
      $(window).off('resize', proxyListener)
      $(document.body).off('keydown', proxyListener)
      this.container.off('click', proxyListener)
      if (this.support.touch) {
        slidesContainer.off(
          'touchstart touchmove touchend touchcancel',
          proxyListener
        )
      } else if (this.options.emulateTouchEvents && this.support.transition) {
        slidesContainer.off(
          'mousedown mousemove mouseup mouseout',
          proxyListener
        )
      }
      if (this.support.transition) {
        slidesContainer.off(this.support.transition.end, proxyListener)
      }
    },


    initView: function () {
      var that = this

      /*
      this.container = $(this.options.container)
      if (!this.container.length) {
        console.log(
          'blueimp Gallery: Widget container not found.',
          this.options.container
        )
        return false
      }
      */

      this.slidesContainer = this.container
        .find(this.options.slidesContainer)
        .first()
      if (!this.slidesContainer.length) {
        console.log(
          'blueimp Gallery: Slides container not found.',
          this.options.slidesContainer
        )
        return false
      }
      this.titleElement = this.container.find(this.options.titleElement).first()
      if (this.num === 1) {
        this.container.addClass(this.options.singleClass)
      }
      if (this.options.hidePageScrollbars) {
        // Hide the page scrollbars:
        this.bodyOverflowStyle = document.body.style.overflow
        document.body.style.overflow = 'hidden'
      }
      this.container[0].style.display = 'block'
      this.initSlides()
      this.container.addClass(this.options.displayClass)
    },

    initOptions: function (options) {
      // Create a copy of the prototype options:
      this.overrided(langx.mixin({}, SliderView.prototype.options,options));

      if (this.num < 3) {
        // 1 or 2 slides cannot be displayed continuous,
        // remember the original option by setting to null instead of false:
        this.options.continuous = this.options.continuous ? null : false
      }
      if (!this.support.transition) {
        this.options.emulateTouchEvents = false
      }
      if (this.options.event) {
        this.preventDefault(this.options.event)
      }
    }
  });

  views["slider"] = {
    "name" :  "slider",
    "ctor" :  SliderView
  };

  return SliderView;

});

define('skylark-widgets-repeater/views/TableView',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "../views",   
    "./ViewBase"
], function(langx, browser, eventer, noder, geom, $, views, ViewBase) {

  var TableView = ViewBase.inherit({
    klassName : "TableView",

    options: {
        columnRendered: null,
        columnSizing: true,
        columnSyncing: true,
        highlightSortedColumn: true,
        infiniteScroll: false,
        noItemsHTML: 'no items found',
        selectable: false,
        sortClearing: false,
        rowRendered: null,
        frozenColumns: 0,
        actions: false
    },

    clearSelectedItems : function listClearSelectedItems () {
        this.repeater.$canvas.find('.repeater-table-check').remove();
        this.repeater.$canvas.find('.repeater-table table tbody tr.selected').removeClass('selected');
    },

    highlightColumn : function listHighlightColumn (index, force) {
        var tbody = this.repeater.$canvas.find('.repeater-table-wrapper > table tbody');
        if (this.options.highlightSortedColumn || force) {
            tbody.find('td.sorted').removeClass('sorted');
            tbody.find('tr').each(function eachTR () {
                var col = $(this).find('td:nth-child(' + (index + 1) + ')').filter(function filterChildren () { return !$(this).parent().hasClass('empty'); });
                col.addClass('sorted');
            });
        }
    },

    getSelectedItems : function listGetSelectedItems () {
        var selected = [];
        this.repeater.$canvas.find('.repeater-table .repeater-table-wrapper > table tbody tr.selected').each(function eachSelectedTR () {
            var $item = $(this);
            selected.push({
                data: $item.data('item_data'),
                element: $item
            });
        });
        return selected;
    },

    positionHeadings : function listPositionHeadings () {
        var $wrapper = this.repeater.$element.find('.repeater-table-wrapper');
        var offsetLeft = $wrapper.offset().left;
        var scrollLeft = $wrapper.scrollLeft();
        if (scrollLeft > 0) {
            $wrapper.find('.repeater-table-heading').each(function eachListHeading () {
                var $heading = $(this);
                var left = ($heading.parents('th:first').offset().left - offsetLeft) + 'px';
                $heading.addClass('shifted').css('left', left);
            });
        } else {
            $wrapper.find('.repeater-table-heading').each(function eachListHeading () {
                $(this).removeClass('shifted').css('left', '');
            });
        }
    },

    setSelectedItems : function listSetSelectedItems (itms, force) {
        var selectable = this.options.selectable;
        var self = this;
        var data;
        var i;
        var $item;
        var length;

        var items = itms;
        if (!$.isArray(items)) {
            items = [items];
        }

        // this function is necessary because lint yells when a function is in a loop
        var checkIfItemMatchesValue = function checkIfItemMatchesValue (rowIndex) {
            $item = $(this);

            data = $item.data('item_data') || {};
            if (data[items[i].property] === items[i].value) {
                selectItem($item, items[i].selected, rowIndex);
            }
        };

        var selectItem = function selectItem ($itm, slct, index) {
            var $frozenCols;

            var select = (slct !== undefined) ? slct : true;
            if (select) {
                if (!force && selectable !== 'multi') {
                    self.clearSelectedItems();
                }

                if (!$itm.hasClass('selected')) {
                    $itm.addClass('selected');

                    if (self.options.frozenColumns || self.options.selectable === 'multi') {
                        $frozenCols = self.repeater.$element.find('.frozen-column-wrapper tr:nth-child(' + (index + 1) + ')');

                        $frozenCols.addClass('selected');
                        $frozenCols.find('.repeater-select-checkbox').addClass('checked');
                    }

                    if (self.options.actions) {
                        self.repeater.$element.find('.actions-column-wrapper tr:nth-child(' + (index + 1) + ')').addClass('selected');
                    }

                    $itm.find('td:first').prepend('<div class="repeater-table-check"><span class="glyphicon glyphicon-ok"></span></div>');
                }
            } else {
                if (self.options.frozenColumns) {
                    $frozenCols = self.repeater.$element.find('.frozen-column-wrapper tr:nth-child(' + (index + 1) + ')');

                    $frozenCols.addClass('selected');
                    $frozenCols.find('.repeater-select-checkbox').removeClass('checked');
                }

                if (self.options.actions) {
                    self.repeater.$element.find('.actions-column-wrapper tr:nth-child(' + (index + 1) + ')').removeClass('selected');
                }

                $itm.find('.repeater-table-check').remove();
                $itm.removeClass('selected');
            }
        };

        if (force === true || selectable === 'multi') {
            length = items.length;
        } else if (selectable) {
            length = (items.length > 0) ? 1 : 0;
        } else {
            length = 0;
        }

        for (i = 0; i < length; i++) {
            if (items[i].index !== undefined) {
                $item = this.repeater.$canvas.find('.repeater-table .repeater-table-wrapper > table tbody tr:nth-child(' + (items[i].index + 1) + ')');
                if ($item.length > 0) {
                    selectItem($item, items[i].selected, items[i].index);
                }
            } else if (items[i].property !== undefined && items[i].value !== undefined) {
                this.repeater.$canvas.find('.repeater-table .repeater-table-wrapper > table tbody tr').each(checkIfItemMatchesValue);
            }
        }
    },

    sizeHeadings : function listSizeHeadings () {
        var $table = this.repeater.$element.find('.repeater-table table');
        $table.find('thead th').each(function eachTH () {
            var $th = $(this);
            var $heading = $th.find('.repeater-table-heading');
            $heading.css({ height: $th.outerHeight() });
            $heading.outerWidth($heading.data('forced-width') || $th.outerWidth());
        });
    },

    setFrozenColumns : function listSetFrozenColumns () {
        var frozenTable = this.repeater.$canvas.find('.table-frozen');
        var $wrapper = this.repeater.$element.find('.repeater-canvas');
        var $table = this.repeater.$element.find('.repeater-table .repeater-table-wrapper > table');
        var repeaterWrapper = this.repeater.$element.find('.repeater-table');
        var numFrozenColumns = this.options.frozenColumns;
        var self = this;

        if (this.options.selectable === 'multi') {
            numFrozenColumns = numFrozenColumns + 1;
            $wrapper.addClass('multi-select-enabled');
        }

        if (frozenTable.length < 1) {
            // setup frozen column markup
            // main wrapper and remove unneeded columns
            var $frozenColumnWrapper = $('<div class="frozen-column-wrapper"></div>').insertBefore($table);
            var $frozenColumn = $table.clone().addClass('table-frozen');
            $frozenColumn.find('th:not(:lt(' + numFrozenColumns + '))').remove();
            $frozenColumn.find('td:not(:nth-child(n+0):nth-child(-n+' + numFrozenColumns + '))').remove();

            // need to set absolute heading for vertical scrolling
            var $frozenThead = $frozenColumn.clone().removeClass('table-frozen');
            $frozenThead.find('tbody').remove();
            var $frozenTheadWrapper = $('<div class="frozen-thead-wrapper"></div>').append($frozenThead);

            // this gets a little messy with all the cloning. We need to make sure the ID and FOR
            // attribs are unique for the 'top most' cloned checkbox
            var $checkboxLabel = $frozenTheadWrapper.find('th label.checkbox-custom.checkbox-inline');
            $checkboxLabel.attr('id', $checkboxLabel.attr('id') + '_cloned');

            $frozenColumnWrapper.append($frozenColumn);
            repeaterWrapper.append($frozenTheadWrapper);
            this.repeater.$canvas.addClass('frozen-enabled');
        }

        this.sizeFrozenColumns();

        $('.frozen-thead-wrapper .repeater-table-heading').on('click', function onClickHeading () {
            var index = $(this).parent('th').index();
            index = index + 1;
            self.repeater.$element.find('.repeater-table-wrapper > table thead th:nth-child(' + index + ') .repeater-table-heading')[0].click();
        });
    },

    positionColumns : function listPositionColumns () {
        var $wrapper = this.repeater.$element.find('.repeater-canvas');
        var scrollTop = $wrapper.scrollTop();
        var scrollLeft = $wrapper.scrollLeft();
        var frozenEnabled = this.options.frozenColumns || this.options.selectable === 'multi';
        var actionsEnabled = this.options.actions;

        var canvasWidth = this.repeater.$element.find('.repeater-canvas').outerWidth();
        var tableWidth = this.repeater.$element.find('.repeater-table .repeater-table-wrapper > table').outerWidth();

        var actionsWidth = this.repeater.$element.find('.table-actions') ? this.repeater.$element.find('.table-actions').outerWidth() : 0;

        var shouldScroll = (tableWidth - (canvasWidth - actionsWidth)) >= scrollLeft;


        if (scrollTop > 0) {
            $wrapper.find('.repeater-table-heading').css('top', scrollTop);
        } else {
            $wrapper.find('.repeater-table-heading').css('top', '0');
        }

        if (scrollLeft > 0) {
            if (frozenEnabled) {
                $wrapper.find('.frozen-thead-wrapper').css('left', scrollLeft);
                $wrapper.find('.frozen-column-wrapper').css('left', scrollLeft);
            }
            if (actionsEnabled && shouldScroll) {
                $wrapper.find('.actions-thead-wrapper').css('right', -scrollLeft);
                $wrapper.find('.actions-column-wrapper').css('right', -scrollLeft);
            }
        } else {
            if (frozenEnabled) {
                $wrapper.find('.frozen-thead-wrapper').css('left', '0');
                $wrapper.find('.frozen-column-wrapper').css('left', '0');
            }
            if (actionsEnabled) {
                $wrapper.find('.actions-thead-wrapper').css('right', '0');
                $wrapper.find('.actions-column-wrapper').css('right', '0');
            }
        }
    },

    createItemActions : function listCreateItemActions () {
        var actionsHtml = '';
        var self = this;
        var i;
        var length;
        var $table = this.repeater.$element.find('.repeater-table .repeater-table-wrapper > table');
        var $actionsTable = this.repeater.$canvas.find('.table-actions');

        for (i = 0, length = this.options.actions.items.length; i < length; i++) {
            var action = this.options.actions.items[i];
            var html = action.html;

            actionsHtml += '<li><a href="#" data-action="' + action.name + '" class="action-item"> ' + html + '</a></li>';
        }

        var actionsDropdown = '<div class="btn-group">' +
            '<button type="button" class="btn btn-xs btn-default dropdown-toggle repeater-actions-button" data-toggle="dropdown" data-flip="auto" aria-expanded="false">' +
            '<span class="caret"></span>' +
            '</button>' +
            '<ul class="dropdown-menu dropdown-menu-right" role="menu">' +
            actionsHtml +
            '</ul></div>';

        if ($actionsTable.length < 1) {
            var $actionsColumnWrapper = $('<div class="actions-column-wrapper" style="width: ' + this.actions_width + 'px"></div>').insertBefore($table);
            var $actionsColumn = $table.clone().addClass('table-actions');
            $actionsColumn.find('th:not(:last-child)').remove();
            $actionsColumn.find('tr td:not(:last-child)').remove();

            // Dont show actions dropdown in header if not multi select
            if (this.options.selectable === 'multi' || this.options.selectable === 'action') {
                $actionsColumn.find('thead tr').html('<th><div class="repeater-table-heading">' + actionsDropdown + '</div></th>');

                if (this.options.selectable !== 'action') {
                    // disable the header dropdown until an item is selected
                    $actionsColumn.find('thead .btn').attr('disabled', 'disabled');
                }
            } else {
                var label = this.options.actions.label || '<span class="actions-hidden">a</span>';
                $actionsColumn.find('thead tr').addClass('empty-heading').html('<th>' + label + '<div class="repeater-table-heading">' + label + '</div></th>');
            }

            // Create Actions dropdown for each cell in actions table
            var $actionsCells = $actionsColumn.find('td');

            $actionsCells.each(function addActionsDropdown (rowNumber) {
                $(this).html(actionsDropdown);
                $(this).find('a').attr('data-row', rowNumber + 1);
            });

            $actionsColumnWrapper.append($actionsColumn);

            this.repeater.$canvas.addClass('actions-enabled');
        }

        this.sizeActionsTable();

        // row level actions click
        this.repeater.$element.find('.table-actions tbody .action-item').on('click', function onBodyActionItemClick (e) {
            if (!self.isDisabled) {
                var actionName = $(this).data('action');
                var row = $(this).data('row');
                var selected = {
                    actionName: actionName,
                    rows: [row]
                };
                self.getActionItems(selected, e);
            }
        });
        // bulk actions click
        this.repeater.$element.find('.table-actions thead .action-item').on('click', function onHeadActionItemClick (e) {
            if (!self.isDisabled) {
                var actionName = $(this).data('action');
                var selected = {
                    actionName: actionName,
                    rows: []
                };
                var selector = '.repeater-table-wrapper > table .selected';

                if ( self.options.selectable === 'action' ) {
                    selector = '.repeater-table-wrapper > table tr';
                }
                self.repeater.$element.find(selector).each(function eachSelector (selectorIndex) {
                    selected.rows.push(selectorIndex + 1);
                });

                self.getActionItems(selected, e);
            }
        });
    },

    getActionItems : function listGetActionItems (selected, e) {
        var selectedObj = [];
        var actionObj = $.grep(this.options.actions.items, function matchedActions (actions) {
            return actions.name === selected.actionName;
        })[0];
        for (var i = 0, selectedRowsL = selected.rows.length; i < selectedRowsL; i++) {
            var clickedRow = this.repeater.$canvas.find('.repeater-table-wrapper > table tbody tr:nth-child(' + selected.rows[i] + ')');
            selectedObj.push({
                item: clickedRow,
                rowData: clickedRow.data('item_data')
            });
        }
        if (selectedObj.length === 1) {
            selectedObj = selectedObj[0];
        }

        if (actionObj.clickAction) {
            var callback = function noop () {};// for backwards compatibility. No idea why this was originally here...
            actionObj.clickAction(selectedObj, callback, e);
        }
    },

    sizeActionsTable : function listSizeActionsTable () {
        var $actionsTable = this.repeater.$element.find('.repeater-table table.table-actions');
        var $actionsTableHeader = $actionsTable.find('thead tr th');
        var $table = this.repeater.$element.find('.repeater-table-wrapper > table');

        $actionsTableHeader.outerHeight($table.find('thead tr th').outerHeight());
        $actionsTableHeader.find('.repeater-table-heading').outerHeight($actionsTableHeader.outerHeight());
        $actionsTable.find('tbody tr td:first-child').each(function eachFirstChild (i) {
            $(this).outerHeight($table.find('tbody tr:eq(' + i + ') td').outerHeight());
        });
    },

    sizeFrozenColumns : function listSizeFrozenColumns () {
        var $table = this.repeater.$element.find('.repeater-table .repeater-table-wrapper > table');

        this.repeater.$element.find('.repeater-table table.table-frozen tr').each(function eachTR (i) {
            $(this).height($table.find('tr:eq(' + i + ')').height());
        });

        var columnWidth = $table.find('td:eq(0)').outerWidth();
        this.repeater.$element.find('.frozen-column-wrapper, .frozen-thead-wrapper').width(columnWidth);
    },

    frozenOptionsInitialize : function listFrozenOptionsInitialize () {
        var $checkboxes = this.repeater.$element.find('.frozen-column-wrapper .checkbox-inline');
        var $headerCheckbox = this.repeater.$element.find('.header-checkbox .checkbox-custom');
        var $everyTable = this.repeater.$element.find('.repeater-table table');
        var self = this;

        // Make sure if row is hovered that it is shown in frozen column as well
        this.repeater.$element.find('tr.selectable').on('mouseover mouseleave', function onMouseEvents (e) {
            var index = $(this).index();
            index = index + 1;
            if (e.type === 'mouseover') {
                $everyTable.find('tbody tr:nth-child(' + index + ')').addClass('hovered');
            } else {
                $everyTable.find('tbody tr:nth-child(' + index + ')').removeClass('hovered');
            }
        });

        $headerCheckbox.checkbox();
        $checkboxes.checkbox();

        // Row checkboxes
        var $rowCheckboxes = this.repeater.$element.find('.table-frozen tbody .checkbox-inline');
        var $checkAll = this.repeater.$element.find('.frozen-thead-wrapper thead .checkbox-inline input');
        $rowCheckboxes.on('change', function onChangeRowCheckboxes (e) {
            e.preventDefault();

            if (!self.revertingCheckbox) {
                if (self.isDisabled) {
                    revertCheckbox($(e.currentTarget));
                } else {
                    var row = $(this).attr('data-row');
                    row = parseInt(row, 10) + 1;
                    self.repeater.$element.find('.repeater-table-wrapper > table tbody tr:nth-child(' + row + ')').click();

                    var numSelected = self.repeater.$element.find('.table-frozen tbody .checkbox-inline.checked').length;
                    if (numSelected === 0) {
                        $checkAll.prop('checked', false);
                        $checkAll.prop('indeterminate', false);
                    } else if (numSelected === $rowCheckboxes.length) {
                        $checkAll.prop('checked', true);
                        $checkAll.prop('indeterminate', false);
                    } else {
                        $checkAll.prop('checked', false);
                        $checkAll.prop('indeterminate', true);
                    }
                }
            }
        });

        // "Check All" checkbox
        $checkAll.on('change', function onChangeCheckAll (e) {
            if (!self.revertingCheckbox) {
                if (self.isDisabled) {
                    revertCheckbox($(e.currentTarget));
                } else if ($(this).is(':checked')) {
                    self.repeater.$element.find('.repeater-table-wrapper > table tbody tr:not(.selected)').click();
                    self.repeater.$element.trigger('selected.lark.repeaterList', $checkboxes);
                } else {
                    self.repeater.$element.find('.repeater-table-wrapper > table tbody tr.selected').click();
                    self.repeater.$element.trigger('deselected.lark.repeaterList', $checkboxes);
                }
            }
        });

        function revertCheckbox ($checkbox) {
            self.revertingCheckbox = true;
            $checkbox.checkbox('toggle');
            delete self.revertingCheckbox;
        }
    },

    cleared: function cleared () {
        if (this.options.columnSyncing) {
            this.sizeHeadings();
        }
    },
    dataOptions: function dataOptions (options) {
        if (this.sortDirection) {
            options.sortDirection = this.sortDirection;
        }
        if (this.sortProperty) {
            options.sortProperty = this.sortProperty;
        }
        return options;
    },
    enabled: function enabled (helpers) {
        if (this.options.actions) {
            if (!helpers.status) {
                this.repeater.$canvas.find('.repeater-actions-button').attr('disabled', 'disabled');
            } else {
                this.repeater.$canvas.find('.repeater-actions-button').removeAttr('disabled');
                toggleActionsHeaderButton.call(this);
            }
        }
    },
    initialize: function initialize (helpers, callback) {
        this.sortDirection = null;
        this.sortProperty = null;
        this.specialBrowserClass = specialBrowserClass();
        this.actions_width = (this.options.actions.width !== undefined) ? this.options.actions.width : 37;
        this.noItems = false;
        callback();
    },
    resize: function resize () {
        sizeColumns.call(this, this.repeater.$element.find('.repeater-table-wrapper > table thead tr'));
        if (this.options.actions) {
            this.sizeActionsTable();
        }
        if (this.options.frozenColumns || this.options.selectable === 'multi') {
            this.sizeFrozenColumns();
        }
        if (this.options.columnSyncing) {
            this.sizeHeadings();
        }
    },
    selected: function selected () {
        var infScroll = this.options.infiniteScroll;
        var opts;

        this.firstRender = true;
        this.repeater.$loader.addClass('noHeader');

        if (infScroll) {
            opts = (typeof infScroll === 'object') ? infScroll : {};
            this.repeater.infiniteScrolling(true, opts);
        }
    },
    before: function before (helpers) {
        var $listContainer = helpers.container.find('.repeater-table');
        var self = this;
        var $table;

        // this is a patch, it was pulled out of `renderThead`
        if (helpers.data.count > 0) {
            this.noItems = false;
        } else {
            this.noItems = true;
        }

        if ($listContainer.length < 1) {
            $listContainer = $('<div class="repeater-table ' + this.specialBrowserClass + '" data-preserve="shallow"><div class="repeater-table-wrapper" data-infinite="true" data-preserve="shallow"><table aria-readonly="true" class="table" data-preserve="shallow" role="grid"></table></div></div>');
            $listContainer.find('.repeater-table-wrapper').on('scroll.lark.repeaterList', function onScrollRepeaterList () {
                if (self.options.columnSyncing) {
                    self.positionHeadings();
                }
            });
            if (self.options.frozenColumns || self.options.actions || self.options.selectable === 'multi') {
                helpers.container.on('scroll.lark.repeaterList', function onScrollRepeaterList () {
                    self.positionColumns();
                });
            }

            helpers.container.append($listContainer);
        }
        helpers.container.removeClass('actions-enabled actions-enabled multi-select-enabled');

        $table = $listContainer.find('table');
        renderThead.call(this, $table, helpers.data);
        renderTbody.call(this, $table, helpers.data);

        return false;
    },
    renderItem: function renderItem (helpers) {
        renderRow.call(this, helpers.container, helpers.subset, helpers.index);
        return false;
    },
    after: function after () {
        var $sorted;

        if ((this.options.frozenColumns || this.options.selectable === 'multi') && !this.noItems) {
            this.setFrozenColumns();
        }

        if (this.options.actions && !this.noItems) {
            this.createItemActions();
            this.sizeActionsTable();
        }

        if ((this.options.frozenColumns || this.options.actions || this.options.selectable === 'multi') && !this.noItems) {
            this.positionColumns();
            this.frozenOptionsInitialize();
        }

        if (this.options.columnSyncing) {
            this.sizeHeadings();
            this.positionHeadings();
        }

        $sorted = this.repeater.$canvas.find('.repeater-table-wrapper > table .repeater-table-heading.sorted');
        if ($sorted.length > 0) {
            this.highlightColumn($sorted.data('fu_item_index'));
        }

        return false;
    }


  });



    // ADDITIONAL METHODS
    var areDifferentColumns = function areDifferentColumns (oldCols, newCols) {
        if (!newCols) {
            return false;
        }
        if (!oldCols || (newCols.length !== oldCols.length)) {
            return true;
        }
        for (var i = 0, newColsL = newCols.length; i < newColsL; i++) {
            if (!oldCols[i]) {
                return true;
            }

            for (var j in newCols[i]) {
                if (newCols[i].hasOwnProperty(j) && oldCols[i][j] !== newCols[i][j]) {
                    return true;
                }
            }
        }
        return false;
    };

    var renderColumn = function renderColumn ($row, rows, rowIndex, columns, columnIndex) {
        var className = columns[columnIndex].className;
        var content = rows[rowIndex][columns[columnIndex].property];
        var $col = $('<td></td>');
        var width = columns[columnIndex]._auto_width;

        var property = columns[columnIndex].property;
        if (this.options.actions !== false && property === '@_ACTIONS_@') {
            content = '<div class="repeater-table-actions-placeholder" style="width: ' + this.actions_width  + 'px"></div>';
        }

        content = (content !== undefined) ? content : '';

        $col.addClass(((className !== undefined) ? className : '')).append(content);
        if (width !== undefined) {
            $col.outerWidth(width);
        }

        $row.append($col);

        if (this.options.selectable === 'multi' && columns[columnIndex].property === '@_CHECKBOX_@') {
            var checkBoxMarkup = '<label data-row="' + rowIndex + '" class="checkbox-custom checkbox-inline body-checkbox repeater-select-checkbox">' +
                '<input class="sr-only" type="checkbox"></label>';

            $col.html(checkBoxMarkup);
        }

        return $col;
    };

    var renderHeader = function renderHeader ($tr, columns, index) {
        var chevDown = 'glyphicon-chevron-down';
        var chevron = '.glyphicon.rlc:first';
        var chevUp = 'glyphicon-chevron-up';
        var $div = $('<div class="repeater-table-heading"><span class="glyphicon rlc"></span></div>');
        var checkAllID = (this.repeater.$element.attr('id') + '_' || '') + 'checkall';

        var checkBoxMarkup = '<div class="repeater-table-heading header-checkbox">' +
                '<label id="' + checkAllID + '" class="checkbox-custom checkbox-inline">' +
                    '<input class="sr-only" type="checkbox" value="">' +
                    '<span class="checkbox-label">&nbsp;</span>' +
                '</label>' +
            '</div>';

        var $header = $('<th></th>');
        var self = this;
        var $both;
        var className;
        var sortable;
        var $span;
        var $spans;

        $div.data('fu_item_index', index);
        $div.prepend(columns[index].label);
        $header.html($div.html()).find('[id]').removeAttr('id');

        if (columns[index].property !== '@_CHECKBOX_@') {
            $header.append($div);
        } else {
            $header.append(checkBoxMarkup);
        }

        $both = $header.add($div);
        $span = $div.find(chevron);
        $spans = $span.add($header.find(chevron));

        if (this.options.actions && columns[index].property === '@_ACTIONS_@') {
            var width = this.actions_width;
            $header.css('width', width);
            $div.css('width', width);
        }

        className = columns[index].className;
        if (className !== undefined) {
            $both.addClass(className);
        }

        sortable = columns[index].sortable;
        if (sortable) {
            $both.addClass('sortable');
            $div.on('click.lark.repeaterList', function onClickRepeaterList () {
                if (!self.isDisabled) {
                    self.sortProperty = (typeof sortable === 'string') ? sortable : columns[index].property;
                    if ($div.hasClass('sorted')) {
                        if ($span.hasClass(chevUp)) {
                            $spans.removeClass(chevUp).addClass(chevDown);
                            self.sortDirection = 'desc';
                        } else if (!self.options.sortClearing) {
                            $spans.removeClass(chevDown).addClass(chevUp);
                            self.sortDirection = 'asc';
                        } else {
                            $both.removeClass('sorted');
                            $spans.removeClass(chevDown);
                            self.sortDirection = null;
                            self.sortProperty = null;
                        }
                    } else {
                        $tr.find('th, .repeater-table-heading').removeClass('sorted');
                        $spans.removeClass(chevDown).addClass(chevUp);
                        self.sortDirection = 'asc';
                        $both.addClass('sorted');
                    }

                    self.repeater.render({
                        clearInfinite: true,
                        pageIncrement: null
                    });
                }
            });
        }

        if (columns[index].sortDirection === 'asc' || columns[index].sortDirection === 'desc') {
            $tr.find('th, .repeater-table-heading').removeClass('sorted');
            $both.addClass('sortable sorted');
            if (columns[index].sortDirection === 'asc') {
                $spans.addClass(chevUp);
                this.sortDirection = 'asc';
            } else {
                $spans.addClass(chevDown);
                this.sortDirection = 'desc';
            }

            this.sortProperty = (typeof sortable === 'string') ? sortable : columns[index].property;
        }

        $tr.append($header);
    };

    var onClickRowRepeaterList = function onClickRowRepeaterList (repeater) {
        var isMulti = repeater.options.selectable === 'multi';
        var isActions = repeater.options.actions;
        var $repeater = repeater.$element;

        if (!repeater.isDisabled) {
            var $item = $(this);
            var index = $(this).index() + 1;
            var $frozenRow = $repeater.find('.frozen-column-wrapper tr:nth-child(' + index + ')');
            var $actionsRow = $repeater.find('.actions-column-wrapper tr:nth-child(' + index + ')');
            var $checkBox = $repeater.find('.frozen-column-wrapper tr:nth-child(' + index + ') .checkbox-inline');

            if ($item.is('.selected')) {
                $item.removeClass('selected');
                if (isMulti) {
                    $checkBox.click();
                    $frozenRow.removeClass('selected');
                    if (isActions) {
                        $actionsRow.removeClass('selected');
                    }
                } else {
                    $item.find('.repeater-table-check').remove();
                }

                $repeater.trigger('deselected.lark.repeaterList', $item);
            } else {
                if (!isMulti) {
                    repeater.$canvas.find('.repeater-table-check').remove();
                    repeater.$canvas.find('.repeater-table tbody tr.selected').each(function deslectRow () {
                        $(this).removeClass('selected');
                        $repeater.trigger('deselected.lark.repeaterList', $(this));
                    });
                    $item.find('td:first').prepend('<div class="repeater-table-check"><span class="glyphicon glyphicon-ok"></span></div>');
                    $item.addClass('selected');
                    $frozenRow.addClass('selected');
                } else {
                    $checkBox.click();
                    $item.addClass('selected');
                    $frozenRow.addClass('selected');
                    if (isActions) {
                        $actionsRow.addClass('selected');
                    }
                }
                $repeater.trigger('selected.lark.repeaterList', $item);
            }

            toggleActionsHeaderButton.call(repeater);
        }
    };

    var renderRow = function renderRow ($tbody, rows, index) {
        var $row = $('<tr></tr>');

        if (this.options.selectable) {
            $row.data('item_data', rows[index]);

            if (this.options.selectable !== 'action') {
                $row.addClass('selectable');
                $row.attr('tabindex', 0);   // allow items to be tabbed to / focused on

                var repeater = this;
                $row.on('click.lark.repeaterList', function callOnClickRowRepeaterList() {
                    onClickRowRepeaterList.call(this, repeater);
                });

                // allow selection via enter key
                $row.keyup(function onRowKeyup (e) {
                    if (e.keyCode === 13) {
                        // triggering a standard click event to be caught by the row click handler above
                        $row.trigger('click.lark.repeaterList');
                    }
                });
            }
        }

        if (this.options.actions && !this.options.selectable) {
            $row.data('item_data', rows[index]);
        }

        var columns = [];
        for (var i = 0, length = this.columns.length; i < length; i++) {
            columns.push(renderColumn.call(this, $row, rows, index, this.columns, i));
        }

        $tbody.append($row);

        if (this.options.columnRendered) {
            for (var columnIndex = 0, colLength = columns.length; columnIndex < colLength; columnIndex++) {
                if (!(this.columns[columnIndex].property === '@_CHECKBOX_@' || this.columns[columnIndex].property === '@_ACTIONS_@')) {
                    this.options.columnRendered({
                        container: $row,
                        columnAttr: this.columns[columnIndex].property,
                        item: columns[columnIndex],
                        rowData: rows[index]
                    }, function noop () {});
                }
            }
        }

        if (this.options.rowRendered) {
            this.options.rowRendered({
                container: $tbody,
                item: $row,
                rowData: rows[index]
            }, function noop () {});
        }
    };

    var renderTbody = function renderTbody ($table, data) {
        var $tbody = $table.find('tbody');
        var $empty;

        if ($tbody.length < 1) {
            $tbody = $('<tbody data-container="true"></tbody>');
            $table.append($tbody);
        }

        if (typeof data.error === 'string' && data.error.length > 0) {
            $empty = $('<tr class="empty text-danger"><td colspan="' + this.columns.length + '"></td></tr>');
            $empty.find('td').append(data.error);
            $tbody.append($empty);
        } else if (data.items && data.items.length < 1) {
            $empty = $('<tr class="empty"><td colspan="' + this.columns.length + '"></td></tr>');
            $empty.find('td').append(this.options.noItemsHTML);
            $tbody.append($empty);
        }
    };

    var renderThead = function renderThead ($table, data) {
        var columns = data.columns || [];
        var $thead = $table.find('thead');
        var i;
        var length;
        var $tr;

        if (this.firstRender || areDifferentColumns(this.columns, columns) || $thead.length === 0) {
            $thead.remove();

            // noItems is set in `before` method

            if (this.options.selectable === 'multi' && !this.noItems) {
                var checkboxColumn = {
                    label: 'c',
                    property: '@_CHECKBOX_@',
                    sortable: false
                };
                columns.splice(0, 0, checkboxColumn);
            }

            this.columns = columns;
            this.firstRender = false;
            this.repeater.$loader.removeClass('noHeader');

            // keep action column header even when empty, you'll need it later....
            if (this.options.actions) {
                var actionsColumn = {
                    label: this.options.actions.label || '<span class="actions-hidden">a</span>',
                    property: '@_ACTIONS_@',
                    sortable: false,
                    width: this.actions_width
                };
                columns.push(actionsColumn);
            }


            $thead = $('<thead data-preserve="deep"><tr></tr></thead>');
            $tr = $thead.find('tr');
            for (i = 0, length = columns.length; i < length; i++) {
                renderHeader.call(this, $tr, columns, i);
            }
            $table.prepend($thead);

            if (this.options.selectable === 'multi' && !this.noItems) {
                // after checkbox column is created need to get width of checkbox column from
                // its css class
                var checkboxWidth = this.repeater.$element.find('.repeater-table-wrapper .header-checkbox').outerWidth();
                var selectColumn = $.grep(columns, function grepColumn (column) {
                    return column.property === '@_CHECKBOX_@';
                })[0];
                selectColumn.width = checkboxWidth;
            }
            sizeColumns.call(this, $tr);
        }
    };

    var sizeColumns = function sizeColumns ($tr) {
        var automaticallyGeneratedWidths = [];
        var self = this;
        var i;
        var length;
        var newWidth;
        var widthTaken;

        if (this.options.columnSizing) {
            i = 0;
            widthTaken = 0;
            $tr.find('th').each(function eachTH () {
                var $th = $(this);
                var width;
                if (self.columns[i].width !== undefined) {
                    width = self.columns[i].width;
                    $th.outerWidth(width);
                    widthTaken += $th.outerWidth();
                    self.columns[i]._auto_width = width;
                } else {
                    var outerWidth = $th.find('.repeater-table-heading').outerWidth();
                    automaticallyGeneratedWidths.push({
                        col: $th,
                        index: i,
                        minWidth: outerWidth
                    });
                }

                i++;
            });

            length = automaticallyGeneratedWidths.length;
            if (length > 0) {
                var canvasWidth = this.repeater.$canvas.find('.repeater-table-wrapper').outerWidth();
                newWidth = Math.floor((canvasWidth - widthTaken) / length);
                for (i = 0; i < length; i++) {
                    if (automaticallyGeneratedWidths[i].minWidth > newWidth) {
                        newWidth = automaticallyGeneratedWidths[i].minWidth;
                    }
                    automaticallyGeneratedWidths[i].col.outerWidth(newWidth);
                    this.columns[automaticallyGeneratedWidths[i].index]._auto_width = newWidth;
                }
            }
        }
    };

    var specialBrowserClass = function specialBrowserClass () {
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        var firefox = ua.indexOf('Firefox');

        if (msie > 0 ) {
            return 'ie-' + parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        } else if (firefox > 0) {
            return 'firefox';
        }

        return '';
    };

    var toggleActionsHeaderButton = function toggleActionsHeaderButton () {
        var selectedSelector = '.repeater-table-wrapper > table .selected';
        var $actionsColumn = this.repeater.$element.find('.table-actions');
        var $selected;

        if (this.options.selectable === 'action') {
            selectedSelector = '.repeater-table-wrapper > table tr';
        }

        $selected = this.repeater.$canvas.find( selectedSelector );

        if ($selected.length > 0) {
            $actionsColumn.find('thead .btn').removeAttr('disabled');
        } else {
            $actionsColumn.find('thead .btn').attr('disabled', 'disabled');
        }
    };


     views["table"] = {
        name : "table",
        ctor : TableView
    }; 

    return TableView;

});
define('skylark-widgets-repeater/views/TileView',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-query",
    "../views",   
    "./ViewBase"
], function(langx, browser, eventer, noder, geom, $, views, ViewBase) {


  var TileView = ViewBase.inherit({
    klassName : "TileView",

    options: {
        alignment: 'left',
        infiniteScroll: false,
        itemRendered: null,
        noItemsHTML: 'no items found',
        selectable: false,
        template : '<div class="clearfix repeater-tile" data-container="true" data-infinite="true" data-preserve="shallow"></div>',
        item : {
            template: '<div class="thumbnail repeater-thumbnail"><img height="75" src="{{src}}" width="65"><span>{{name}}</span></div>'
        }
    },

    //ADDITIONAL METHODS
    clearSelectedItems : function() {
        this.repeater.$canvas.find('.repeater-tile .selectable.selected').removeClass('selected');
    },

    getSelectedItems : function() {
        var selected = [];
        this.repeater.$canvas.find('.repeater-tile .selectable.selected').each(function() {
            selected.push($(this));
        });
        return selected;
    },

    setSelectedItems : function(items, force) {
        var selectable = this.options.selectable;
        var self = this;
        var i, $item, l, n;

        //this function is necessary because lint yells when a function is in a loop
        function compareItemIndex() {
            if (n === items[i].index) {
                $item = $(this);
                return false;
            } else {
                n++;
            }
        }

        //this function is necessary because lint yells when a function is in a loop
        function compareItemSelector() {
            $item = $(this);
            if ($item.is(items[i].selector)) {
                selectItem($item, items[i].selected);
            }
        }

        function selectItem($itm, select) {
            select = (select !== undefined) ? select : true;
            if (select) {
                if (!force && selectable !== 'multi') {
                    self.thumbnail_clearSelectedItems();
                }

                $itm.addClass('selected');
            } else {
                $itm.removeClass('selected');
            }
        }

        if (!langx.isArray(items)) {
            items = [items];
        }

        if (force === true || selectable === 'multi') {
            l = items.length;
        } else if (selectable) {
            l = (items.length > 0) ? 1 : 0;
        } else {
            l = 0;
        }

        for (i = 0; i < l; i++) {
            if (items[i].index !== undefined) {
                $item = $();
                n = 0;
                this.repeater.$canvas.find('.repeater-tile .selectable').each(compareItemIndex);
                if ($item.length > 0) {
                    selectItem($item, items[i].selected);
                }

            } else if (items[i].selector) {
                this.repeater.$canvas.find('.repeater-tile .selectable').each(compareItemSelector);
            }
        }
    },

    selected: function() {
        var infScroll = this.options.infiniteScroll;
        var opts;
        if (infScroll) {
            opts = (typeof infScroll === 'object') ? infScroll : {};
            this.infiniteScrolling(true, opts);
        }
    },
    before: function(helpers) {
        var alignment = this.options.alignment;
        var $cont = this.repeater.$canvas.find('.repeater-tile');
        var data = helpers.data;
        var response = {};
        var $empty, validAlignments;

        if ($cont.length < 1) {
            $cont = $(this.options.template);
            if (alignment && alignment !== 'none') {
                validAlignments = {
                    'center': 1,
                    'justify': 1,
                    'left': 1,
                    'right': 1
                };
                alignment = (validAlignments[alignment]) ? alignment : 'justify';
                $cont.addClass('align-' + alignment);
                this.thumbnail_injectSpacers = true;
            } else {
                this.thumbnail_injectSpacers = false;
            }
            response.item = $cont;
        } else {
            response.action = 'none';
        }

        if (data.items && data.items.length < 1) {
            $empty = $('<div class="empty"></div>');
            $empty.append(this.options.noItemsHTML);
            $cont.append($empty);
        } else {
            $cont.find('.empty:first').remove();
        }

        return response;
    },
    renderItem: function(helpers) {
        var selectable = this.options.selectable;
        var selected = 'selected';
        var self = this;
        var $thumbnail = this._create$Item(this.options.item.template,helpers.subset[helpers.index]);

        $thumbnail.data('item_data', helpers.data.items[helpers.index]);

        if (selectable) {
            $thumbnail.addClass('selectable');
            $thumbnail.on('click', function() {
                if (self.isDisabled) return;

                if (!$thumbnail.hasClass(selected)) {
                    if (selectable !== 'multi') {
                        self.repeater.$canvas.find('.repeater-tile .selectable.selected').each(function() {
                            var $itm = $(this);
                            $itm.removeClass(selected);
                            self.repeater.$element.trigger('deselected.lark.repeaterThumbnail', $itm);
                        });
                    }

                    $thumbnail.addClass(selected);
                    self.repeater.$element.trigger('selected.lark.repeaterThumbnail', $thumbnail);
                } else {
                    $thumbnail.removeClass(selected);
                    self.repeater.$element.trigger('deselected.lark.repeaterThumbnail', $thumbnail);
                }
            });
        }

        helpers.container.append($thumbnail);
        if (this.thumbnail_injectSpacers) {
            $thumbnail.after('<span class="spacer">&nbsp;</span>');
        }

        if (this.options.itemRendered) {
            this.options.itemRendered({
                container: helpers.container,
                item: $thumbnail,
                itemData: helpers.subset[helpers.index]
            }, function() {});
        }

        return false;
    }
    
  });


    views["tile"] = {
        name : "tile",
        ctor : TileView
    };

    return TileView;
    
});
define('skylark-widgets-repeater/main',[
    "./Repeater",
    "./views",
    "./views/ViewBase",
    "./views/ListView",
    "./views/SliderView",
    "./views/TableView",
    "./views/TileView"
], function(Repeater) {
    return Repeater;
});
define('skylark-widgets-repeater', ['skylark-widgets-repeater/main'], function (main) { return main; });

define('skylark-widgets-uploads/uploads',[
  "skylark-langx/skylark"
],function(skylark){
	return skylark.attach("widgets.updates",{});
});
define('skylark-widgets-uploads/MultiUploader',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-net-http/Upload",
  "skylark-widgets-base/Widget",
  "./uploads"
]  ,function(skylark,langx,$, FileUpload, Widget,uploads){

    var fileListTemplate = '<div class="lark-multiuploader">' + 
        '    <h3 class="popover-title">Upload files</h3>' + 
        '    <div class="popover-content container-fluid" class="file-list file-dropzone file-pastezone">' + 
        '        <div class="no-data"><em>Add files.</em></div>' + 
        '    </div>' + 
        '    <footer>' + 
        '        <button class="btn btn-warning pull-right btn-sm" id="cancel-uploads-button"><i class="icon-cancel"></i>Cancel uploads</button>' + 
        '        <span class="btn btn-success fileinput-button btn-sm" id="fileinput-button">' + 
        '            <i class="icon-plus"></i>' + 
        '            <span>Add files...</span>' + 
        '            <input id="fileupload" type="file" name="files[]" multiple="multiple">' + 
        '        </span>' + 
        '        <button class="btn btn-primary btn-sm" id="start-uploads-button"><i class="icon-start"></i>Start uploads</button>' + 
        '    </footer>' + 
        '</div>',
        fileItemTemplate = '<div class="file-item row">' +
        '   <div class="col-md-6"><span class="name"></span></div>' + 
        '   <div class="col-md-3">' +
        '    <span class="size"></span>' +
        '    <div class="progress hidden">' +
        '        <div class="progress-label"></div>' +
        '        <div class="bar"></div>' +
        '    </div>' +
        '    <span class="message hidden"></span>' +
        '   </div>' +
        '   <div class="col-md-3">' +
        '    <button class="btn btn-warning btn-xs cancel"><i class="icon-remove"></i>Cancel</button>' +
        '    <button class="btn btn-xs clear hidden">Clear</button>' +
        '   </div>' +
        '</div>';

    var MultiUploader =  Widget.inherit({
        klassName : "Uploader",
        pluginName : "lark.multiuploader",

        options: {
            uploadUrl: '/upload',

        	params: {
                formParamName : "file"
            },

    	    maxConnections: 3,
        	// validation
        	allowedExtensions: [],
        	sizeLimit: 0,
        	minSizeLimit: 0,

            autoUpload: false,
            selectors : {
              fileList : ".file-list",
              fileItem : ".file-item",
              nodata : ".file-list .no-data",

              picker   : ".file-picker",
              dropzone : ".file-dropzone",
              pastezone: ".file-pastezone",

              startUploads: '.start-uploads',
              cancelUploads: '.cancel-uploads',
            },

            template : fileListTemplate,

            dataType: 'json',

            fileItem : {
            	selectors : {
                    name : ".name",
                    size : ".size",
                    cancel: ".cancel",
                    clear : ".clear",
                    progress : ".progress",
                    message : ".message"                   
            	},

            	template : fileItemTemplate
            }
        },

        state : {
        },

        _init: function () {
            var self = this;


            // Render current files
            /*
            this.files.forEach(function (file) {
                self.renderFile(file);
            });
            */

            //this._refresh({files:true});
        

            //this._files.on('all', function(){
            //  self._refresh({files:true});
            //});

            this._initEventHandler();
            this._initFileHandlers();
            this._initUpoadHandler();
            this._updateFileList();
        },

        _initFileHandlers : function() {
            var self = this;

            var selectors = this.options.selectors,
            	dzSelector = selectors.dropzone,
            	pzSelector = selectors.pastezone,
            	pkSelector = selectors.picker;

            if (dzSelector) {
				this._velm.$(dzSelector).dropzone({
	                dropped : function (files) {
                        self._addFiles(files);
	                }
				});
            }


            if (pzSelector) {
                this._velm.$(pzSelector).pastezone({
                    pasted : function (files) {
                        self._addFiles(files);
                    }
                });                
            }

            if (pkSelector) {
                this._velm.$(pkSelector).picker({
                    multiple: true,
                    picked : function (files) {
                        self._addFiles(files);
                    }
                });                
            }
        },

        _initUpoadHandler: function(){
            var self = this,
                handlerClass;

            this._handler = new FileUpload({
                url: this.options.uploadUrl,
                maxConnections: this.options.maxConnections,
                onProgress: function(id, fileName, loaded, total){
                    self._onProgress(id, fileName, loaded, total);
                },
                onComplete: function(id, fileName, result){
                    self._onComplete(id, fileName, result);
                },
                onCancel: function(id, fileName){
                    self._onCancel(id, fileName);
                },
                onFailure: function(id,fileName,e){
                    self._onFailure(id,fileName,e);
                }
            });
        },
        
         /**
         * delegate click event for cancel link
         **/
        _initEventHandler: function(){
            var self = this,
               selectors = this.options.selectors,
               itemSelectors = this.options.fileItem.selectors, 
               list = this._listElement;

            // Add cancel handler
            this._velm.$(selectors.fileList).on("click",itemSelectors.cancel,function(e){
                var $fileItem = $(this).closest(selectors.fileItem),
                    fileId = $fileItem.data("fileId");
                self._handler.cancel(fileId);
                $fileItem.remove();
                self._updateFileList();
            });

            // Add clear handler
            this._velm.$(selectors.fileList).on("click",itemSelectors.clear,function(e){
                var $fileItem = $(this).closest(selectors.fileItem),
                    fileId = $fileItem.data("fileId");
                $fileItem.remove();
                self._updateFileList();
            });

            // Add cancel all handler
            this._velm.$(selectors.cancelUploads).click(function(){
                var $files = self._velm.$(selectors.fileList).find(selectors.fileItem);           
                $files.forEach(function(fileItem){
                    var $fileItem = $(fileItem),
                        fileId = $fileItem.data("fileId");
                    self._handler.cancel(fileId);
                    $fileItem.remove();
                });
                self._updateFileList();

            });

            // Add start uploads handler
            this._velm.$(selectors.startUploads).click(function(){
                var $files = self._velm.$(selectors.fileList).find(selectors.fileItem);           
                $files.forEach(function(fileItem){
                    var $fileItem = $(fileItem),
                        fileId = $fileItem.data("fileId");
                    if (!$fileItem.data("status")) {
                        // The file has not yet been sent
                        self._handler.send(fileId,self.options.params);
                    }
                });

            });
            

        },       

        _onProgress: function(id, fileName, loaded, total){          
            var $item = this._getItemByFileId(id);

            var percent = parseInt(loaded / total * 100, 10);
            var progressHTML = this._formatSize(loaded)+' of '+ this._formatSize(total);

            $item.data("status","running");
            $item.find('.progress')
                .find('.bar')
                .css('width', percent+'%')
                .parent()
                .find('.progress-label')
                .html(progressHTML);
            this._updateFile($item);

        },

        _onComplete: function(id, fileName, result){
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","done");
            $item.find('.message').html('<i class="icon-success"></i> ' + (this.doneMsg || 'Uploaded'));
            this._updateFile($item);
        },

        _onFailure : function(id,fileName,e) {
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","error");
            $item.find('.message').html('<i class="icon-error"></i> ');;
            this._updateFile($item)

        },

        _onCancel: function(id, fileName){
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","cancel");
            this._updateFile($item)
        },

        _addToList: function(id, fileName){
            var self = this;


            var fileName = this._handler.getName(id),
                fileSize = this._handler.getSize(id);

            var item = $(this.options.fileItem.template);
            item.data("fileId",id);

            item.find(this.options.fileItem.selectors.name).html(this._formatFileName(fileName));
            item.find(this.options.fileItem.selectors.size).html(this._formatSize(fileSize));

            this._velm.$(this.options.selectors.fileList).append(item);

            this._updateFileList();
        },
    
        _updateFileList : function ()  {
            var selectors = this.options.selectors,
                itemSelectors = this.options.fileItem.selectors,
                files = this._velm.$(selectors.fileList).find(selectors.fileItem);

            var with_files_elements = this._velm.$(selectors.cancelUploads + ',' + selectors.startUploads);
            var without_files_elements = this._velm.$(selectors.nodata);
            if (files.length > 0) {
                with_files_elements.removeClass('hidden');
                without_files_elements.addClass('hidden');
            } else {
                with_files_elements.addClass('hidden');
                without_files_elements.removeClass('hidden');
            }
        },
        
        _updateFile: function ($item) {
            var selectors = this.options.fileItem.selectors,
                when_pending = $item.find(selectors.size + "," + selectors.cancel),
                when_running = $item.find(selectors.progress + "," + selectors.cancel),
                when_done = $item.find(selectors.message + "," + selectors.clear);

            var status = $item.data("status");    
            if (status == "pending") {
                when_running.add(when_done).addClass('hidden');
                when_pending.removeClass('hidden');
            } else if (status == "running") {
                when_pending.add(when_done).addClass('hidden');
                when_running.removeClass('hidden');
            } else if (status == "done" || status == "error") {
                when_pending.add(when_running).addClass('hidden');
                when_done.removeClass('hidden');
            }
        },

        _getItemByFileId: function(id){
            var selectors = this.options.selectors,
                files = this._velm.$(selectors.fileList).find(selectors.fileItem),
                item;

            // there can't be txt nodes in dynamically created list
            // and we can  use nextSibling

            for (var i = 0; i<files.length;i++){
                var item2 = files[i];
                if ($(item2).data("fileId") == id) {
                    item = item2;
                    break;
                }
            }
            if (item) {
                return $(item);
            }
        },


            
        _addFiles: function(files){
            for (var i=0; i<files.length; i++){
                if ( !this._validateFile(files[i])){
                    return;
                }
            }

            for (var i=0; i<files.length; i++){
                this._addFile(files[i]);
            }
        },

        _addFile: function(file){
            var id = this._handler.add(file);

            this._filesInProgress++;
            this._addToList(id);

            //this._handler.upload(id, this.options.params);
        },

        _validateFile: function(file){
            var name, size;

            if (file.value){
                // it is a file input
                // get input value and remove path to normalize
                name = file.value.replace(/.*(\/|\\)/, "");
            } else {
                // fix missing properties in Safari
                name = file.fileName != null ? file.fileName : file.name;
                size = file.fileSize != null ? file.fileSize : file.size;
            }

            if (! this._isAllowedExtension(name)){
                this._error('typeError', name);
                return false;

            } else if (size === 0){
                this._error('emptyError', name);
                return false;

            } else if (size && this.options.sizeLimit && size > this.options.sizeLimit){
                this._error('sizeError', name);
                return false;

            } else if (size && size < this.options.minSizeLimit){
                this._error('minSizeError', name);
                return false;
            }

            return true;
        },

        _error: function(code, fileName){
            var message = this.options.messages[code];
            function r(name, replacement){ message = message.replace(name, replacement); }

            r('{file}', this._formatFileName(fileName));
            r('{extensions}', this.options.allowedExtensions.join(', '));
            r('{sizeLimit}', this._formatSize(this.options.sizeLimit));
            r('{minSizeLimit}', this._formatSize(this.options.minSizeLimit));

            this.options.showMessage(message);
        },

        _formatFileName: function(name){
            if (name.length > 33){
                name = name.slice(0, 19) + '...' + name.slice(-13);
            }
            return name;
        },

        _isAllowedExtension: function(fileName){
            var ext = (-1 !== fileName.indexOf('.')) ? fileName.replace(/.*[.]/, '').toLowerCase() : '';
            var allowed = this.options.allowedExtensions;

            if (!allowed.length){return true;}

            for (var i=0; i<allowed.length; i++){
                if (allowed[i].toLowerCase() == ext){ return true;}
            }

            return false;
        },

        _formatSize: function(bytes){
            var i = -1;
            do {
                bytes = bytes / 1024;
                i++;
            } while (bytes > 99);

            return Math.max(bytes, 0.1).toFixed(1) + ['KB', 'MB', 'GB', 'TB', 'PB', 'EB'][i];
        }

    });


	return uploads.MultiUploader = MultiUploader;
});
define('skylark-widgets-uploads/main',[
	"./uploads",
	"./MultiUploader"
],function(uploads){
	return uploads;
});
define('skylark-widgets-uploads', ['skylark-widgets-uploads/main'], function (main) { return main; });

define('skylark-domx-contents/contents',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data"
], function(skylark, langx, noder,datax) {
    "use strict";

    var contents = function() {
        return contents;
    };


    return skylark.attach("domx.contents",contents);

});
define('skylark-domx-contents/Hotkeys',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 


  var Hotkeys = langx.Evented.inherit({

  });


  Hotkeys.count = 0;

  Hotkeys.keyNameMap = {
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Spacebar",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    45: "Insert",
    46: "Del",
    91: "Meta",
    93: "Meta",
    48: "0",
    49: "1",
    50: "2",
    51: "3",
    52: "4",
    53: "5",
    54: "6",
    55: "7",
    56: "8",
    57: "9",
    65: "A",
    66: "B",
    67: "C",
    68: "D",
    69: "E",
    70: "F",
    71: "G",
    72: "H",
    73: "I",
    74: "J",
    75: "K",
    76: "L",
    77: "M",
    78: "N",
    79: "O",
    80: "P",
    81: "Q",
    82: "R",
    83: "S",
    84: "T",
    85: "U",
    86: "V",
    87: "W",
    88: "X",
    89: "Y",
    90: "Z",
    96: "0",
    97: "1",
    98: "2",
    99: "3",
    100: "4",
    101: "5",
    102: "6",
    103: "7",
    104: "8",
    105: "9",
    106: "Multiply",
    107: "Add",
    109: "Subtract",
    110: "Decimal",
    111: "Divide",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    124: "F13",
    125: "F14",
    126: "F15",
    127: "F16",
    128: "F17",
    129: "F18",
    130: "F19",
    131: "F20",
    132: "F21",
    133: "F22",
    134: "F23",
    135: "F24",
    59: ";",
    61: "=",
    186: ";",
    187: "=",
    188: ",",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };

  Hotkeys.aliases = {
    "escape": "esc",
    "delete": "del",
    "return": "enter",
    "ctrl": "control",
    "space": "spacebar",
    "ins": "insert",
    "cmd": "meta",
    "command": "meta",
    "wins": "meta",
    "windows": "meta"
  };

  Hotkeys.normalize = function(shortcut) {
    var i, j, key, keyname, keys, len;
    keys = shortcut.toLowerCase().replace(/\s+/gi, "").split("+");
    for (i = j = 0, len = keys.length; j < len; i = ++j) {
      key = keys[i];
      keys[i] = this.aliases[key] || key;
    }
    keyname = keys.pop();
    keys.sort().push(keyname);
    return keys.join("_");
  };

  Hotkeys.prototype.opts = {
    el: document
  };

  Hotkeys.prototype.init = function() {
    this.id = ++this.constructor.count;
    this._map = {};
    this._delegate = typeof this.opts.el === "string" ? document : this.opts.el;
    $(this._delegate).on("keydown.simple-hotkeys-" + this.id, this.opts.el, (function(_this) {
      return function(e) {
        var ref;
        return (ref = _this._getHander(e)) != null ? ref.call(_this, e) : void 0;
      };
    })(this));
  };

  Hotkeys.prototype._getHander = function(e) {
    var keyname, shortcut;
    if (!(keyname = this.constructor.keyNameMap[e.which])) {
      return;
    }
    shortcut = "";
    if (e.altKey) {
      shortcut += "alt_";
    }
    if (e.ctrlKey) {
      shortcut += "control_";
    }
    if (e.metaKey) {
      shortcut += "meta_";
    }
    if (e.shiftKey) {
      shortcut += "shift_";
    }
    shortcut += keyname.toLowerCase();
    return this._map[shortcut];
  };

  Hotkeys.prototype.respondTo = function(subject) {
    if (typeof subject === 'string') {
      return this._map[this.constructor.normalize(subject)] != null;
    } else {
      return this._getHander(subject) != null;
    }
  };

  Hotkeys.prototype.add = function(shortcut, handler) {
    this._map[this.constructor.normalize(shortcut)] = handler;
    return this;
  };

  Hotkeys.prototype.remove = function(shortcut) {
    delete this._map[this.constructor.normalize(shortcut)];
    return this;
  };

  Hotkeys.prototype.destroy = function() {
    $(this._delegate).off(".simple-hotkeys-" + this.id);
    this._map = {};
    return this;
  };

  return  contents.Hotkeys = Hotkeys;

});


define('skylark-domx-contents/Util',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 

  var Util = langx.Evented.inherit({
    init : function(editor,opts) {
      this.editor = editor; // this._module;
      this.opts = langx.extend({}, this.opts, opts);
      if (this.browser.msie && this.browser.version < 11) {
        return this.phBr = '';
      }
    }

  });

  Util.pluginName = 'Util';

  Util.prototype.phBr = '<br/>';

  Util.prototype.os = (function() {
    var os;
    os = {};
    if (/Mac/.test(navigator.appVersion)) {
      os.mac = true;
    } else if (/Linux/.test(navigator.appVersion)) {
      os.linux = true;
    } else if (/Win/.test(navigator.appVersion)) {
      os.win = true;
    } else if (/X11/.test(navigator.appVersion)) {
      os.unix = true;
    }
    if (/Mobi/.test(navigator.appVersion)) {
      os.mobile = true;
    }
    return os;
  })();

  Util.prototype.browser = (function() {
    var chrome, edge, firefox, ie, ref, ref1, ref2, ref3, ref4, safari, ua;
    ua = navigator.userAgent;
    ie = /(msie|trident)/i.test(ua);
    chrome = /chrome|crios/i.test(ua);
    safari = /safari/i.test(ua) && !chrome;
    firefox = /firefox/i.test(ua);
    edge = /edge/i.test(ua);
    if (ie) {
      return {
        msie: true,
        version: ((ref = ua.match(/(msie |rv:)(\d+(\.\d+)?)/i)) != null ? ref[2] : void 0) * 1
      };
    } else if (edge) {
      return {
        edge: true,
        webkit: true,
        version: ((ref1 = ua.match(/edge\/(\d+(\.\d+)?)/i)) != null ? ref1[1] : void 0) * 1
      };
    } else if (chrome) {
      return {
        webkit: true,
        chrome: true,
        version: ((ref2 = ua.match(/(?:chrome|crios)\/(\d+(\.\d+)?)/i)) != null ? ref2[1] : void 0) * 1
      };
    } else if (safari) {
      return {
        webkit: true,
        safari: true,
        version: ((ref3 = ua.match(/version\/(\d+(\.\d+)?)/i)) != null ? ref3[1] : void 0) * 1
      };
    } else if (firefox) {
      return {
        mozilla: true,
        firefox: true,
        version: ((ref4 = ua.match(/firefox\/(\d+(\.\d+)?)/i)) != null ? ref4[1] : void 0) * 1
      };
    } else {
      return {};
    }
  })();

  Util.prototype.support = (function() {
    return {
      onselectionchange: (function() {
        var e, onselectionchange;
        onselectionchange = document.onselectionchange;
        if (onselectionchange !== void 0) {
          try {
            document.onselectionchange = 0;
            return document.onselectionchange === null;
          } catch (_error) {
            e = _error;
          } finally {
            document.onselectionchange = onselectionchange;
          }
        }
        return false;
      })(),
      oninput: (function() {
        return !/(msie|trident)/i.test(navigator.userAgent);
      })()
    };
  })();

  Util.prototype.reflow = function(el) {
    if (el == null) {
      el = document;
    }
    return $(el)[0].offsetHeight;
  };

  Util.prototype.metaKey = function(e) {
    var isMac;
    isMac = /Mac/.test(navigator.userAgent);
    if (isMac) {
      return e.metaKey;
    } else {
      return e.ctrlKey;
    }
  };

  Util.prototype.isEmptyNode = function(node) {
    var $node;
    $node = $(node);
    return $node.is(':empty') || (!$node.text() && !$node.find(':not(br, span, div)').length);
  };

  Util.prototype.isDecoratedNode = function(node) {
    return $(node).is('[class^="' + this.opts.classPrefix + '"]');
  };

  Util.prototype.blockNodes = ["div", "p", "ul", "ol", "li", "blockquote", "hr", "pre", "h1", "h2", "h3", "h4", "h5", "table"];

  Util.prototype.isBlockNode = function(node) {
    node = $(node)[0];
    if (!node || node.nodeType === 3) {
      return false;
    }
    return new RegExp("^(" + (this.blockNodes.join('|')) + ")$").test(node.nodeName.toLowerCase());
  };

  Util.prototype.getNodeLength = function(node) {
    node = $(node)[0];
    switch (node.nodeType) {
      case 7:
      case 10:
        return 0;
      case 3:
      case 8:
        return node.length;
      default:
        return node.childNodes.length;
    }
  };

  Util.prototype.dataURLtoBlob = function(dataURL) {
    var BlobBuilder, arrayBuffer, bb, blobArray, byteString, hasArrayBufferViewSupport, hasBlobConstructor, i, intArray, k, mimeString, ref, supportBlob;
    hasBlobConstructor = window.Blob && (function() {
      var e;
      try {
        return Boolean(new Blob());
      } catch (_error) {
        e = _error;
        return false;
      }
    })();
    hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array && (function() {
      var e;
      try {
        return new Blob([new Uint8Array(100)]).size === 100;
      } catch (_error) {
        e = _error;
        return false;
      }
    })();
    BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
    supportBlob = hasBlobConstructor || BlobBuilder;
    if (!(supportBlob && window.atob && window.ArrayBuffer && window.Uint8Array)) {
      return false;
    }
    if (dataURL.split(',')[0].indexOf('base64') >= 0) {
      byteString = atob(dataURL.split(',')[1]);
    } else {
      byteString = decodeURIComponent(dataURL.split(',')[1]);
    }
    arrayBuffer = new ArrayBuffer(byteString.length);
    intArray = new Uint8Array(arrayBuffer);
    for (i = k = 0, ref = byteString.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      intArray[i] = byteString.charCodeAt(i);
    }
    mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
    if (hasBlobConstructor) {
      blobArray = hasArrayBufferViewSupport ? intArray : arrayBuffer;
      return new Blob([blobArray], {
        type: mimeString
      });
    }
    bb = new BlobBuilder();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeString);
  };

  Util.prototype.throttle = function(func, wait) {
    var args, call, ctx, last, rtn, throttled, timeoutID;
    last = 0;
    timeoutID = 0;
    ctx = args = rtn = null;
    call = function() {
      timeoutID = 0;
      last = +new Date();
      rtn = func.apply(ctx, args);
      ctx = null;
      return args = null;
    };
    throttled = function() {
      var delta;
      ctx = this;
      args = arguments;
      delta = new Date() - last;
      if (!timeoutID) {
        if (delta >= wait) {
          call();
        } else {
          timeoutID = setTimeout(call, wait - delta);
        }
      }
      return rtn;
    };
    throttled.clear = function() {
      if (!timeoutID) {
        return;
      }
      clearTimeout(timeoutID);
      return call();
    };
    return throttled;
  };

  Util.prototype.formatHTML = function(html) {
    var cursor, indentString, lastMatch, level, match, re, repeatString, result, str;
    re = /<(\/?)(.+?)(\/?)>/g;
    result = '';
    level = 0;
    lastMatch = null;
    indentString = '  ';
    repeatString = function(str, n) {
      return new Array(n + 1).join(str);
    };
    while ((match = re.exec(html)) !== null) {
      match.isBlockNode = langx.inArray(match[2], this.blockNodes) > -1;
      match.isStartTag = match[1] !== '/' && match[3] !== '/';
      match.isEndTag = match[1] === '/' || match[3] === '/';
      cursor = lastMatch ? lastMatch.index + lastMatch[0].length : 0;
      if ((str = html.substring(cursor, match.index)).length > 0 && langx.trim(str)) {
        result += str;
      }
      if (match.isBlockNode && match.isEndTag && !match.isStartTag) {
        level -= 1;
      }
      if (match.isBlockNode && match.isStartTag) {
        if (!(lastMatch && lastMatch.isBlockNode && lastMatch.isEndTag)) {
          result += '\n';
        }
        result += repeatString(indentString, level);
      }
      result += match[0];
      if (match.isBlockNode && match.isEndTag) {
        result += '\n';
      }
      if (match.isBlockNode && match.isStartTag) {
        level += 1;
      }
      lastMatch = match;
    }
    return langx.trim(result);
  };

  return contents.Util = Util;
});
define('skylark-domx-contents/InputManager',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 
 

  var indexOf = [].indexOf ;

  var InputManager = langx.Evented.inherit({
    init : function(editable,opts) {
      this.editable = editable;
      this.opts = langx.extend({}, this.opts, opts);

      var selectAllKey, submitKey;
      this.throttledValueChanged = this.editable.util.throttle((function(_this) {
        return function(params) {
          return setTimeout(function() {
            return _this.editable.trigger('valuechanged', params);
          }, 10);
        };
      })(this), 300);
      this.throttledSelectionChanged = this.editable.util.throttle((function(_this) {
        return function() {
          return _this.editable.trigger('selectionchanged');
        };
      })(this), 50);
      $(document).on('selectionchange.simditor' + this.editable.id, (function(_this) {
        return function(e) {
          var triggerEvent;
          if (!(_this.focused && !_this.editable.clipboard.pasting)) {
            return;
          }
          triggerEvent = function() {
            if (_this._selectionTimer) {
              clearTimeout(_this._selectionTimer);
              _this._selectionTimer = null;
            }
            if (_this.editable.selection._selection.rangeCount > 0) {
              return _this.throttledSelectionChanged();
            } else {
              return _this._selectionTimer = setTimeout(function() {
                _this._selectionTimer = null;
                if (_this.focused) {
                  return triggerEvent();
                }
              }, 10);
            }
          };
          return triggerEvent();
        };
      })(this));
      this.editable.on('valuechanged', (function(_this) {
        return function() {
          var $rootBlocks;
          _this.lastCaretPosition = null;
          $rootBlocks = _this.editable.body.children().filter(function(i, node) {
            return _this.editable.util.isBlockNode(node);
          });
          if (_this.focused && $rootBlocks.length === 0) {
            _this.editable.selection.save();
            _this.editable.formatter.format();
            _this.editable.selection.restore();
          }
          _this.editable.body.find('hr, pre, .' + _this.opts.classPrefix + 'table').each(function(i, el) {
            var $el, formatted;
            $el = $(el);
            if ($el.parent().is('blockquote') || $el.parent()[0] === _this.editable.body[0]) {
              formatted = false;
              if ($el.next().length === 0) {
                $('<p/>').append(_this.editable.util.phBr).insertAfter($el);
                formatted = true;
              }
              if ($el.prev().length === 0) {
                $('<p/>').append(_this.editable.util.phBr).insertBefore($el);
                formatted = true;
              }
              if (formatted) {
                return _this.throttledValueChanged();
              }
            }
          });
          _this.editable.body.find('pre:empty').append(_this.editable.util.phBr);
          if (!_this.editable.util.support.onselectionchange && _this.focused) {
            return _this.throttledSelectionChanged();
          }
        };
      })(this));
      this.editable.body.on('keydown', langx.proxy(this._onKeyDown, this)).on('keypress', langx.proxy(this._onKeyPress, this)).on('keyup', langx.proxy(this._onKeyUp, this)).on('mouseup', langx.proxy(this._onMouseUp, this)).on('focus', langx.proxy(this._onFocus, this)).on('blur', langx.proxy(this._onBlur, this)).on('drop', langx.proxy(this._onDrop, this)).on('input', langx.proxy(this._onInput, this));
      if (this.editable.util.browser.firefox) {
        this.editable.hotkeys.add('cmd+left', (function(_this) {
          return function(e) {
            e.preventDefault();
            _this.editable.selection._selection.modify('move', 'backward', 'lineboundary');
            return false;
          };
        })(this));
        this.editable.hotkeys.add('cmd+right', (function(_this) {
          return function(e) {
            e.preventDefault();
            _this.editable.selection._selection.modify('move', 'forward', 'lineboundary');
            return false;
          };
        })(this));
        selectAllKey = this.editable.util.os.mac ? 'cmd+a' : 'ctrl+a';
        this.editable.hotkeys.add(selectAllKey, (function(_this) {
          return function(e) {
            var $children, firstBlock, lastBlock, range;
            $children = _this.editable.body.children();
            if (!($children.length > 0)) {
              return;
            }
            firstBlock = $children.first().get(0);
            lastBlock = $children.last().get(0);
            range = document.createRange();
            range.setStart(firstBlock, 0);
            range.setEnd(lastBlock, _this.editable.util.getNodeLength(lastBlock));
            _this.editable.selection.range(range);
            return false;
          };
        })(this));
      }
      submitKey = this.editable.util.os.mac ? 'cmd+enter' : 'ctrl+enter';
      this.editable.hotkeys.add(submitKey, (function(_this) {
        return function(e) {
          _this.editable.$el.closest('form').find('button:submit').click();
          return false;
        };
      })(this));
    }

  });

  InputManager.pluginName = 'InputManager';

  InputManager.prototype._modifierKeys = [16, 17, 18, 91, 93, 224];

  InputManager.prototype._arrowKeys = [37, 38, 39, 40];


  InputManager.prototype._onFocus = function(e) {
    if (this.editable.clipboard.pasting) {
      return;
    }
    this.editable.$el.addClass('focus').removeClass('error');
    this.focused = true;
    return setTimeout((function(_this) {
      return function() {
        var $blockEl, range;
        range = _this.editable.selection._selection.getRangeAt(0);
        if (range.startContainer === _this.editable.body[0]) {
          if (_this.lastCaretPosition) {
            _this.editable.undoManager.caretPosition(_this.lastCaretPosition);
          } else {
            $blockEl = _this.editable.body.children().first();
            range = document.createRange();
            _this.editable.selection.setRangeAtStartOf($blockEl, range);
            console.log("aaaaaa");
          }
        }
        _this.lastCaretPosition = null;
        _this.editable.trigger('focus');
        if (!_this.editable.util.support.onselectionchange) {
          return _this.throttledSelectionChanged();
        }
      };
    })(this), 0);
  };

  InputManager.prototype._onBlur = function(e) {
    var ref;
    if (this.editable.clipboard.pasting) {
      return;
    }
    this.editable.$el.removeClass('focus');
    this.editable.sync();
    this.focused = false;
    this.lastCaretPosition = (ref = this.editable.undoManager.currentState()) != null ? ref.caret : void 0;
    return this.editable.trigger('blur');
  };

  InputManager.prototype._onMouseUp = function(e) {
    if (!this.editable.util.support.onselectionchange) {
      return this.throttledSelectionChanged();
    }
  };

  InputManager.prototype._onKeyDown = function(e) {
    var ref, ref1;
    if (this.editable.trigger(e) === false) {
      return false;
    }
    if (this.editable.hotkeys.respondTo(e)) {
      return;
    }
    if (this.editable.keystroke.respondTo(e)) {
      this.throttledValueChanged();
      return false;
    }
    if ((ref = e.which, indexOf.call(this._modifierKeys, ref) >= 0) || (ref1 = e.which, indexOf.call(this._arrowKeys, ref1) >= 0)) {
      return;
    }
    if (this.editable.util.metaKey(e) && e.which === 86) {
      return;
    }
    if (!this.editable.util.support.oninput) {
      this.throttledValueChanged(['typing']);
    }
    return null;
  };

  InputManager.prototype._onKeyPress = function(e) {
    if (this.editable.trigger(e) === false) {
      return false;
    }
  };

  InputManager.prototype._onKeyUp = function(e) {
    var p, ref;
    if (this.editable.trigger(e) === false) {
      return false;
    }
    if (!this.editable.util.support.onselectionchange && (ref = e.which, indexOf.call(this._arrowKeys, ref) >= 0)) {
      this.throttledValueChanged();
      return;
    }
    if ((e.which === 8 || e.which === 46) && this.editable.util.isEmptyNode(this.editable.body)) {
      this.editable.body.empty();
      p = $('<p/>').append(this.editable.util.phBr).appendTo(this.editable.body);
      this.editable.selection.setRangeAtStartOf(p);
    }
  };

  InputManager.prototype._onDrop = function(e) {
    if (this.editable.trigger(e) === false) {
      return false;
    }
    return this.throttledValueChanged();
  };

  InputManager.prototype._onInput = function(e) {
    return this.throttledValueChanged(['oninput']);
  };

  return contents.InputManager = InputManager;

});

define('skylark-domx-contents/Selection',[
  "skylark-langx/langx",
  "skylark-domx-noder",
  "skylark-domx-query",
  "./contents"
],function(langx,noder,$,contents){ 

  var Selection = langx.Evented.inherit({
    _range : null,

    _startNodes : null,

    _endNodes : null,

    _containerNode : null,

    _nodes : null,

    _blockNodes : null,

    _rootNodes : null,

    init : function(editable,opts) {
      var self = this;
      this.editable = editable; //this._module;
      this.opts = langx.extend({}, this.opts, opts);
      this._selection = document.getSelection();

      this.editable.on('selectionchanged', function(e) {
        console.log("selectionchanged");
        self.reset();
        return self._range = self._selection.getRangeAt(0);
      });

      this.editable.on('blur', function(e) {
        return self.reset();
      });

      this.editable.on('focus', function(e) {
        self.reset();
        return self._range = self._selection.getRangeAt(0);
      });
    },

    reset : function() {
      this._range = null;
      this._startNodes = null;
      this._endNodes = null;
      this._containerNode = null;
      this._nodes = null;
      this._blockNodes = null;

      return this._rootNodes = null;
    },

    clear : function() {
      var e;
      try {
        this._selection.removeAllRanges();
        console.log("clear");
      } catch (_error) {
        e = _error;
      }
      return this.reset();
    },

    range : function(range) {
      var ffOrIE;
      if (range) {
        this.clear();
        this._selection.addRange(range);
        this._range = range;
 //       ffOrIE = this.editable.util.browser.firefox || this.editable.util.browser.msie;
        ffOrIE = langx.hoster.browser.mozilla || langx.hoster.browser.msie;
        if (!this.editable.inputManager.focused && ffOrIE) {
          this.editable.body.focus();
        }
      } else if (!this._range && this.editable.inputManager.focused && this._selection.rangeCount) {
        this._range = this._selection.getRangeAt(0);
      }
      return this._range;
    },

    startNodes : function() {
      if (this._range) {
        if (!this._startNodes) {
          this._startNodes = (function(self) {
            return function() {
              var startNodes;
              startNodes = $(self._range.startContainer).parentsUntil(self.editable.body).get();
              startNodes.unshift(self._range.startContainer);
              return $(startNodes);
            };
          })(this)();
        } 

      }
      return this._startNodes;
    },

    endNodes : function() {
      var endNodes;
      if (this._range) {
        this._endNodes || (this._endNodes = this._range.collapsed ? this.startNodes() : (endNodes = $(this._range.endContainer).parentsUntil(this.editable.body).get(), endNodes.unshift(this._range.endContainer), $(endNodes)));
      }
      return this._endNodes;
    },

    containerNode : function() {
      if (this._range) {
        this._containerNode || (this._containerNode = $(this._range.commonAncestorContainer));
      }
      return this._containerNode;
    },

    nodes : function() {
      if (this._range) {
        this._nodes || (this._nodes = (function(self) {
          return function() {
            var nodes;
            nodes = [];
            if (self.startNodes().first().is(self.endNodes().first())) {
              nodes = self.startNodes().get();
            } else {
              self.startNodes().each(function(i, node) {
                var $endNode, $node, $nodes, endIndex, index, sharedIndex, startIndex;
                $node = $(node);
                if (self.endNodes().index($node) > -1) {
                  return nodes.push(node);
                } else if ($node.parent().is(self.editable.body) || (sharedIndex = self.endNodes().index($node.parent())) > -1) {
                  if (sharedIndex && sharedIndex > -1) {
                    $endNode = self.endNodes().eq(sharedIndex - 1);
                  } else {
                    $endNode = self.endNodes().last();
                  }
                  $nodes = $node.parent().contents();
                  startIndex = $nodes.index($node);
                  endIndex = $nodes.index($endNode);
                  return langx.merge(nodes, $nodes.slice(startIndex, endIndex).get());
                } else {
                  $nodes = $node.parent().contents();
                  index = $nodes.index($node);
                  return langx.merge(nodes, $nodes.slice(index).get());
                }
              });
              self.endNodes().each(function(i, node) {
                var $node, $nodes, index;
                $node = $(node);
                if ($node.parent().is(self.editable.body) || self.startNodes().index($node.parent()) > -1) {
                  nodes.push(node);
                  return false;
                } else {
                  $nodes = $node.parent().contents();
                  index = $nodes.index($node);
                  return langx.merge(nodes, $nodes.slice(0, index + 1));
                }
              });
            }
            return $(langx.uniq(nodes));
          };
        })(this)());
      }
      return this._nodes;
    },

    blockNodes : function() {
      if (!this._range) {
        return;
      }

      this._blockNodes || (this._blockNodes = (function(self) {
        return function() {
          return self.nodes().filter(function(i, node) {
            return self.editable.util.isBlockNode(node);
          });
        };
      })(this)());

      return this._blockNodes;
    },

    rootNodes : function() {
      if (!this._range) {
        return;
      }
      this._rootNodes || (this._rootNodes = (function(self) {
        return function() {
          return self.nodes().filter(function(i, node) {
            var $parent;
            $parent = $(node).parent();
            return $parent.is(self.editable.body) || $parent.is('blockquote');
          });
        };
      })(this)());

      return this._rootNodes;
    },

    rangeAtEndOf : function(node, range) {
      var afterLastNode, beforeLastNode, endNode, endNodeLength, lastNodeIsBr, result;
      if (range == null) {
        range = this.range();
      }
      if (!(range && range.collapsed)) {
        return;
      }
      node = $(node)[0];
      endNode = range.endContainer;
      endNodeLength = this.editable.util.getNodeLength(endNode);
      beforeLastNode = range.endOffset === endNodeLength - 1;
      lastNodeIsBr = $(endNode).contents().last().is('br');
      afterLastNode = range.endOffset === endNodeLength;
      if (!((beforeLastNode && lastNodeIsBr) || afterLastNode)) {
        return false;
      }
      if (node === endNode) {
        return true;
      } else if (!noder.contains(node, endNode)) {
        return false;
      }
      result = true;
      $(endNode).parentsUntil(node).addBack().each(function(i, n) {
        var $lastChild, beforeLastbr, isLastNode, nodes;
        nodes = $(n).parent().contents().filter(function() {
          return !(this !== n && this.nodeType === 3 && !this.nodeValue);
        });
        $lastChild = nodes.last();
        isLastNode = $lastChild.get(0) === n;
        beforeLastbr = $lastChild.is('br') && $lastChild.prev().get(0) === n;
        if (!(isLastNode || beforeLastbr)) {
          result = false;
          return false;
        }
      });
      return result;
    },

    rangeAtStartOf : function(node, range) {
      var result, startNode;
      if (range == null) {
        range = this.range();
      }
      if (!(range && range.collapsed)) {
        return;
      }
      node = $(node)[0];
      startNode = range.startContainer;
      if (range.startOffset !== 0) {
        return false;
      }
      if (node === startNode) {
        return true;
      } else if (!noder.contains(node, startNode)) {
        return false;
      }
      result = true;
      $(startNode).parentsUntil(node).addBack().each(function(i, n) {
        var nodes;
        nodes = $(n).parent().contents().filter(function() {
          return !(this !== n && this.nodeType === 3 && !this.nodeValue);
        });
        if (nodes.first().get(0) !== n) {
          return result = false;
        }
      });
      return result;
    },

    insertNode : function(node, range) {
      if (range == null) {
        range = this.range();
      }
      if (!range) {
        return;
      }
      node = $(node)[0];
      range.insertNode(node);
      return this.setRangeAfter(node, range);
    },

    setRangeAfter : function(node, range) {
      if (range == null) {
        range = this.range();
      }
      if (range == null) {
        return;
      }
      node = $(node)[0];
      range.setEndAfter(node);
      range.collapse(false);
      return this.range(range);
    },

    setRangeBefore : function(node, range) {
      if (range == null) {
        range = this.range();
      }
      if (range == null) {
        return;
      }
      node = $(node)[0];
      range.setEndBefore(node);
      range.collapse(false);
      return this.range(range);
    },

    setRangeAtStartOf : function(node, range) {
      if (range == null) {
        range = this.range();
      }
      node = $(node).get(0);
      range.setEnd(node, 0);
      range.collapse(false);
      return this.range(range);
    },

    setRangeAtEndOf : function(node, range) {
      var $lastNode, $node, contents, lastChild, lastChildLength, lastText, nodeLength;
      if (range == null) {
        range = this.range();
      }
      $node = $(node);
      node = $node[0];
      if (!node) {
        return;
      }
      if ($node.is('pre')) {
        contents = $node.contents();
        if (contents.length > 0) {
          lastChild = contents.last();
          lastText = lastChild.text();
          lastChildLength = this.editable.util.getNodeLength(lastChild[0]);
          if (lastText.charAt(lastText.length - 1) === '\n') {
            range.setEnd(lastChild[0], lastChildLength - 1);
          } else {
            range.setEnd(lastChild[0], lastChildLength);
          }
        } else {
          range.setEnd(node, 0);
        }
      } else {
        nodeLength = this.editable.util.getNodeLength(node);
        if (node.nodeType !== 3 && nodeLength > 0) {
          $lastNode = $(node).contents().last();
          if ($lastNode.is('br')) {
            nodeLength -= 1;
          } else if ($lastNode[0].nodeType !== 3 && this.editable.util.isEmptyNode($lastNode)) {
            $lastNode.append(this.editable.util.phBr);
            node = $lastNode[0];
            nodeLength = 0;
          }
        }
        range.setEnd(node, nodeLength);
      }
      range.collapse(false);
      return this.range(range);
    },

    deleteRangeContents : function(range) {
      var atEndOfBody, atStartOfBody, endRange, startRange;
      if (range == null) {
        range = this.range();
      }
      startRange = range.cloneRange();
      endRange = range.cloneRange();
      startRange.collapse(true);
      endRange.collapse(false);
      atStartOfBody = this.rangeAtStartOf(this.editable.body, startRange);
      atEndOfBody = this.rangeAtEndOf(this.editable.body, endRange);
      if (!range.collapsed && atStartOfBody && atEndOfBody) {
        this.editable.body.empty();
        range.setStart(this.editable.body[0], 0);
        range.collapse(true);
        this.range(range);
      } else {
        range.deleteContents();
      }
      return range;
    },

    breakBlockEl : function(el, range) {
      var $el;
      if (range == null) {
        range = this.range();
      }
      $el = $(el);
      if (!range.collapsed) {
        return $el;
      }
      range.setStartBefore($el.get(0));
      if (range.collapsed) {
        return $el;
      }
      return $el.before(range.extractContents());
    },

    save : function(range) {
      var endCaret, endRange, startCaret;
      if (range == null) {
        range = this.range();
      }
      if (this._selectionSaved) {
        return;
      }
      endRange = range.cloneRange();
      endRange.collapse(false);
      startCaret = $('<span/>').addClass(this.opts.classPrefix +'caret-start');
      endCaret = $('<span/>').addClass(this.opts.classPrefix +'caret-end');
      endRange.insertNode(endCaret[0]);
      range.insertNode(startCaret[0]);
      this.clear();
      return this._selectionSaved = true;
    },

    restore : function() {
      var endCaret, endContainer, endOffset, range, startCaret, startContainer, startOffset;
      if (!this._selectionSaved) {
        return false;
      }
      startCaret = this.editable.body.find('.' + this.opts.classPrefix +'caret-start');
      endCaret = this.editable.body.find('.' + this.opts.classPrefix +'caret-end');
      if (startCaret.length && endCaret.length) {
        startContainer = startCaret.parent();
        startOffset = startContainer.contents().index(startCaret);
        endContainer = endCaret.parent();
        endOffset = endContainer.contents().index(endCaret);
        if (startContainer[0] === endContainer[0]) {
          endOffset -= 1;
        }
        range = document.createRange();
        range.setStart(startContainer.get(0), startOffset);
        range.setEnd(endContainer.get(0), endOffset);
        startCaret.remove();
        endCaret.remove();
        this.range(range);
      } else {
        startCaret.remove();
        endCaret.remove();
      }
      this._selectionSaved = false;
      return range;
    },
  });

  Selection.pluginName = 'Selection';


  return contents.Selection = Selection;

});
define('skylark-domx-contents/UndoManager',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 

  var UndoManager = langx.Evented.inherit({
    init : function(editable,opts) {
      this.editable = editable;
      this.opts = langx.extend({}, this.opts, opts);

      var redoShortcut, undoShortcut;
      this._stack = [];
      if (this.editable.util.os.mac) {
        undoShortcut = 'cmd+z';
        redoShortcut = 'shift+cmd+z';
      } else if (this.editable.util.os.win) {
        undoShortcut = 'ctrl+z';
        redoShortcut = 'ctrl+y';
      } else {
        undoShortcut = 'ctrl+z';
        redoShortcut = 'shift+ctrl+z';
      }
      this.editable.hotkeys.add(undoShortcut, (function(_this) {
        return function(e) {
          e.preventDefault();
          _this.undo();
          return false;
        };
      })(this));
      this.editable.hotkeys.add(redoShortcut, (function(_this) {
        return function(e) {
          e.preventDefault();
          _this.redo();
          return false;
        };
      })(this));
      this.throttledPushState = this.editable.util.throttle((function(_this) {
        return function() {
          return _this._pushUndoState();
        };
      })(this), 2000);
      this.editable.on('valuechanged', (function(_this) {
        return function(e, src) {
          if (src === 'undo' || src === 'redo') {
            return;
          }
          return _this.throttledPushState();
        };
      })(this));
      this.editable.on('selectionchanged', (function(_this) {
        return function(e) {
          _this.resetCaretPosition();
          return _this.update();
        };
      })(this));
      this.editable.on('focus', (function(_this) {
        return function(e) {
          if (_this._stack.length === 0) {
            return _this._pushUndoState();
          }
        };
      })(this));
      this.editable.on('blur', (function(_this) {
        return function(e) {
          return _this.resetCaretPosition();
        };
      })(this));
    }

  });

  UndoManager.pluginName = 'UndoManager';

  UndoManager.prototype._index = -1;

  UndoManager.prototype._capacity = 20;

  UndoManager.prototype._startPosition = null;

  UndoManager.prototype._endPosition = null;

  UndoManager.prototype.resetCaretPosition = function() {
    this._startPosition = null;
    return this._endPosition = null;
  };

  UndoManager.prototype.startPosition = function() {
    if (this.editable.selection._range) {
      this._startPosition || (this._startPosition = this._getPosition('start'));
    }
    return this._startPosition;
  };

  UndoManager.prototype.endPosition = function() {
    if (this.editable.selection._range) {
      this._endPosition || (this._endPosition = (function(_this) {
        return function() {
          var range;
          range = _this.editable.selection.range();
          if (range.collapsed) {
            return _this._startPosition;
          }
          return _this._getPosition('end');
        };
      })(this)());
    }
    return this._endPosition;
  };

  UndoManager.prototype._pushUndoState = function() {
    var caret;
    if (this.editable.trigger('pushundostate') === false) {
      return;
    }
    caret = this.caretPosition();
    if (!caret.start) {
      return;
    }
    this._index += 1;
    this._stack.length = this._index;
    this._stack.push({
      html: this.editable.body.html(),
      caret: this.caretPosition()
    });
    if (this._stack.length > this._capacity) {
      this._stack.shift();
      return this._index -= 1;
    }
  };

  UndoManager.prototype.currentState = function() {
    if (this._stack.length && this._index > -1) {
      return this._stack[this._index];
    } else {
      return null;
    }
  };

  UndoManager.prototype.undo = function() {
    var state;
    if (this._index < 1 || this._stack.length < 2) {
      return;
    }
    this.editable.hidePopover();
    this._index -= 1;
    state = this._stack[this._index];
    this.editable.body.get(0).innerHTML = state.html;
    this.caretPosition(state.caret);
    this.editable.body.find('.selected').removeClass('selected');
    this.editable.sync();
    return this.editable.trigger('valuechanged', ['undo']);
  };

  UndoManager.prototype.redo = function() {
    var state;
    if (this._index < 0 || this._stack.length < this._index + 2) {
      return;
    }
    this.editable.hidePopover();
    this._index += 1;
    state = this._stack[this._index];
    this.editable.body.get(0).innerHTML = state.html;
    this.caretPosition(state.caret);
    this.editable.body.find('.selected').removeClass('selected');
    this.editable.sync();
    return this.editable.trigger('valuechanged', ['redo']);
  };

  UndoManager.prototype.update = function() {
    var currentState;
    currentState = this.currentState();
    if (!currentState) {
      return;
    }
    currentState.html = this.editable.body.html();
    return currentState.caret = this.caretPosition();
  };

  UndoManager.prototype._getNodeOffset = function(node, index) {
    var $parent, merging, offset;
    if (langx.isNumber(index)) {
      $parent = $(node);
    } else {
      $parent = $(node).parent();
    }
    offset = 0;
    merging = false;
    $parent.contents().each(function(i, child) {
      if (node === child || (index === i && i === 0)) {
        return false;
      }
      if (child.nodeType === Node.TEXT_NODE) {
        if (!merging && child.nodeValue.length > 0) {
          offset += 1;
          merging = true;
        }
      } else {
        offset += 1;
        merging = false;
      }
      if (index - 1 === i) {
        return false;
      }
      return null;
    });
    return offset;
  };

  UndoManager.prototype._getPosition = function(type) {
    var $nodes, node, nodes, offset, position, prevNode, range;
    if (type == null) {
      type = 'start';
    }
    range = this.editable.selection.range();
    offset = range[type + "Offset"];
    $nodes = this.editable.selection[type + "Nodes"]();
    node = $nodes.first()[0];
    if (node.nodeType === Node.TEXT_NODE) {
      prevNode = node.previousSibling;
      while (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
        node = prevNode;
        offset += this.editable.util.getNodeLength(prevNode);
        prevNode = prevNode.previousSibling;
      }
      nodes = $nodes.get();
      nodes[0] = node;
      $nodes = $(nodes);
    } else {
      offset = this._getNodeOffset(node, offset);
    }
    position = [offset];
    $nodes.each((function(_this) {
      return function(i, node) {
        return position.unshift(_this._getNodeOffset(node));
      };
    })(this));
    return position;
  };

  UndoManager.prototype._getNodeByPosition = function(position) {
    var child, childNodes, i, k, len, node, offset, ref;
    node = this.editable.body[0];
    ref = position.slice(0, position.length - 1);
    for (i = k = 0, len = ref.length; k < len; i = ++k) {
      offset = ref[i];
      childNodes = node.childNodes;
      if (offset > childNodes.length - 1) {
        if (i === position.length - 2 && $(node).is(':empty')) {
          child = document.createTextNode('');
          node.appendChild(child);
          childNodes = node.childNodes;
        } else {
          node = null;
          break;
        }
      }
      node = childNodes[offset];
    }
    return node;
  };

  UndoManager.prototype.caretPosition = function(caret) {
    var endContainer, endOffset, range, startContainer, startOffset;
    if (!caret) {
      range = this.editable.selection.range();
      caret = this.editable.inputManager.focused && (range != null) ? {
        start: this.startPosition(),
        end: this.endPosition(),
        collapsed: range.collapsed
      } : {};
      return caret;
    } else {
      if (!caret.start) {
        return;
      }
      startContainer = this._getNodeByPosition(caret.start);
      startOffset = caret.start[caret.start.length - 1];
      if (caret.collapsed) {
        endContainer = startContainer;
        endOffset = startOffset;
      } else {
        endContainer = this._getNodeByPosition(caret.end);
        endOffset = caret.start[caret.start.length - 1];
      }
      if (!startContainer || !endContainer) {
        if (typeof console !== "undefined" && console !== null) {
          if (typeof console.warn === "function") {
            console.warn('simditor: invalid caret state');
          }
        }
        return;
      }
      range = document.createRange();
      range.setStart(startContainer, startOffset);
      range.setEnd(endContainer, endOffset);
      return this.editable.selection.range(range);
    }
  };

  return contents.UndoManager = UndoManager;

});
define('skylark-domx-contents/Keystroke',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 

  var Keystroke = langx.Evented.inherit({
    init : function(editable,opts) {
      this.editable = editable; //this._module;
      this.opts = langx.extend({}, this.opts, opts);

      this._keystrokeHandlers = {};
      this._initKeystrokeHandlers();
    }
  });


  Keystroke.pluginName = 'Keystroke';


  Keystroke.prototype.add = function(key, node, handler) {
    key = key.toLowerCase();
    key = this.editable.hotkeys.constructor.aliases[key] || key;
    if (!this._keystrokeHandlers[key]) {
      this._keystrokeHandlers[key] = {};
    }
    return this._keystrokeHandlers[key][node] = handler;
  };

  Keystroke.prototype.respondTo = function(e) {
    var base, key, ref, result;
    key = (ref = this.editable.hotkeys.constructor.keyNameMap[e.which]) != null ? ref.toLowerCase() : void 0;
    if (!key) {
      return;
    }
    if (key in this._keystrokeHandlers) {
      result = typeof (base = this._keystrokeHandlers[key])['*'] === "function" ? base['*'](e) : void 0;
      if (!result) {
        this.editable.selection.startNodes().each((function(_this) {
          return function(i, node) {
            var handler, ref1;
            if (node.nodeType !== Node.ELEMENT_NODE) {
              return;
            }
            handler = (ref1 = _this._keystrokeHandlers[key]) != null ? ref1[node.tagName.toLowerCase()] : void 0;
            result = typeof handler === "function" ? handler(e, $(node)) : void 0;
            if (result === true || result === false) {
              return false;
            }
          };
        })(this));
      }
      if (result) {
        return true;
      }
    }
  };

  Keystroke.prototype._initKeystrokeHandlers = function() {
    var titleEnterHandler;
    if (this.editable.util.browser.safari) {
      this.add('enter', '*', (function(_this) {
        return function(e) {
          var $blockEl, $br;
          if (!e.shiftKey) {
            return;
          }
          $blockEl = _this.editable.selection.blockNodes().last();
          if ($blockEl.is('pre')) {
            return;
          }
          $br = $('<br/>');
          if (_this.editable.selection.rangeAtEndOf($blockEl)) {
            _this.editable.selection.insertNode($br);
            _this.editable.selection.insertNode($('<br/>'));
            _this.editable.selection.setRangeBefore($br);
          } else {
            _this.editable.selection.insertNode($br);
          }
          return true;
        };
      })(this));
    }
    if (this.editable.util.browser.webkit || this.editable.util.browser.msie) {
      titleEnterHandler = (function(_this) {
        return function(e, $node) {
          var $p;
          if (!_this.editable.selection.rangeAtEndOf($node)) {
            return;
          }
          $p = $('<p/>').append(_this.editable.util.phBr).insertAfter($node);
          _this.editable.selection.setRangeAtStartOf($p);
          return true;
        };
      })(this);
      this.add('enter', 'h1', titleEnterHandler);
      this.add('enter', 'h2', titleEnterHandler);
      this.add('enter', 'h3', titleEnterHandler);
      this.add('enter', 'h4', titleEnterHandler);
      this.add('enter', 'h5', titleEnterHandler);
      this.add('enter', 'h6', titleEnterHandler);
    }
    this.add('backspace', '*', (function(_this) {
      return function(e) {
        var $blockEl, $prevBlockEl, $rootBlock, isWebkit;
        $rootBlock = _this.editable.selection.rootNodes().first();
        $prevBlockEl = $rootBlock.prev();
        if ($prevBlockEl.is('hr') && _this.editable.selection.rangeAtStartOf($rootBlock)) {
          _this.editable.selection.save();
          $prevBlockEl.remove();
          _this.editable.selection.restore();
          return true;
        }
        $blockEl = _this.editable.selection.blockNodes().last();
        if ($blockEl.is('.' + this.opts.classPrefix + 'resize-handle') && $rootBlock.is('.' + this.opts.classPrefix + 'table')) {
          e.preventDefault();
          $rootBlock.remove();
          _this.editable.selection.setRangeAtEndOf($prevBlockEl);
        }
        if ($prevBlockEl.is('.' + this.opts.classPrefix + 'table') && !$blockEl.is('table') && _this.editable.util.isEmptyNode($blockEl)) {
          e.preventDefault();
          $blockEl.remove();
          _this.editable.selection.setRangeAtEndOf($prevBlockEl);
        }
        isWebkit = _this.editable.util.browser.webkit;
        if (isWebkit && _this.editable.selection.rangeAtStartOf($blockEl)) {
          _this.editable.selection.save();
          _this.editable.formatter.cleanNode($blockEl, true);
          _this.editable.selection.restore();
          return null;
        }
      };
    })(this));
    this.add('enter', 'div', (function(_this) {
      return function(e, $node) {
        var $blockEl, $p;
        if ($node.is('.' + this.opts.classPrefix + 'table')) {
          $blockEl = _this.editable.selection.blockNodes().last();
          if ($blockEl.is('.' + this.opts.classPrefix + 'resize-handle')) {
            e.preventDefault();
            $p = $('<p/>').append(_this.editable.util.phBr).insertAfter($node);
            return _this.editable.selection.setRangeAtStartOf($p);
          }
        }
      };
    })(this));
    this.add('enter', 'li', (function(_this) {
      return function(e, $node) {
        var $cloneNode, listEl, newBlockEl, newListEl;
        $cloneNode = $node.clone();
        $cloneNode.find('ul, ol').remove();
        if (!(_this.editable.util.isEmptyNode($cloneNode) && $node.is(_this.editable.selection.blockNodes().last()))) {
          return;
        }
        listEl = $node.parent();  
        if ($node.next('li').length > 0) {
          if (!_this.editable.util.isEmptyNode($node)) {
            return;
          }
          if (listEl.parent('li').length > 0) {
            newBlockEl = $('<li/>').append(_this.editable.util.phBr).insertAfter(listEl.parent('li'));
            newListEl = $('<' + listEl[0].tagName + '/>').append($node.nextAll('li'));
            newBlockEl.append(newListEl);
          } else {
            newBlockEl = $('<p/>').append(_this.editable.util.phBr).insertAfter(listEl);
            newListEl = $('<' + listEl[0].tagName + '/>').append($node.nextAll('li'));
            newBlockEl.after(newListEl);
          }
        } else {
          if (listEl.parent('li').length > 0) {
            newBlockEl = $('<li/>').insertAfter(listEl.parent('li'));
            if ($node.contents().length > 0) {
              newBlockEl.append($node.contents());
            } else {
              newBlockEl.append(_this.editable.util.phBr);
            }
          } else {
            newBlockEl = $('<p/>').append(_this.editable.util.phBr).insertAfter(listEl);
            if ($node.children('ul, ol').length > 0) {
              newBlockEl.after($node.children('ul, ol'));
            }
          }
        }
        if ($node.prev('li').length) {
          $node.remove();
        } else {
          if ($node.prev('ul').length || $node.prev('ol').length) {
            $node.remove();
          } else {
            listEl.remove();
          }
        }
        _this.editable.selection.setRangeAtStartOf(newBlockEl);
        return true;
      };
    })(this));
    this.add('enter', 'pre', (function(_this) {
      return function(e, $node) {
        var $p, breakNode, range;
        e.preventDefault();
        if (e.shiftKey) {
          $p = $('<p/>').append(_this.editable.util.phBr).insertAfter($node);
          _this.editable.selection.setRangeAtStartOf($p);
          return true;
        }
        range = _this.editable.selection.range();
        breakNode = null;
        range.deleteContents();
        if (!_this.editable.util.browser.msie && _this.editable.selection.rangeAtEndOf($node)) {
          breakNode = document.createTextNode('\n\n');
        } else {
          breakNode = document.createTextNode('\n');
        }
        range.insertNode(breakNode);
        range.setEnd(breakNode, 1);
        range.collapse(false);
        _this.editable.selection.range(range);
        return true;
      };
    })(this));
    this.add('enter', 'blockquote', (function(_this) {
      return function(e, $node) {
        var $closestBlock, range;
        $closestBlock = _this.editable.selection.blockNodes().last();
        if (!($closestBlock.is('p') && !$closestBlock.next().length && _this.editable.util.isEmptyNode($closestBlock))) {
          return;
        }
        $node.after($closestBlock);
        range = document.createRange();
        _this.editable.selection.setRangeAtStartOf($closestBlock, range);
        return true;
      };
    })(this));
    this.add('backspace', 'li', (function(_this) {
      return function(e, $node) {
        var $br, $childList, $newLi, $prevChildList, $prevNode, $textNode, isFF, range, text;
        $childList = $node.children('ul, ol');
        $prevNode = $node.prev('li');
        if (!($childList.length > 0 && $prevNode.length > 0)) {
          return false;
        }
        text = '';
        $textNode = null;
        $node.contents().each(function(i, n) {
          if (n.nodeType === 1 && /UL|OL/.test(n.nodeName)) {
            return false;
          }
          if (n.nodeType === 1 && /BR/.test(n.nodeName)) {
            return;
          }
          if (n.nodeType === 3 && n.nodeValue) {
            text += n.nodeValue;
          } else if (n.nodeType === 1) {
            text += $(n).text();
          }
          return $textNode = $(n);
        });
        isFF = _this.editable.util.browser.firefox && !$textNode.next('br').length;
        if ($textNode && text.length === 1 && isFF) {
          $br = $(_this.editable.util.phBr).insertAfter($textNode);
          $textNode.remove();
          _this.editable.selection.setRangeBefore($br);
          return true;
        } else if (text.length > 0) {
          return false;
        }
        range = document.createRange();
        $prevChildList = $prevNode.children('ul, ol');
        if ($prevChildList.length > 0) {
          $newLi = $('<li/>').append(_this.editable.util.phBr).appendTo($prevChildList);
          $prevChildList.append($childList.children('li'));
          $node.remove();
          _this.editable.selection.setRangeAtEndOf($newLi, range);
        } else {
          _this.editable.selection.setRangeAtEndOf($prevNode, range);
          $prevNode.append($childList);
          $node.remove();
          _this.editable.selection.range(range);
        }
        return true;
      };
    })(this));
    this.add('backspace', 'pre', (function(_this) {
      return function(e, $node) {
        var $newNode, codeStr, range;
        if (!_this.editable.selection.rangeAtStartOf($node)) {
          return;
        }
        codeStr = $node.html().replace('\n', '<br/>') || _this.editable.util.phBr;
        $newNode = $('<p/>').append(codeStr).insertAfter($node);
        $node.remove();
        range = document.createRange();
        _this.editable.selection.setRangeAtStartOf($newNode, range);
        return true;
      };
    })(this));
    return this.add('backspace', 'blockquote', (function(_this) {
      return function(e, $node) {
        var $firstChild, range;
        if (!_this.editable.selection.rangeAtStartOf($node)) {
          return;
        }
        $firstChild = $node.children().first().unwrap();
        range = document.createRange();
        _this.editable.selection.setRangeAtStartOf($firstChild, range);
        return true;
      };
    })(this));
  };

  return contents.Keystroke = Keystroke;

});

define('skylark-domx-contents/Formatter',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 


  var indexOf = [].indexOf ;

  var Formatter = langx.Evented.inherit({
    opts : {
      allowedTags: [],
      allowedAttributes: {},
      allowedStyles: {}
    },

    init : function(editable,opts) {
      this.editable = editable; //this._module;
      this.opts = langx.extend({}, this.opts, opts);

      this._allowedTags = langx.merge(['br', 'span', 'a', 'img', 'b', 'strong', 'i', 'strike', 'u', 'font', 'p', 'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'h1', 'h2', 'h3', 'h4', 'hr'], this.opts.allowedTags);
      this._allowedAttributes = langx.extend({
        img: ['src', 'alt', 'width', 'height', 'data-non-image'],
        a: ['href', 'target'],
        font: ['color'],
        code: ['class']
      }, this.opts.allowedAttributes);
      this._allowedStyles = langx.extend({
        span: ['color', 'font-size'],
        b: ['color', 'font-size'],
        i: ['color', 'font-size'],
        strong: ['color', 'font-size'],
        strike: ['color', 'font-size'],
        u: ['color', 'font-size'],
        p: ['margin-left', 'text-align'],
        h1: ['margin-left', 'text-align'],
        h2: ['margin-left', 'text-align'],
        h3: ['margin-left', 'text-align'],
        h4: ['margin-left', 'text-align']
      }, this.opts.allowedStyles);
      this.editable.body.on('click', 'a', function(e) {
        return false;
      });
    },

    decorate : function($el) {
      if ($el == null) {
        $el = this.editable.body;
      }
      this.editable.trigger('decorate', [$el]);
      return $el;
    },

    undecorate : function($el) {
      if ($el == null) {
        $el = this.editable.body.clone();
      }
      this.editable.trigger('undecorate', [$el]);
      return $el;
    },

    autolink : function($el) {
      var $link, $node, findLinkNode, k, lastIndex, len, linkNodes, match, re, replaceEls, subStr, text, uri;
      if ($el == null) {
        $el = this.editable.body;
      }
      linkNodes = [];
      findLinkNode = function($parentNode) {
        return $parentNode.contents().each(function(i, node) {
          var $node, text;
          $node = $(node);
          if ($node.is('a') || $node.closest('a, pre', $el).length) {
            return;
          }
          if (!$node.is('iframe') && $node.contents().length) {
            return findLinkNode($node);
          } else if ((text = $node.text()) && /https?:\/\/|www\./ig.test(text)) {
            return linkNodes.push($node);
          }
        });
      };
      findLinkNode($el);
      re = /(https?:\/\/|www\.)[\w\-\.\?&=\/#%:,@\!\+]+/ig;
      for (k = 0, len = linkNodes.length; k < len; k++) {
        $node = linkNodes[k];
        text = $node.text();
        replaceEls = [];
        match = null;
        lastIndex = 0;
        while ((match = re.exec(text)) !== null) {
          subStr = text.substring(lastIndex, match.index);
          replaceEls.push(document.createTextNode(subStr));
          lastIndex = re.lastIndex;
          uri = /^(http(s)?:\/\/|\/)/.test(match[0]) ? match[0] : 'http://' + match[0];
          $link = $("<a href=\"" + uri + "\" rel=\"nofollow\"></a>").text(match[0]);
          replaceEls.push($link[0]);
        }
        replaceEls.push(document.createTextNode(text.substring(lastIndex)));
        $node.replaceWith($(replaceEls));
      }
      return $el;
    },

    format : function($el) {
      var $node, blockNode, k, l, len, len1, n, node, ref, ref1;
      if ($el == null) {
        $el = this.editable.body;
      }
      if ($el.is(':empty')) {
        $el.append('<p>' + this.editable.util.phBr + '</p>');
        return $el;
      }
      ref = $el.contents();
      for (k = 0, len = ref.length; k < len; k++) {
        n = ref[k];
        this.cleanNode(n, true);
      }
      ref1 = $el.contents();
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        node = ref1[l];
        $node = $(node);
        if ($node.is('br')) {
          if (typeof blockNode !== "undefined" && blockNode !== null) {
            blockNode = null;
          }
          $node.remove();
        } else if (this.editable.util.isBlockNode(node)) {
          if ($node.is('li')) {
            if (blockNode && blockNode.is('ul, ol')) {
              blockNode.append(node);
            } else {
              blockNode = $('<ul/>').insertBefore(node);
              blockNode.append(node);
            }
          } else {
            blockNode = null;
          }
        } else {
          if (!blockNode || blockNode.is('ul, ol')) {
            blockNode = $('<p/>').insertBefore(node);
          }
          blockNode.append(node);
          if (this.editable.util.isEmptyNode(blockNode)) {
            blockNode.append(this.editable.util.phBr);
          }
        }
      }
      return $el;
    },

    cleanNode : function(node, recursive) {
      var $blockEls, $childImg, $node, $p, $td, allowedAttributes, attr, contents, isDecoration, k, l, len, len1, n, ref, ref1, text, textNode;
      $node = $(node);
      if (!($node.length > 0)) {
        return;
      }
      if ($node[0].nodeType === 3) {
        text = $node.text().replace(/(\r\n|\n|\r)/gm, '');
        if (text) {
          textNode = document.createTextNode(text);
          $node.replaceWith(textNode);
        } else {
          $node.remove();
        }
        return;
      }
      contents = $node.is('iframe') ? null : $node.contents();
      isDecoration = this.editable.util.isDecoratedNode($node);
      if ($node.is(this._allowedTags.join(',')) || isDecoration) {
        if ($node.is('a') && ($childImg = $node.find('img')).length > 0) {
          $node.replaceWith($childImg);
          $node = $childImg;
          contents = null;
        }
        if ($node.is('td') && ($blockEls = $node.find(this.editable.util.blockNodes.join(','))).length > 0) {
          $blockEls.each((function(_this) {
            return function(i, blockEl) {
              return $(blockEl).contents().unwrap();
            };
          })(this));
          contents = $node.contents();
        }
        if ($node.is('img') && $node.hasClass('uploading')) {
          $node.remove();
        }
        if (!isDecoration) {
          allowedAttributes = this._allowedAttributes[$node[0].tagName.toLowerCase()];
          ref = langx.makeArray($node[0].attributes);
          for (k = 0, len = ref.length; k < len; k++) {
            attr = ref[k];
            if (attr.name === 'style') {
              continue;
            }
            if (!((allowedAttributes != null) && (ref1 = attr.name, indexOf.call(allowedAttributes, ref1) >= 0))) {
              $node.removeAttr(attr.name);
            }
          }
          this._cleanNodeStyles($node);
          if ($node.is('span')) {
            if ($node[0].attributes.length === 0) {
              $node.contents().first().unwrap();
            }
            if ($node[0].style.length === 2 && $node[0].style.color === 'rgb(51, 51, 51)' && $node[0].style.fontSize === '16px') {
              $node.contents().unwrap();
            }
          }
        }
      } else if ($node[0].nodeType === 1 && !$node.is(':empty')) {
        if ($node.is('div, article, dl, header, footer, tr')) {
          $node.append('<br/>');
          contents.first().unwrap();
        } else if ($node.is('table')) {
          $p = $('<p/>');
          $node.find('tr').each(function(i, tr) {
            return $p.append($(tr).text() + '<br/>');
          });
          $node.replaceWith($p);
          contents = null;
        } else if ($node.is('thead, tfoot')) {
          $node.remove();
          contents = null;
        } else if ($node.is('th')) {
          $td = $('<td/>').append($node.contents());
          $node.replaceWith($td);
        } else {
          contents.first().unwrap();
        }
      } else {
        $node.remove();
        contents = null;
      }
      if (recursive && (contents != null) && !$node.is('pre')) {
        for (l = 0, len1 = contents.length; l < len1; l++) {
          n = contents[l];
          this.cleanNode(n, true);
        }
      }
      return null;
    },

    _cleanNodeStyles : function($node) {
      var allowedStyles, k, len, pair, ref, ref1, style, styleStr, styles;
      styleStr = $node.attr('style');
      if (!styleStr) {
        return;
      }
      $node.removeAttr('style');
      allowedStyles = this._allowedStyles[$node[0].tagName.toLowerCase()];
      if (!(allowedStyles && allowedStyles.length > 0)) {
        return $node;
      }
      styles = {};
      ref = styleStr.split(';');
      for (k = 0, len = ref.length; k < len; k++) {
        style = ref[k];
        style = langx.trim(style);
        pair = style.split(':');
        if (pair.length !== 2) {
          continue;
        }
        if (pair[0] === 'font-size' && pair[1].indexOf('px') > 0) {
          if (parseInt(pair[1], 10) < 12) {
            continue;
          }
        }
        if (ref1 = pair[0], indexOf.call(allowedStyles, ref1) >= 0) {
          styles[langx.trim(pair[0])] = langx.trim(pair[1]);
        }
      }
      if (Object.keys(styles).length > 0) {
        $node.css(styles);
      }
      return $node;
    },

    clearHtml : function(html, lineBreak) {
      var container, contents, result;
      if (lineBreak == null) {
        lineBreak = true;
      }
      container = $('<div/>').append(html);
      contents = container.contents();
      result = '';
      contents.each((function(_this) {
        return function(i, node) {
          var $node, children;
          if (node.nodeType === 3) {
            return result += node.nodeValue;
          } else if (node.nodeType === 1) {
            $node = $(node);
            children = $node.is('iframe') ? null : $node.contents();
            if (children && children.length > 0) {
              result += _this.clearHtml(children);
            }
            if (lineBreak && i < contents.length - 1 && $node.is('br, p, div, li,tr, pre, address, artticle, aside, dl, figcaption, footer, h1, h2,h3, h4, header')) {
              return result += '\n';
            }
          }
        };
      })(this));
      return result;
    },

    beautify : function($contents) {
      var uselessP;
      uselessP = function($el) {
        return !!($el.is('p') && !$el.text() && $el.children(':not(br)').length < 1);
      };
      return $contents.each(function(i, el) {
        var $el, invalid;
        $el = $(el);
        invalid = $el.is(':not(img, br, col, td, hr, [class^="' + this.opts.classPrefix + '"]):empty');
        if (invalid || uselessP($el)) {
          $el.remove();
        }
        return $el.find(':not(img, br, col, td, hr, [class^="' + this.opts.classPrefix + '"]):empty').remove();
      });
    }

  });

  Formatter.pluginName = 'Formatter';

  return contents.Formatter = Formatter;

});
define('skylark-domx-contents/Indentation',[
  "skylark-langx/langx",
  "skylark-domx-noder",
  "skylark-domx-query",
  "./contents"
],function(langx,noder,$,contents){ 


  var Indentation = langx.Evented.inherit({

  });


  Indentation.pluginName = 'Indentation';

  Indentation.prototype.opts = {
    tabIndent: true,
    indentWidth: 40
   
  };

  Indentation.prototype.init = function(editable,opts) {
    this.editable = editable; // this._module;
    this.opts = langx.extend({}, this.opts, opts);

    this.editable.keystroke.add('tab', '*', (function(_this) {
      return function(e) {
        var codeButton;
        codeButton = _this.editable.toolbar.findButton('code');
        if (!(_this.opts.tabIndent || (codeButton && codeButton.active))) {
          return;
        }
        return _this.indent(e.shiftKey);
      };
    })(this));
  };

  Indentation.prototype.indent = function(isBackward) {
    var $blockNodes, $endNodes, $startNodes, nodes, result;
    $startNodes = this.editable.selection.startNodes();
    $endNodes = this.editable.selection.endNodes();
    $blockNodes = this.editable.selection.blockNodes();
    nodes = [];
    $blockNodes = $blockNodes.each(function(i, node) {
      var include, j, k, len, n;
      include = true;
      for (j = k = 0, len = nodes.length; k < len; j = ++k) {
        n = nodes[j];
        if (noder.contains(node, n)) {
          include = false;
          break;
        } else if (noder.contains(n, node)) {
          nodes.splice(j, 1, node);
          include = false;
          break;
        }
      }
      if (include) {
        return nodes.push(node);
      }
    });
    $blockNodes = $(nodes);
    result = false;
    $blockNodes.each((function(_this) {
      return function(i, blockEl) {
        var r;
        r = isBackward ? _this.outdentBlock(blockEl) : _this.indentBlock(blockEl);
        if (r) {
          return result = r;
        }
      };
    })(this));
    return result;
  };

  Indentation.prototype.indentBlock = function(blockEl) {
    var $blockEl, $childList, $nextTd, $nextTr, $parentLi, $pre, $td, $tr, marginLeft, tagName;
    $blockEl = $(blockEl);
    if (!$blockEl.length) {
      return;
    }
    if ($blockEl.is('pre')) {
      $pre = this.editable.selection.containerNode();
      if (!($pre.is($blockEl) || $pre.closest('pre').is($blockEl))) {
        return;
      }
      this.indentText(this.editable.selection.range());
    } else if ($blockEl.is('li')) {
      $parentLi = $blockEl.prev('li');
      if ($parentLi.length < 1) {
        return;
      }
      this.editable.selection.save();
      tagName = $blockEl.parent()[0].tagName;
      $childList = $parentLi.children('ul, ol');
      if ($childList.length > 0) {
        $childList.append($blockEl);
      } else {
        $('<' + tagName + '/>').append($blockEl).appendTo($parentLi);
      }
      this.editable.selection.restore();
    } else if ($blockEl.is('p, h1, h2, h3, h4')) {
      marginLeft = parseInt($blockEl.css('margin-left')) || 0;
      marginLeft = (Math.round(marginLeft / this.opts.indentWidth) + 1) * this.opts.indentWidth;
      $blockEl.css('margin-left', marginLeft);
    } else if ($blockEl.is('table') || $blockEl.is('.' + this.opts.classPrefix +'table')) {
      $td = this.editable.selection.containerNode().closest('td, th');
      $nextTd = $td.next('td, th');
      if (!($nextTd.length > 0)) {
        $tr = $td.parent('tr');
        $nextTr = $tr.next('tr');
        if ($nextTr.length < 1 && $tr.parent().is('thead')) {
          $nextTr = $tr.parent('thead').next('tbody').find('tr:first');
        }
        $nextTd = $nextTr.find('td:first, th:first');
      }
      if (!($td.length > 0 && $nextTd.length > 0)) {
        return;
      }
      this.editable.selection.setRangeAtEndOf($nextTd);
    } else {
      return false;
    }
    return true;
  };

  Indentation.prototype.indentText = function(range) {
    var text, textNode;
    text = range.toString().replace(/^(?=.+)/mg, '\u00A0\u00A0');
    textNode = document.createTextNode(text || '\u00A0\u00A0');
    range.deleteContents();
    range.insertNode(textNode);
    if (text) {
      range.selectNode(textNode);
      return this.editable.selection.range(range);
    } else {
      return this.editable.selection.setRangeAfter(textNode);
    }
  };

  Indentation.prototype.outdentBlock = function(blockEl) {
    var $blockEl, $parent, $parentLi, $pre, $prevTd, $prevTr, $td, $tr, marginLeft, range;
    $blockEl = $(blockEl);
    if (!($blockEl && $blockEl.length > 0)) {
      return;
    }
    if ($blockEl.is('pre')) {
      $pre = this.editable.selection.containerNode();
      if (!($pre.is($blockEl) || $pre.closest('pre').is($blockEl))) {
        return;
      }
      this.outdentText(range);
    } else if ($blockEl.is('li')) {
      $parent = $blockEl.parent();
      $parentLi = $parent.parent('li');
      this.editable.selection.save();
      if ($parentLi.length < 1) {
        range = document.createRange();
        range.setStartBefore($parent[0]);
        range.setEndBefore($blockEl[0]);
        $parent.before(range.extractContents());
        $('<p/>').insertBefore($parent).after($blockEl.children('ul, ol')).append($blockEl.contents());
        $blockEl.remove();
      } else {
        if ($blockEl.next('li').length > 0) {
          $('<' + $parent[0].tagName + '/>').append($blockEl.nextAll('li')).appendTo($blockEl);
        }
        $blockEl.insertAfter($parentLi);
        if ($parent.children('li').length < 1) {
          $parent.remove();
        }
      }
      this.editable.selection.restore();
    } else if ($blockEl.is('p, h1, h2, h3, h4')) {
      marginLeft = parseInt($blockEl.css('margin-left')) || 0;
      marginLeft = Math.max(Math.round(marginLeft / this.opts.indentWidth) - 1, 0) * this.opts.indentWidth;
      $blockEl.css('margin-left', marginLeft === 0 ? '' : marginLeft);
    } else if ($blockEl.is('table') || $blockEl.is('.' + this.opts.classPrefix + 'table')) {
      $td = this.editable.selection.containerNode().closest('td, th');
      $prevTd = $td.prev('td, th');
      if (!($prevTd.length > 0)) {
        $tr = $td.parent('tr');
        $prevTr = $tr.prev('tr');
        if ($prevTr.length < 1 && $tr.parent().is('tbody')) {
          $prevTr = $tr.parent('tbody').prev('thead').find('tr:first');
        }
        $prevTd = $prevTr.find('td:last, th:last');
      }
      if (!($td.length > 0 && $prevTd.length > 0)) {
        return;
      }
      this.editable.selection.setRangeAtEndOf($prevTd);
    } else {
      return false;
    }
    return true;
  };

  Indentation.prototype.outdentText = function(range) {};

  return contents.Indentation = Indentation;

});

define('skylark-domx-contents/Clipboard',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./contents"
],function(langx,$,contents){ 

  var Clipboard = langx.Evented.inherit({

  });


  Clipboard.pluginName = 'Clipboard';

  Clipboard.prototype.opts = {
    pasteImage: false,
    cleanPaste: false
  };

  Clipboard.prototype.init = function(editable,opts) {
    this.editable = editable; //this._module;
    this.opts = langx.extend({}, this.opts, opts);
    if (this.opts.pasteImage && typeof this.opts.pasteImage !== 'string') {
      this.opts.pasteImage = 'inline';
    }
    this.editable.body.on('paste', (function(_this) {
      return function(e) {
        var range;
        if (_this.pasting || _this._pasteBin) {
          return;
        }
        if (_this.editable.trigger(e) === false) {
          return false;
        }
        range = _this.editable.selection.deleteRangeContents();
        if (_this.editable.body.html()) {
          if (!range.collapsed) {
            range.collapse(true);
          }
        } else {
          _this.editable.formatter.format();
          _this.editable.selection.setRangeAtStartOf(_this.editable.body.find('p:first'));
        }
        if (_this._processPasteByClipboardApi(e)) {
          return false;
        }
        _this.editable.inputManager.throttledValueChanged.clear();
        _this.editable.inputManager.throttledSelectionChanged.clear();
        _this.editable.undoManager.throttledPushState.clear();
        _this.editable.selection.reset();
        _this.editable.undoManager.resetCaretPosition();
        _this.pasting = true;
        return _this._getPasteContent(function(pasteContent) {
          _this._processPasteContent(pasteContent);
          _this._pasteInBlockEl = null;
          _this._pastePlainText = null;
          return _this.pasting = false;
        });
      };
    })(this));
  };

  Clipboard.prototype._processPasteByClipboardApi = function(e) {
    var imageFile, pasteItem, ref, uploadOpt;
    if (this.editable.util.browser.edge) {
      return;
    }
    if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.items && e.originalEvent.clipboardData.items.length > 0) {
      pasteItem = e.originalEvent.clipboardData.items[0];
      if (/^image\//.test(pasteItem.type)) {
        imageFile = pasteItem.getAsFile();
        if (!((imageFile != null) && this.opts.pasteImage)) {
          return;
        }
        if (!imageFile.name) {
          imageFile.name = "Clipboard Image.png";
        }
        if (this.editable.triggerHandler('pasting', [imageFile]) === false) {
          return;
        }
        uploadOpt = {};
        uploadOpt[this.opts.pasteImage] = true;
        if ((ref = this.editable.uploader) != null) {
          ref.upload(imageFile, uploadOpt);
        }
        return true;
      }
    }
  };

  Clipboard.prototype._getPasteContent = function(callback) {
    var state;
    this._pasteBin = $('<div contenteditable="true" />').addClass(this.opts.classPrefix + 'paste-bin').attr('tabIndex', '-1').appendTo(this.editable.$el);
    state = {
      html: this.editable.body.html(),
      caret: this.editable.undoManager.caretPosition()
    };
    this._pasteBin.focus();
    return setTimeout((function(_this) {
      return function() {
        var pasteContent;
        _this.editable.hidePopover();
        _this.editable.body.get(0).innerHTML = state.html;
        _this.editable.undoManager.caretPosition(state.caret);
        _this.editable.body.focus();
        _this.editable.selection.reset();
        _this.editable.selection.range();
        _this._pasteInBlockEl = _this.editable.selection.blockNodes().last();
        _this._pastePlainText = _this.opts.cleanPaste || _this._pasteInBlockEl.is('pre, table');
        if (_this._pastePlainText) {
          pasteContent = _this.editable.formatter.clearHtml(_this._pasteBin.html(), true);
        } else {
          pasteContent = $('<div/>').append(_this._pasteBin.contents());
          pasteContent.find('style').remove();
          pasteContent.find('table colgroup').remove();
          _this._cleanPasteFontSize(pasteContent);
          _this.editable.formatter.format(pasteContent);
          _this.editable.formatter.decorate(pasteContent);
          _this.editable.formatter.beautify(pasteContent.children());
          pasteContent = pasteContent.contents();
        }
        _this._pasteBin.remove();
        _this._pasteBin = null;
        return callback(pasteContent);
      };
    })(this), 0);
  };

  Clipboard.prototype._processPasteContent = function(pasteContent) {
    var $blockEl, $img, blob, children, dataURLtoBlob, img, insertPosition, k, l, lastLine, len, len1, len2, len3, len4, line, lines, m, node, o, q, ref, ref1, ref2, uploadOpt, uploader;
    if (this.editable.triggerHandler('pasting', [pasteContent]) === false) {
      return;
    }
    $blockEl = this._pasteInBlockEl;
    if (!pasteContent) {
      return;
    }
    if (this._pastePlainText) {
      if ($blockEl.is('table')) {
        lines = pasteContent.split('\n');
        lastLine = lines.pop();
        for (k = 0, len = lines.length; k < len; k++) {
          line = lines[k];
          this.editable.selection.insertNode(document.createTextNode(line));
          this.editable.selection.insertNode($('<br/>'));
        }
        this.editable.selection.insertNode(document.createTextNode(lastLine));
      } else {
        pasteContent = $('<div/>').text(pasteContent);
        ref = pasteContent.contents();
        for (l = 0, len1 = ref.length; l < len1; l++) {
          node = ref[l];
          this.editable.selection.insertNode($(node)[0]);
        }
      }
    } else if ($blockEl.is(this.editable.body)) {
      for (m = 0, len2 = pasteContent.length; m < len2; m++) {
        node = pasteContent[m];
        this.editable.selection.insertNode(node);
      }
    } else if (pasteContent.length < 1) {
      return;
    } else if (pasteContent.length === 1) {
      if (pasteContent.is('p')) {
        children = pasteContent.contents();
        if ($blockEl.is('h1, h2, h3, h4, h5')) {
          if (children.length) {
            children.css('font-size', '');
          }
        }
        if (children.length === 1 && children.is('img')) {
          $img = children;
          if (/^data:image/.test($img.attr('src'))) {
            if (!this.opts.pasteImage) {
              return;
            }
            blob = this.editable.util.dataURLtoBlob($img.attr("src"));
            blob.name = "Clipboard Image.png";
            uploadOpt = {};
            uploadOpt[this.opts.pasteImage] = true;
            if ((ref1 = this.editable.uploader) != null) {
              ref1.upload(blob, uploadOpt);
            }
            return;
          } else if (new RegExp('^blob:' + location.origin + '/').test($img.attr('src'))) {
            if (!this.opts.pasteImage) {
              return;
            }
            uploadOpt = {};
            uploadOpt[this.opts.pasteImage] = true;
            dataURLtoBlob = this.editable.util.dataURLtoBlob;
            uploader = this.editable.uploader;
            img = new Image;
            img.onload = function() {
              var canvas;
              canvas = document.createElement('canvas');
              canvas.width = img.naturalWidth;
              canvas.height = img.naturalHeight;
              canvas.getContext('2d').drawImage(img, 0, 0);
              blob = dataURLtoBlob(canvas.toDataURL('image/png'));
              blob.name = 'Clipboard Image.png';
              if (uploader !== null) {
                uploader.upload(blob, uploadOpt);
              }
            };
            img.src = $img.attr('src');
            return;
          } else if ($img.is('img[src^="webkit-fake-url://"]')) {
            return;
          }
        }
        for (o = 0, len3 = children.length; o < len3; o++) {
          node = children[o];
          this.editable.selection.insertNode(node);
        }
      } else if ($blockEl.is('p') && this.editable.util.isEmptyNode($blockEl)) {
        $blockEl.replaceWith(pasteContent);
        this.editable.selection.setRangeAtEndOf(pasteContent);
      } else if (pasteContent.is('ul, ol')) {
        if (pasteContent.find('li').length === 1) {
          pasteContent = $('<div/>').text(pasteContent.text());
          ref2 = pasteContent.contents();
          for (q = 0, len4 = ref2.length; q < len4; q++) {
            node = ref2[q];
            this.editable.selection.insertNode($(node)[0]);
          }
        } else if ($blockEl.is('li')) {
          $blockEl.parent().after(pasteContent);
          this.editable.selection.setRangeAtEndOf(pasteContent);
        } else {
          $blockEl.after(pasteContent);
          this.editable.selection.setRangeAtEndOf(pasteContent);
        }
      } else {
        $blockEl.after(pasteContent);
        this.editable.selection.setRangeAtEndOf(pasteContent);
      }
    } else {
      if ($blockEl.is('li')) {
        $blockEl = $blockEl.parent();
      }
      if (this.editable.selection.rangeAtStartOf($blockEl)) {
        insertPosition = 'before';
      } else if (this.editable.selection.rangeAtEndOf($blockEl)) {
        insertPosition = 'after';
      } else {
        this.editable.selection.breakBlockEl($blockEl);
        insertPosition = 'before';
      }
      $blockEl[insertPosition](pasteContent);
      this.editable.selection.setRangeAtEndOf(pasteContent.last());
    }
    return this.editable.inputManager.throttledValueChanged();
  };

  Clipboard.prototype._cleanPasteFontSize = function(node) {
    var $node, sizeMap;
    $node = $(node);
    if (!($node.length > 0)) {
      return;
    }
    sizeMap = ['1.5em', '1.25em', '0.75em', '0.5em'];
    return $node.find('[style*="font-size"]').map(function(i, el) {
      var $el;
      $el = $(el);
      if (langx.inArray($el.css('font-size'), sizeMap) < 0) {
        return $el.css('font-size', '');
      }
    });
  };

  return contents.Clipboard = Clipboard;

});


define('skylark-domx-contents/Editable',[
	"skylark-langx/langx",
	"skylark-domx-noder",
	"skylark-domx-query",
	"./contents",
	"./Hotkeys",
	"./Util",
	"./InputManager", 
	"./Selection", 
	"./UndoManager", 
	"./Keystroke",
	"./Formatter", 
	"./Indentation", 
	"./Clipboard"
],function(langx, noder, $, contents,Hotkeys,Util,InputManager,Selection,UndoManager,Keystroke,Formatter,Indentation,Clipboard){
  var Editable = langx.Evented.inherit({
    init : function(el,opts) {
    	this.$el = $(el);
    	this.textarea = $(opts.textarea);
    	this.body = $(opts.body);

    	var pluginOpts = {
    		classPrefix : opts.classPrefix
    	};

        this.util = new Util(this,pluginOpts);

		this.hotkeys = new Hotkeys({
		  el: this.body
		});

      this.inputManager = new InputManager(this,pluginOpts);
      this.selection = new Selection(this,pluginOpts);
      this.undoManager = new UndoManager(this,pluginOpts);
      this.keystroke = new Keystroke(this,pluginOpts);
      this.formatter = new Formatter(this,pluginOpts);
      this.indentation = new Indentation(this,pluginOpts);
      this.clipboard = new Clipboard(this,pluginOpts);

		if (this.util.os.mac) {
		  this.$el.addClass(opts.classPrefix + 'mac');
		} else if (this.util.os.linux) {
		  this.$el.addClass(opts.classPrefix + 'linux');
		}
		if (this.util.os.mobile) {
		  this.$el.addClass(opts.classPrefix + 'mobile');
		}

      if (this.util.browser.mozilla) {
        this.util.reflow();
        try {
          document.execCommand('enableObjectResizing', false, false);
          return document.execCommand('enableInlineTableEditing', false, false);
        } catch (_error) {
          e = _error;
        }
      }

    },

	setValue : function(val) {
		this.textarea.val(val);
		this.body.get(0).innerHTML = val;
		this.formatter.format();
		this.formatter.decorate();
		this.util.reflow(this.body);
		this.inputManager.lastCaretPosition = null;
	},

	getValue : function() {
		return this.sync();
	},

	sync : function() {
		var children, cloneBody, emptyP, firstP, lastP, val;
		cloneBody = this.body.clone();
		this.formatter.undecorate(cloneBody);
		this.formatter.format(cloneBody);
		this.formatter.autolink(cloneBody);
		children = cloneBody.children();
		lastP = children.last('p');
		firstP = children.first('p');
		while (lastP.is('p') && this.util.isEmptyNode(lastP)) {
		  emptyP = lastP;
		  lastP = lastP.prev('p');
		  emptyP.remove();
		}
		while (firstP.is('p') && this.util.isEmptyNode(firstP)) {
		  emptyP = firstP;
		  firstP = lastP.next('p');
		  emptyP.remove();
		}
		cloneBody.find('img.uploading').remove();
		val = langx.trim(cloneBody.html());
		this.textarea.val(val);
		return val;
	},

	focus : function() {
		var $blockEl, range;
		if (!(this.body.is(':visible') && this.body.is('[contenteditable]'))) {
		  this.$el.find('textarea:visible').focus();
		  return;
		}
		if (this.inputManager.lastCaretPosition) {
		  this.undoManager.caretPosition(this.inputManager.lastCaretPosition);
		  return this.inputManager.lastCaretPosition = null;
		} else {
		  $blockEl = this.body.children().last();
		  if (!$blockEl.is('p')) {
		    $blockEl = $('<p/>').append(this.util.phBr).appendTo(this.body);
		  }
		  range = document.createRange();
		  return this.selection.setRangeAtEndOf($blockEl, range);
		}
	},

	blur : function() {
		if (this.body.is(':visible') && this.body.is('[contenteditable]')) {
		  return this.body.blur();
		} else {
		  return this.body.find('textarea:visible').blur();
		}
	},

	isActive : function(state) {
		return document.queryCommandState(state) === true; //'bold'
	},

	status : function(cmd,htmlTag) {
		if (cmd === "alignment") {
		    var nodes = this.selection.nodes().filter(htmlTag);
		    if (nodes.length < 1) {
		    	return null;
		    } else {
		      return nodes.first().css('text-align');
		    }

		}
	},

	alignment : function(align,htmlTag) {
	    if (align !== 'left' && align !== 'center' && align !== 'right') {
	      throw new Error("simditor alignment button: invalid align " + align);
	    }
    	var nodes = this.selection.nodes().filter(htmlTag);
	    nodes.css({
	      'text-align': align === 'left' ? '' : align
	    });
	    this.trigger('valuechanged');
	    return this.inputManager.throttledSelectionChanged();

	},

	blockquote : function(htmlTag,disableTag) {
	    var $rootNodes, clearCache, nodeCache;
	    $rootNodes = this.selection.rootNodes();
	    $rootNodes = $rootNodes.filter(function(i, node) {
	      return !$(node).parent().is('blockquote');
	    });
	    this.selection.save();
	    nodeCache = [];
	    clearCache = (function(_this) {
	      return function() {
	        if (nodeCache.length > 0) {
	          $("<" + _this.htmlTag + "/>").insertBefore(nodeCache[0]).append(nodeCache);
	          return nodeCache.length = 0;
	        }
	      };
	    })(this);
	    $rootNodes.each((function(_this) {
	      return function(i, node) {
	        var $node;
	        $node = $(node);
	        if (!$node.parent().is(_this.body)) {
	          return;
	        }
	        if ($node.is(htmlTag)) {
	          clearCache();
	          return $node.children().unwrap();
	        } else if ($node.is(disableTag) || _this.util.isDecoratedNode($node)) {
	          return clearCache();
	        } else {
	          return nodeCache.push(node);
	        }
	      };
	    })(this));
	    clearCache();
	    this.selection.restore();
	    return this.trigger('valuechanged');

	},

	blockCode : function(htmlTag,disableTag) {
	    var $rootNodes, clearCache, nodeCache, resultNodes;
	    $rootNodes = this.selection.rootNodes();
	    nodeCache = [];
	    resultNodes = [];
	    clearCache = (function(_this) {
	      return function() {
	        var $pre;
	        if (!(nodeCache.length > 0)) {
	          return;
	        }
	        $pre = $("<" + htmlTag + "/>").insertBefore(nodeCache[0]).text(_this.formatter.clearHtml(nodeCache));
	        resultNodes.push($pre[0]);
	        return nodeCache.length = 0;
	      };
	    })(this);
	    $rootNodes.each((function(_this) {
	      return function(i, node) {
	        var $node, $p;
	        $node = $(node);
	        if ($node.is(htmlTag)) {
	          clearCache();
	          $p = $('<p/>').append($node.html().replace('\n', '<br/>')).replaceAll($node);
	          return resultNodes.push($p[0]);
	        } else if ($node.is(disableTag) || _this.util.isDecoratedNode($node) || $node.is('blockquote')) {
	          return clearCache();
	        } else {
	          return nodeCache.push(node);
	        }
	      };
	    })(this));
	    clearCache();
	    this.selection.setRangeAtEndOf($(resultNodes).last());
	    return this.trigger('valuechanged');

	},

	fontColor : function(hex,isDefault,coloredText) {
        var range = this.selection.range();
        if (!isDefault && range.collapsed) {
          textNode = document.createTextNode(coloredText);
          range.insertNode(textNode);
          range.selectNodeContents(textNode);
        }
        this.selection.range(range);
        document.execCommand('styleWithCSS', false, true);
        document.execCommand('foreColor', false, hex);
        document.execCommand('styleWithCSS', false, false);
        if (!this.util.support.oninput) {
          return this.trigger('valuechanged');
        }

	},

	fontScale : function(param,sizeMap) {
  		if (!sizeMap){
  			sizeMap = {
			    'x-large': '1.5em',
			    'large': '1.25em',
			    'small': '.75em',
			    'x-small': '.5em'
		   };
		}

	    var $scales, containerNode, range;
	    range = this.selection.range();
	    if (range.collapsed) {
	      return;
	    }
	    this.selection.range(range);
	    document.execCommand('styleWithCSS', false, true);
	    document.execCommand('fontSize', false, param);
	    document.execCommand('styleWithCSS', false, false);
	    this.selection.reset();
	    this.selection.range();
	    containerNode = this.selection.containerNode();
	    if (containerNode[0].nodeType === Node.TEXT_NODE) {
	      $scales = containerNode.closest('span[style*="font-size"]');
	    } else {
	      $scales = containerNode.find('span[style*="font-size"]');
	    }
	    $scales.each((function(_this) {
	      return function(i, n) {
	        var $span, size;
	        $span = $(n);
	        size = n.style.fontSize;
	        if (/large|x-large|small|x-small/.test(size)) {
	          return $span.css('fontSize', sizeMap[size]);
	        } else if (size === 'medium') {
	          if ($span[0].style.length > 1) {
	            return $span.css('fontSize', '');
	          } else {
	            return $span.replaceWith($span.contents());
	          }
	        }
	      };
	    })(this));
	    return this.trigger('valuechanged');
	},

	hr : function() {
	    var $hr, $newBlock, $nextBlock, $rootBlock;
	    $rootBlock = this.selection.rootNodes().first();
	    $nextBlock = $rootBlock.next();
	    if ($nextBlock.length > 0) {
	      this.selection.save();
	    } else {
	      $newBlock = $('<p/>').append(this.util.phBr);
	    }
	    $hr = $('<hr/>').insertAfter($rootBlock);
	    if ($newBlock) {
	      $newBlock.insertAfter($hr);
	      this.selection.setRangeAtStartOf($newBlock);
	    } else {
	      this.selection.restore();
	    }
	    return this.trigger('valuechanged');
	},

	inlineCode : function(active) {
	    var $code, $contents, range;
	    range = this.selection.range();
	    if (this.active) {
	      range.selectNodeContents(this.node[0]);
	      this.selection.save(range);
	      this.node.contents().unwrap();
	      this.selection.restore();
	    } else {
	      $contents = $(range.extractContents());
	      $code = $("<" + this.htmlTag + "/>").append($contents.contents());
	      range.insertNode($code[0]);
	      range.selectNodeContents($code[0]);
	      this.selection.range(range);
	    }
	    return this.trigger('valuechanged');

	},

	indent : function() {
	    return this.indentation.indent();
	},

	link : function(active,defaultLinkText) {
	    var $contents, $link, $newBlock, linkText, range, txtNode;
	    range = this.selection.range();
	    if (active) {
		  var node = this.selection.startNodes();
	      txtNode = document.createTextNode(node.text());
	      node.replaceWith(txtNode);
	      range.selectNode(txtNode);
	    } else {
	      $contents = $(range.extractContents());
	      linkText = this.formatter.clearHtml($contents.contents(), false);
	      $link = $('<a/>', {
	        href: '',
	        target: '_blank',
	        text: linkText || defaultLinkText
	      });
	      if (this.selection.blockNodes().length > 0) {
	        range.insertNode($link[0]);
	      } else {
	        $newBlock = $('<p/>').append($link);
	        range.insertNode($newBlock[0]);
	      }
	      range.selectNodeContents($link[0]);
	    }
	    this.selection.range(range);
	    return this.trigger('valuechanged');

	},

	list : function(type,param,disableTag) {
      var $list, $rootNodes, anotherType;
      $rootNodes = this.selection.blockNodes();
      anotherType = type === 'ul' ? 'ol' : 'ul';
      this.selection.save();
      $list = null;
      $rootNodes.each((function(_this) {
        return function(i, node) {
          var $node;
          $node = $(node);
          if ($node.is('blockquote, li') || $node.is(disableTag) || _this.util.isDecoratedNode($node) || !noder.contains(document, node)) {
            return;
          }
          if ($node.is(type)) {
            $node.children('li').each(function(i, li) {
              var $childList, $li;
              $li = $(li);
              $childList = $li.children('ul, ol').insertAfter($node);
              return $('<p/>').append($(li).html() || _this.util.phBr).insertBefore($node);
            });
            return $node.remove();
          } else if ($node.is(anotherType)) {
            return $('<' + type + '/>').append($node.contents()).replaceAll($node);
          } else if ($list && $node.prev().is($list)) {
            $('<li/>').append($node.html() || _this.util.phBr).appendTo($list);
            return $node.remove();
          } else {
            $list = $("<" + type + "><li></li></" + type + ">");
            $list.find('li').append($node.html() || _this.util.phBr);
            return $list.replaceAll($node);
          }
        };
      })(this));
      this.selection.restore();
      return this.trigger('valuechanged');

	},

	outdent : function() {
	    return this.indentation.indent(true);
	},

	// toggle
	title : function(param,disableTag) {
	    var $rootNodes;
	    $rootNodes = this.selection.rootNodes();
	    this.selection.save();
	    $rootNodes.each((function(_this) {
	      return function(i, node) {
	        var $node;
	        $node = $(node);
	        if ($node.is('blockquote') || $node.is(param) || $node.is(disableTag) || _this.util.isDecoratedNode($node)) {
	          return;
	        }
	        return $('<' + param + '/>').append($node.contents()).replaceAll($node);
	      };
	    })(this));
	    this.selection.restore();
	    return this.trigger('valuechanged');

	}



  });

	var commands =  [
		"bold", // toggle 
		"insertImage",
		"insertorderedlist",
		"insertunorderedlist",
		"italic", // toggle
		"justifyLeft",
		"justifyCenter",
		"justifyFull",
		"justifyRight",
		"strikethrough",
		"underline",
		"undo"
	];

	commands.forEach(function(cmd){
		Editable.prototype[cmd] = function() {
	      document.execCommand(cmd,false,null);
	      if (!this.util.support.oninput) {
	        this.trigger('valuechanged');
	      }
	      return $(document).trigger('selectionchange');					
		};
	});


	function editable(el,opts) {

		/*	
		if (value === undefined) {
   			return node.contentEditable == "true"
		} else {
			if (!value) {
				value = null;
			} else {
				value = "true";
			}
			datax.attr(node,"contentEditable",value);
		}
		*/
		return new Editable(el,opts);
		
	};


	return contents.Editable  = Editable;
	
});
define('skylark-widgets-wordpad/i18n',[

],function(){ 

    var i18n =  {
      'zh-CN': {
        'blockquote': '引用',
        'bold': '加粗文字',
        'code': '插入代码',
        'color': '文字颜色',
        'coloredText': '彩色文字',
        'hr': '分隔线',
        'image': '插入图片',
        'externalImage': '外链图片',
        'uploadImage': '上传图片',
        'uploadFailed': '上传失败了',
        'uploadError': '上传出错了',
        'imageUrl': '图片地址',
        'imageSize': '图片尺寸',
        'imageAlt': '图片描述',
        'restoreImageSize': '还原图片尺寸',
        'uploading': '正在上传',
        'indent': '向右缩进',
        'outdent': '向左缩进',
        'italic': '斜体文字',
        'link': '插入链接',
        'linkText': '链接文字',
        'linkUrl': '链接地址',
        'linkTarget': '打开方式',
        'openLinkInCurrentWindow': '在当前窗口中打开',
        'openLinkInNewWindow': '在新窗口中打开',
        'removeLink': '移除链接',
        'ol': '有序列表',
        'ul': '无序列表',
        'strikethrough': '删除线文字',
        'table': '表格',
        'deleteRow': '删除行',
        'insertRowAbove': '在上面插入行',
        'insertRowBelow': '在下面插入行',
        'deleteColumn': '删除列',
        'insertColumnLeft': '在左边插入列',
        'insertColumnRight': '在右边插入列',
        'deleteTable': '删除表格',
        'title': '标题',
        'normalText': '普通文本',
        'underline': '下划线文字',
        'alignment': '水平对齐',
        'alignCenter': '居中',
        'alignLeft': '居左',
        'alignRight': '居右',
        'selectLanguage': '选择程序语言',
        'fontScale': '字体大小',
        'fontScaleXLarge': '超大字体',
        'fontScaleLarge': '大号字体',
        'fontScaleNormal': '正常大小',
        'fontScaleSmall': '小号字体',
        'fontScaleXSmall': '超小字体'
      },
      'en-US': {
        'blockquote': 'Block Quote',
        'bold': 'Bold',
        'code': 'Code',
        'color': 'Text Color',
        'coloredText': 'Colored Text',
        'hr': 'Horizontal Line',
        'image': 'Insert Image',
        'externalImage': 'External Image',
        'uploadImage': 'Upload Image',
        'uploadFailed': 'Upload failed',
        'uploadError': 'Error occurs during upload',
        'imageUrl': 'Url',
        'imageSize': 'Size',
        'imageAlt': 'Alt',
        'restoreImageSize': 'Restore Origin Size',
        'uploading': 'Uploading',
        'indent': 'Indent',
        'outdent': 'Outdent',
        'italic': 'Italic',
        'link': 'Insert Link',
        'linkText': 'Text',
        'linkUrl': 'Url',
        'linkTarget': 'Target',
        'openLinkInCurrentWindow': 'Open link in current window',
        'openLinkInNewWindow': 'Open link in new window',
        'removeLink': 'Remove Link',
        'ol': 'Ordered List',
        'ul': 'Unordered List',
        'strikethrough': 'Strikethrough',
        'table': 'Table',
        'deleteRow': 'Delete Row',
        'insertRowAbove': 'Insert Row Above',
        'insertRowBelow': 'Insert Row Below',
        'deleteColumn': 'Delete Column',
        'insertColumnLeft': 'Insert Column Left',
        'insertColumnRight': 'Insert Column Right',
        'deleteTable': 'Delete Table',
        'title': 'Title',
        'normalText': 'Text',
        'underline': 'Underline',
        'alignment': 'Alignment',
        'alignCenter': 'Align Center',
        'alignLeft': 'Align Left',
        'alignRight': 'Align Right',
        'selectLanguage': 'Select Language',
        'fontScale': 'Font Size',
        'fontScaleXLarge': 'X Large Size',
        'fontScaleLarge': 'Large Size',
        'fontScaleNormal': 'Normal Size',
        'fontScaleSmall': 'Small Size',
        'fontScaleXSmall': 'X Small Size'
      },

      translate : function() {
        var args, key, ref, result;
        key = arguments[0], args = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
        result = ((ref = i18n[this.locale]) != null ? ref[key] : void 0) || '';
        if (!(args.length > 0)) {
          return result;
        }
        result = result.replace(/([^%]|^)%(?:(\d+)\$)?s/g, function(p0, p, position) {
          if (position) {
            return p + args[parseInt(position) - 1];
          } else {
            return p + args.shift();
          }
        });
        return result.replace(/%%s/g, '%s');
      }

    };

    return i18n;
});
define('skylark-widgets-wordpad/ToolButton',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-widgets-base/Widget",
  "./i18n"
],function(langx, $, Widget, i18n){ 
  var slice = [].slice;

  var ToolButton = Widget.inherit( {

    options : {
      template: '<li><a tabindex="-1" unselectable="on" class="toolbar-item" href="javascript:;"><span></span></a></li>',

      menu : {
        menuWrapper: '<div class="toolbar-menu"></div>',
        menuItem: '<li><a tabindex="-1" unselectable="on" class="menu-item" href="javascript:;"><span></span></a></li>',
        separator: '<li><span class="separator"></span></li>'      
      }

    },

    _construct : function(opts) {
      this.action = opts.action;
      this.toolbar = opts.toolbar;
      this.editor = opts.toolbar.editor;
      Widget.prototype._construct.call(this,opts);
    },

    _init : function() {
      var k, len, ref, tag;
      this.render();
      var _this = this;
      this.el.on('mousedown', function(e) {
          var exceed, noFocus, param;
          e.preventDefault();
          noFocus = _this.needFocus && !_this.editor.editable.inputManager.focused;
          if (_this.el.hasClass('disabled')) {
            return false;
          }
          if (noFocus) {
            _this.editor.focus();
          }
          if (_this.menu) {
            _this.wrapper.toggleClass('menu-on').siblings('li').removeClass('menu-on');
            if (_this.wrapper.is('.menu-on')) {
              exceed = _this.menuWrapper.offset().left + _this.menuWrapper.outerWidth() + 5 - _this.editor.wrapper.offset().left - _this.editor.wrapper.outerWidth();
              if (exceed > 0) {
                _this.menuWrapper.css({
                  'left': 'auto',
                  'right': 0
                });
              }
              _this.trigger('menuexpand');
            }
            return false;
          }
          param = _this.el.data('param');
          _this.command(param);
          return false;
      });
      this.wrapper.on('click', 'a.menu-item', function(e) {
          var btn, noFocus, param;
          e.preventDefault();
          btn = $(e.currentTarget);
          _this.wrapper.removeClass('menu-on');
          noFocus = _this.needFocus && !_this.editor.editable.inputManager.focused;
          if (btn.hasClass('disabled') || noFocus) {
            return false;
          }
          _this.toolbar.wrapper.removeClass('menu-on');
          param = btn.data('param');
          _this.command(param);
          return false;
      });
      this.wrapper.on('mousedown', 'a.menu-item', function(e) {
        return false;
      });

      this.action.state.on("changed", function(e,args) {
        var updates = args.data;
        if (updates["active"] !== undefined) {
          _this._doActive(updates["active"].value);
        }

        if (updates["disabled"] !== undefined) {
          _this._doDisabled(updates["disabled"].value);
        }

      });
    },

    _doActive : function(value) {
      return this.el.toggleClass('active', this.active);
    },

    _doDisabled : function(value) {
      return this.el.toggleClass('disabled', this.disabled);
    },

    iconClassOf : function(icon) {
      if (icon) {
        return "wordpad-icon wordpad-icon-" + icon;
      } else {
        return '';
      }
    },

    setIcon : function(icon) {
      return this.el.find('span').removeClass().addClass(this.iconClassOf(icon)).text(this.text);
    },

    render : function() {

      //this.wrapper = $(this._tpl.item).appendTo(this.toolbar.list);
      this.toolbar.addToolItem(this);
      this.wrapper = $(this._elm);

      this.el = this.wrapper.find('a.toolbar-item');
      this.el.attr('title', this.title).addClass("toolbar-item-" + this.name).data('button', this);
      this.setIcon(this.icon);
      if (!this.menu) {
        return;
      }
      this.menuWrapper = $(this.options.menu.menuWrapper).appendTo(this.wrapper);
      this.menuWrapper.addClass("toolbar-menu-" + this.name);
      return this.renderMenu();
    },

    renderMenu : function() {
      var $menuBtnEl, $menuItemEl, k, len, menuItem, ref, ref1, results;
      if (!langx.isArray(this.menu)) {
        return;
      }
      this.menuEl = $('<ul/>').appendTo(this.menuWrapper);
      ref = this.menu;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        menuItem = ref[k];
        if (menuItem === '|') {
          $(this.options.menu.separator).appendTo(this.menuEl);
          continue;
        }
        $menuItemEl = $(this.options.menu.menuItem).appendTo(this.menuEl);
        $menuBtnEl = $menuItemEl.find('a.menu-item').attr({
          'title': (ref1 = menuItem.title) != null ? ref1 : menuItem.text,
          'data-param': menuItem.param
        }).addClass('menu-item-' + menuItem.name);
        if (menuItem.icon) {
          results.push($menuBtnEl.find('span').addClass(this.iconClassOf(menuItem.icon)));
        } else {
          results.push($menuBtnEl.find('span').text(menuItem.text));
        }
      }
      return results;
    },

    command : function(params) {
      this.action.execute(params);
    },

    "name" : {
      get : function() {
        return this.action.name;
      }
    },

    "icon" : {
      get : function() {
        return this.action.icon;
      }
    },

    "title" : {
      get : function() {
        return this.action.tooltip;
      }
    },

    "text" : {
      get : function() {
        return this.action.text;
      }
    },

    "htmlTag" : {
      get : function() {
        return this.action.htmlTag;
      }
    },

    "disableTag" : {
      get : function() {
        return this.action.disableTag;
      }
    },

    "menu" : {
      get : function() {
        return this.action.menu;
      }
    },

    "editable" : {
      get : function() {
        return this._options.editable;
      }
    },

    "active" : {
      get : function() {
        return this.action.active;
      }
    },

    "disabled" : {
      get : function() {
        return this.action.disabled;
      }
    },

    "needFocus" : {
      get : function() {
        return this.action.needFocus;
      }
    },


    "shortcut" : {
      get : function() {
        return this.action.shortcut;
      }
    }


  }); 


  return ToolButton;
});

define('skylark-widgets-wordpad/addons',[],function(){
	return {
	    general : {

	    },

	    actions : {

	    },

	    toolbar : {
	      items : {
	        
	      }
	      
	    }  		
	};
});
define('skylark-widgets-wordpad/Toolbar',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-widgets-swt/Toolbar",
  "./ToolButton",
  "./addons"
],function(langx,$,_Toolbar, ToolButton,addons){ 

  var Toolbar = _Toolbar.inherit({
    pluginName : "lark.Wordpad.toolbar",

    _construct : function(editor,opts) {
      this.editor =editor;
      _Toolbar.prototype._construct.call(this,opts);
    },

    _init : function() {
      _Toolbar.prototype._init.call(this);
      this._render();
    }

  });

  Toolbar.prototype._render = function() {
    var k, len, name, ref;
    this.buttons = [];
    //this.wrapper = $(this._tpl.wrapper).prependTo(this.editor.wrapper);
    this.wrapper = $(this._elm).prependTo(this.editor.wrapper);
    ref = this.opts.toolbar;
    for (k = 0, len = ref.length; k < len; k++) {
      name = ref[k];
      if (name === '|') {
        this.addSeparator();
        continue;
      }

      var action  = this.editor.findAction(name),
          toolItemCtor = addons.toolbar.items[name];

      if (!toolItemCtor) {
        toolItemCtor = ToolButton;
      }

      this.buttons.push(new toolItemCtor({
        "action" : action,
        "toolbar" : this
      }));
    }
    if (this.opts.toolbarHidden) {
      return this.wrapper.hide();
    }
  };

  Toolbar.prototype.findButton = function(name) {
    var button;
    button = this.list.find('.toolbar-item-' + name).data('button');
    return button != null ? button : null;
  };

  Toolbar.addButton = function(btn) {
    return this.buttons[btn.prototype.name] = btn;
  };

  Toolbar.buttons = {};

  return Toolbar;

});
define('skylark-widgets-wordpad/uploader',[
  "skylark-langx/langx",
  "skylark-domx-query"
],function(langx,$){ 

  var Uploader = langx.Evented.inherit({
    init : function() {
      this.files = [];
      this.queue = [];
      this.id = ++Uploader.count;
      this.on('uploadcomplete', (function(_this) {
        return function(e, file) {
          _this.files.splice(langx.inArray(file, _this.files), 1);
          if (_this.queue.length > 0 && _this.files.length < _this.opts.connectionCount) {
            return _this.upload(_this.queue.shift());
          } else {
            return _this.uploading = false;
          }
        };
      })(this));
      return $(window).on('beforeunload.uploader-' + this.id, (function(_this) {
        return function(e) {
          if (!_this.uploading) {
            return;
          }
          e.originalEvent.returnValue = _this._t('leaveConfirm');
          return _this._t('leaveConfirm');  
        };
      })(this));
    }

  });

  Uploader.count = 0;

  Uploader.prototype.opts = {
    url: '',
    params: null,
    fileKey: 'upload_file',
    connectionCount: 3
  };



  Uploader.prototype.generateId = (function() {
    var id;
    id = 0;
    return function() {
      return id += 1;
    };
  })();

  Uploader.prototype.upload = function(file, opts) {
    var f, i, key, len;
    if (opts == null) {
      opts = {};
    }
    if (file == null) {
      return;
    }
    if (langx.isArray(file) || file instanceof FileList) {
      for (i = 0, len = file.length; i < len; i++) {
        f = file[i];
        this.upload(f, opts);
      }
    } else if ($(file).is('input:file')) {
      key = $(file).attr('name');
      if (key) {
        opts.fileKey = key;
      }
      this.upload(langx.makeArray($(file)[0].files), opts);
    } else if (!file.id || !file.obj) {
      file = this.getFile(file);
    }
    if (!(file && file.obj)) {
      return;
    }
    langx.extend(file, opts);
    if (this.files.length >= this.opts.connectionCount) {
      this.queue.push(file);
      return;
    }
    if (this.trigger('beforeupload', [file]) === false) {
      return;
    }
    this.files.push(file);
    this._xhrUpload(file);
    return this.uploading = true;
  };

  Uploader.prototype.getFile = function(fileObj) {
    var name, ref, ref1;
    if (fileObj instanceof window.File || fileObj instanceof window.Blob) {
      name = (ref = fileObj.fileName) != null ? ref : fileObj.name;
    } else {
      return null;
    }
    return {
      id: this.generateId(),
      url: this.opts.url,
      params: this.opts.params,
      fileKey: this.opts.fileKey,
      name: name,
      size: (ref1 = fileObj.fileSize) != null ? ref1 : fileObj.size,
      ext: name ? name.split('.').pop().toLowerCase() : '',
      obj: fileObj
    };
  };

  Uploader.prototype._xhrUpload = function(file) {
    var formData, k, ref, v;
    formData = new FormData();
    formData.append(file.fileKey, file.obj);
    formData.append("original_filename", file.name);
    if (file.params) {
      ref = file.params;
      for (k in ref) {
        v = ref[k];
        formData.append(k, v);
      }
    }

    //TODO
    return file.xhr = langx.xhr({
      url: file.url,
      data: formData,
      processData: false,
      contentType: false,
      type: 'POST',
      headers: {
        'X-File-Name': encodeURIComponent(file.name)
      },
      xhr: function() {
        var req;
        req = $.ajaxSettings.xhr();
        if (req) {
          req.upload.onprogress = (function(_this) {
            return function(e) {
              return _this.progress(e);
            };
          })(this);
        }
        return req;
      },
      progress: (function(_this) {
        return function(e) {
          if (!e.lengthComputable) {
            return;
          }
          return _this.trigger('uploadprogress', [file, e.loaded, e.total]);
        };
      })(this),
      error: (function(_this) {
        return function(xhr, status, err) {
          return _this.trigger('uploaderror', [file, xhr, status]);
        };
      })(this),
      success: (function(_this) {
        return function(result) {
          _this.trigger('uploadprogress', [file, file.size, file.size]);
          _this.trigger('uploadsuccess', [file, result]);
          return $(document).trigger('uploadsuccess', [file, result, _this]);
        };
      })(this),
      complete: (function(_this) {
        return function(xhr, status) {
          return _this.trigger('uploadcomplete', [file, xhr.responseText]);
        };
      })(this)
    });
  };

  Uploader.prototype.cancel = function(file) {
    var f, i, len, ref;
    if (!file.id) {
      ref = this.files;
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        if (f.id === file * 1) {
          file = f;
          break;
        }
      }
    }
    this.trigger('uploadcancel', [file]);
    if (file.xhr) {
      file.xhr.abort();
    }
    return file.xhr = null;
  };

  Uploader.prototype.readImageFile = function(fileObj, callback) {
    var fileReader, img;
    if (!langx.isFunction(callback)) {
      return;
    }
    img = new Image();
    img.onload = function() {
      return callback(img);
    };
    img.onerror = function() {
      return callback();
    };
    if (window.FileReader && FileReader.prototype.readAsDataURL && /^image/.test(fileObj.type)) {
      fileReader = new FileReader();
      fileReader.onload = function(e) {
        return img.src = e.target.result;
      };
      return fileReader.readAsDataURL(fileObj);
    } else {
      return callback();
    }
  };

  Uploader.prototype.destroy = function() {
    var file, i, len, ref;
    this.queue.length = 0;
    ref = this.files;
    for (i = 0, len = ref.length; i < len; i++) {
      file = ref[i];
      this.cancel(file);
    }
    $(window).off('.uploader-' + this.id);
    return $(document).off('.uploader-' + this.id);
  };

  Uploader.i18n = {
    'zh-CN': {
      leaveConfirm: '正在上传文件，如果离开上传会自动取消'
    }
  };

  Uploader.locale = 'zh-CN';

  return  function(opts) {
    return new Uploader(opts);
  };

});

define('skylark-widgets-wordpad/Wordpad',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-contents/Editable",
  "skylark-widgets-base/Widget",
  "./Toolbar",
  "./uploader",
  "./i18n",
  "./addons"

],function(skylark,langx, $, Editable,Widget,Toolbar,uploader,i18n,addons){ 

  var Wordpad = Widget.inherit({
      options : {
        srcNodeRef: null,
        placeholder: '',
        defaultImage: 'images/image.png',
        params: {},
        upload: false,
        template : "<div class=\"wordpad\">\n  <div class=\"wordpad-wrapper\">\n    <div class=\"wordpad-placeholder\"></div>\n    <div class=\"wordpad-body\" contenteditable=\"true\">\n    </div>\n  </div>\n</div>"
      },


    _init : function() {
      this._actions = [];

      //this.opts = langx.extend({}, this.opts, opts);
      this.opts = this.options;

      var e, editor, uploadOpts;
      this.textarea = $(this.opts.srcNodeRef);

      this.opts.placeholder = this.opts.placeholder || this.textarea.attr('placeholder');

      if (!this.textarea.length) {
        throw new Error('Wordpad: param textarea is required.');
        return;
      }

      editor = this.textarea.data('wordpad');
      if (editor != null) {
        editor.destroy();
      }
      this.id = ++Wordpad.count;
      this._render();


      var self = this;
      this.editable = new Editable(this._elm,{
        classPrefix : "wordpad-",
        textarea : this.textarea,
        body : this.body
      });

      // TODO
      this.editable.on("all",function(e,data){
        return self.trigger(e.type,data);
      });

      if (this.opts.upload && uploader) {
        uploadOpts = typeof this.opts.upload === 'object' ? this.opts.upload : {};
        this.uploader = uploader(uploadOpts);
      }

      this.toolbar = new Toolbar(this,{
        toolbar: this.opts.toolbar,
        toolbarFloat:  this.opts.toolbarFloat,
        toolbarHidden:  this.opts.toolbarHidden,
        toolbarFloatOffset:  this.opts.toolbarFloatOffset

      });

      if (this.opts.placeholder) {
        this.on('valuechanged', function() {
          return self._placeholder();
        });
      }
      this.setValue(this.textarea.val().trim() || '');
      if (this.textarea.attr('autofocus')) {
        return self.focus();
      }


    }
  });

  Wordpad.prototype.triggerHandler =  Wordpad.prototype.trigger = function(type,data) {
    var args, ref;
    args = [type];
    if (data) {
      args = args.concat(data);
    }
    langx.Evented.prototype.trigger.apply(this, args);
    return this;
  };


  //Wordpad.connect(Util);

  //Wordpad.connect(InputManager);

  //Wordpad.connect(Selection);

  //Wordpad.connect(UndoManager);

  //Wordpad.connect(Keystroke);

  //Wordpad.connect(Formatter);

  //Wordpad.connect(Toolbar);

  //Wordpad.connect(Indentation);

  //Wordpad.connect(Clipboard);

  Wordpad.count = 0;


  Wordpad.prototype._render = function() {
    var key, ref, results, val;

    //this.el = $(this._tpl).insertBefore(this.textarea);
    this.el = $(this._elm).insertBefore (this.textarea);

    this.wrapper = this.el.find('.wordpad-wrapper');
    this.body = this.wrapper.find('.wordpad-body');
    this.placeholderEl = this.wrapper.find('.wordpad-placeholder').append(this.opts.placeholder);
    this.el.data('wordpad', this);
    this.wrapper.append(this.textarea);
    this.textarea.data('wordpad', this).blur();
    this.body.attr('tabindex', this.textarea.attr('tabindex'));

    if (this.opts.params) {
      ref = this.opts.params;
      results = [];
      for (key in ref) {
        val = ref[key];
        results.push($('<input/>', {
          type: 'hidden',
          name: key,
          value: val
        }).insertAfter(this.textarea));
      }
      return results;
    }
  };

  Wordpad.prototype._placeholder = function() {
    var children;
    children = this.body.children();
    if (children.length === 0 || (children.length === 1 && this.util.isEmptyNode(children) && parseInt(children.css('margin-left') || 0) < this.opts.indentWidth)) {
      return this.placeholderEl.show();
    } else {
      return this.placeholderEl.hide();
    }
  };

  Wordpad.prototype.setValue = function(val) {
    this.hidePopover();

    this.editable.setValue(val);

    return this.trigger('valuechanged');
  };

  Wordpad.prototype.getValue = function() {
    return this.editable.getValue();
  };

  Wordpad.prototype.focus = function() {
    return this.editable.focus();
  };

  Wordpad.prototype.blur = function() {
    return this.editable.blur();
  };

  Wordpad.prototype.findAction = function(name) {
    if (!this._actions[name]) {
      if (!this.constructor.addons.actions[name]) {
        throw new Error("Wordpad: invalid action " + name);
      }

      this._actions[name] = new this.constructor.addons.actions[name]({
        editor: this
      });

    }

    return this._actions[name];
  };

  Wordpad.prototype.hidePopover = function() {
    return this.el.find('.wordpad-popover').each(function(i, popover) {
      popover = $(popover).data('popover');
      if (popover.active) {
        return popover.hide();
      }
    });
  };

  Wordpad.prototype.destroy = function() {
    this.trigger('destroy');
    this.textarea.closest('form').off('.Wordpad .wordpad-' + this.id);
    this.selection.clear();
    this.inputManager.focused = false;
    this.textarea.insertBefore(this.el).hide().val('').removeData('wordpad');
    this.el.remove();
    $(document).off('.wordpad-' + this.id);
    $(window).off('.wordpad-' + this.id);
    return this.off();
  };


  Wordpad.Toolbar = Toolbar;

  Wordpad.i18n = i18n;

  Wordpad.addons = addons;


  return skylark.attach("widgets.Wordpad",Wordpad);

});

define('skylark-widgets-base/ActionManager',[
	"skylark-langx/Evented",
	"./base"
], function(Evented,base){

	var ActionManager = Evented.inherit({
		"klassName"		:	"Manager",


		addAction : function(category,name,fn,options) {

		},

		executeAction : function() {

		},

		removeAction : function(category,name) {

		}

	});

	return base.ActionManager = ActionManager;

});


define('skylark-widgets-base/Action',[
	"skylark-langx/objects",
	"skylark-langx/Evented",
	"skylark-data-collection/HashMap",
	"./base",
	"./ActionManager"
], function(objects,Evented, HashMap, base, ActiionManager){

	var Action = Evented.inherit({
		"klassName" : "Action",

		"name"  : "",

		"category" : "",

		"text" : "",

		"tooltip" : "",

		"icon" : "",

		"shortcut" : "",

		"state"  : {
			get : function() {
				return  this._state || (this._state = new HashMap({
					checked : false,
					disabled : false
				}));
			}
		},

		_construct : function(options) {
			if (options) {
				objects.mixin(this,options);
			}
		},

		_init : function() {

		},

	    /**
	     * Executes the command. Additional arguments are passed to the executing function
	     *
	     * @return {$.Promise} a  promise that will be resolved when the command completes.
	     */
		execute: function(params){
			if (this._execute) {
				this._execute(params);
			}
			this.trigger("executed",{
				params :params
			});
		}

	});
	
	return base.Action = Action;
});



define('skylark-widgets-wordpad/Action',[
  "skylark-langx/langx",
  "skylark-widgets-base/Action",
  "./Wordpad",
  "./i18n"
],function(langx, _Action, Wordpad,i18n){ 
  var slice = [].slice;

  var Action = _Action.inherit( {
    htmlTag : '',

    disableTag : '',

    menu : false,

    active : {
      get : function() {
        return this.state.get("active");
      },

      set : function(value) {
        return this.state.set("active",value);

      }

    },

    disabled : {
      get : function() {
        return this.state.get("disabled");
      },

      set : function(value) {
        return this.state.set("disabled",value);

      }
    },

    needFocus : true,

    _construct  : function(opts) {
      _Action.prototype._construct.apply(this,arguments);
      //this.toolbar = opts.toolbar;
      //this.editor = this.toolbar.editor;
      this.title = i18n.translate(this.name);

      var _this = this;

      this.editor.on('blur', function() {
        var editorActive;
        editorActive = _this.editor.body.is(':visible') && _this.editor.body.is('[contenteditable]');
        if (!(editorActive && !_this.editor.editable.clipboard.pasting)) {
          return;
        }
        _this.setActive(false);
        return _this.setDisabled(false);
      });

      if (this.shortcut != null) {
        this.editor.editable.hotkeys.add(this.shortcut, function(e) {
          //_this.el.mousedown();
          _this.execute();
          return false;
        });
      }

      var ref = this.htmlTag.split(',');
      for (k = 0, len = ref.length; k < len; k++) {
        tag = ref[k];
        tag = langx.trim(tag);
        if (tag && langx.inArray(tag, this.editor.editable.formatter._allowedTags) < 0) {
          this.editor.editable.formatter._allowedTags.push(tag);
        }
      }
      this.editor.on('selectionchanged', function(e) {
        if (_this.editor.editable.inputManager.focused) {
          return _this._status();
        }
      });

      this._init();
    },

    _init : function() {


    },

    _disableStatus : function() {
      var disabled, endNodes, startNodes;
      startNodes = this.editor.editable.selection.startNodes();
      endNodes = this.editor.editable.selection.endNodes();
      disabled = startNodes.filter(this.disableTag).length > 0 || endNodes.filter(this.disableTag).length > 0;
      this.setDisabled(disabled);
      if (this.disabled) {
        this.setActive(false);
      }
      return this.disabled;
    },

    _activeStatus : function() {
      var active, endNode, endNodes, startNode, startNodes;
      startNodes = this.editor.editable.selection.startNodes();
      endNodes = this.editor.editable.selection.endNodes();
      startNode = startNodes.filter(this.htmlTag);
      endNode = endNodes.filter(this.htmlTag);
      active = startNode.length > 0 && endNode.length > 0 && startNode.is(endNode);
      this.node = active ? startNode : null;
      this.setActive(active);
      return this.active;
    },

    _status : function() {
      this._disableStatus();
      if (this.disabled) {
        return;
      }
      return this._activeStatus();
    },

    setActive : function(active) {
      if (active === this.active) {
        return;
      }
      this.active = active;
    },

    setDisabled : function(disabled) {
      if (disabled === this.disabled) {
        return;
      }
      this.disabled = disabled;
    }
  }); 


  Action.prototype._t = i18n.translate;


  return Action;

});
define('skylark-widgets-wordpad/Popover',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./Wordpad",
  "./i18n"
],function(langx,$,Wordpad,i18n){ 

  var Popover = langx.Evented.inherit({
     init : function(opts) {
      this.action = opts.action;
      this.editor = opts.action.editor;
      this._init();
    }
  });


  Popover.prototype.offset = {
    top: 4,
    left: 0
  };

  Popover.prototype.target = null;

  Popover.prototype.active = false;

  Popover.prototype._init = function() {
    this.el = $('<div class="wordpad-popover"></div>').appendTo(this.editor.el).data('popover', this);
    this.render();
    this.el.on('mouseenter', (function(_this) {
      return function(e) {
        return _this.el.addClass('hover');
      };
    })(this));
    return this.el.on('mouseleave', (function(_this) {
      return function(e) {
        return _this.el.removeClass('hover');
      };
    })(this));
  };

  Popover.prototype.render = function() {};

  Popover.prototype._initLabelWidth = function() {
    var $fields;
    $fields = this.el.find('.settings-field');
    if (!($fields.length > 0)) {
      return;
    }
    this._labelWidth = 0;
    $fields.each((function(_this) {
      return function(i, field) {
        var $field, $label;
        $field = $(field);
        $label = $field.find('label');
        if (!($label.length > 0)) {
          return;
        }
        return _this._labelWidth = Math.max(_this._labelWidth, $label.width());
      };
    })(this));
    return $fields.find('label').width(this._labelWidth);
  };

  Popover.prototype.show = function($target, position) {
    if (position == null) {
      position = 'bottom';
    }
    if ($target == null) {
      return;
    }
    this.el.siblings('.wordpad-popover').each(function(i, popover) {
      popover = $(popover).data('popover');
      if (popover.active) {
        return popover.hide();
      }
    });
    if (this.active && this.target) {
      this.target.removeClass('selected');
    }
    this.target = $target.addClass('selected');
    if (this.active) {
      this.refresh(position);
      return this.trigger('popovershow');
    } else {
      this.active = true;
      this.el.css({
        left: -9999
      }).show();
      if (!this._labelWidth) {
        this._initLabelWidth();
      }
      this.editor.editable.util.reflow();
      this.refresh(position);
      return this.trigger('popovershow');
    }
  };

  Popover.prototype.hide = function() {
    if (!this.active) {
      return;
    }
    if (this.target) {
      this.target.removeClass('selected');
    }
    this.target = null;
    this.active = false;
    this.el.hide();
    return this.trigger('popoverhide');
  };

  Popover.prototype.refresh = function(position) {
    var editorOffset, left, maxLeft, targetH, targetOffset, top;
    if (position == null) {
      position = 'bottom';
    }
    if (!this.active) {
      return;
    }
    editorOffset = this.editor.el.offset();
    targetOffset = this.target.offset();
    targetH = this.target.outerHeight();
    if (position === 'bottom') {
      top = targetOffset.top - editorOffset.top + targetH;
    } else if (position === 'top') {
      top = targetOffset.top - editorOffset.top - this.el.height();
    }
    maxLeft = this.editor.wrapper.width() - this.el.outerWidth() - 10;
    left = Math.min(targetOffset.left - editorOffset.left, maxLeft);
    return this.el.css({
      top: top + this.offset.top,
      left: left + this.offset.left
    });
  };

  Popover.prototype.destroy = function() {
    this.target = null;
    this.active = false;
    this.editor.off('.linkpopover');
    return this.el.remove();
  };

  Popover.prototype._t = function(name) {
    var args, ref, result;
    args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
    result = i18n.translate.apply(i18n, args);
    return result;
  };

  Wordpad.Popover = Popover;

  return Popover;

	
});
define('skylark-widgets-wordpad/addons/actions/AlignmentAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n"
],function($,addons,Action,i18n){ 
  var AlignmentAction = Action.inherit({
    name : "alignment",

    icon : 'align-left',
    
    htmlTag : 'p, h1, h2, h3, h4, td, th',

    _init : function() {
     Action.prototype._init.call(this);
     this.menu = [
          {
            name: 'left',
            text: i18n.translate('alignLeft'),
            icon: 'align-left',
            param: 'left'
          }, {
            name: 'center',
            text: i18n.translate('alignCenter'),
            icon: 'align-center',
            param: 'center'
          }, {
            name: 'right',
            text: i18n.translate('alignRight'),
            icon: 'align-right',
            param: 'right'
          }
      ] ;    
    },


    _execute : function(align) {
      return this.editor.editable.alignment(align,this.htmlTag);
    },

    setActive : function(align) {
      if (align == null) {
        align = 'left';
      }
      if (align !== 'left' && align !== 'center' && align !== 'right') {
        align = 'left';
      }
      Action.prototype.setActive.call(this, align);
   },

    _status : function() {
      var value = this.editor.editable.status("alignment",this.htmlTag);
      if (value) {
        this.setDisabled(false);
        return this.setActive(value);
      } else {
        this.setDisabled(true);
        return this.setActive("left");
      }    
    }
  });
 
  return addons.actions.alignment = AlignmentAction;
});
define('skylark-widgets-wordpad/addons/actions/BlockquoteAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
   var BlockquoteAction = Action.inherit({
      name : 'blockquote',

      icon : 'quote-left',

      htmlTag : 'blockquote',

      disableTag : 'pre, table',

      _execute : function() {
        return this.editor.editable.blockquote(this.htmlTag,this.disableTag);
      }
   });


   addons.actions.blockquote = BlockquoteAction; 

   return BlockquoteAction;
});
define('skylark-widgets-wordpad/addons/actions/BoldAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
  
    var BoldAction = Action.inherit({
      name : 'bold',

      icon : 'bold',

      htmlTag : 'b, strong',

      disableTag : 'pre',

      shortcut : 'cmd+b',

      _init : function() {
        if (this.editor.editable.util.os.mac) {
          this.title = this.title + ' ( Cmd + b )';
        } else {
          this.title = this.title + ' ( Ctrl + b )';
          this.shortcut = 'ctrl+b';
        }
        return Action.prototype._init.call(this);
      },

      _activeStatus : function() {
        var active;
        active = this.editor.editable.isActive('bold');
        this.setActive(active);
        return this.active;
      },

      _execute : function() {
        return this.editor.editable.bold();
      }

    });


    addons.actions.bold = BoldAction; 

    return BoldAction;
});
define('skylark-widgets-wordpad/addons/actions/CodePopover',[
  "skylark-domx-query",
  "../../addons",
  "../../Popover"
],function($,addons,Popover){ 
  
   var CodePopover = Popover.inherit({
     render : function() {
      var $option, k, lang, len, ref;
      this._tpl = "<div class=\"code-settings\">\n  <div class=\"settings-field\">\n    <select class=\"select-lang\">\n      <option value=\"-1\">" + (this._t('selectLanguage')) + "</option>\n    </select>\n  </div>\n</div>";
      this.langs = this.editor.opts.codeLanguages || [
        {
          name: 'Bash',
          value: 'bash'
        }, {
          name: 'C++',
          value: 'c++'
        }, {
          name: 'C#',
          value: 'cs'
        }, {
          name: 'CSS',
          value: 'css'
        }, {
          name: 'Erlang',
          value: 'erlang'
        }, {
          name: 'Less',
          value: 'less'
        }, {
          name: 'Sass',
          value: 'sass'
        }, {
          name: 'Diff',
          value: 'diff'
        }, {
          name: 'CoffeeScript',
          value: 'coffeescript'
        }, {
          name: 'HTML,XML',
          value: 'html'
        }, {
          name: 'JSON',
          value: 'json'
        }, {
          name: 'Java',
          value: 'java'
        }, {
          name: 'JavaScript',
          value: 'js'
        }, {
          name: 'Markdown',
          value: 'markdown'
        }, {
          name: 'Objective C',
          value: 'oc'
        }, {
          name: 'PHP',
          value: 'php'
        }, {
          name: 'Perl',
          value: 'parl'
        }, {
          name: 'Python',
          value: 'python'
        }, {
          name: 'Ruby',
          value: 'ruby'
        }, {
          name: 'SQL',
          value: 'sql'
        }
      ];
      this.el.addClass('code-popover').append(this._tpl);
      this.selectEl = this.el.find('.select-lang');
      ref = this.langs;
      for (k = 0, len = ref.length; k < len; k++) {
        lang = ref[k];
        $option = $('<option/>', {
          text: lang.name,
          value: lang.value
        }).appendTo(this.selectEl);
      }
      this.selectEl.on('change', (function(_this) {
        return function(e) {
          var selected;
          _this.lang = _this.selectEl.val();
          selected = _this.target.hasClass('selected');
          _this.target.removeClass().removeAttr('data-lang');
          if (_this.lang !== -1) {
            _this.target.attr('data-lang', _this.lang);
          }
          if (selected) {
            _this.target.addClass('selected');
          }
          return _this.editor.trigger('valuechanged');
        };
      })(this));
      return this.editor.on('valuechanged', (function(_this) {
        return function(e) {
          if (_this.active) {
            return _this.refresh();
          }
        };
      })(this));
    },

    show : function() {
      var args;
      args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
      Popover.prototype.show.apply(this, args);
      this.lang = this.target.attr('data-lang');
      if (this.lang != null) {
        return this.selectEl.val(this.lang);
      } else {
        return this.selectEl.val(-1);
      }
    }
   });

  return CodePopover;
});
define('skylark-widgets-wordpad/addons/actions/CodeAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "./CodePopover"
],function($,addons,Action,CodePopover){ 
  

   var CodeAction = Action.inherit({
      name : 'code',

      icon : 'code',

      htmlTag : 'pre',

      disableTag : 'ul, ol, table',

      _init : function() {
        Action.prototype._init.call(this);
        this.editor.on('decorate', (function(_this) {
          return function(e, $el) {
            return $el.find('pre').each(function(i, pre) {
              return _this.decorate($(pre));
            });
          };
        })(this));
        return this.editor.on('undecorate', (function(_this) {
          return function(e, $el) {
            return $el.find('pre').each(function(i, pre) {
              return _this.undecorate($(pre));
            });
          };
        })(this));
      },

      _checkMode : function() {
        var $blockNodes, range;
        range = this.editor.editable.selection.range();
        if (($blockNodes = $(range.cloneContents()).find(this.editor.editable.util.blockNodes.join(','))) > 0 || (range.collapsed && this.editor.editable.selection.startNodes().filter('code').length === 0)) {
          this.inlineMode = false;
          return this.htmlTag = 'pre';
        } else {
          this.inlineMode = true;
          return this.htmlTag = 'code';
        }
      },

      _status : function() {
        this._checkMode();
        Action.prototype._status.call(this);
        if (this.inlineMode) {
          return;
        }
        if (this.active) {
          if (!this.popover) {
            this.popover = new CodePopover({
              action: this
            });
          }
          return this.popover.show(this.node);
        } else {
          if (this.popover) {
            return this.popover.hide();
          }
        }
      },

      decorate : function($pre) {
        var $code, lang, ref, ref1;
        $code = $pre.find('> code');
        if ($code.length > 0) {
          lang = (ref = $code.attr('class')) != null ? (ref1 = ref.match(/lang-(\S+)/)) != null ? ref1[1] : void 0 : void 0;
          $code.contents().unwrap();
          if (lang) {
            return $pre.attr('data-lang', lang);
          }
        }
      },

      undecorate : function($pre) {
        var $code, lang;
        lang = $pre.attr('data-lang');
        $code = $('<code/>');
        if (lang && lang !== -1) {
          $code.addClass('lang-' + lang);
        }
        return $pre.wrapInner($code).removeAttr('data-lang');
      },

      _execute : function() {
        if (this.inlineMode) {
          return this._inlineCommand();
        } else {
          return this._blockCommand();
        }
      },

      _blockCommand : function() {
        return this.editor.editable.blockCode(this.htmlTag,this.disableTag);
      },

      _inlineCommand : function() {
        return this.editor.editable.inlineCode(this.active);
      }
   });


   addons.actions.code = CodeAction; 

   return CodeAction;

});
define('skylark-widgets-wordpad/addons/actions/ColorAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n"
],function($,addons,Action,i18n){ 
  

   var ColorAction = Action.inherit({
    name : 'color',

    icon : 'tint',

    disableTag : 'pre',

    menu : true

   });

   addons.actions.color = ColorAction; 


   return ColorAction;
	
});
define('skylark-widgets-wordpad/addons/actions/EmojiAction',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function(langx,$,addons,Action){ 
  var EmojiAction = Action.inherit({
    name : 'emoji',

    icon : 'smile-o',

    menu : true,

    _init : function() {
      Action.prototype._init.apply(this);
      langx.merge(this.editor.editable.formatter._allowedAttributes['img'], ['data-emoji', 'alt']);
    }

  });


  addons.actions.emoji = EmojiAction; 

  return EmojiAction;
	
});
define('skylark-widgets-wordpad/addons/actions/FontScaleAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n"
],function($,addons,Action,i18n){ 
  
  var FontScaleAction = Action.inherit({
    name : 'fontScale',

    icon : 'font',

    htmlTag : 'span',

    disableTag : 'pre, h1, h2, h3, h4, h5',


    _init : function() {
      this.menu = [
        {
          name: '150%',
          text: i18n.translate('fontScaleXLarge'),
          param: '5'
        }, {
          name: '125%',
          text: i18n.translate('fontScaleLarge'),
          param: '4'
        }, {
          name: '100%',
          text: i18n.translate('fontScaleNormal'),
          param: '3'
        }, {
          name: '75%',
          text: i18n.translate('fontScaleSmall'),
          param: '2'
        }, {
          name: '50%',
          text: i18n.translate('fontScaleXSmall'),
          param: '1'
        }
      ];
      return Action.prototype._init.call(this);
    },

    _activeStatus : function() {
      var active, endNode, endNodes, range, startNode, startNodes;
      range = this.editor.editable.selection.range();
      startNodes = this.editor.editable.selection.startNodes();
      endNodes = this.editor.editable.selection.endNodes();
      startNode = startNodes.filter('span[style*="font-size"]');
      endNode = endNodes.filter('span[style*="font-size"]');
      active = startNodes.length > 0 && endNodes.length > 0 && startNode.is(endNode);
      this.setActive(active);
      return this.active;
    },

    _execute : function(param) {
      return this.editor.editable.fontScale(param);
    }
  });


  addons.actions.fontScale = FontScaleAction; 

  return FontScaleAction;
});
define('skylark-widgets-wordpad/addons/actions/FullScreenAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n"
],function($,addons,Action,i18n){ 

  
  var FullScrennAction = Action.inherit({
    name : 'fullscreen',

    needFocus : false,

    _init : function() {
      Action.prototype._init.call(this);

      this.window = $(window);
      this.body = $('body');
      this.editable = this.editor.body;
    },

    iconClassOf : function() {
      return 'icon-fullscreen';
    },


    status : function() {
      return this.setActive(this.body.hasClass(this.constructor.cls));
    },

    _execute : function() {
      var editablePadding, isFullscreen;
      this.body.toggleClass(this.constructor.cls);
      isFullscreen = this.body.hasClass(this.constructor.cls);
      if (isFullscreen) {
        editablePadding = this.editable.outerHeight() - this.editable.height();
        this.window.on("resize.wordpad-fullscreen-" + this.editor.id, (function(_this) {
          return function() {
            return _this._resize({
              height: _this.window.height() - _this.editor.toolbar.outerHeight() - editablePadding
            });
          };
        })(this)).resize();
      } else {
        this.window.off("resize.wordpad-fullscreen-" + this.editor.id).resize();
        this._resize({
          height: 'auto'
        });
      }
      return this.setActive(isFullscreen);
    },

    _resize : function(size) {
      return this.editable.height(size.height);
    }
  });

  FullScrennAction.cls = 'wordpad-fullscreen';

  FullScrennAction.i18n = {
    'zh-CN': {
      fullscreen: '全屏'
    }
  };


  addons.actions.fullscreen = FullScrennAction; 

  return FullScrennAction;

 }); 
define('skylark-widgets-wordpad/addons/actions/HrAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
  
   var HrAction = Action.inherit({

	  name : 'hr',

	  icon : 'minus',

	  htmlTag : 'hr',

	  _status : function() {},

	  _execute : function() {
	    return this.editor.editable.hr();
	  }

   });


  addons.actions.hr = HrAction; 

  return HrAction;	
});
define('skylark-widgets-wordpad/addons/actions/HtmlAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
   var  hasProp = {}.hasOwnProperty,
        slice = [].slice;
  

   var HtmlAction = Action.inherit({
    name : 'html',

    icon : 'html5',

    needFocus : false,

    _init : function() {
      Action.prototype._init.call(this);
      this.editor.textarea.on('focus', (function(_this) {
        return function(e) {
          return _this.editor.el.addClass('focus').removeClass('error');
        };
      })(this));
      this.editor.textarea.on('blur', (function(_this) {
        return function(e) {
          _this.editor.el.removeClass('focus');
          return _this.editor.setValue(_this.editor.textarea.val());
        };
      })(this));
      return this.editor.textarea.on('input', (function(_this) {
        return function(e) {
          return _this._resizeTextarea();
        };
      })(this));
    },

    status : function() {},

    _execute : function() {
      var action, i, len, ref;
      this.editor.blur();
      this.editor.el.toggleClass('wordpad-html');
      this.editor.htmlMode = this.editor.el.hasClass('wordpad-html');
      if (this.editor.htmlMode) {
        this.editor.hidePopover();
        this.editor.textarea.val(this.beautifyHTML(this.editor.textarea.val()));
        this._resizeTextarea();
      } else {
        this.editor.setValue(this.editor.textarea.val());
      }
      ref = this.editor._actions;
      for (i = 0, len = ref.length; i < len; i++) {
        action = ref[i];
        if (action.name === 'html') {
          action.setActive(this.editor.htmlMode);
        } else {
          action.setDisabled(this.editor.htmlMode);
        }
      }
      return null;
    },

    beautifyHTML : function() {
      return arguments[0];
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (beautify.html) {
        return beautify.html.apply(beautify, args);
      } else {
        return beautify.apply(null, args);
      }
    },

    _resizeTextarea : function() {
      this._textareaPadding || (this._textareaPadding = this.editor.textarea.innerHeight() - this.editor.textarea.height());
      return this.editor.textarea.height(this.editor.textarea[0].scrollHeight - this._textareaPadding);
    }

   });


   addons.actions.html = HtmlAction; 

   return HtmlAction;
});
define('skylark-widgets-wordpad/addons/actions/ImagePopover',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "../../addons",
  "../../Popover"
],function(langx, $,addons,Popover){ 
   var ImagePopover = Popover.inherit({

   });

  ImagePopover.prototype.offset = {
    top: 6,
    left: -4
  };

  ImagePopover.prototype.render = function() {
    var tpl;
    tpl = "<div class=\"link-settings\">\n  <div class=\"settings-field\">\n    <label>" + (this._t('imageUrl')) + "</label>\n    <input class=\"image-src\" type=\"text\" tabindex=\"1\" />\n    <a class=\"btn-upload\" href=\"javascript:;\"\n      title=\"" + (this._t('uploadImage')) + "\" tabindex=\"-1\">\n      <span class=\"wordpad-icon wordpad-icon-upload\"></span>\n    </a>\n  </div>\n  <div class='settings-field'>\n    <label>" + (this._t('imageAlt')) + "</label>\n    <input class=\"image-alt\" id=\"image-alt\" type=\"text\" tabindex=\"1\" />\n  </div>\n  <div class=\"settings-field\">\n    <label>" + (this._t('imageSize')) + "</label>\n    <input class=\"image-size\" id=\"image-width\" type=\"text\" tabindex=\"2\" />\n    <span class=\"times\">×</span>\n    <input class=\"image-size\" id=\"image-height\" type=\"text\" tabindex=\"3\" />\n    <a class=\"btn-restore\" href=\"javascript:;\"\n      title=\"" + (this._t('restoreImageSize')) + "\" tabindex=\"-1\">\n      <span class=\"wordpad-icon wordpad-icon-undo\"></span>\n    </a>\n  </div>\n</div>";
    this.el.addClass('image-popover').append(tpl);
    this.srcEl = this.el.find('.image-src');
    this.widthEl = this.el.find('#image-width');
    this.heightEl = this.el.find('#image-height');
    this.altEl = this.el.find('#image-alt');
    this.srcEl.on('keydown', (function(_this) {
      return function(e) {
        var range;
        if (!(e.which === 13 && !_this.target.hasClass('uploading'))) {
          return;
        }
        e.preventDefault();
        range = document.createRange();
        _this.Action.editor.editable.selection.setRangeAfter(_this.target, range);
        return _this.hide();
      };
    })(this));
    this.srcEl.on('blur', (function(_this) {
      return function(e) {
        return _this._loadImage(_this.srcEl.val());
      };
    })(this));
    this.el.find('.image-size').on('blur', (function(_this) {
      return function(e) {
        _this._resizeImg($(e.currentTarget));
        return _this.el.data('popover').refresh();
      };
    })(this));
    this.el.find('.image-size').on('keyup', (function(_this) {
      return function(e) {
        var inputEl;
        inputEl = $(e.currentTarget);
        if (!(e.which === 13 || e.which === 27 || e.which === 9)) {
          return _this._resizeImg(inputEl, true);
        }
      };
    })(this));
    this.el.find('.image-size').on('keydown', (function(_this) {
      return function(e) {
        var $img, inputEl, range;
        inputEl = $(e.currentTarget);
        if (e.which === 13 || e.which === 27) {
          e.preventDefault();
          if (e.which === 13) {
            _this._resizeImg(inputEl);
          } else {
            _this._restoreImg();
          }
          $img = _this.target;
          _this.hide();
          range = document.createRange();
          return _this.Action.editor.editable.selection.setRangeAfter($img, range);
        } else if (e.which === 9) {
          return _this.el.data('popover').refresh();
        }
      };
    })(this));
    this.altEl.on('keydown', (function(_this) {
      return function(e) {
        var range;
        if (e.which === 13) {
          e.preventDefault();
          range = document.createRange();
          _this.Action.editor.editable.selection.setRangeAfter(_this.target, range);
          return _this.hide();
        }
      };
    })(this));
    this.altEl.on('keyup', (function(_this) {
      return function(e) {
        if (e.which === 13 || e.which === 27 || e.which === 9) {
          return;
        }
        _this.alt = _this.altEl.val();
        return _this.target.attr('alt', _this.alt);
      };
    })(this));
    this.el.find('.btn-restore').on('click', (function(_this) {
      return function(e) {
        _this._restoreImg();
        return _this.el.data('popover').refresh();
      };
    })(this));
    this.editor.on('valuechanged', (function(_this) {
      return function(e) {
        if (_this.active) {
          return _this.refresh();
        }
      };
    })(this));
    return this._initUploader();
  };

  ImagePopover.prototype._initUploader = function() {
    var $uploadBtn, createInput;
    $uploadBtn = this.el.find('.btn-upload');
    if (this.editor.uploader == null) {
      $uploadBtn.remove();
      return;
    }
    createInput = (function(_this) {
      return function() {
        if (_this.input) {
          _this.input.remove();
        }
        return _this.input = $('<input/>', {
          type: 'file',
          title: _this._t('uploadImage'),
          multiple: true,
          accept: 'image/gif,image/jpeg,image/jpg,image/png,image/svg'
        }).appendTo($uploadBtn);
      };
    })(this);
    createInput();
    this.el.on('click mousedown', 'input[type=file]', function(e) {
      return e.stopPropagation();
    });
    return this.el.on('change', 'input[type=file]', (function(_this) {
      return function(e) {
        _this.editor.uploader.upload(_this.input, {
          inline: true,
          img: _this.target
        });
        return createInput();
      };
    })(this));
  };

  ImagePopover.prototype._resizeImg = function(inputEl, onlySetVal) {
    var height, value, width;
    if (onlySetVal == null) {
      onlySetVal = false;
    }
    value = inputEl.val() * 1;
    if (!(this.target && (langx.isNumber(value) || value < 0))) {
      return;
    }
    if (inputEl.is(this.widthEl)) {
      width = value;
      height = this.height * value / this.width;
      this.heightEl.val(height);
    } else {
      height = value;
      width = this.width * value / this.height;
      this.widthEl.val(width);
    }
    if (!onlySetVal) {
      this.target.attr({
        width: width,
        height: height
      });
      return this.editor.trigger('valuechanged');
    }
  };

  ImagePopover.prototype._restoreImg = function() {
    var ref, size;
    size = ((ref = this.target.data('image-size')) != null ? ref.split(",") : void 0) || [this.width, this.height];
    this.target.attr({
      width: size[0] * 1,
      height: size[1] * 1
    });
    this.widthEl.val(size[0]);
    this.heightEl.val(size[1]);
    return this.editor.trigger('valuechanged');
  };

  ImagePopover.prototype._loadImage = function(src, callback) {
    if (/^data:image/.test(src) && !this.editor.uploader) {
      if (callback) {
        callback(false);
      }
      return;
    }
    if (this.target.attr('src') === src) {
      return;
    }
    return this.Action.loadImage(this.target, src, (function(_this) {
      return function(img) {
        var blob;
        if (!img) {
          return;
        }
        if (_this.active) {
          _this.width = img.width;
          _this.height = img.height;
          _this.widthEl.val(_this.width);
          _this.heightEl.val(_this.height);
        }
        if (/^data:image/.test(src)) {
          blob = _this.editor.editable.util.dataURLtoBlob(src);
          blob.name = "Base64 Image.png";
          _this.editor.uploader.upload(blob, {
            inline: true,
            img: _this.target
          });
        } else {
          _this.editor.trigger('valuechanged');
        }
        if (callback) {
          return callback(img);
        }
      };
    })(this));
  };

  ImagePopover.prototype.show = function() {
    var $img, args;
    args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
    Popover.prototype.show.apply(this, args);
    $img = this.target;
    this.width = $img.width();
    this.height = $img.height();
    this.alt = $img.attr('alt');
    if ($img.hasClass('uploading')) {
      return this.srcEl.val(this._t('uploading')).prop('disabled', true);
    } else {
      this.srcEl.val($img.attr('src')).prop('disabled', false);
      this.widthEl.val(this.width);
      this.heightEl.val(this.height);
      return this.altEl.val(this.alt);
    }
  };

  return ImagePopover;

});
define('skylark-widgets-wordpad/addons/actions/ImageAction',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "./ImagePopover",
  "../../i18n"
],function(langx, $,addons,Action,ImagePopover,i18n){ 
   var ImageAction = Action.inherit({
      name : 'image',

      icon : 'picture-o',

      htmlTag : 'img',

      disableTag : 'pre, table',

      defaultImage : '',

      needFocus : false,

      _init : function() {
        var item, k, len, ref;
        if (this.editor.opts.imageAction) {
          if (Array.isArray(this.editor.opts.imageAction)) {
            this.menu = [];
            ref = this.editor.opts.imageAction;
            for (k = 0, len = ref.length; k < len; k++) {
              item = ref[k];
              this.menu.push({
                name: item + '-image',
                text: this._t(item + 'Image')
              });
            }
          } else {
            this.menu = false;
          }
        } else {
          if (this.editor.uploader != null) {
            this.menu = [
              {
                name: 'upload-image',
                text: i18n.translate('uploadImage')
              }, {
                name: 'external-image',
                text: i18n.translate('externalImage')
              }
            ];
          } else {
            this.menu = false;
          }
        }
        this.defaultImage = this.editor.opts.defaultImage;
        this.editor.body.on('click', 'img:not([data-non-image])', (function(_this) {
          return function(e) {
            var $img, range;
            $img = $(e.currentTarget);
            range = document.createRange();
            range.selectNode($img[0]);
            _this.editor.editable.selection.range(range);
            if (!_this.editor.editable.util.support.onselectionchange) {
              _this.editor.trigger('selectionchanged');
            }
            return false;
          };
        })(this));
        this.editor.body.on('mouseup', 'img:not([data-non-image])', function(e) {
          return false;
        });
        this.editor.on('selectionchanged.image', (function(_this) {
          return function() {
            var $contents, $img, range;
            range = _this.editor.editable.selection.range();
            if (range == null) {
              return;
            }
            $contents = $(range.cloneContents()).contents();
            if ($contents.length === 1 && $contents.is('img:not([data-non-image])')) {
              $img = $(range.startContainer).contents().eq(range.startOffset);
              if (!_this.popover) {
                _this.popover = new ImagePopover({
                  action: _this
                });                
              }

              return _this.popover.show($img);
            } else {
              if (_this.popover) {
                  return _this.popover.hide();
              }
            }
          };
        })(this));
        this.editor.on('valuechanged.image', (function(_this) {
          return function() {
            var $masks;
            $masks = _this.editor.wrapper.find('.wordpad-image-loading');
            if (!($masks.length > 0)) {
              return;
            }
            return $masks.each(function(i, mask) {
              var $img, $mask, file;
              $mask = $(mask);
              $img = $mask.data('img');
              if (!($img && $img.parent().length > 0)) {
                $mask.remove();
                if ($img) {
                  file = $img.data('file');
                  if (file) {
                    _this.editor.uploader.cancel(file);
                    if (_this.editor.body.find('img.uploading').length < 1) {
                      return _this.editor.uploader.trigger('uploadready', [file]);
                    }
                  }
                }
              }
            });
          };
        })(this));
        return Action.prototype._init.call(this);
      },

      render : function() {
        var args;
        args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
        Action.prototype.render.apply(this, args);
        this.popover = new ImagePopover({
          Action: this
        });
        if (this.editor.opts.imageAction === 'upload') {
          return this._initUploader(this.el);
        }
      },

      renderMenu : function() {
        Action.prototype.renderMenu.call(this);
        return this._initUploader();
      },

      _initUploader : function($uploadItem) {
        var $input, createInput, uploadProgress;
        if ($uploadItem == null) {
          $uploadItem = this.menuEl.find('.menu-item-upload-image');
        }
        if (this.editor.uploader == null) {
          this.el.find('.btn-upload').remove();
          return;
        }
        $input = null;
        createInput = (function(_this) {
          return function() {
            if ($input) {
              $input.remove();
            }
            return $input = $('<input/>', {
              type: 'file',
              title: _this._t('uploadImage'),
              multiple: true,
              accept: 'image/gif,image/jpeg,image/jpg,image/png,image/svg'
            }).appendTo($uploadItem);
          };
        })(this);
        createInput();
        $uploadItem.on('click mousedown', 'input[type=file]', function(e) {
          return e.stopPropagation();
        });
        $uploadItem.on('change', 'input[type=file]', (function(_this) {
          return function(e) {
            if (_this.editor.editable.inputManager.focused) {
              _this.editor.uploader.upload($input, {
                inline: true
              });
              createInput();
            } else {
              _this.editor.one('focus', function(e) {
                _this.editor.uploader.upload($input, {
                  inline: true
                });
                return createInput();
              });
              _this.editor.focus();
            }
            return _this.wrapper.removeClass('menu-on');
          };
        })(this));
        this.editor.uploader.on('beforeupload', (function(_this) {
          return function(e, file) {
            var $img;
            if (!file.inline) {
              return;
            }
            if (file.img) {
              $img = $(file.img);
            } else {
              $img = _this.createImage(file.name);
              file.img = $img;
            }
            $img.addClass('uploading');
            $img.data('file', file);
            return _this.editor.uploader.readImageFile(file.obj, function(img) {
              var src;
              if (!$img.hasClass('uploading')) {
                return;
              }
              src = img ? img.src : _this.defaultImage;
              return _this.loadImage($img, src, function() {
                if (_this.popover.active) {
                  _this.popover.refresh();
                  return _this.popover.srcEl.val(_this._t('uploading')).prop('disabled', true);
                }
              });
            });
          };
        })(this));
        uploadProgress = langx.proxy(this.editor.editable.util.throttle(function(e, file, loaded, total) {
          var $img, $mask, percent;
          if (!file.inline) {
            return;
          }
          $mask = file.img.data('mask');
          if (!$mask) {
            return;
          }
          $img = $mask.data('img');
          if (!($img.hasClass('uploading') && $img.parent().length > 0)) {
            $mask.remove();
            return;
          }
          percent = loaded / total;
          percent = (percent * 100).toFixed(0);
          if (percent > 99) {
            percent = 99;
          }
          return $mask.find('.progress').height((100 - percent) + "%");
        }, 500), this);
        this.editor.uploader.on('uploadprogress', uploadProgress);
        this.editor.uploader.on('uploadsuccess', (function(_this) {
          return function(e, file, result) {
            var $img, img_path, msg;
            if (!file.inline) {
              return;
            }
            $img = file.img;
            if (!($img.hasClass('uploading') && $img.parent().length > 0)) {
              return;
            }
            if (typeof result !== 'object') {
              try {
                result = JSON.parse(result);
              } catch (_error) {
                e = _error;
                result = {
                  success: false
                };
              }
            }
            if (result.success === false) {
              msg = result.msg || _this._t('uploadFailed');
              alert(msg);
              img_path = _this.defaultImage;
            } else {
              img_path = result.file_path;
            }
            _this.loadImage($img, img_path, function() {
              var $mask;
              $img.removeData('file');
              $img.removeClass('uploading').removeClass('loading');
              $mask = $img.data('mask');
              if ($mask) {
                $mask.remove();
              }
              $img.removeData('mask');
              _this.editor.trigger('valuechanged');
              if (_this.editor.body.find('img.uploading').length < 1) {
                return _this.editor.uploader.trigger('uploadready', [file, result]);
              }
            });
            if (_this.popover.active) {
              _this.popover.srcEl.prop('disabled', false);
              return _this.popover.srcEl.val(result.file_path);
            }
          };
        })(this));
        return this.editor.uploader.on('uploaderror', (function(_this) {
          return function(e, file, xhr) {
            var $img, msg, result;
            if (!file.inline) {
              return;
            }
            if (xhr.statusText === 'abort') {
              return;
            }
            if (xhr.responseText) {
              try {
                result = JSON.parse(xhr.responseText);
                msg = result.msg;
              } catch (_error) {
                e = _error;
                msg = _this._t('uploadError');
              }
            }
            $img = file.img;
            if (!($img.hasClass('uploading') && $img.parent().length > 0)) {
              return;
            }
            _this.loadImage($img, _this.defaultImage, function() {
              var $mask;
              $img.removeData('file');
              $img.removeClass('uploading').removeClass('loading');
              $mask = $img.data('mask');
              if ($mask) {
                $mask.remove();
              }
              return $img.removeData('mask');
            });
            if (_this.popover.active) {
              _this.popover.srcEl.prop('disabled', false);
              _this.popover.srcEl.val(_this.defaultImage);
            }
            _this.editor.trigger('valuechanged');
            if (_this.editor.body.find('img.uploading').length < 1) {
              return _this.editor.uploader.trigger('uploadready', [file, result]);
            }
          };
        })(this));
      },

      _status : function() {
        return this._disableStatus();
      },

      loadImage : function($img, src, callback) {
        var $mask, img, positionMask;
        positionMask = (function(_this) {
          return function() {
            var imgOffset, wrapperOffset;
            imgOffset = $img.offset();
            wrapperOffset = _this.editor.wrapper.offset();
            return $mask.css({
              top: imgOffset.top - wrapperOffset.top,
              left: imgOffset.left - wrapperOffset.left,
              width: $img.width(),
              height: $img.height()
            }).show();
          };
        })(this);
        $img.addClass('loading');
        $mask = $img.data('mask');
        if (!$mask) {
          $mask = $('<div class="wordpad-image-loading">\n  <div class="progress"></div>\n</div>').hide().appendTo(this.editor.wrapper);
          positionMask();
          $img.data('mask', $mask);
          $mask.data('img', $img);
        }
        img = new Image();
        img.onload = (function(_this) {
          return function() {
            var height, width;
            if (!$img.hasClass('loading') && !$img.hasClass('uploading')) {
              return;
            }
            width = img.width;
            height = img.height;
            $img.attr({
              src: src,
              width: width,
              height: height,
              'data-image-size': width + ',' + height
            }).removeClass('loading');
            if ($img.hasClass('uploading')) {
              _this.editor.editable.util.reflow(_this.editor.body);
              positionMask();
            } else {
              $mask.remove();
              $img.removeData('mask');
            }
            if (langx.isFunction(callback)) {
              return callback(img);
            }
          };
        })(this);
        img.onerror = function() {
          if (langx.isFunction(callback)) {
            callback(false);
          }
          $mask.remove();
          return $img.removeData('mask').removeClass('loading');
        };
        return img.src = src;
      },

      createImage : function(name) {
        var $img, range;
        if (name == null) {
          name = 'Image';
        }
        if (!this.editor.editable.inputManager.focused) {
          this.editor.focus();
        }
        range = this.editor.editable.selection.range();
        range.deleteContents();
        this.editor.editable.selection.range(range);
        $img = $('<img/>').attr('alt', name);
        range.insertNode($img[0]);
        this.editor.editable.selection.setRangeAfter($img, range);
        this.editor.trigger('valuechanged');
        return $img;
      },

      _execute : function(src) {
        var $img;
        $img = this.createImage();
        return this.loadImage($img, src || this.defaultImage, (function(_this) {
          return function() {
            _this.editor.trigger('valuechanged');
            _this.editor.editable.util.reflow($img);
            $img.click();
            return _this.popover.one('popovershow', function() {
              _this.popover.srcEl.focus();
              return _this.popover.srcEl[0].select();
            });
          };
        })(this));
      }

   });

   addons.actions.image = ImageAction; 

   return ImageAction;

});
define('skylark-widgets-wordpad/addons/actions/IndentAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
  
   var IndentAction = Action.inherit({
      name :'indent',

      icon : 'indent',

      _init : function() {
        var hotkey;
        hotkey = this.editor.opts.tabIndent === false ? '' : ' (Tab)';
        this.title = this._t(this.name) + hotkey;
        return Action.prototype._init.call(this);
      },

      _execute : function() {
        return this.editor.editable.indent()
      }

   });


   addons.actions.indent = IndentAction; 

   return IndentAction;
});
define('skylark-widgets-wordpad/addons/actions/ItalicAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
  

  var ItalicAction = Action.inherit({
      name : 'italic',

      icon : 'italic',

      htmlTag : 'i',

      disableTag : 'pre',

      shortcut : 'cmd+i',

      _init : function() {
        if (this.editor.editable.util.os.mac) {
          this.title = this.title + " ( Cmd + i )";
        } else {
          this.title = this.title + " ( Ctrl + i )";
          this.shortcut = 'ctrl+i';
        }
        return Action.prototype._init.call(this);
      },

      _activeStatus : function() {
        var active;
        active = this.editor.editable.isActive('italic');
        this.setActive(active);
        return this.active;
      },

      _execute : function() {
        return this.editor.editable.italic();
      }
   });


   addons.actions.italic = ItalicAction; 

   return ItalicAction;

});
define('skylark-widgets-wordpad/addons/actions/LinkPopover',[
  "skylark-domx-query",
  "../../addons",
  "../../Popover"
],function($,addons,Popover){ 
  var LinkPopover = Popover.inherit({
    render : function() {
      var tpl;
      tpl = "<div class=\"link-settings\">\n  <div class=\"settings-field\">\n    <label>" + (this._t('linkText')) + "</label>\n    <input class=\"link-text\" type=\"text\"/>\n    <a class=\"btn-unlink\" href=\"javascript:;\" title=\"" + (this._t('removeLink')) + "\"\n      tabindex=\"-1\">\n      <span class=\"wordpad-icon wordpad-icon-unlink\"></span>\n    </a>\n  </div>\n  <div class=\"settings-field\">\n    <label>" + (this._t('linkUrl')) + "</label>\n    <input class=\"link-url\" type=\"text\"/>\n  </div>\n  <div class=\"settings-field\">\n    <label>" + (this._t('linkTarget')) + "</label>\n    <select class=\"link-target\">\n      <option value=\"_blank\">" + (this._t('openLinkInNewWindow')) + " (_blank)</option>\n      <option value=\"_self\">" + (this._t('openLinkInCurrentWindow')) + " (_self)</option>\n    </select>\n  </div>\n</div>";
      this.el.addClass('link-popover').append(tpl);
      this.textEl = this.el.find('.link-text');
      this.urlEl = this.el.find('.link-url');
      this.unlinkEl = this.el.find('.btn-unlink');
      this.selectTarget = this.el.find('.link-target');
      this.textEl.on('keyup', (function(_this) {
        return function(e) {
          if (e.which === 13) {
            return;
          }
          _this.target.text(_this.textEl.val());
          return _this.editor.editable.inputManager.throttledValueChanged();
        };
      })(this));
      this.urlEl.on('keyup', (function(_this) {
        return function(e) {
          var val;
          if (e.which === 13) {
            return;
          }
          val = _this.urlEl.val();
          if (!(/^(http|https|ftp|ftps|file)?:\/\/|^(mailto|tel)?:|^\//ig.test(val) || !val)) {
            val = 'http://' + val;
          }
          _this.target.attr('href', val);
          return _this.editor.editable.inputManager.throttledValueChanged();
        };
      })(this));
      $([this.urlEl[0], this.textEl[0]]).on('keydown', (function(_this) {
        return function(e) {
          var range;
          if (e.which === 13 || e.which === 27 || (!e.shiftKey && e.which === 9 && $(e.target).hasClass('link-url'))) {
            e.preventDefault();
            range = document.createRange();
            _this.editor.editable.selection.setRangeAfter(_this.target, range);
            _this.hide();
            return _this.editor.editable.inputManager.throttledValueChanged();
          }
        };
      })(this));
      this.unlinkEl.on('click', (function(_this) {
        return function(e) {
          var range, txtNode;
          txtNode = document.createTextNode(_this.target.text());
          _this.target.replaceWith(txtNode);
          _this.hide();
          range = document.createRange();
          _this.editor.editable.selection.setRangeAfter(txtNode, range);
          return _this.editor.editable.inputManager.throttledValueChanged();
        };
      })(this));
      return this.selectTarget.on('change', (function(_this) {
        return function(e) {
          _this.target.attr('target', _this.selectTarget.val());
          return _this.editor.editable.inputManager.throttledValueChanged();
        };
      })(this));
    },

    show : function() {
      var args;
      args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
      Popover.prototype.show.apply(this, args);
      this.textEl.val(this.target.text());
      return this.urlEl.val(this.target.attr('href'));
    }
  });

  return LinkPopover;
});
define('skylark-widgets-wordpad/addons/actions/LinkAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n",
  "./LinkPopover"
],function($,addons,Action,i18n,LinkPopover){ 
  

  var LinkAction = Action.inherit({
    name : 'link',

    icon : 'link',

    htmlTag : 'a',

    disableTag : 'pre',

    _status : function() {
     Action.prototype._status.call(this);
      if (this.active && !this.editor.editable.selection.rangeAtEndOf(this.node)) {
        if (!this.popover) {
          this.popover = new LinkPopover({
            action: this
          });
        }
        return this.popover.show(this.node);
      } else {
        if (this.popover) {
          return this.popover.hide();
        }
      }
    },

    _execute : function() {
      if (this.active) {
        this.popover.one('popovershow', (function(_this) {
          return function() {
            if (linkText) {
              _this.popover.urlEl.focus();
              return _this.popover.urlEl[0].select();
            } else {
              _this.popover.textEl.focus();
              return _this.popover.textEl[0].select();
            }
          };
        })(this));

      }

      return this.editor.editable.link(this.active,i18n.translate('linkText'));

    }

   });



  addons.actions.link = LinkAction; 

  return LinkAction;

});
define('skylark-widgets-wordpad/addons/actions/ListAction',[
  "skylark-domx-noder",
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function(noder,$,addons,Action){ 
  var ListAction = Action.inherit({
    type : '',

    disableTag : 'pre, table',

    _execute : function(param) {
      return this.editor.editable.list(this.type,param,this.disableTag);
    }

   });



    return ListAction;
	
});
define('skylark-widgets-wordpad/addons/actions/MarkAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n"
],function($,addons,Action,i18n){ 


  var MarkAction = Action.inherit({
    name : 'mark',

    icon : 'mark',

    htmlTag : 'mark',

    disableTag : 'pre, table',

    _execute : function() {
      var $end, $start, range;
      range = this.editor.editable.selection.range();
      if (this.active) {
        this.editor.editable.selection.save();
        this.unmark(range);
        this.editor.editable.selection.restore();
        this.editor.trigger('valuechanged');
        return;
      }
      if (range.collapsed) {
        return;
      }
      this.editor.editable.selection.save();
      $start = $(range.startContainer);
      $end = $(range.endContainer);
      if ($start.closest('mark').length) {
        range.setStartBefore($start.closest('mark')[0]);
      }
      if ($end.closest('mark').length) {
        range.setEndAfter($end.closest('mark')[0]);
      }
      this.mark(range);
      this.editor.editable.selection.restore();
      this.editor.trigger('valuechanged');
      if (this.editor.editable.util.support.onselectionchange) {
        return this.editor.trigger('selectionchanged');
      }
    },

    mark : function(range) {
      var $contents, $mark;
      if (range == null) {
        range = this.editor.editable.selection.range();
      }
      $contents = $(range.extractContents());
      $contents.find('mark').each(function(index, ele) {
        return $(ele).replaceWith($(ele).html());
      });
      $mark = $('<mark>').append($contents);
      return range.insertNode($mark[0]);
    },

    unmark : function(range) {
      var $mark;
      if (range == null) {
        range = this.editor.editable.selection.range();
      }
      if (range.collapsed) {
        $mark = $(range.commonAncestorContainer);
        if (!$mark.is('mark')) {
          $mark = $mark.parent();
        }
      } else if ($(range.startContainer).closest('mark').length) {
        $mark = $(range.startContainer).closest('mark');
      } else if ($(range.endContainer).closest('mark').length) {
        $mark = $(range.endContainer).closest('mark');
      }
      return $mark.replaceWith($mark.html());
    }

  });

  
  addons.actions.mark = MarkAction;

  return MarkAction;

 }); 
define('skylark-widgets-wordpad/addons/actions/OrderListAction',[
  "skylark-domx-query",
  "../../addons",
  "./ListAction"
],function($,addons,ListAction){ 
  var OrderListAction = ListAction.inherit({
    type : 'ol',

    name : 'ol',

    icon : 'list-ol',

    htmlTag : 'ol',

    shortcut : 'cmd+/',

    _init : function() {
      if (this.editor.editable.util.os.mac) {
        this.title = this.title + ' ( Cmd + / )';
      } else {
        this.title = this.title + ' ( ctrl + / )';
        this.shortcut = 'ctrl+/';
      }
      return ListAction.prototype._init.call(this);
    }

   });

    return addons.actions.ol = OrderListAction;	
});
define('skylark-widgets-wordpad/addons/actions/OutdentAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
  var OutdentAction = Action.inherit({
    name : 'outdent',

    icon : 'outdent',

    _init : function() {
      var hotkey;
      hotkey = this.editor.opts.tabIndent === false ? '' : ' (Shift + Tab)';
      this.title = this._t(this.name) + hotkey;
      return Action.prototype._init.call(this);
    },

    _status : function() {},

    _execute : function() {
      return this.editor.editable.outdent();
    }

   });


   addons.actions.outdent = OutdentAction; 
 
   return OutdentAction;

});
define('skylark-widgets-wordpad/addons/actions/StrikethroughAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){ 
  
  var StrikethroughAction = Action.inherit({
    name : 'strikethrough',

    icon : 'strikethrough',

    htmlTag : 'strike',

    disableTag : 'pre',

    _activeStatus : function() {
      var active;
      active = this.editor.editable.isActive('strikethrough');
      this.setActive(active);
      return this.active;
    },

    _execute : function() {
      return this.editor.editable.strikethrough();
    }

  });


  return addons.actions.strikethrough = StrikethroughAction;	
});
define('skylark-domx-tables/tables',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-query",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "skylark-domx-fx",
    "skylark-domx-data",
    "skylark-domx-finder",
    "skylark-domx-geom"
], function(skylark, langx,$) {
  //TODO : don't use query

  function tables() {
      return tables;
  }

  function _changeCellTag($tr, tagName) {
    return $tr.find('td, th').each(function(i, cell) {
      var $cell;
      $cell = $(cell);
      return $cell.replaceWith("<" + tagName + ">" + ($cell.html()) + "</" + tagName + ">");
    });
  }

  function _nextRow($tr) {
    var $nextTr;
    $nextTr = $tr.next('tr');
    if ($nextTr.length < 1 && $tr.parent('thead').length > 0) {
      $nextTr = $tr.parent('thead').next('tbody').find('tr:first');
    }
    return $nextTr;
  };

  function _prevRow($tr) {
    var $prevTr;
    $prevTr = $tr.prev('tr');
    if ($prevTr.length < 1 && $tr.parent('tbody').length > 0) {
      $prevTr = $tr.parent('tbody').prev('thead').find('tr');
    }
    return $prevTr;
  }

  function createTable(row, col, phBr) {
    var $table, $tbody, $td, $thead, $tr, c, k, l, r, ref, ref1;
    $table = $('<table/>');
    $thead = $('<thead/>').appendTo($table);
    $tbody = $('<tbody/>').appendTo($table);
    for (r = k = 0, ref = row; 0 <= ref ? k < ref : k > ref; r = 0 <= ref ? ++k : --k) {
        $tr = $('<tr/>');
        $tr.appendTo(r === 0 ? $thead : $tbody);
        for (c = l = 0, ref1 = col; 0 <= ref1 ? l < ref1 : l > ref1; c = 0 <= ref1 ? ++l : --l) {
          $td = $(r === 0 ? '<th/>' : '<td/>').appendTo($tr);
          if (phBr) {
              $td.append(phBr);
          }
        }
    }   
    return $table[0];
  }
    

  //cls = simditor-table
  function decorate(table,cssClasses) {
    var $table = $(table);

    var $colgroup, $headRow, $resizeHandle, $tbody, $thead, $wrapper;
    if ($table.parent('.' + cssClasses.tableDecorate).length > 0) {
      undecorate(table);
    }
    $table.wrap('<div class="' + cssClasses.tableDecorate + '"></div>');
    $wrapper = $table.parent('.' + cssClasses.tableDecorate );
    $colgroup = $table.find('colgroup');
    if ($table.find('thead').length < 1) {
      $thead = $('<thead />');
      $headRow = $table.find('tr').first();
      $thead.append($headRow);
      _changeCellTag($headRow, 'th');
      $tbody = $table.find('tbody');
      if ($tbody.length > 0) {
        $tbody.before($thead);
      } else {
        $table.prepend($thead);
      }
    }
    if ($colgroup.length < 1) {
      $colgroup = $('<colgroup/>').prependTo($table);
      $table.find('thead tr th').each(function(i, td) {
        var $col;
        return $col = $('<col/>').appendTo($colgroup);
      });
      refreshTableWidth($table);
    }
    $resizeHandle = $('<div />', {
      "class": cssClasses.resizeHandle, // 'simditor-resize-handle',
      contenteditable: 'false'
    }).appendTo($wrapper);
    return $table.parent();
  }

  function deleteTable(td,callback) {
    var $td = $(td);

    var $block, $table;
    $table = $td.closest('.simditor-table');
    $block = $table.next('p');
    $table.remove();
    if (callback) {
      callback($block);
    }
  }

  function deleteRow(td,callback) {
    var $td = $(td);

    var $newTr, $tr, index;
    $tr = $td.parent('tr');
    if ($tr.closest('table').find('tr').length < 1) {
      return deleteTable(td);
    } else {
      $newTr = _nextRow($tr);
      if (!($newTr.length > 0)) {
        $newTr = _prevRow($tr);
      }
      index = $tr.find('td, th').index($td);
      if ($tr.parent().is('thead')) {
        $newTr.appendTo($tr.parent());
        _changeCellTag($newTr, 'th');
      }
      $tr.remove();
    
      if (callback) {
        callback($newTr[0],index);
      }
      //return this.editor.selection.setRangeAtEndOf($newTr.find('td, th').eq(index));
    }
  }

  function insertRow(td, direction,phBr,callback) {
    var $td = $(td);

    var $newTr, $table, $tr, cellTag, colNum, i, index, k, ref;
    if (direction == null) {
      direction = 'after';
    }
    $tr = $td.parent('tr');
    $table = $tr.closest('table');
    colNum = 0;
    $table.find('tr').each(function(i, tr) {
      return colNum = Math.max(colNum, $(tr).find('td').length);
    });
    index = $tr.find('td, th').index($td);
    $newTr = $('<tr/>');
    cellTag = 'td';
    if (direction === 'after' && $tr.parent().is('thead')) {
      $tr.parent().next('tbody').prepend($newTr);
    } else if (direction === 'before' && $tr.parent().is('thead')) {
      $tr.before($newTr);
      $tr.parent().next('tbody').prepend($tr);
      _changeCellTag($tr, 'td');
      cellTag = 'th';
    } else {
      $tr[direction]($newTr);
    }
    for (i = k = 1, ref = colNum; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
      $("<" + cellTag + "/>").append(phBr).appendTo($newTr);
    }

    if (callback) {
      callback($newTr[0],index);
    }
  }

  function deleteCol(td,callback) {
    var $td = $(td);

    var $newTd, $table, $tr, index, noOtherCol, noOtherRow;
    $tr = $td.parent('tr');
    noOtherRow = $tr.closest('table').find('tr').length < 2;
    noOtherCol = $td.siblings('td, th').length < 1;
    if (noOtherRow && noOtherCol) {
      return deleteTable(td);
    } else {
      index = $tr.find('td, th').index($td);
      $newTd = $td.next('td, th');
      if (!($newTd.length > 0)) {
        $newTd = $tr.prev('td, th');
      }
      $table = $tr.closest('table');
      $table.find('col').eq(index).remove();
      $table.find('tr').each(function(i, tr) {
        return $(tr).find('td, th').eq(index).remove();
      });
      refreshTableWidth($table);
      //return this.editor.selection.setRangeAtEndOf($newTd);
      if (callback) {
        callback($newTd[0]);
      }
    }
  }

  function insertCol(td, direction,phBr,callback) {
    var $td = $(td);

    var $col, $newCol, $newTd, $table, $tr, index, tableWidth, width;
    if (direction == null) {
      direction = 'after';
    }
    $tr = $td.parent('tr');
    index = $tr.find('td, th').index($td);
    $table = $td.closest('table');
    $col = $table.find('col').eq(index);
    $table.find('tr').each((function(_this) {
      return function(i, tr) {
        var $newTd, cellTag;
        cellTag = $(tr).parent().is('thead') ? 'th' : 'td';
        $newTd = $("<" + cellTag + "/>").append(phBr);
        return $(tr).find('td, th').eq(index)[direction]($newTd);
      };
    })(this));
    $newCol = $('<col/>');
    $col[direction]($newCol);
    tableWidth = $table.width();
    width = Math.max(parseFloat($col.attr('width')) / 2, 50 / tableWidth * 100);
    $col.attr('width', width + '%');
    $newCol.attr('width', width + '%');
    refreshTableWidth($table);
    $newTd = direction === 'after' ? $td.next('td, th') : $td.prev('td, th');
    //return this.editor.selection.setRangeAtStartOf($newTd);
    if (callback) {
      callback($newTd[0]);
    }
  }


  function refreshTableWidth($table) {
    return setTimeout((function(_this) {
      return function() {
        var cols, tableWidth;
        tableWidth = $table.width();
        cols = $table.find('col');
        return $table.find('thead tr th').each(function(i, td) {
          var $col;
          $col = cols.eq(i);
          return $col.attr('width', ($(td).outerWidth() / tableWidth * 100) + '%');
        });
      };
    })(this), 0);
  }


  function resizable(container,options) {
    var cssClasses = options.cssClasses,
        clsResizeHandle = cssClasses.resizeHandle, // simditor-resize-handle
        clsWrapper = cssClasses.wrapper, // .simditor-table
        selectorWrapper = "." + clsWrapper,
        selectorResizeHandle = "." + clsResizeHandle;

    $(container).on('mousemove.table', selectorWrapper +' td, ' + selectorWrapper +' th', function(e) {
      var $col, $colgroup, $resizeHandle, $td, $wrapper, index, ref, ref1, x;
      $wrapper = $(this).parents(selectorWrapper);
      $resizeHandle = $wrapper.find(selectorResizeHandle);
      $colgroup = $wrapper.find('colgroup');
      if ($wrapper.hasClass('resizing')) {
        return;
      }
      $td = $(e.currentTarget);
      x = e.pageX - $(e.currentTarget).offset().left;
      if (x < 5 && $td.prev().length > 0) {
        $td = $td.prev();
      }
      if ($td.next('td, th').length < 1) {
        $resizeHandle.hide();
        return;
      }
      if ((ref = $resizeHandle.data('td')) != null ? ref.is($td) : void 0) {
        $resizeHandle.show();
        return;
      }
      index = $td.parent().find('td, th').index($td);
      $col = $colgroup.find('col').eq(index);
      if ((ref1 = $resizeHandle.data('col')) != null ? ref1.is($col) : void 0) {
        $resizeHandle.show();
        return;
      }
      return $resizeHandle.css('left', $td.position().left + $td.outerWidth() - 5).data('td', $td).data('col', $col).show();
    });

    $(container).on('mouseleave'+ selectorWrapper, selectorWrapper, function(e) {
      return $(this).find(selectorResizeHandle).hide();
    });
    return $(container).on('mousedown'+ selectorResizeHandle, selectorResizeHandle, function(e) {
      var $handle, $leftCol, $leftTd, $rightCol, $rightTd, $wrapper, minWidth, startHandleLeft, startLeftWidth, startRightWidth, startX, tableWidth;
      $wrapper = $(this).parent(selectorWrapper);
      $handle = $(e.currentTarget);
      $leftTd = $handle.data('td');
      $leftCol = $handle.data('col');
      $rightTd = $leftTd.next('td, th');
      $rightCol = $leftCol.next('col');
      startX = e.pageX;
      startLeftWidth = $leftTd.outerWidth() * 1;
      startRightWidth = $rightTd.outerWidth() * 1;
      startHandleLeft = parseFloat($handle.css('left'));
      tableWidth = $leftTd.closest(selectorWrapper).width();
      minWidth = 50;
      $(container).on('mousemove.resize-table', function(e) {
        var deltaX, leftWidth, rightWidth;
        deltaX = e.pageX - startX;
        leftWidth = startLeftWidth + deltaX;
        rightWidth = startRightWidth - deltaX;
        if (leftWidth < minWidth) {
          leftWidth = minWidth;
          deltaX = minWidth - startLeftWidth;
          rightWidth = startRightWidth - deltaX;
        } else if (rightWidth < minWidth) {
          rightWidth = minWidth;
          deltaX = startRightWidth - minWidth;
          leftWidth = startLeftWidth + deltaX;
        }
        $leftCol.attr('width', (leftWidth / tableWidth * 100) + '%');
        $rightCol.attr('width', (rightWidth / tableWidth * 100) + '%');
        return $handle.css('left', startHandleLeft + deltaX);
      });
      $(container).one('mouseup.resize-table', function(e) {
        //$editor.sync();
        $(container).off('.resize-table');
        return $wrapper.removeClass('resizing');
      });
      $wrapper.addClass('resizing');
      return false;
    });
  };

  function undecorate(table) {
    var $table = $(table);
    if (!($table.parent('.simditor-table').length > 0)) {
      return;
    }
    return $table.parent().replaceWith($table)[0];
  };



  langx.mixin(tables,{
    "createTable" : createTable,
    "decorate" : decorate,
    "deleteCol" : deleteCol,
    "deleteRow" : deleteRow,
    "deleteTable" : deleteTable,
    "insertCol" : insertCol,
    "insertRow" : insertRow,
    "refreshTableWidth" : refreshTableWidth,
    "resizable" : resizable,
    "undecorate" : undecorate
  })


  return skylark.attach("domx.tables", tables);
});
define('skylark-domx-tables/main',[
	"./tables"
],function(tables){
	return tables;
});
define('skylark-domx-tables', ['skylark-domx-tables/main'], function (main) { return main; });

define('skylark-widgets-wordpad/addons/actions/TableAction',[
  "skylark-langx/langx",
  "skylark-domx-tables",
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function(langx,tables,$,addons,Action){ 
  var TableAction = Action.inherit({
    name : 'table',

    icon : 'table',

    htmlTag : 'table',

    disableTag : 'pre, li, blockquote',

    menu : true,

    _init : function() {
      Action.prototype._init.call(this);
      langx.merge(this.editor.editable.formatter._allowedTags, ['thead', 'th', 'tbody', 'tr', 'td', 'colgroup', 'col']);
      langx.extend(this.editor.editable.formatter._allowedAttributes, {
        td: ['rowspan', 'colspan'],
        col: ['width']
      });
      langx.extend(this.editor.editable.formatter._allowedStyles, {
        td: ['text-align'],
        th: ['text-align']
      });
      this._initShortcuts();
      this._initResize();
      this.editor.on('decorate', (function(_this) {
        return function(e, $el) {
          return $el.find('table').each(function(i, table) {
            return _this.decorate($(table));
          });
        };
      })(this));
      this.editor.on('undecorate', (function(_this) {
        return function(e, $el) {
          return $el.find('table').each(function(i, table) {
            return _this.undecorate($(table));
          });
        };
      })(this));
      this.editor.on('selectionchanged.table', (function(_this) {
        return function(e) {
          var $container, range;
          _this.editor.body.find('.wordpad-table td, .wordpad-table th').removeClass('active');
          range = _this.editor.editable.selection.range();
          if (!range) {
            return;
          }
          $container = _this.editor.editable.selection.containerNode();
          if (range.collapsed && $container.is('.wordpad-table')) {
            _this.editor.editable.selection.setRangeAtEndOf($container);
          }
          return $container.closest('td, th', _this.editor.body).addClass('active');
        };
      })(this));
      this.editor.on('blur.table', (function(_this) {
        return function(e) {
          return _this.editor.body.find('.wordpad-table td, .wordpad-table th').removeClass('active');
        };
      })(this));
      this.editor.editable.keystroke.add('up', 'td', (function(_this) {
        return function(e, $node) {
          _this._tdNav($node, 'up');
          return true;
        };
      })(this));
      this.editor.editable.keystroke.add('up', 'th', (function(_this) {
        return function(e, $node) {
          _this._tdNav($node, 'up');
          return true;
        };
      })(this));
      this.editor.editable.keystroke.add('down', 'td', (function(_this) {
        return function(e, $node) {
          _this._tdNav($node, 'down');
          return true;
        };
      })(this));
      return this.editor.editable.keystroke.add('down', 'th', (function(_this) {
        return function(e, $node) {
          _this._tdNav($node, 'down');
          return true;
        };
      })(this));
    },

    _tdNav : function($td, direction) {
      var $anotherTr, $tr, action, anotherTag, index, parentTag, ref;
      if (direction == null) {
        direction = 'up';
      }
      action = direction === 'up' ? 'prev' : 'next';
      ref = direction === 'up' ? ['tbody', 'thead'] : ['thead', 'tbody'], parentTag = ref[0], anotherTag = ref[1];
      $tr = $td.parent('tr');
      $anotherTr = this["_" + action + "Row"]($tr);
      if (!($anotherTr.length > 0)) {
        return true;
      }
      index = $tr.find('td, th').index($td);
      return this.editor.editable.selection.setRangeAtEndOf($anotherTr.find('td, th').eq(index));
    },

    _initResize : function() {

      tables.resizable(document,{
        cssClasses : {
          resizeHandle : "wordpad-resize-handle",
          wrapper : "wordpad-table"
        }
      });

    },

    _initShortcuts : function() {
      this.editor.editable.hotkeys.add('ctrl+alt+up', (function(_this) {
        return function(e) {
          _this.editMenu.find('.menu-item[data-param=insertRowAbove]').click();
          return false;
        };
      })(this));
      this.editor.editable.hotkeys.add('ctrl+alt+down', (function(_this) {
        return function(e) {
          _this.editMenu.find('.menu-item[data-param=insertRowBelow]').click();
          return false;
        };
      })(this));
      this.editor.editable.hotkeys.add('ctrl+alt+left', (function(_this) {
        return function(e) {
          _this.editMenu.find('.menu-item[data-param=insertColLeft]').click();
          return false;
        };
      })(this));
      return this.editor.editable.hotkeys.add('ctrl+alt+right', (function(_this) {
        return function(e) {
          _this.editMenu.find('.menu-item[data-param=insertColRight]').click();
          return false;
        };
      })(this));
    },

    renderMenu : function() {
      var $table;
      $("<div class=\"menu-create-table\">\n</div>\n<div class=\"menu-edit-table\">\n  <ul>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"deleteRow\">\n        <span>" + (this._t('deleteRow')) + "</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertRowAbove\">\n        <span>" + (this._t('insertRowAbove')) + " ( Ctrl + Alt + ↑ )</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertRowBelow\">\n        <span>" + (this._t('insertRowBelow')) + " ( Ctrl + Alt + ↓ )</span>\n      </a>\n    </li>\n    <li><span class=\"separator\"></span></li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"deleteCol\">\n        <span>" + (this._t('deleteColumn')) + "</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertColLeft\">\n        <span>" + (this._t('insertColumnLeft')) + " ( Ctrl + Alt + ← )</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertColRight\">\n        <span>" + (this._t('insertColumnRight')) + " ( Ctrl + Alt + → )</span>\n      </a>\n    </li>\n    <li><span class=\"separator\"></span></li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"deleteTable\">\n        <span>" + (this._t('deleteTable')) + "</span>\n      </a>\n    </li>\n  </ul>\n</div>").appendTo(this.menuWrapper);
      this.createMenu = this.menuWrapper.find('.menu-create-table');
      this.editMenu = this.menuWrapper.find('.menu-edit-table');
      $table = this.createTable(6, 6).appendTo(this.createMenu);
      this.createMenu.on('mouseenter', 'td, th', (function(_this) {
        return function(e) {
          var $td, $tr, $trs, num;
          _this.createMenu.find('td, th').removeClass('selected');
          $td = $(e.currentTarget);
          $tr = $td.parent();
          num = $tr.find('td, th').index($td) + 1;
          $trs = $tr.prevAll('tr').addBack();
          if ($tr.parent().is('tbody')) {
            $trs = $trs.add($table.find('thead tr'));
          }
          return $trs.find("td:lt(" + num + "), th:lt(" + num + ")").addClass('selected');
        };
      })(this));
      this.createMenu.on('mouseleave', function(e) {
        return $(e.currentTarget).find('td, th').removeClass('selected');
      });
      return this.createMenu.on('mousedown', 'td, th', (function(_this) {
        return function(e) {
          var $closestBlock, $td, $tr, colNum, rowNum;
          _this.wrapper.removeClass('menu-on');
          if (!_this.editor.editable.inputManager.focused) {
            return;
          }
          $td = $(e.currentTarget);
          $tr = $td.parent();
          colNum = $tr.find('td').index($td) + 1;
          rowNum = $tr.prevAll('tr').length + 1;
          if ($tr.parent().is('tbody')) {
            rowNum += 1;
          }
          $table = _this.createTable(rowNum, colNum, true);
          $closestBlock = _this.editor.editable.selection.blockNodes().last();
          if (_this.editor.editable.util.isEmptyNode($closestBlock)) {
            $closestBlock.replaceWith($table);
          } else {
            $closestBlock.after($table);
          }
          _this.decorate($table);
          _this.editor.editable.selection.setRangeAtStartOf($table.find('th:first'));
          _this.editor.trigger('valuechanged');
          return false;
        };
      })(this));
    },

    decorate : function($table) {
      return $(tables.decorate($table[0],{
        tableDecorate : 'wordpad-table',
        resizeHandle : 'wordpad-resize-handle'
      }));

    },

    undecorate : function($table) {
      return $(tables.undecorate($table[0],{
        tableDecorate : 'wordpad-table',
        resizeHandle : 'wordpad-resize-handle'
      }));

    },


    createTable : function(row, col, phBr) {
      return $(tables.createTable(row,col,phBr ? this.editor.editable.util.phBr : null));
    },

    refreshTableWidth : function($table) {
      return table.refreshTableWidth($table[0]);
    },

    deleteRow : function($td) {
      var self = this,
          ret; 

      tables.deleteRow($td[0],function(newTr,index){
        if (newTr) {
          ret = self.editor.editable.selection.setRangeAtEndOf($(newTr).find('td, th').eq(index));
        }
      })

      return ret;
    },

    insertRow : function($td, direction) {
      var self = this,
          ret; 

      tables.insertRow($td[0],direction,self.editor.editable.util.phBr,function(newTr,index){
        ret =  self.editor.editable.selection.setRangeAtStartOf($(newTr).find('td, th').eq(index));
      })

      return ret;

    },

    deleteCol : function($td) {
      var self = this,
          ret; 

      tables.deleteCol($td[0],function(newTd){
        if (newTd) {
          ret = self.editor.editable.selection.setRangeAtEndOf($(newTd));
        }
      })

      return ret;
    },

    insertCol : function($td, direction) {
      var self = this,
          ret; 

      tables.insertCol($td[0],direction,self.editor.editable.util.phBr,function(newTd){
        ret = self.editor.editable.selection.setRangeAtStartOf($(newTd));
      })

      return ret;
    },

    deleteTable : function($td) {
      var self = this;
      tables.deleteTable($td[0],function($block){
        if ($block.length > 0) {
          return self.editor.editable.selection.setRangeAtStartOf($block);
        }
      });
    },

    _execute : function(param) {
      var $td;
      $td = this.editor.editable.selection.containerNode().closest('td, th');
      if (!($td.length > 0)) {
        return;
      }
      if (param === 'deleteRow') {
        this.deleteRow($td);
      } else if (param === 'insertRowAbove') {
        this.insertRow($td, 'before');
      } else if (param === 'insertRowBelow') {
        this.insertRow($td);
      } else if (param === 'deleteCol') {
        this.deleteCol($td);
      } else if (param === 'insertColLeft') {
        this.insertCol($td, 'before');
      } else if (param === 'insertColRight') {
        this.insertCol($td);
      } else if (param === 'deleteTable') {
        this.deleteTable($td);
      } else {
        return;
      }
      return this.editor.trigger('valuechanged');
    }

   });


  addons.actions.table = TableAction;

  return TableAction;

});
define('skylark-widgets-wordpad/addons/actions/TitleAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action",
  "../../i18n"
],function($,addons,Action,i18n){ 
  var TitleAction = Action.inherit({
    name : 'title',

    htmlTag : 'h1, h2, h3, h4, h5',

    disableTag : 'pre, table',

    _init : function() {
      this.menu = [
        {
          name: 'normal',
          text: i18n.translate('normalText'),
          param: 'p'
        }, '|', {
          name: 'h1',
          text: i18n.translate('title') + ' 1',
          param: 'h1'
        }, {
          name: 'h2',
          text: i18n.translate('title') + ' 2',
          param: 'h2'
        }, {
          name: 'h3',
          text: i18n.translate('title') + ' 3',
          param: 'h3'
        }, {
          name: 'h4',
          text: i18n.translate('title') + ' 4',
          param: 'h4'
        }, {
          name: 'h5',
          text: i18n.translate('title') + ' 5',
          param: 'h5'
        }
      ];
      return Action.prototype._init.call(this);
    },

    setActive : function(active, param) {
      if (active) {
        active = this.node[0].tagName.toLowerCase();
      }
      Action.prototype.setActive.call(this, active);
    },

    _execute : function(param) {
      return this.editor.editable.title(param,this.disableTag);
    }

  });

  addons.actions.title = TitleAction;

  return TitleAction;

});
define('skylark-widgets-wordpad/addons/actions/UnderlineAction',[
  "skylark-domx-query",
  "../../addons",
  "../../Action"
],function($,addons,Action){
  var UnderlineAction = Action.inherit({
    name : 'underline',

    icon : 'underline',

    htmlTag : 'u',

    disableTag : 'pre',

    shortcut : 'cmd+u',

    render : function() {
      if (this.editor.editable.util.os.mac) {
        this.title = this.title + ' ( Cmd + u )';
      } else {
        this.title = this.title + ' ( Ctrl + u )';
        this.shortcut = 'ctrl+u';
      }
      return Action.prototype.render.call(this);
    },

    _activeStatus : function() {
      var active;
      active = this.editor.editable.isActive('underline');
      this.setActive(active);
      return this.active;
    },

    _execute : function() {
      return this.editor.editable.underline();
    }

   });


  addons.actions.underline = UnderlineAction;

  return UnderlineAction;

});
define('skylark-widgets-wordpad/addons/actions/UnorderListAction',[
  "skylark-domx-query",
  "../../addons",
  "./ListAction"
],function($,addons,ListAction){ 
   var UnorderListAction = ListAction.inherit({
      type : 'ul',

      name : 'ul',

      icon : 'list-ul',

      htmlTag : 'ul',

      shortcut : 'cmd+.',

      _init : function() {
        if (this.editor.editable.util.os.mac) {
          this.title = this.title + ' ( Cmd + . )';
        } else {
          this.title = this.title + ' ( Ctrl + . )';
          this.shortcut = 'ctrl+.';
        }
        return ListAction.prototype._init.call(this);
      }

   });


    addons.actions.ul = UnorderListAction;

    return UnorderListAction;

});
define('skylark-widgets-wordpad/addons/toolbar/items/AlignmentButton',[
  "skylark-domx-query",
  "../../../ToolButton",
  "../../../i18n",
  "../../../addons"
],function($,ToolButton,i18n,addons){ 

 var AlignmentButton = ToolButton.inherit({
    _doActive : function(align) {

      ToolButton.prototype._doActive.call(this, !!align);

      this.el.removeClass('align-left align-center align-right');
      if (align) {
        this.el.addClass('align-' + align);
      }
      this.setIcon('align-' + align);
      return this.menuEl.find('.menu-item').show().end().find('.menu-item-' + align).hide();

    }

  });


  addons.toolbar.items.alignment = AlignmentButton;

  return AlignmentButton;

});
define('skylark-widgets-wordpad/addons/toolbar/items/ColorButton',[
  "skylark-domx-query",
  "../../../ToolButton",
  "../../../i18n",
  "../../../addons"
],function($,ToolButton,i18n,addons){ 
  

   var ColorButton = ToolButton.inherit({
    render : function() {
      var args;
      args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
      return ToolButton.prototype.render.apply(this, args);
    },

    renderMenu : function() {
      $('<ul class="color-list">\n  <li><a href="javascript:;" class="font-color font-color-1"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-2"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-3"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-4"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-5"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-6"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-7"></a></li>\n  <li><a href="javascript:;" class="font-color font-color-default"></a></li>\n</ul>').appendTo(this.menuWrapper);
      this.menuWrapper.on('mousedown', '.color-list', function(e) {
        return false;
      });
      return this.menuWrapper.on('click', '.font-color', (function(_this) {
        return function(e) {
          var $link, $p, hex, range, rgb, textNode;
          _this.wrapper.removeClass('menu-on');
          $link = $(e.currentTarget);
          if ($link.hasClass('font-color-default')) {
            $p = _this.editor.body.find('p, li');
            if (!($p.length > 0)) {
              return;
            }
            rgb = window.getComputedStyle($p[0], null).getPropertyValue('color');
            hex = _this._convertRgbToHex(rgb);
          } else {
            rgb = window.getComputedStyle($link[0], null).getPropertyValue('background-color');
            hex = _this._convertRgbToHex(rgb);
          }
          if (!hex) {
            return;
          }

          return _this.editor.editable.fontColor(hex,$link.hasClass('font-color-default'),i18n.translate('coloredText'));
        };
      })(this));
    },

    _convertRgbToHex : function(rgb) {
      var match, re, rgbToHex;
      re = /rgb\((\d+),\s?(\d+),\s?(\d+)\)/g;
      match = re.exec(rgb);
      if (!match) {
        return '';
      }
      rgbToHex = function(r, g, b) {
        var componentToHex;
        componentToHex = function(c) {
          var hex;
          hex = c.toString(16);
          if (hex.length === 1) {
            return '0' + hex;
          } else {
            return hex;
          }
        };
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
      };
      return rgbToHex(match[1] * 1, match[2] * 1, match[3] * 1);
    }

   });

   
   addons.toolbar.items.color = ColorButton; 


   return ColorButton;
	
});
define('skylark-widgets-wordpad/addons/toolbar/items/EmojiButton',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "../../../ToolButton",
  "../../../i18n",
  "../../../addons"
],function(langx, $,ToolButton,i18n,addons){ 

  var EmojiButton = ToolButton.inherit({

    renderMenu : function() {
      var $list, dir, html, name, opts, src, tpl, _i, _len, _ref;
      tpl = '<ul class="emoji-list">\n</ul>';
      opts = langx.extend({
        imagePath: 'images/emoji/',
        images: EmojiButton.images
      }, this.editor.opts.emoji || {});
      html = "";
      dir = opts.imagePath.replace(/\/$/, '') + '/';
      _ref = opts.images;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        src = "" + dir + name;
        name = name.split('.')[0];
        html += "<li data-name='" + name + "'><img src='" + src + "' width='20' height='20' alt='" + name + "' /></li>";
      }
      $list = $(tpl);
      $list.html(html).appendTo(this.menuWrapper);
      return $list.on('mousedown', 'li', (function(_this) {
        return function(e) {
          var $img;
          _this.wrapper.removeClass('menu-on');
          if (!_this.editor.editable.inputManager.focused) {
            return;
          }
          $img = $(e.currentTarget).find('img').clone().attr({
            'data-emoji': true,
            'data-non-image': true
          });
          _this.editor.editable.selection.insertNode($img);
          _this.editor.trigger('valuechanged');
          _this.editor.trigger('selectionchanged');
          return false;
        };
      })(this));
    }

  });


  EmojiButton.i18n = {
    'zh-CN': {
      emoji: '表情'
    },
    'en-US': {
      emoji: 'emoji'
    }
  };

  EmojiButton.images = ['smile.png', 'smiley.png', 'laughing.png', 'blush.png', 'heart_eyes.png', 'smirk.png', 'flushed.png', 'grin.png', 'wink.png', 'kissing_closed_eyes.png', 'stuck_out_tongue_winking_eye.png', 'stuck_out_tongue.png', 'sleeping.png', 'worried.png', 'expressionless.png', 'sweat_smile.png', 'cold_sweat.png', 'joy.png', 'sob.png', 'angry.png', 'mask.png', 'scream.png', 'sunglasses.png', 'heart.png', 'broken_heart.png', 'star.png', 'anger.png', 'exclamation.png', 'question.png', 'zzz.png', 'thumbsup.png', 'thumbsdown.png', 'ok_hand.png', 'punch.png', 'v.png', 'clap.png', 'muscle.png', 'pray.png', 'skull.png', 'trollface.png'];


  addons.toolbar.items.emoji = EmojiButton; 

  return EmojiButton;
	
});
define('skylark-widgets-wordpad/addons/toolbar/items/TableButton',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "../../../ToolButton",
  "../../../i18n",
  "../../../addons"
],function(langx, $,ToolButton,i18n,addons){ 

  var TableButton = ToolButton.inherit({
    _doActive : function(active) {

      ToolButton.prototype._doActive.call(this, active);

      if (active) {
        this.createMenu.hide();
        return this.editMenu.show();
      } else {
        this.createMenu.show();
        return this.editMenu.hide();
      }

    }
   });


  TableButton.prototype.renderMenu = function() {
    var $table;
    $("<div class=\"menu-create-table\">\n</div>\n<div class=\"menu-edit-table\">\n  <ul>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"deleteRow\">\n        <span>" + (i18n.translate('deleteRow')) + "</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertRowAbove\">\n        <span>" + (i18n.translate('insertRowAbove')) + " ( Ctrl + Alt + ↑ )</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertRowBelow\">\n        <span>" + (i18n.translate('insertRowBelow')) + " ( Ctrl + Alt + ↓ )</span>\n      </a>\n    </li>\n    <li><span class=\"separator\"></span></li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"deleteCol\">\n        <span>" + (i18n.translate('deleteColumn')) + "</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertColLeft\">\n        <span>" + (i18n.translate('insertColumnLeft')) + " ( Ctrl + Alt + ← )</span>\n      </a>\n    </li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"insertColRight\">\n        <span>" + (i18n.translate('insertColumnRight')) + " ( Ctrl + Alt + → )</span>\n      </a>\n    </li>\n    <li><span class=\"separator\"></span></li>\n    <li>\n      <a tabindex=\"-1\" unselectable=\"on\" class=\"menu-item\"\n        href=\"javascript:;\" data-param=\"deleteTable\">\n        <span>" + (i18n.translate('deleteTable')) + "</span>\n      </a>\n    </li>\n  </ul>\n</div>").appendTo(this.menuWrapper);
    this.createMenu = this.menuWrapper.find('.menu-create-table');
    this.editMenu = this.menuWrapper.find('.menu-edit-table');
    $table = this.action.createTable(6, 6).appendTo(this.createMenu);
    this.createMenu.on('mouseenter', 'td, th', (function(_this) {
      return function(e) {
        var $td, $tr, $trs, num;
        _this.createMenu.find('td, th').removeClass('selected');
        $td = $(e.currentTarget);
        $tr = $td.parent();
        num = $tr.find('td, th').index($td) + 1;
        $trs = $tr.prevAll('tr').addBack();
        if ($tr.parent().is('tbody')) {
          $trs = $trs.add($table.find('thead tr'));
        }
        return $trs.find("td:lt(" + num + "), th:lt(" + num + ")").addClass('selected');
      };
    })(this));
    this.createMenu.on('mouseleave', function(e) {
      return $(e.currentTarget).find('td, th').removeClass('selected');
    });
    return this.createMenu.on('mousedown', 'td, th', (function(_this) {
      return function(e) {
        var $closestBlock, $td, $tr, colNum, rowNum;
        _this.wrapper.removeClass('menu-on');
        if (!_this.editor.editable.inputManager.focused) {
          return;
        }
        $td = $(e.currentTarget);
        $tr = $td.parent();
        colNum = $tr.find('td').index($td) + 1;
        rowNum = $tr.prevAll('tr').length + 1;
        if ($tr.parent().is('tbody')) {
          rowNum += 1;
        }
        $table = _this.action.createTable(rowNum, colNum, true);
        $closestBlock = _this.editor.editable.selection.blockNodes().last();
        if (_this.editor.editable.util.isEmptyNode($closestBlock)) {
          $closestBlock.replaceWith($table);
        } else {
          $closestBlock.after($table);
        }
        _this.action.decorate($table);
        _this.editor.editable.selection.setRangeAtStartOf($table.find('th:first'));
        _this.editor.trigger('valuechanged');
        return false;
      };
    })(this));
  };


  addons.toolbar.items.table = TableButton;

  return TableButton;


});
define('skylark-widgets-wordpad/addons/toolbar/items/TitleButton',[
  "skylark-domx-query",
  "../../../ToolButton",
  "../../../addons"
],function($,ToolButton,addons){ 
  var TitleButton = ToolButton.inherit({
      _doActive : function(value) {
        var active = !!value,
            param = value;
        ToolButton.prototype._doActive.call(this, active);

        if (active) {
          param || (param = this.node[0].tagName.toLowerCase());
        }
        this.el.removeClass('active-p active-h1 active-h2 active-h3 active-h4 active-h5');
        if (active) {
          return this.el.addClass('active active-' + param);
        }
      }
   });


  addons.toolbar.items.title = TitleButton;

  return TitleButton;

});
define('skylark-widgets-base/Addon',[
  "skylark-langx/langx",	
  "skylark-langx/Evented",
	"./base"
],function(langx,Evented,base){

	var Addon = Evented.inherit({

		_construct : function(widget,options) {
			this._widget = widget;
            Object.defineProperty(this,"options",{
              value :langx.mixin({},this.options,options,true)
            });
			if (this._init) {
				this._init();
			}
		}

	});

	Addon.register = function(Widget) {
		var categoryName = this.categoryName,
			addonName = this.addonName;

		if (categoryName && addonName) {
			Widget.addons = Widget.addons || {};
			Widget.addons[categoryName] = Widget.addons[categoryName] || {};
			Widget.addons[categoryName][addonName] = this;
		}
	};

	return base.Addon = Addon;

});
define('skylark-widgets-wordpad/addons/AutoSave',[
  "skylark-domx-query",
  "skylark-widgets-base/Addon",
  "../Toolbar",
  "../Wordpad",
  "../i18n"
],function($,Addon, Toolbar,Wordpad,i18n){ 


  var AutoSave = Addon.inherit({
    needFocus : false,

    _init : function() {

	    var currentVal, link, name, val;
	    this.editor = this._module;
	    if (!this.opts.autosave) {
	      return;
	    }
	    this.name = typeof this.opts.autosave === 'string' ? this.opts.autosave : 'simditor';
	    if (this.opts.autosavePath) {
	      this.path = this.opts.autosavePath;
	    } else {
	      link = $("<a/>", {
	        href: location.href
	      });
	      name = this.editor.textarea.data('autosave') || this.name;
	      this.path = "/" + (link[0].pathname.replace(/\/$/g, "").replace(/^\//g, "")) + "/autosave/" + name + "/";
	    }
	    if (!this.path) {
	      return;
	    }
	    this.editor.on("valuechanged", (function(_this) {
	      return function() {
	        return _this.storage.set(_this.path, _this.editor.getValue());
	      };
	    })(this));
	    this.editor.el.closest('form').on('ajax:success.simditor-' + this.editor.id, (function(_this) {
	      return function(e) {
	        return _this.storage.remove(_this.path);
	      };
	    })(this));
	    val = this.storage.get(this.path);
	    if (!val) {
	      return;
	    }
	    currentVal = this.editor.textarea.val();
	    if (val === currentVal) {
	      return;
	    }
	    if (this.editor.textarea.is('[data-autosave-confirm]')) {
	      if (confirm(this.editor.textarea.data('autosave-confirm') || 'Are you sure to restore unsaved changes?')) {
	        return this.editor.setValue(val);
	      } else {
	        return this.storage.remove(this.path);
	      }
	    } else {
	      return this.editor.setValue(val);
	    }

    }

  });


  AutoSave.categoryName = "general";
  AutoSave.addonName = 'autosave';

  AutoSave.prototype.opts = {
    autosave: true,
    autosavePath: null
  };


  AutoSave.prototype.storage = {
    supported: function() {
      var error;
      try {
        localStorage.setItem('_storageSupported', 'yes');
        localStorage.removeItem('_storageSupported');
        return true;
      } catch (_error) {
        error = _error;
        return false;
      }
    },
    set: function(key, val, session) {
      var storage;
      if (session == null) {
        session = false;
      }
      if (!this.supported()) {
        return;
      }
      storage = session ? sessionStorage : localStorage;
      return storage.setItem(key, val);
    },
    get: function(key, session) {
      var storage;
      if (session == null) {
        session = false;
      }
      if (!this.supported()) {
        return;
      }
      storage = session ? sessionStorage : localStorage;
      return storage[key];
    },
    remove: function(key, session) {
      var storage;
      if (session == null) {
        session = false;
      }
      if (!this.supported()) {
        return;
      }
      storage = session ? sessionStorage : localStorage;
      return storage.removeItem(key);
    }
  };

  return Wordpad.addons.general.autoSave = AutoSave;

});
define('skylark-widgets-wordpad/addons/Dropzone',[
  "skylark-domx-query",
  "skylark-widgets-base/Addon",
  "../Toolbar",
  "../Wordpad",
  "../i18n"
],function($,Addon, Toolbar,Wordpad,i18n){ 


  var Dropzone = Addon.inherit({
  });

  Dropzone.categoryName = "genernal";

  Dropzone.addonName = "dropzone";


  Dropzone.prototype._entered = 0;

  Dropzone.prototype._init = function() {
    this.editor = this._widget;
    if (this.editor.uploader == null) {
      //throw new Error("Can't work without 'simple-uploader' module");
      return;
    }
    $(document.body).on("dragover", function(e) {
      e.originalEvent.dataTransfer.dropEffect = "none";
      return e.preventDefault();
    });
    $(document.body).on('drop', function(e) {
      return e.preventDefault();
    });
    this.imageBtn = this.editor.toolbar.findButton("image");
    return this.editor.body.on("dragover", function(e) {
      e.originalEvent.dataTransfer.dropEffect = "copy";
      e.stopPropagation();
      return e.preventDefault();
    }).on("dragenter", (function(_this) {
      return function(e) {
        if ((_this._entered += 1) === 1) {
          _this.show();
        }
        e.preventDefault();
        return e.stopPropagation();
      };
    })(this)).on("dragleave", (function(_this) {
      return function(e) {
        if ((_this._entered -= 1) <= 0) {
          _this.hide();
        }
        e.preventDefault();
        return e.stopPropagation();
      };
    })(this)).on("drop", (function(_this) {
      return function(e) {
        var file, imageFiles, _i, _j, _len, _len1, _ref;
        imageFiles = [];
        _ref = e.originalEvent.dataTransfer.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (!_this.validFile(file)) {
            alert("「" + file.name + "]」文件不是图片。");
            _this.hide();
            return false;
          }
          imageFiles.push(file);
        }
        for (_j = 0, _len1 = imageFiles.length; _j < _len1; _j++) {
          file = imageFiles[_j];
          _this.editor.uploader.upload(file, {
            inline: true
          });
        }
        _this.hide();
        e.stopPropagation();
        return e.preventDefault();
      };
    })(this));
  };

  Dropzone.prototype.show = function() {
    return this.imageBtn.setActive(true);
  };

  Dropzone.prototype.hide = function() {
    this.imageBtn.setActive(false);
    return this._entered = 0;
  };

  Dropzone.prototype.validFile = function(file) {
    return file.type.indexOf("image/") > -1;
  };

  return Wordpad.addons.general.dropzone = Dropzone;


});
define('skylark-widgets-wordpad/main',[
  "./Wordpad", 
  "./Action",
  "./Popover",
  "./Toolbar",
  "./ToolButton", 

  "./addons/actions/AlignmentAction", 
  "./addons/actions/BlockquoteAction", 
  "./addons/actions/BoldAction", 
  "./addons/actions/CodeAction", 
  "./addons/actions/CodePopover", 
  "./addons/actions/ColorAction", 
  "./addons/actions/EmojiAction", 
  "./addons/actions/FontScaleAction", 
  "./addons/actions/FullScreenAction", 
  "./addons/actions/HrAction", 
  "./addons/actions/HtmlAction", 
  "./addons/actions/ImageAction", 
  "./addons/actions/ImagePopover", 
  "./addons/actions/IndentAction", 
  "./addons/actions/ItalicAction", 
  "./addons/actions/LinkAction", 
  "./addons/actions/LinkPopover", 
  "./addons/actions/ListAction", 
  "./addons/actions/MarkAction", 
  "./addons/actions/OrderListAction", 
  "./addons/actions/OutdentAction",
  "./addons/actions/StrikethroughAction", 
  "./addons/actions/TableAction", 
  "./addons/actions/TitleAction", 
  "./addons/actions/UnderlineAction", 
  "./addons/actions/UnorderListAction",

  "./addons/toolbar/items/AlignmentButton",
  "./addons/toolbar/items/ColorButton",
  "./addons/toolbar/items/EmojiButton",
  "./addons/toolbar/items/TableButton",
  "./addons/toolbar/items/TitleButton",

  "./addons/AutoSave",
  "./addons/Dropzone"
],function(Wordpad){
	
  return Wordpad;
});
define('skylark-widgets-wordpad', ['skylark-widgets-wordpad/main'], function (main) { return main; });

define('skylark-slax-runtime/main',[
	"./slax",
	"./cache",
	"skylark-langx",
	"skylark-widgets-shells",
	"skylark-jquery",
	"skylark-ajaxfy-spa",
	"skylark-data-entities",
	"skylark-data-streams",
	"skylark-data-zip",
	"skylark-net-http",
	"skylark-widgets-colorpicker",
	"skylark-widgets-gradienter",
	"skylark-widgets-hierarchy",
	"skylark-widgets-iconpicker",
	"skylark-widgets-repeater",
	"skylark-widgets-uploads",
	"skylark-widgets-wordpad"
],function(slax){
	return slax;
});
define('skylark-slax-runtime', ['skylark-slax-runtime/main'], function (main) { return main; });


},this);